((typeof self !== 'undefined' ? self : this)["webpackJsonp"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp"] || []).push([[12],{

/***/ "./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js/library/fn/get-iterator */ "./node_modules/core-js/library/fn/get-iterator.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptor.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptor */ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/core-js/reflect/get.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/core-js/reflect/get.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! core-js/library/fn/reflect/get */ "./node_modules/core-js/library/fn/reflect/get.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithHoles; });
/* harmony import */ var _core_js_array_is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core-js/array/is-array */ "./node_modules/@babel/runtime-corejs2/core-js/array/is-array.js");
/* harmony import */ var _core_js_array_is_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_js_array_is_array__WEBPACK_IMPORTED_MODULE_0__);

function _arrayWithHoles(arr) {
  if (_core_js_array_is_array__WEBPACK_IMPORTED_MODULE_0___default()(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/get.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/get.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _get; });
/* harmony import */ var _core_js_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core-js/object/get-own-property-descriptor */ "./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-descriptor.js");
/* harmony import */ var _core_js_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_js_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_js_reflect_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core-js/reflect/get */ "./node_modules/@babel/runtime-corejs2/core-js/reflect/get.js");
/* harmony import */ var _core_js_reflect_get__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_core_js_reflect_get__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _superPropBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./superPropBase */ "./node_modules/@babel/runtime-corejs2/helpers/esm/superPropBase.js");



function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && _core_js_reflect_get__WEBPACK_IMPORTED_MODULE_1___default.a) {
    _get = _core_js_reflect_get__WEBPACK_IMPORTED_MODULE_1___default.a;
  } else {
    _get = function _get(target, property, receiver) {
      var base = Object(_superPropBase__WEBPACK_IMPORTED_MODULE_2__["default"])(target, property);
      if (!base) return;

      var desc = _core_js_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_0___default()(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArrayLimit; });
/* harmony import */ var _core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core-js/get-iterator */ "./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js");
/* harmony import */ var _core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _core_js_is_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core-js/is-iterable */ "./node_modules/@babel/runtime-corejs2/core-js/is-iterable.js");
/* harmony import */ var _core_js_is_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_core_js_is_iterable__WEBPACK_IMPORTED_MODULE_1__);


function _iterableToArrayLimit(arr, i) {
  if (!(_core_js_is_iterable__WEBPACK_IMPORTED_MODULE_1___default()(Object(arr)) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = _core_js_get_iterator__WEBPACK_IMPORTED_MODULE_0___default()(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableRest; });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _slicedToArray; });
/* harmony import */ var _arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _nonIterableRest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js");



function _slicedToArray(arr, i) {
  return Object(_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || Object(_nonIterableRest__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs2/helpers/esm/superPropBase.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs2/helpers/esm/superPropBase.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _superPropBase; });
/* harmony import */ var _getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf */ "./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf.js");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = Object(_getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
    if (object === null) break;
  }

  return object;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inheritsLoose.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeFunction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeFunction.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(/*! ./getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeFunction = __webpack_require__(/*! ./isNativeFunction */ "./node_modules/@babel/runtime/helpers/isNativeFunction.js");

var construct = __webpack_require__(/*! ./construct */ "./node_modules/@babel/runtime/helpers/construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

/***/ }),

/***/ "./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/@babel/runtime/node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@keepkey/keepkey.js/dist/keepkey.browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/@keepkey/keepkey.js/dist/keepkey.browser.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {
     true ? factory(exports) :
    undefined;
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
    var inited = false;
    function init () {
      inited = true;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
    }

    function toByteArray (b64) {
      if (!inited) {
        init();
      }
      var i, j, l, tmp, placeHolders, arr;
      var len = b64.length;

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // the number of equal signs (place holders)
      // if there are two placeholders, than the two characters before it
      // represent one byte
      // if there is only one, then the three characters before it represent 2 bytes
      // this is just a cheap hack to not do indexOf twice
      placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

      // base64 is 4/3 + up to two characters of the original data
      arr = new Arr(len * 3 / 4 - placeHolders);

      // if there are placeholders, only get up to the last complete 4 chars
      l = placeHolders > 0 ? len - 4 : len;

      var L = 0;

      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = (tmp >> 16) & 0xFF;
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      if (placeHolders === 2) {
        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[L++] = tmp & 0xFF;
      } else if (placeHolders === 1) {
        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[L++] = (tmp >> 8) & 0xFF;
        arr[L++] = tmp & 0xFF;
      }

      return arr
    }

    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
    }

    function encodeChunk (uint8, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output.push(tripletToBase64(tmp));
      }
      return output.join('')
    }

    function fromByteArray (uint8) {
      if (!inited) {
        init();
      }
      var tmp;
      var len = uint8.length;
      var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
      var output = '';
      var parts = [];
      var maxChunkLength = 16383; // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[(tmp << 4) & 0x3F];
        output += '==';
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
        output += lookup[tmp >> 10];
        output += lookup[(tmp >> 4) & 0x3F];
        output += lookup[(tmp << 2) & 0x3F];
        output += '=';
      }

      parts.push(output);

      return parts.join('')
    }

    function read (buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];

      i += d;

      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    function write (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

      value = Math.abs(value);

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }

        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

      buffer[offset + i - d] |= s * 128;
    }

    var toString = {}.toString;

    var isArray = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

    var INSPECT_MAX_BYTES = 50;

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.

     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
      ? global$1.TYPED_ARRAY_SUPPORT
      : true;

    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192; // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype;
      return arr
    };

    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    };

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
    }

    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc (that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    };

    function allocUnsafe (that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    };

    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);

      var actual = that.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual);
      }

      return that
    }

    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that
    }

    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength; // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array);
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array);
      }
      return that
    }

    function fromObject (that, obj) {
      if (internalIsBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len);
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    Buffer.isBuffer = isBuffer;
    function internalIsBuffer (b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare (a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    };

    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i;
      if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer
    };

    function byteLength (string, encoding) {
      if (internalIsBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string;
      }

      var len = string.length;
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;

    function slowToString (encoding, start, end) {
      var loweredCase = false;

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0;
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true;

    function swap (b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this
    };

    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this
    };

    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this
    };

    Buffer.prototype.toString = function toString () {
      var length = this.length | 0;
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    };

    Buffer.prototype.equals = function equals (b) {
      if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    };

    Buffer.prototype.inspect = function inspect () {
      var str = '';
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
      }
      return '<Buffer ' + str + '>'
    };

    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0;
      }
      if (end === undefined) {
        end = target ? target.length : 0;
      }
      if (thisStart === undefined) {
        thisStart = 0;
      }
      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;

      if (this === target) return 0

      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);

      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    };

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }
      byteOffset = +byteOffset;  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (internalIsBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read$$1 (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read$$1(arr, i + j) !== read$$1(val, j)) {
              found = false;
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    };

    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    };

    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }

      // must be an even number of digits
      var strLen = string.length;
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed;
      }
      return i
    }

    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8';

      var loweredCase = false;
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return fromByteArray(buf)
      } else {
        return fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];

      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }
              break
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }
              break
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = '';
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res
    }

    function asciiSlice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }
      return ret
    }

    function latin1Slice (buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret
    }

    function hexSlice (buf, start, end) {
      var len = buf.length;

      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;

      var out = '';
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out
    }

    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res
    }

    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;

      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }

      return newBuf
    };

    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val
    };

    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val
    };

    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset]
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | (this[offset + 1] << 8)
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      return (this[offset] << 8) | this[offset + 1]
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    };

    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);

      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }
      mul *= 0x80;

      if (val >= mul) val -= Math.pow(2, 8 * byteLength);

      return val
    };

    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    };

    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | (this[offset + 1] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | (this[offset] << 8);
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    };

    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    };

    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    };

    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4)
    };

    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4)
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8)
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8)
    };

    function checkInt (buf, value, offset, ext, max, min) {
      if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength = byteLength | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      this[offset] = (value & 0xff);
      return offset + 1
    };

    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8;
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);

        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
      }

      return offset + byteLength
    };

    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = (value & 0xff);
      return offset + 1
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        this[offset + 2] = (value >>> 16);
        this[offset + 3] = (value >>> 24);
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4
    };

    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
      }
      write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    };

    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
      }
      write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    };

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;
      var i;

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }

      return len
    };

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;

      if (!val) val = 0;

      var i;
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this
    };

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '');
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '=';
      }
      return str
    }

    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes (string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue
            }

            // valid lead
            leadSurrogate = codePoint;

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          );
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes (str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }
      return byteArray
    }

    function utf16leToBytes (str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray
    }


    function base64ToBytes (str) {
      return toByteArray(base64clean(str))
    }

    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i];
      }
      return i
    }

    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }


    // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    function isBuffer(obj) {
      return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
    }

    function isFastBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
    }

    var $jscomp={scope:{},getGlobal:function(a){return "undefined"!=typeof window&&window===a?a:"undefined"!=typeof commonjsGlobal?commonjsGlobal:a}};$jscomp.global=$jscomp.getGlobal(commonjsGlobal);$jscomp.initSymbol=function(){$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol);$jscomp.initSymbol=function(){};};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(a){return "jscomp_symbol_"+a+$jscomp.symbolCounter_++};
    $jscomp.initSymbolIterator=function(){$jscomp.initSymbol();$jscomp.global.Symbol.iterator||($jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));$jscomp.initSymbolIterator=function(){};};$jscomp.makeIterator=function(a){$jscomp.initSymbolIterator();$jscomp.initSymbol();$jscomp.initSymbolIterator();var b=a[Symbol.iterator];if(b)return b.call(a);var c=0;return {next:function(){return c<a.length?{done:!1,value:a[c++]}:{done:!0}}}};
    $jscomp.arrayFromIterator=function(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c};$jscomp.arrayFromIterable=function(a){return a instanceof Array?a:$jscomp.arrayFromIterator($jscomp.makeIterator(a))};$jscomp.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.prototype=new c;a.prototype.constructor=a;for(var d in b)if(Object.defineProperties){var e=Object.getOwnPropertyDescriptor(b,d);e&&Object.defineProperty(a,d,e);}else a[d]=b[d];};$jscomp.array=$jscomp.array||{};
    $jscomp.iteratorFromArray=function(a,b){$jscomp.initSymbolIterator();a instanceof String&&(a+="");var c=0,d={next:function(){if(c<a.length){var e=c++;return {value:b(e,a[e]),done:!1}}d.next=function(){return {done:!0,value:void 0}};return d.next()}};$jscomp.initSymbol();$jscomp.initSymbolIterator();d[Symbol.iterator]=function(){return d};return d};
    $jscomp.findInternal=function(a,b,c){a instanceof String&&(a=String(a));for(var d=a.length,e=0;e<d;e++){var f=a[e];if(b.call(c,f,e,a))return {i:e,v:f}}return {i:-1,v:void 0}};
    $jscomp.array.from=function(a,b,c){$jscomp.initSymbolIterator();b=null!=b?b:function(a){return a};var d=[];$jscomp.initSymbol();$jscomp.initSymbolIterator();var e=a[Symbol.iterator];"function"==typeof e&&(a=e.call(a));if("function"==typeof a.next)for(;!(e=a.next()).done;)d.push(b.call(c,e.value));else for(var e=a.length,f=0;f<e;f++)d.push(b.call(c,a[f]));return d};$jscomp.array.of=function(a){return $jscomp.array.from(arguments)};
    $jscomp.array.entries=function(){return $jscomp.iteratorFromArray(this,function(a,b){return [a,b]})};$jscomp.array.installHelper_=function(a,b){!Array.prototype[a]&&Object.defineProperties&&Object.defineProperty&&Object.defineProperty(Array.prototype,a,{configurable:!0,enumerable:!1,writable:!0,value:b});};$jscomp.array.entries$install=function(){$jscomp.array.installHelper_("entries",$jscomp.array.entries);};$jscomp.array.keys=function(){return $jscomp.iteratorFromArray(this,function(a){return a})};
    $jscomp.array.keys$install=function(){$jscomp.array.installHelper_("keys",$jscomp.array.keys);};$jscomp.array.values=function(){return $jscomp.iteratorFromArray(this,function(a,b){return b})};$jscomp.array.values$install=function(){$jscomp.array.installHelper_("values",$jscomp.array.values);};
    $jscomp.array.copyWithin=function(a,b,c){var d=this.length;a=Number(a);b=Number(b);c=Number(null!=c?c:d);if(a<b)for(c=Math.min(c,d);b<c;)b in this?this[a++]=this[b++]:(delete this[a++],b++);else for(c=Math.min(c,d+b-a),a+=c-b;c>b;)--c in this?this[--a]=this[c]:delete this[a];return this};$jscomp.array.copyWithin$install=function(){$jscomp.array.installHelper_("copyWithin",$jscomp.array.copyWithin);};
    $jscomp.array.fill=function(a,b,c){var d=this.length||0;0>b&&(b=Math.max(0,d+b));if(null==c||c>d)c=d;c=Number(c);0>c&&(c=Math.max(0,d+c));for(b=Number(b||0);b<c;b++)this[b]=a;return this};$jscomp.array.fill$install=function(){$jscomp.array.installHelper_("fill",$jscomp.array.fill);};$jscomp.array.find=function(a,b){return $jscomp.findInternal(this,a,b).v};$jscomp.array.find$install=function(){$jscomp.array.installHelper_("find",$jscomp.array.find);};
    $jscomp.array.findIndex=function(a,b){return $jscomp.findInternal(this,a,b).i};$jscomp.array.findIndex$install=function(){$jscomp.array.installHelper_("findIndex",$jscomp.array.findIndex);};$jscomp.ASSUME_NO_NATIVE_MAP=!1;
    $jscomp.Map$isConformant=function(){if($jscomp.ASSUME_NO_NATIVE_MAP)return !1;var a=$jscomp.global.Map;if(!a||!a.prototype.entries||"function"!=typeof Object.seal)return !1;try{var b=Object.seal({x:4}),c=new a($jscomp.makeIterator([[b,"s"]]));if("s"!=c.get(b)||1!=c.size||c.get({x:4})||c.set({x:4},"t")!=c||2!=c.size)return !1;var d=c.entries(),e=d.next();if(e.done||e.value[0]!=b||"s"!=e.value[1])return !1;e=d.next();return e.done||4!=e.value[0].x||"t"!=e.value[1]||!d.next().done?!1:!0}catch(f){return !1}};
    $jscomp.Map=function(a){this.data_={};this.head_=$jscomp.Map.createHead();this.size=0;if(a){a=$jscomp.makeIterator(a);for(var b;!(b=a.next()).done;)b=b.value,this.set(b[0],b[1]);}};
    $jscomp.Map.prototype.set=function(a,b){var c=$jscomp.Map.maybeGetEntry(this,a);c.list||(c.list=this.data_[c.id]=[]);c.entry?c.entry.value=b:(c.entry={next:this.head_,previous:this.head_.previous,head:this.head_,key:a,value:b},c.list.push(c.entry),this.head_.previous.next=c.entry,this.head_.previous=c.entry,this.size++);return this};
    $jscomp.Map.prototype["delete"]=function(a){a=$jscomp.Map.maybeGetEntry(this,a);return a.entry&&a.list?(a.list.splice(a.index,1),a.list.length||delete this.data_[a.id],a.entry.previous.next=a.entry.next,a.entry.next.previous=a.entry.previous,a.entry.head=null,this.size--,!0):!1};$jscomp.Map.prototype.clear=function(){this.data_={};this.head_=this.head_.previous=$jscomp.Map.createHead();this.size=0;};$jscomp.Map.prototype.has=function(a){return !!$jscomp.Map.maybeGetEntry(this,a).entry};
    $jscomp.Map.prototype.get=function(a){return (a=$jscomp.Map.maybeGetEntry(this,a).entry)&&a.value};$jscomp.Map.prototype.entries=function(){return $jscomp.Map.makeIterator_(this,function(a){return [a.key,a.value]})};$jscomp.Map.prototype.keys=function(){return $jscomp.Map.makeIterator_(this,function(a){return a.key})};$jscomp.Map.prototype.values=function(){return $jscomp.Map.makeIterator_(this,function(a){return a.value})};
    $jscomp.Map.prototype.forEach=function(a,b){for(var c=this.entries(),d;!(d=c.next()).done;)d=d.value,a.call(b,d[1],d[0],this);};$jscomp.Map.maybeGetEntry=function(a,b){var c=$jscomp.Map.getId(b),d=a.data_[c];if(d&&Object.prototype.hasOwnProperty.call(a.data_,c))for(var e=0;e<d.length;e++){var f=d[e];if(b!==b&&f.key!==f.key||b===f.key)return {id:c,list:d,index:e,entry:f}}return {id:c,list:d,index:-1,entry:void 0}};
    $jscomp.Map.makeIterator_=function(a,b){var c=a.head_,d={next:function(){if(c){for(;c.head!=a.head_;)c=c.previous;for(;c.next!=c.head;)return c=c.next,{done:!1,value:b(c)};c=null;}return {done:!0,value:void 0}}};$jscomp.initSymbol();$jscomp.initSymbolIterator();d[Symbol.iterator]=function(){return d};return d};$jscomp.Map.mapIndex_=0;$jscomp.Map.createHead=function(){var a={};return a.previous=a.next=a.head=a};
    $jscomp.Map.getId=function(a){if(!(a instanceof Object))return "p_"+a;if(!($jscomp.Map.idKey in a))try{$jscomp.Map.defineProperty(a,$jscomp.Map.idKey,{value:++$jscomp.Map.mapIndex_});}catch(b){}return $jscomp.Map.idKey in a?a[$jscomp.Map.idKey]:"o_ "+a};$jscomp.Map.defineProperty=Object.defineProperty?function(a,b,c){Object.defineProperty(a,b,{value:String(c)});}:function(a,b,c){a[b]=String(c);};$jscomp.Map.Entry=function(){};
    $jscomp.Map$install=function(){$jscomp.initSymbol();$jscomp.initSymbolIterator();$jscomp.Map$isConformant()?$jscomp.Map=$jscomp.global.Map:($jscomp.initSymbol(),$jscomp.initSymbolIterator(),$jscomp.Map.prototype[Symbol.iterator]=$jscomp.Map.prototype.entries,$jscomp.initSymbol(),$jscomp.Map.idKey=Symbol("map-id-key"),$jscomp.Map$install=function(){});};$jscomp.math=$jscomp.math||{};
    $jscomp.math.clz32=function(a){a=Number(a)>>>0;if(0===a)return 32;var b=0;0===(a&4294901760)&&(a<<=16,b+=16);0===(a&4278190080)&&(a<<=8,b+=8);0===(a&4026531840)&&(a<<=4,b+=4);0===(a&3221225472)&&(a<<=2,b+=2);0===(a&2147483648)&&b++;return b};$jscomp.math.imul=function(a,b){a=Number(a);b=Number(b);var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};$jscomp.math.sign=function(a){a=Number(a);return 0===a||isNaN(a)?a:0<a?1:-1};
    $jscomp.math.log10=function(a){return Math.log(a)/Math.LN10};$jscomp.math.log2=function(a){return Math.log(a)/Math.LN2};$jscomp.math.log1p=function(a){a=Number(a);if(.25>a&&-.25<a){for(var b=a,c=1,d=a,e=0,f=1;e!=d;)b*=a,f*=-1,d=(e=d)+f*b/++c;return d}return Math.log(1+a)};$jscomp.math.expm1=function(a){a=Number(a);if(.25>a&&-.25<a){for(var b=a,c=1,d=a,e=0;e!=d;)b*=a/++c,d=(e=d)+b;return d}return Math.exp(a)-1};$jscomp.math.cosh=function(a){a=Number(a);return (Math.exp(a)+Math.exp(-a))/2};
    $jscomp.math.sinh=function(a){a=Number(a);return 0===a?a:(Math.exp(a)-Math.exp(-a))/2};$jscomp.math.tanh=function(a){a=Number(a);if(0===a)return a;var b=Math.exp(-2*Math.abs(a)),b=(1-b)/(1+b);return 0>a?-b:b};$jscomp.math.acosh=function(a){a=Number(a);return Math.log(a+Math.sqrt(a*a-1))};$jscomp.math.asinh=function(a){a=Number(a);if(0===a)return a;var b=Math.log(Math.abs(a)+Math.sqrt(a*a+1));return 0>a?-b:b};
    $jscomp.math.atanh=function(a){a=Number(a);return ($jscomp.math.log1p(a)-$jscomp.math.log1p(-a))/2};$jscomp.math.hypot=function(a,b,c){a=Number(a);b=Number(b);var d,e,f,g=Math.max(Math.abs(a),Math.abs(b));for(d=2;d<arguments.length;d++)g=Math.max(g,Math.abs(arguments[d]));if(1E100<g||1E-100>g){a/=g;b/=g;f=a*a+b*b;for(d=2;d<arguments.length;d++)e=Number(arguments[d])/g,f+=e*e;return Math.sqrt(f)*g}f=a*a+b*b;for(d=2;d<arguments.length;d++)e=Number(arguments[d]),f+=e*e;return Math.sqrt(f)};
    $jscomp.math.trunc=function(a){a=Number(a);if(isNaN(a)||Infinity===a||-Infinity===a||0===a)return a;var b=Math.floor(Math.abs(a));return 0>a?-b:b};$jscomp.math.cbrt=function(a){if(0===a)return a;a=Number(a);var b=Math.pow(Math.abs(a),1/3);return 0>a?-b:b};$jscomp.number=$jscomp.number||{};$jscomp.number.isFinite=function(a){return "number"!==typeof a?!1:!isNaN(a)&&Infinity!==a&&-Infinity!==a};$jscomp.number.isInteger=function(a){return $jscomp.number.isFinite(a)?a===Math.floor(a):!1};
    $jscomp.number.isNaN=function(a){return "number"===typeof a&&isNaN(a)};$jscomp.number.isSafeInteger=function(a){return $jscomp.number.isInteger(a)&&Math.abs(a)<=$jscomp.number.MAX_SAFE_INTEGER};$jscomp.number.EPSILON=function(){return Math.pow(2,-52)}();$jscomp.number.MAX_SAFE_INTEGER=function(){return 9007199254740991}();$jscomp.number.MIN_SAFE_INTEGER=function(){return -9007199254740991}();$jscomp.object=$jscomp.object||{};
    $jscomp.object.assign=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(d)for(var e in d)Object.prototype.hasOwnProperty.call(d,e)&&(a[e]=d[e]);}return a};$jscomp.object.is=function(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b};$jscomp.ASSUME_NO_NATIVE_SET=!1;
    $jscomp.Set$isConformant=function(){if($jscomp.ASSUME_NO_NATIVE_SET)return !1;var a=$jscomp.global.Set;if(!a||!a.prototype.entries||"function"!=typeof Object.seal)return !1;try{var b=Object.seal({x:4}),c=new a($jscomp.makeIterator([b]));if(!c.has(b)||1!=c.size||c.add(b)!=c||1!=c.size||c.add({x:4})!=c||2!=c.size)return !1;var d=c.entries(),e=d.next();if(e.done||e.value[0]!=b||e.value[1]!=b)return !1;e=d.next();return e.done||e.value[0]==b||4!=e.value[0].x||e.value[1]!=e.value[0]?!1:d.next().done}catch(f){return !1}};
    $jscomp.Set=function(a){this.map_=new $jscomp.Map;if(a){a=$jscomp.makeIterator(a);for(var b;!(b=a.next()).done;)this.add(b.value);}this.size=this.map_.size;};$jscomp.Set.prototype.add=function(a){this.map_.set(a,a);this.size=this.map_.size;return this};$jscomp.Set.prototype["delete"]=function(a){a=this.map_["delete"](a);this.size=this.map_.size;return a};$jscomp.Set.prototype.clear=function(){this.map_.clear();this.size=0;};$jscomp.Set.prototype.has=function(a){return this.map_.has(a)};
    $jscomp.Set.prototype.entries=function(){return this.map_.entries()};$jscomp.Set.prototype.values=function(){return this.map_.values()};$jscomp.Set.prototype.forEach=function(a,b){var c=this;this.map_.forEach(function(d){return a.call(b,d,d,c)});};$jscomp.Set$install=function(){$jscomp.Map$install();$jscomp.Set$isConformant()?$jscomp.Set=$jscomp.global.Set:($jscomp.initSymbol(),$jscomp.initSymbolIterator(),$jscomp.Set.prototype[Symbol.iterator]=$jscomp.Set.prototype.values,$jscomp.Set$install=function(){});};
    $jscomp.string=$jscomp.string||{};$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
    $jscomp.string.fromCodePoint=function(a){for(var b="",c=0;c<arguments.length;c++){var d=Number(arguments[c]);if(0>d||1114111<d||d!==Math.floor(d))throw new RangeError("invalid_code_point "+d);65535>=d?b+=String.fromCharCode(d):(d-=65536,b+=String.fromCharCode(d>>>10&1023|55296),b+=String.fromCharCode(d&1023|56320));}return b};
    $jscomp.string.repeat=function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var c="";a;)if(a&1&&(c+=b),a>>>=1)b+=b;return c};$jscomp.string.repeat$install=function(){String.prototype.repeat||(String.prototype.repeat=$jscomp.string.repeat);};
    $jscomp.string.codePointAt=function(a){var b=$jscomp.checkStringArgs(this,null,"codePointAt"),c=b.length;a=Number(a)||0;if(0<=a&&a<c){a|=0;var d=b.charCodeAt(a);if(55296>d||56319<d||a+1===c)return d;a=b.charCodeAt(a+1);return 56320>a||57343<a?d:1024*(d-55296)+a+9216}};$jscomp.string.codePointAt$install=function(){String.prototype.codePointAt||(String.prototype.codePointAt=$jscomp.string.codePointAt);};
    $jscomp.string.includes=function(a,b){return -1!==$jscomp.checkStringArgs(this,a,"includes").indexOf(a,b||0)};$jscomp.string.includes$install=function(){String.prototype.includes||(String.prototype.includes=$jscomp.string.includes);};$jscomp.string.startsWith=function(a,b){var c=$jscomp.checkStringArgs(this,a,"startsWith");a+="";for(var d=c.length,e=a.length,f=Math.max(0,Math.min(b|0,c.length)),g=0;g<e&&f<d;)if(c[f++]!=a[g++])return !1;return g>=e};
    $jscomp.string.startsWith$install=function(){String.prototype.startsWith||(String.prototype.startsWith=$jscomp.string.startsWith);};$jscomp.string.endsWith=function(a,b){var c=$jscomp.checkStringArgs(this,a,"endsWith");a+="";void 0===b&&(b=c.length);for(var d=Math.max(0,Math.min(b|0,c.length)),e=a.length;0<e&&0<d;)if(c[--d]!=a[--e])return !1;return 0>=e};$jscomp.string.endsWith$install=function(){String.prototype.endsWith||(String.prototype.endsWith=$jscomp.string.endsWith);};
    var COMPILED$1=!0,goog=goog||{};goog.global=commonjsGlobal;goog.isDef=function(a){return void 0!==a};goog.exportPath_=function(a,b,c){a=a.split(".");c=c||goog.global;a[0]in c||!c.execScript||c.execScript("var "+a[0]);for(var d;a.length&&(d=a.shift());)!a.length&&goog.isDef(b)?c[d]=b:c=c[d]?c[d]:c[d]={};};
    goog.define=function(a,b){var c=b;goog.exportPath_(a,c);};goog.DEBUG=!0;goog.LOCALE="en";goog.TRUSTED_SITE=!0;goog.STRICT_MODE_COMPATIBLE=!1;goog.DISALLOW_TEST_ONLY_CODE=!goog.DEBUG;
    goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING=!1;goog.provide=function(a){goog.constructNamespace_(a);};goog.constructNamespace_=function(a,b){goog.exportPath_(a,b);};goog.VALID_MODULE_RE_=/^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
    goog.module=function(a){if(!goog.isString(a)||!a||-1==a.search(goog.VALID_MODULE_RE_))throw Error("Invalid module identifier");if(!goog.isInModuleLoader_())throw Error("Module "+a+" has been loaded incorrectly.");if(goog.moduleLoaderState_.moduleName)throw Error("goog.module may only be called once per module.");goog.moduleLoaderState_.moduleName=a;};goog.module.get=function(a){return goog.module.getInternal_(a)};
    goog.module.getInternal_=function(a){};goog.moduleLoaderState_=null;goog.isInModuleLoader_=function(){return null!=goog.moduleLoaderState_};
    goog.module.declareLegacyNamespace=function(){goog.moduleLoaderState_.declareLegacyNamespace=!0;};
    goog.setTestOnly=function(a){if(goog.DISALLOW_TEST_ONLY_CODE)throw a=a||"",Error("Importing test-only code into non-debug environment"+(a?": "+a:"."));};goog.forwardDeclare=function(a){};goog.getObjectByName=function(a,b){for(var c=a.split("."),d=b||goog.global,e;e=c.shift();)if(goog.isDefAndNotNull(d[e]))d=d[e];else return null;return d};goog.globalize=function(a,b){var c=b||goog.global,d;for(d in a)c[d]=a[d];};goog.addDependency=function(a,b,c,d){if(goog.DEPENDENCIES_ENABLED){var e;a=a.replace(/\\/g,"/");for(var f=goog.dependencies_,g=0;e=b[g];g++)f.nameToPath[e]=a,f.pathIsModule[a]=!!d;for(d=0;b=c[d];d++)a in f.requires||(f.requires[a]={}),f.requires[a][b]=!0;}};
    goog.ENABLE_DEBUG_LOADER=!0;goog.logToConsole_=function(a){goog.global.console&&goog.global.console.error(a);};goog.require=function(a){};
    goog.basePath="";goog.nullFunction=function(){};goog.abstractMethod=function(){throw Error("unimplemented abstract method");};goog.addSingletonGetter=function(a){a.getInstance=function(){if(a.instance_)return a.instance_;goog.DEBUG&&(goog.instantiatedSingletons_[goog.instantiatedSingletons_.length]=a);return a.instance_=new a};};goog.instantiatedSingletons_=[];goog.LOAD_MODULE_USING_EVAL=!0;goog.SEAL_MODULE_EXPORTS=goog.DEBUG;goog.loadedModules_={};goog.DEPENDENCIES_ENABLED=!COMPILED$1;
    goog.DEPENDENCIES_ENABLED&&(goog.dependencies_={pathIsModule:{},nameToPath:{},requires:{},visited:{},written:{},deferred:{}},goog.inHtmlDocument_=function(){var a=goog.global.document;return null!=a&&"write"in a},goog.findBasePath_=function(){if(goog.isDef(goog.global.CLOSURE_BASE_PATH))goog.basePath=goog.global.CLOSURE_BASE_PATH;else if(goog.inHtmlDocument_())for(var a=goog.global.document.getElementsByTagName("SCRIPT"),b=a.length-1;0<=b;--b){var c=a[b].src,d=c.lastIndexOf("?"),d=-1==d?c.length:
    d;if("base.js"==c.substr(d-7,7)){goog.basePath=c.substr(0,d-7);break}}},goog.importScript_=function(a,b){(goog.global.CLOSURE_IMPORT_SCRIPT||goog.writeScriptTag_)(a,b)&&(goog.dependencies_.written[a]=!0);},goog.IS_OLD_IE_=!(goog.global.atob||!goog.global.document||!goog.global.document.all),goog.importModule_=function(a){goog.importScript_("",'goog.retrieveAndExecModule_("'+a+'");')&&(goog.dependencies_.written[a]=!0);},goog.queuedModules_=[],goog.wrapModule_=function(a,b){return goog.LOAD_MODULE_USING_EVAL&&
    goog.isDef(goog.global.JSON)?"goog.loadModule("+goog.global.JSON.stringify(b+"\n//# sourceURL="+a+"\n")+");":'goog.loadModule(function(exports) {"use strict";'+b+"\n;return exports});\n//# sourceURL="+a+"\n"},goog.loadQueuedModules_=function(){var a=goog.queuedModules_.length;if(0<a){var b=goog.queuedModules_;goog.queuedModules_=[];for(var c=0;c<a;c++)goog.maybeProcessDeferredPath_(b[c]);}},goog.maybeProcessDeferredDep_=function(a){goog.isDeferredModule_(a)&&goog.allDepsAreAvailable_(a)&&(a=goog.getPathFromDeps_(a),
    goog.maybeProcessDeferredPath_(goog.basePath+a));},goog.isDeferredModule_=function(a){return (a=goog.getPathFromDeps_(a))&&goog.dependencies_.pathIsModule[a]?goog.basePath+a in goog.dependencies_.deferred:!1},goog.allDepsAreAvailable_=function(a){if((a=goog.getPathFromDeps_(a))&&a in goog.dependencies_.requires)for(var b in goog.dependencies_.requires[a])if(!goog.isProvided_(b)&&!goog.isDeferredModule_(b))return !1;return !0},goog.maybeProcessDeferredPath_=function(a){if(a in goog.dependencies_.deferred){var b=
    goog.dependencies_.deferred[a];delete goog.dependencies_.deferred[a];goog.globalEval(b);}},goog.loadModuleFromUrl=function(a){goog.retrieveAndExecModule_(a);},goog.loadModule=function(a){var b=goog.moduleLoaderState_;try{goog.moduleLoaderState_={moduleName:void 0,declareLegacyNamespace:!1};var c;if(goog.isFunction(a))c=a.call(goog.global,{});else if(goog.isString(a))c=goog.loadModuleFromSource_.call(goog.global,a);else throw Error("Invalid module definition");var d=goog.moduleLoaderState_.moduleName;
    if(!goog.isString(d)||!d)throw Error('Invalid module name "'+d+'"');goog.moduleLoaderState_.declareLegacyNamespace?goog.constructNamespace_(d,c):goog.SEAL_MODULE_EXPORTS&&Object.seal&&Object.seal(c);goog.loadedModules_[d]=c;}finally{goog.moduleLoaderState_=b;}},goog.loadModuleFromSource_=function(a){eval(a);return {}},goog.writeScriptSrcNode_=function(a){goog.global.document.write('<script type="text/javascript" src="'+a+'">\x3c/script>');},goog.appendScriptSrcNode_=function(a){var b=goog.global.document,
    c=b.createElement("script");c.type="text/javascript";c.src=a;c.defer=!1;c.async=!1;b.head.appendChild(c);},goog.writeScriptTag_=function(a,b){if(goog.inHtmlDocument_()){var c=goog.global.document;if(!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&&"complete"==c.readyState){if(/\bdeps.js$/.test(a))return !1;throw Error('Cannot write "'+a+'" after document load');}var d=goog.IS_OLD_IE_;void 0===b?d?(d=" onreadystatechange='goog.onScriptLoad_(this, "+ ++goog.lastNonModuleScriptIndex_+")' ",c.write('<script type="text/javascript" src="'+
    a+'"'+d+">\x3c/script>")):goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING?goog.appendScriptSrcNode_(a):goog.writeScriptSrcNode_(a):c.write('<script type="text/javascript">'+b+"\x3c/script>");return !0}return !1},goog.lastNonModuleScriptIndex_=0,goog.onScriptLoad_=function(a,b){"complete"==a.readyState&&goog.lastNonModuleScriptIndex_==b&&goog.loadQueuedModules_();return !0},goog.writeScripts_=function(a){function b(a){if(!(a in e.written||a in e.visited)){e.visited[a]=!0;if(a in e.requires)for(var f in e.requires[a])if(!goog.isProvided_(f))if(f in
    e.nameToPath)b(e.nameToPath[f]);else throw Error("Undefined nameToPath for "+f);a in d||(d[a]=!0,c.push(a));}}var c=[],d={},e=goog.dependencies_;b(a);for(a=0;a<c.length;a++){var f=c[a];goog.dependencies_.written[f]=!0;}var g=goog.moduleLoaderState_;goog.moduleLoaderState_=null;for(a=0;a<c.length;a++)if(f=c[a])e.pathIsModule[f]?goog.importModule_(goog.basePath+f):goog.importScript_(goog.basePath+f);else throw goog.moduleLoaderState_=g,Error("Undefined script input");goog.moduleLoaderState_=g;},goog.getPathFromDeps_=
    function(a){return a in goog.dependencies_.nameToPath?goog.dependencies_.nameToPath[a]:null},goog.findBasePath_(),goog.global.CLOSURE_NO_DEPS||goog.importScript_(goog.basePath+"deps.js"));goog.normalizePath_=function(a){a=a.split("/");for(var b=0;b<a.length;)"."==a[b]?a.splice(b,1):b&&".."==a[b]&&a[b-1]&&".."!=a[b-1]?a.splice(--b,2):b++;return a.join("/")};
    goog.loadFileSync_=function(a){if(goog.global.CLOSURE_LOAD_FILE_SYNC)return goog.global.CLOSURE_LOAD_FILE_SYNC(a);var b=new goog.global.XMLHttpRequest;b.open("get",a,!1);b.send();return b.responseText};
    goog.retrieveAndExecModule_=function(a){};
    goog.typeOf=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return "array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return "object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return "array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return "function"}else return "null";
    else if("function"==b&&"undefined"==typeof a.call)return "object";return b};goog.isNull=function(a){return null===a};goog.isDefAndNotNull=function(a){return null!=a};goog.isArray=function(a){return "array"==goog.typeOf(a)};goog.isArrayLike=function(a){var b=goog.typeOf(a);return "array"==b||"object"==b&&"number"==typeof a.length};goog.isDateLike=function(a){return goog.isObject(a)&&"function"==typeof a.getFullYear};goog.isString=function(a){return "string"==typeof a};
    goog.isBoolean=function(a){return "boolean"==typeof a};goog.isNumber=function(a){return "number"==typeof a};goog.isFunction=function(a){return "function"==goog.typeOf(a)};goog.isObject=function(a){var b=typeof a;return "object"==b&&null!=a||"function"==b};goog.getUid=function(a){return a[goog.UID_PROPERTY_]||(a[goog.UID_PROPERTY_]=++goog.uidCounter_)};goog.hasUid=function(a){return !!a[goog.UID_PROPERTY_]};
    goog.removeUid=function(a){null!==a&&"removeAttribute"in a&&a.removeAttribute(goog.UID_PROPERTY_);try{delete a[goog.UID_PROPERTY_];}catch(b){}};goog.UID_PROPERTY_="closure_uid_"+(1E9*Math.random()>>>0);goog.uidCounter_=0;goog.getHashCode=goog.getUid;goog.removeHashCode=goog.removeUid;goog.cloneObject=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(a.clone)return a.clone();var b="array"==b?[]:{},c;for(c in a)b[c]=goog.cloneObject(a[c]);return b}return a};
    goog.bindNative_=function(a,b,c){return a.call.apply(a.bind,arguments)};goog.bindJs_=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}};
    goog.bind=function(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?goog.bind=goog.bindNative_:goog.bind=goog.bindJs_;return goog.bind.apply(null,arguments)};goog.partial=function(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}};goog.mixin=function(a,b){for(var c in b)a[c]=b[c];};goog.now=goog.TRUSTED_SITE&&Date.now||function(){return +new Date};
    goog.globalEval=function(a){if(goog.global.execScript)goog.global.execScript(a,"JavaScript");else if(goog.global.eval){if(null==goog.evalWorksForGlobals_)if(goog.global.eval("var _evalTest_ = 1;"),"undefined"!=typeof goog.global._evalTest_){try{delete goog.global._evalTest_;}catch(d){}goog.evalWorksForGlobals_=!0;}else goog.evalWorksForGlobals_=!1;if(goog.evalWorksForGlobals_)goog.global.eval(a);else{var b=goog.global.document,c=b.createElement("SCRIPT");c.type="text/javascript";c.defer=!1;c.appendChild(b.createTextNode(a));
    b.body.appendChild(c);b.body.removeChild(c);}}else throw Error("goog.globalEval not available");};goog.evalWorksForGlobals_=null;goog.getCssName=function(a,b){var c=function(a){return goog.cssNameMapping_[a]||a},d=function(a){a=a.split("-");for(var b=[],d=0;d<a.length;d++)b.push(c(a[d]));return b.join("-")},d=goog.cssNameMapping_?"BY_WHOLE"==goog.cssNameMappingStyle_?c:d:function(a){return a};return b?a+"-"+d(b):d(a)};
    goog.setCssNameMapping=function(a,b){goog.cssNameMapping_=a;goog.cssNameMappingStyle_=b;};goog.getMsg=function(a,b){b&&(a=a.replace(/\{\$([^}]+)}/g,function(a,d){return null!=b&&d in b?b[d]:a}));return a};goog.getMsgWithFallback=function(a,b){return a};goog.exportSymbol=function(a,b,c){goog.exportPath_(a,b,c);};goog.exportProperty=function(a,b,c){a[b]=c;};
    goog.inherits=function(a,b){function c(){}c.prototype=b.prototype;a.superClass_=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.base=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)};};
    goog.base=function(a,b,c){var d=arguments.callee.caller;if(goog.STRICT_MODE_COMPATIBLE||goog.DEBUG&&!d)throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");if(d.superClass_){for(var e=Array(arguments.length-1),f=1;f<arguments.length;f++)e[f-1]=arguments[f];return d.superClass_.constructor.apply(a,e)}e=Array(arguments.length-2);for(f=2;f<arguments.length;f++)e[f-2]=arguments[f];for(var f=!1,g=a.constructor;g;g=
    g.superClass_&&g.superClass_.constructor)if(g.prototype[b]===d)f=!0;else if(f)return g.prototype[b].apply(a,e);if(a[b]===d)return a.constructor.prototype[b].apply(a,e);throw Error("goog.base called from a method of one name to a method of a different name");};goog.scope=function(a){a.call(goog.global);};goog.defineClass=function(a,b){var c=b.constructor,d=b.statics;c&&c!=Object.prototype.constructor||(c=function(){throw Error("cannot instantiate an interface (no constructor defined).");});c=goog.defineClass.createSealingConstructor_(c,a);a&&goog.inherits(c,a);delete b.constructor;delete b.statics;goog.defineClass.applyProperties_(c.prototype,b);null!=d&&(d instanceof Function?d(c):goog.defineClass.applyProperties_(c,d));return c};goog.defineClass.SEAL_CLASS_INSTANCES=goog.DEBUG;
    goog.defineClass.createSealingConstructor_=function(a,b){if(goog.defineClass.SEAL_CLASS_INSTANCES&&Object.seal instanceof Function){if(b&&b.prototype&&b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_])return a;var c=function(){var b=a.apply(this,arguments)||this;b[goog.UID_PROPERTY_]=b[goog.UID_PROPERTY_];this.constructor===c&&Object.seal(b);return b};return c}return a};goog.defineClass.OBJECT_PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.defineClass.applyProperties_=function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);for(var d=0;d<goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length;d++)c=goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d],Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c]);};goog.tagUnsealableClass=function(a){};goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_="goog_defineClass_legacy_unsealable";goog.dom={};goog.dom.NodeType={ELEMENT:1,ATTRIBUTE:2,TEXT:3,CDATA_SECTION:4,ENTITY_REFERENCE:5,ENTITY:6,PROCESSING_INSTRUCTION:7,COMMENT:8,DOCUMENT:9,DOCUMENT_TYPE:10,DOCUMENT_FRAGMENT:11,NOTATION:12};goog.debug={};goog.debug.Error=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,goog.debug.Error);else{var b=Error().stack;b&&(this.stack=b);}a&&(this.message=String(a));this.reportErrorToServer=!0;};goog.inherits(goog.debug.Error,Error);goog.debug.Error.prototype.name="CustomError";goog.string={};goog.string.DETECT_DOUBLE_ESCAPING=!1;goog.string.FORCE_NON_DOM_HTML_UNESCAPING=!1;goog.string.Unicode={NBSP:"\u00a0"};goog.string.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};goog.string.endsWith=function(a,b){var c=a.length-b.length;return 0<=c&&a.indexOf(b,c)==c};goog.string.caseInsensitiveStartsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(0,b.length))};
    goog.string.caseInsensitiveEndsWith=function(a,b){return 0==goog.string.caseInsensitiveCompare(b,a.substr(a.length-b.length,b.length))};goog.string.caseInsensitiveEquals=function(a,b){return a.toLowerCase()==b.toLowerCase()};goog.string.subs=function(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")};goog.string.collapseWhitespace=function(a){return a.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")};
    goog.string.isEmptyOrWhitespace=function(a){return /^[\s\xa0]*$/.test(a)};goog.string.isEmptyString=function(a){return 0==a.length};goog.string.isEmpty=goog.string.isEmptyOrWhitespace;goog.string.isEmptyOrWhitespaceSafe=function(a){return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a))};goog.string.isEmptySafe=goog.string.isEmptyOrWhitespaceSafe;goog.string.isBreakingWhitespace=function(a){return !/[^\t\n\r ]/.test(a)};goog.string.isAlpha=function(a){return !/[^a-zA-Z]/.test(a)};
    goog.string.isNumeric=function(a){return !/[^0-9]/.test(a)};goog.string.isAlphaNumeric=function(a){return !/[^a-zA-Z0-9]/.test(a)};goog.string.isSpace=function(a){return " "==a};goog.string.isUnicodeChar=function(a){return 1==a.length&&" "<=a&&"~">=a||"\u0080"<=a&&"\ufffd">=a};goog.string.stripNewlines=function(a){return a.replace(/(\r\n|\r|\n)+/g," ")};goog.string.canonicalizeNewlines=function(a){return a.replace(/(\r\n|\r|\n)/g,"\n")};
    goog.string.normalizeWhitespace=function(a){return a.replace(/\xa0|\s/g," ")};goog.string.normalizeSpaces=function(a){return a.replace(/\xa0|[ \t]+/g," ")};goog.string.collapseBreakingSpaces=function(a){return a.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")};goog.string.trim=goog.TRUSTED_SITE&&String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};goog.string.trimLeft=function(a){return a.replace(/^[\s\xa0]+/,"")};
    goog.string.trimRight=function(a){return a.replace(/[\s\xa0]+$/,"")};goog.string.caseInsensitiveCompare=function(a,b){var c=String(a).toLowerCase(),d=String(b).toLowerCase();return c<d?-1:c==d?0:1};
    goog.string.numberAwareCompare_=function(a,b,c){if(a==b)return 0;if(!a)return -1;if(!b)return 1;for(var d=a.toLowerCase().match(c),e=b.toLowerCase().match(c),f=Math.min(d.length,e.length),g=0;g<f;g++){c=d[g];var h=e[g];if(c!=h)return a=parseInt(c,10),!isNaN(a)&&(b=parseInt(h,10),!isNaN(b)&&a-b)?a-b:c<h?-1:1}return d.length!=e.length?d.length-e.length:a<b?-1:1};goog.string.intAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\D+/g)};
    goog.string.floatAwareCompare=function(a,b){return goog.string.numberAwareCompare_(a,b,/\d+|\.\d+|\D+/g)};goog.string.numerateCompare=goog.string.floatAwareCompare;goog.string.urlEncode=function(a){return encodeURIComponent(String(a))};goog.string.urlDecode=function(a){return decodeURIComponent(a.replace(/\+/g," "))};goog.string.newLineToBr=function(a,b){return a.replace(/(\r\n|\r|\n)/g,b?"<br />":"<br>")};
    goog.string.htmlEscape=function(a,b){if(b)a=a.replace(goog.string.AMP_RE_,"&amp;").replace(goog.string.LT_RE_,"&lt;").replace(goog.string.GT_RE_,"&gt;").replace(goog.string.QUOT_RE_,"&quot;").replace(goog.string.SINGLE_QUOTE_RE_,"&#39;").replace(goog.string.NULL_RE_,"&#0;"),goog.string.DETECT_DOUBLE_ESCAPING&&(a=a.replace(goog.string.E_RE_,"&#101;"));else{if(!goog.string.ALL_RE_.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(goog.string.AMP_RE_,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(goog.string.LT_RE_,
    "&lt;"));-1!=a.indexOf(">")&&(a=a.replace(goog.string.GT_RE_,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(goog.string.QUOT_RE_,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(goog.string.SINGLE_QUOTE_RE_,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(goog.string.NULL_RE_,"&#0;"));goog.string.DETECT_DOUBLE_ESCAPING&&-1!=a.indexOf("e")&&(a=a.replace(goog.string.E_RE_,"&#101;"));}return a};goog.string.AMP_RE_=/&/g;goog.string.LT_RE_=/</g;goog.string.GT_RE_=/>/g;goog.string.QUOT_RE_=/"/g;
    goog.string.SINGLE_QUOTE_RE_=/'/g;goog.string.NULL_RE_=/\x00/g;goog.string.E_RE_=/e/g;goog.string.ALL_RE_=goog.string.DETECT_DOUBLE_ESCAPING?/[\x00&<>"'e]/:/[\x00&<>"']/;goog.string.unescapeEntities=function(a){return goog.string.contains(a,"&")?!goog.string.FORCE_NON_DOM_HTML_UNESCAPING&&"document"in goog.global?goog.string.unescapeEntitiesUsingDom_(a):goog.string.unescapePureXmlEntities_(a):a};
    goog.string.unescapeEntitiesWithDocument=function(a,b){return goog.string.contains(a,"&")?goog.string.unescapeEntitiesUsingDom_(a,b):a};
    goog.string.unescapeEntitiesUsingDom_=function(a,b){var c={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'},d;d=b?b.createElement("div"):goog.global.document.createElement("div");return a.replace(goog.string.HTML_ENTITY_PATTERN_,function(a,b){var g=c[a];if(g)return g;if("#"==b.charAt(0)){var h=Number("0"+b.substr(1));isNaN(h)||(g=String.fromCharCode(h));}g||(d.innerHTML=a+" ",g=d.firstChild.nodeValue.slice(0,-1));return c[a]=g})};
    goog.string.unescapePureXmlEntities_=function(a){return a.replace(/&([^;]+);/g,function(a,c){switch(c){case "amp":return "&";case "lt":return "<";case "gt":return ">";case "quot":return '"';default:if("#"==c.charAt(0)){var d=Number("0"+c.substr(1));if(!isNaN(d))return String.fromCharCode(d)}return a}})};goog.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g;goog.string.whitespaceEscape=function(a,b){return goog.string.newLineToBr(a.replace(/  /g," &#160;"),b)};
    goog.string.preserveSpaces=function(a){return a.replace(/(^|[\n ]) /g,"$1"+goog.string.Unicode.NBSP)};goog.string.stripQuotes=function(a,b){for(var c=b.length,d=0;d<c;d++){var e=1==c?b:b.charAt(d);if(a.charAt(0)==e&&a.charAt(a.length-1)==e)return a.substring(1,a.length-1)}return a};goog.string.truncate=function(a,b,c){c&&(a=goog.string.unescapeEntities(a));a.length>b&&(a=a.substring(0,b-3)+"...");c&&(a=goog.string.htmlEscape(a));return a};
    goog.string.truncateMiddle=function(a,b,c,d){c&&(a=goog.string.unescapeEntities(a));if(d&&a.length>b){d>b&&(d=b);var e=a.length-d;a=a.substring(0,b-d)+"..."+a.substring(e);}else a.length>b&&(d=Math.floor(b/2),e=a.length-d,a=a.substring(0,d+b%2)+"..."+a.substring(e));c&&(a=goog.string.htmlEscape(a));return a};goog.string.specialEscapeChars_={"\x00":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\x0B",'"':'\\"',"\\":"\\\\","<":"<"};goog.string.jsEscapeCache_={"'":"\\'"};
    goog.string.quote=function(a){a=String(a);for(var b=['"'],c=0;c<a.length;c++){var d=a.charAt(c),e=d.charCodeAt(0);b[c+1]=goog.string.specialEscapeChars_[d]||(31<e&&127>e?d:goog.string.escapeChar(d));}b.push('"');return b.join("")};goog.string.escapeString=function(a){for(var b=[],c=0;c<a.length;c++)b[c]=goog.string.escapeChar(a.charAt(c));return b.join("")};
    goog.string.escapeChar=function(a){if(a in goog.string.jsEscapeCache_)return goog.string.jsEscapeCache_[a];if(a in goog.string.specialEscapeChars_)return goog.string.jsEscapeCache_[a]=goog.string.specialEscapeChars_[a];var b,c=a.charCodeAt(0);if(31<c&&127>c)b=a;else{if(256>c){if(b="\\x",16>c||256<c)b+="0";}else b="\\u",4096>c&&(b+="0");b+=c.toString(16).toUpperCase();}return goog.string.jsEscapeCache_[a]=b};goog.string.contains=function(a,b){return -1!=a.indexOf(b)};
    goog.string.caseInsensitiveContains=function(a,b){return goog.string.contains(a.toLowerCase(),b.toLowerCase())};goog.string.countOf=function(a,b){return a&&b?a.split(b).length-1:0};goog.string.removeAt=function(a,b,c){var d=a;0<=b&&b<a.length&&0<c&&(d=a.substr(0,b)+a.substr(b+c,a.length-b-c));return d};goog.string.remove=function(a,b){var c=new RegExp(goog.string.regExpEscape(b),"");return a.replace(c,"")};
    goog.string.removeAll=function(a,b){var c=new RegExp(goog.string.regExpEscape(b),"g");return a.replace(c,"")};goog.string.regExpEscape=function(a){return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")};goog.string.repeat=String.prototype.repeat?function(a,b){return a.repeat(b)}:function(a,b){return Array(b+1).join(a)};
    goog.string.padNumber=function(a,b,c){a=goog.isDef(c)?a.toFixed(c):String(a);c=a.indexOf(".");-1==c&&(c=a.length);return goog.string.repeat("0",Math.max(0,b-c))+a};goog.string.makeSafe=function(a){return null==a?"":String(a)};goog.string.buildString=function(a){return Array.prototype.join.call(arguments,"")};goog.string.getRandomString=function(){return Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^goog.now()).toString(36)};
    goog.string.compareVersions=function(a,b){for(var c=0,d=goog.string.trim(String(a)).split("."),e=goog.string.trim(String(b)).split("."),f=Math.max(d.length,e.length),g=0;0==c&&g<f;g++){var h=d[g]||"",k=e[g]||"",l=RegExp("(\\d*)(\\D*)","g"),p=RegExp("(\\d*)(\\D*)","g");do{var m=l.exec(h)||["","",""],n=p.exec(k)||["","",""];if(0==m[0].length&&0==n[0].length)break;var c=0==m[1].length?0:parseInt(m[1],10),q=0==n[1].length?0:parseInt(n[1],10),c=goog.string.compareElements_(c,q)||goog.string.compareElements_(0==
    m[2].length,0==n[2].length)||goog.string.compareElements_(m[2],n[2]);}while(0==c)}return c};goog.string.compareElements_=function(a,b){return a<b?-1:a>b?1:0};goog.string.hashCode=function(a){for(var b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c)>>>0;return b};goog.string.uniqueStringCounter_=2147483648*Math.random()|0;goog.string.createUniqueString=function(){return "goog_"+goog.string.uniqueStringCounter_++};
    goog.string.toNumber=function(a){var b=Number(a);return 0==b&&goog.string.isEmptyOrWhitespace(a)?NaN:b};goog.string.isLowerCamelCase=function(a){return /^[a-z]+([A-Z][a-z]*)*$/.test(a)};goog.string.isUpperCamelCase=function(a){return /^([A-Z][a-z]*)+$/.test(a)};goog.string.toCamelCase=function(a){return String(a).replace(/\-([a-z])/g,function(a,c){return c.toUpperCase()})};goog.string.toSelectorCase=function(a){return String(a).replace(/([A-Z])/g,"-$1").toLowerCase()};
    goog.string.toTitleCase=function(a,b){var c=goog.isString(b)?goog.string.regExpEscape(b):"\\s";return a.replace(new RegExp("(^"+(c?"|["+c+"]+":"")+")([a-z])","g"),function(a,b,c){return b+c.toUpperCase()})};goog.string.capitalize=function(a){return String(a.charAt(0)).toUpperCase()+String(a.substr(1)).toLowerCase()};goog.string.parseInt=function(a){isFinite(a)&&(a=String(a));return goog.isString(a)?/^\s*-?0x/i.test(a)?parseInt(a,16):parseInt(a,10):NaN};
    goog.string.splitLimit=function(a,b,c){a=a.split(b);for(var d=[];0<c&&a.length;)d.push(a.shift()),c--;a.length&&d.push(a.join(b));return d};goog.string.editDistance=function(a,b){var c=[],d=[];if(a==b)return 0;if(!a.length||!b.length)return Math.max(a.length,b.length);for(var e=0;e<b.length+1;e++)c[e]=e;for(e=0;e<a.length;e++){d[0]=e+1;for(var f=0;f<b.length;f++)d[f+1]=Math.min(d[f]+1,c[f+1]+1,c[f]+Number(a[e]!=b[f]));for(f=0;f<c.length;f++)c[f]=d[f];}return d[b.length]};goog.asserts={};goog.asserts.ENABLE_ASSERTS=goog.DEBUG;goog.asserts.AssertionError=function(a,b){b.unshift(a);goog.debug.Error.call(this,goog.string.subs.apply(null,b));b.shift();this.messagePattern=a;};goog.inherits(goog.asserts.AssertionError,goog.debug.Error);goog.asserts.AssertionError.prototype.name="AssertionError";goog.asserts.DEFAULT_ERROR_HANDLER=function(a){throw a;};goog.asserts.errorHandler_=goog.asserts.DEFAULT_ERROR_HANDLER;
    goog.asserts.doAssertFailure_=function(a,b,c,d){var e="Assertion failed";if(c)var e=e+(": "+c),f=d;else a&&(e+=": "+a,f=b);a=new goog.asserts.AssertionError(""+e,f||[]);goog.asserts.errorHandler_(a);};goog.asserts.setErrorHandler=function(a){goog.asserts.ENABLE_ASSERTS&&(goog.asserts.errorHandler_=a);};goog.asserts.assert=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!a&&goog.asserts.doAssertFailure_("",null,b,Array.prototype.slice.call(arguments,2));return a};
    goog.asserts.fail=function(a,b){goog.asserts.ENABLE_ASSERTS&&goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1)));};goog.asserts.assertNumber=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isNumber(a)&&goog.asserts.doAssertFailure_("Expected number but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
    goog.asserts.assertString=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isString(a)&&goog.asserts.doAssertFailure_("Expected string but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertFunction=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isFunction(a)&&goog.asserts.doAssertFailure_("Expected function but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
    goog.asserts.assertObject=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isObject(a)&&goog.asserts.doAssertFailure_("Expected object but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertArray=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isArray(a)&&goog.asserts.doAssertFailure_("Expected array but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
    goog.asserts.assertBoolean=function(a,b,c){goog.asserts.ENABLE_ASSERTS&&!goog.isBoolean(a)&&goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};goog.asserts.assertElement=function(a,b,c){!goog.asserts.ENABLE_ASSERTS||goog.isObject(a)&&a.nodeType==goog.dom.NodeType.ELEMENT||goog.asserts.doAssertFailure_("Expected Element but got %s: %s.",[goog.typeOf(a),a],b,Array.prototype.slice.call(arguments,2));return a};
    goog.asserts.assertInstanceof=function(a,b,c,d){!goog.asserts.ENABLE_ASSERTS||a instanceof b||goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.",[goog.asserts.getType_(b),goog.asserts.getType_(a)],c,Array.prototype.slice.call(arguments,3));return a};goog.asserts.assertObjectPrototypeIsIntact=function(){for(var a in Object.prototype)goog.asserts.fail(a+" should not be enumerable in Object.prototype.");};
    goog.asserts.getType_=function(a){return a instanceof Function?a.displayName||a.name||"unknown type name":a instanceof Object?a.constructor.displayName||a.constructor.name||Object.prototype.toString.call(a):null===a?"null":typeof a};var jspb={Map:function(a,b){this.arr_=a;this.valueCtor_=b;this.map_={};this.arrClean=!0;0<this.arr_.length&&this.loadFromArray_();}};jspb.Map.prototype.loadFromArray_=function(){for(var a=0;a<this.arr_.length;a++){var b=this.arr_[a],c=b[0];this.map_[c.toString()]=new jspb.Map.Entry_(c,b[1]);}this.arrClean=!0;};
    jspb.Map.prototype.toArray=function(){if(this.arrClean){if(this.valueCtor_){var a=this.map_,b;for(b in a)if(Object.prototype.hasOwnProperty.call(a,b)){var c=a[b].valueWrapper;c&&c.toArray();}}}else{this.arr_.length=0;a=this.stringKeys_();a.sort();for(b=0;b<a.length;b++){var d=this.map_[a[b]];(c=d.valueWrapper)&&c.toArray();this.arr_.push([d.key,d.value]);}this.arrClean=!0;}return this.arr_};
    jspb.Map.prototype.toObject=function(a,b){for(var c=this.toArray(),d=[],e=0;e<c.length;e++){var f=this.map_[c[e][0].toString()];this.wrapEntry_(f);var g=f.valueWrapper;g?(goog.asserts.assert(b),d.push([f.key,b(a,g)])):d.push([f.key,f.value]);}return d};jspb.Map.fromObject=function(a,b,c){b=new jspb.Map([],b);for(var d=0;d<a.length;d++){var e=a[d][0],f=c(a[d][1]);b.set(e,f);}return b};jspb.Map.ArrayIteratorIterable_=function(a){this.idx_=0;this.arr_=a;};
    jspb.Map.ArrayIteratorIterable_.prototype.next=function(){return this.idx_<this.arr_.length?{done:!1,value:this.arr_[this.idx_++]}:{done:!0,value:void 0}};$jscomp.initSymbol();"undefined"!=typeof Symbol&&($jscomp.initSymbol(),$jscomp.initSymbolIterator(),jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator]=function(){return this});jspb.Map.prototype.getLength=function(){return this.stringKeys_().length};jspb.Map.prototype.clear=function(){this.map_={};this.arrClean=!1;};
    jspb.Map.prototype.del=function(a){a=a.toString();var b=this.map_.hasOwnProperty(a);delete this.map_[a];this.arrClean=!1;return b};jspb.Map.prototype.getEntryList=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,d.value]);}return a};jspb.Map.prototype.entries=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++){var d=this.map_[b[c]];a.push([d.key,this.wrapEntry_(d)]);}return new jspb.Map.ArrayIteratorIterable_(a)};
    jspb.Map.prototype.keys=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.map_[b[c]].key);return new jspb.Map.ArrayIteratorIterable_(a)};jspb.Map.prototype.values=function(){var a=[],b=this.stringKeys_();b.sort();for(var c=0;c<b.length;c++)a.push(this.wrapEntry_(this.map_[b[c]]));return new jspb.Map.ArrayIteratorIterable_(a)};
    jspb.Map.prototype.forEach=function(a,b){var c=this.stringKeys_();c.sort();for(var d=0;d<c.length;d++){var e=this.map_[c[d]];a.call(b,this.wrapEntry_(e),e.key,this);}};jspb.Map.prototype.set=function(a,b){var c=new jspb.Map.Entry_(a);this.valueCtor_?(c.valueWrapper=b,c.value=b.toArray()):c.value=b;this.map_[a.toString()]=c;this.arrClean=!1;return this};jspb.Map.prototype.wrapEntry_=function(a){return this.valueCtor_?(a.valueWrapper||(a.valueWrapper=new this.valueCtor_(a.value)),a.valueWrapper):a.value};
    jspb.Map.prototype.get=function(a){if(a=this.map_[a.toString()])return this.wrapEntry_(a)};jspb.Map.prototype.has=function(a){return a.toString()in this.map_};jspb.Map.prototype.serializeBinary=function(a,b,c,d,e){var f=this.stringKeys_();f.sort();for(var g=0;g<f.length;g++){var h=this.map_[f[g]];b.beginSubMessage(a);c.call(b,1,h.key);this.valueCtor_?d.call(b,2,this.wrapEntry_(h),e):d.call(b,2,h.value);b.endSubMessage();}};
    jspb.Map.deserializeBinary=function(a,b,c,d,e,f){for(var g=void 0;b.nextField()&&!b.isEndGroup();){var h=b.getFieldNumber();1==h?f=c.call(b):2==h&&(a.valueCtor_?(goog.asserts.assert(e),g=new a.valueCtor_,d.call(b,g,e)):g=d.call(b));}goog.asserts.assert(void 0!=f);goog.asserts.assert(void 0!=g);a.set(f,g);};jspb.Map.prototype.stringKeys_=function(){var a=this.map_,b=[],c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&b.push(c);return b};
    jspb.Map.Entry_=function(a,b){this.key=a;this.value=b;this.valueWrapper=void 0;};goog.array={};goog.NATIVE_ARRAY_PROTOTYPES=goog.TRUSTED_SITE;goog.array.ASSUME_NATIVE_FUNCTIONS=!1;goog.array.peek=function(a){return a[a.length-1]};goog.array.last=goog.array.peek;
    goog.array.indexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.indexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(goog.isString(a))return goog.isString(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return -1};
    goog.array.lastIndexOf=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.lastIndexOf)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.lastIndexOf.call(a,b,null==c?a.length-1:c)}:function(a,b,c){c=null==c?a.length-1:c;0>c&&(c=Math.max(0,a.length+c));if(goog.isString(a))return goog.isString(b)&&1==b.length?a.lastIndexOf(b,c):-1;for(;0<=c;c--)if(c in a&&a[c]===b)return c;return -1};
    goog.array.forEach=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.forEach)?function(a,b,c){goog.asserts.assert(null!=a.length);Array.prototype.forEach.call(a,b,c);}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a);};goog.array.forEachRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,d=d-1;0<=d;--d)d in e&&b.call(c,e[d],d,a);};
    goog.array.filter=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.filter)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.filter.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=[],f=0,g=goog.isString(a)?a.split(""):a,h=0;h<d;h++)if(h in g){var k=g[h];b.call(c,k,h,a)&&(e[f++]=k);}return e};
    goog.array.map=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.map)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=goog.isString(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e};
    goog.array.reduce=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduce)?function(a,b,c,d){goog.asserts.assert(null!=a.length);d&&(b=goog.bind(b,d));return Array.prototype.reduce.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEach(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
    goog.array.reduceRight=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.reduceRight)?function(a,b,c,d){goog.asserts.assert(null!=a.length);goog.asserts.assert(null!=b);d&&(b=goog.bind(b,d));return Array.prototype.reduceRight.call(a,b,c)}:function(a,b,c,d){var e=c;goog.array.forEachRight(a,function(c,g){e=b.call(d,e,c,g,a);});return e};
    goog.array.some=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.some)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return !0;return !1};
    goog.array.every=goog.NATIVE_ARRAY_PROTOTYPES&&(goog.array.ASSUME_NATIVE_FUNCTIONS||Array.prototype.every)?function(a,b,c){goog.asserts.assert(null!=a.length);return Array.prototype.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return !1;return !0};goog.array.count=function(a,b,c){var d=0;goog.array.forEach(a,function(a,f,g){b.call(c,a,f,g)&&++d;},c);return d};
    goog.array.find=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};goog.array.findIndex=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return f;return -1};goog.array.findRight=function(a,b,c){b=goog.array.findIndexRight(a,b,c);return 0>b?null:goog.isString(a)?a.charAt(b):a[b]};
    goog.array.findIndexRight=function(a,b,c){for(var d=a.length,e=goog.isString(a)?a.split(""):a,d=d-1;0<=d;d--)if(d in e&&b.call(c,e[d],d,a))return d;return -1};goog.array.contains=function(a,b){return 0<=goog.array.indexOf(a,b)};goog.array.isEmpty=function(a){return 0==a.length};goog.array.clear=function(a){if(!goog.isArray(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0;};goog.array.insert=function(a,b){goog.array.contains(a,b)||a.push(b);};
    goog.array.insertAt=function(a,b,c){goog.array.splice(a,c,0,b);};goog.array.insertArrayAt=function(a,b,c){goog.partial(goog.array.splice,a,c,0).apply(null,b);};goog.array.insertBefore=function(a,b,c){var d;2==arguments.length||0>(d=goog.array.indexOf(a,c))?a.push(b):goog.array.insertAt(a,b,d);};goog.array.remove=function(a,b){var c=goog.array.indexOf(a,b),d;(d=0<=c)&&goog.array.removeAt(a,c);return d};
    goog.array.removeAt=function(a,b){goog.asserts.assert(null!=a.length);return 1==Array.prototype.splice.call(a,b,1).length};goog.array.removeIf=function(a,b,c){b=goog.array.findIndex(a,b,c);return 0<=b?(goog.array.removeAt(a,b),!0):!1};goog.array.removeAllIf=function(a,b,c){var d=0;goog.array.forEachRight(a,function(e,f){b.call(c,e,f,a)&&goog.array.removeAt(a,f)&&d++;});return d};goog.array.concat=function(a){return Array.prototype.concat.apply(Array.prototype,arguments)};
    goog.array.join=function(a){return Array.prototype.concat.apply(Array.prototype,arguments)};goog.array.toArray=function(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return []};goog.array.clone=goog.array.toArray;goog.array.extend=function(a,b){for(var c=1;c<arguments.length;c++){var d=arguments[c];if(goog.isArrayLike(d)){var e=a.length||0,f=d.length||0;a.length=e+f;for(var g=0;g<f;g++)a[e+g]=d[g];}else a.push(d);}};
    goog.array.splice=function(a,b,c,d){goog.asserts.assert(null!=a.length);return Array.prototype.splice.apply(a,goog.array.slice(arguments,1))};goog.array.slice=function(a,b,c){goog.asserts.assert(null!=a.length);return 2>=arguments.length?Array.prototype.slice.call(a,b):Array.prototype.slice.call(a,b,c)};
    goog.array.removeDuplicates=function(a,b,c){b=b||a;var d=function(a){return goog.isObject(a)?"o"+goog.getUid(a):(typeof a).charAt(0)+a};c=c||d;for(var d={},e=0,f=0;f<a.length;){var g=a[f++],h=c(g);Object.prototype.hasOwnProperty.call(d,h)||(d[h]=!0,b[e++]=g);}b.length=e;};goog.array.binarySearch=function(a,b,c){return goog.array.binarySearch_(a,c||goog.array.defaultCompare,!1,b)};goog.array.binarySelect=function(a,b,c){return goog.array.binarySearch_(a,b,!0,void 0,c)};
    goog.array.binarySearch_=function(a,b,c,d,e){for(var f=0,g=a.length,h;f<g;){var k=f+g>>1,l;l=c?b.call(e,a[k],k,a):b(d,a[k]);0<l?f=k+1:(g=k,h=!l);}return h?f:~f};goog.array.sort=function(a,b){a.sort(b||goog.array.defaultCompare);};goog.array.stableSort=function(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||goog.array.defaultCompare;goog.array.sort(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value;};
    goog.array.sortByKey=function(a,b,c){var d=c||goog.array.defaultCompare;goog.array.sort(a,function(a,c){return d(b(a),b(c))});};goog.array.sortObjectsByKey=function(a,b,c){goog.array.sortByKey(a,function(a){return a[b]},c);};goog.array.isSorted=function(a,b,c){b=b||goog.array.defaultCompare;for(var d=1;d<a.length;d++){var e=b(a[d-1],a[d]);if(0<e||0==e&&c)return !1}return !0};
    goog.array.equals=function(a,b,c){if(!goog.isArrayLike(a)||!goog.isArrayLike(b)||a.length!=b.length)return !1;var d=a.length;c=c||goog.array.defaultCompareEquality;for(var e=0;e<d;e++)if(!c(a[e],b[e]))return !1;return !0};goog.array.compare3=function(a,b,c){c=c||goog.array.defaultCompare;for(var d=Math.min(a.length,b.length),e=0;e<d;e++){var f=c(a[e],b[e]);if(0!=f)return f}return goog.array.defaultCompare(a.length,b.length)};goog.array.defaultCompare=function(a,b){return a>b?1:a<b?-1:0};
    goog.array.inverseDefaultCompare=function(a,b){return -goog.array.defaultCompare(a,b)};goog.array.defaultCompareEquality=function(a,b){return a===b};goog.array.binaryInsert=function(a,b,c){c=goog.array.binarySearch(a,b,c);return 0>c?(goog.array.insertAt(a,b,-(c+1)),!0):!1};goog.array.binaryRemove=function(a,b,c){b=goog.array.binarySearch(a,b,c);return 0<=b?goog.array.removeAt(a,b):!1};
    goog.array.bucket=function(a,b,c){for(var d={},e=0;e<a.length;e++){var f=a[e],g=b.call(c,f,e,a);goog.isDef(g)&&(d[g]||(d[g]=[])).push(f);}return d};goog.array.toObject=function(a,b,c){var d={};goog.array.forEach(a,function(e,f){d[b.call(c,e,f,a)]=e;});return d};goog.array.range=function(a,b,c){var d=[],e=0,f=a;c=c||1;void 0!==b&&(e=a,f=b);if(0>c*(f-e))return [];if(0<c)for(a=e;a<f;a+=c)d.push(a);else for(a=e;a>f;a+=c)d.push(a);return d};
    goog.array.repeat=function(a,b){for(var c=[],d=0;d<b;d++)c[d]=a;return c};goog.array.flatten=function(a){for(var b=[],c=0;c<arguments.length;c++){var d=arguments[c];if(goog.isArray(d))for(var e=0;e<d.length;e+=8192)for(var f=goog.array.slice(d,e,e+8192),f=goog.array.flatten.apply(null,f),g=0;g<f.length;g++)b.push(f[g]);else b.push(d);}return b};
    goog.array.rotate=function(a,b){goog.asserts.assert(null!=a.length);a.length&&(b%=a.length,0<b?Array.prototype.unshift.apply(a,a.splice(-b,b)):0>b&&Array.prototype.push.apply(a,a.splice(0,-b)));return a};goog.array.moveItem=function(a,b,c){goog.asserts.assert(0<=b&&b<a.length);goog.asserts.assert(0<=c&&c<a.length);b=Array.prototype.splice.call(a,b,1);Array.prototype.splice.call(a,c,0,b[0]);};
    goog.array.zip=function(a){if(!arguments.length)return [];for(var b=[],c=arguments[0].length,d=1;d<arguments.length;d++)arguments[d].length<c&&(c=arguments[d].length);for(d=0;d<c;d++){for(var e=[],f=0;f<arguments.length;f++)e.push(arguments[f][d]);b.push(e);}return b};goog.array.shuffle=function(a,b){for(var c=b||Math.random,d=a.length-1;0<d;d--){var e=Math.floor(c()*(d+1)),f=a[d];a[d]=a[e];a[e]=f;}};goog.array.copyByIndex=function(a,b){var c=[];goog.array.forEach(b,function(b){c.push(a[b]);});return c};goog.crypt={};goog.crypt.stringToByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){for(var e=a.charCodeAt(d);255<e;)b[c++]=e&255,e>>=8;b[c++]=e;}return b};goog.crypt.byteArrayToString=function(a){if(8192>=a.length)return String.fromCharCode.apply(null,a);for(var b="",c=0;c<a.length;c+=8192)var d=goog.array.slice(a,c,c+8192),b=b+String.fromCharCode.apply(null,d);return b};goog.crypt.byteArrayToHex=function(a){return goog.array.map(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join("")};
    goog.crypt.hexToByteArray=function(a){goog.asserts.assert(0==a.length%2,"Key string length must be multiple of 2");for(var b=[],c=0;c<a.length;c+=2)b.push(parseInt(a.substring(c,c+2),16));return b};
    goog.crypt.stringToUtf8ByteArray=function(a){for(var b=[],c=0,d=0;d<a.length;d++){var e=a.charCodeAt(d);128>e?b[c++]=e:(2048>e?b[c++]=e>>6|192:(55296==(e&64512)&&d+1<a.length&&56320==(a.charCodeAt(d+1)&64512)?(e=65536+((e&1023)<<10)+(a.charCodeAt(++d)&1023),b[c++]=e>>18|240,b[c++]=e>>12&63|128):b[c++]=e>>12|224,b[c++]=e>>6&63|128),b[c++]=e&63|128);}return b};
    goog.crypt.utf8ByteArrayToString=function(a){for(var b=[],c=0,d=0;c<a.length;){var e=a[c++];if(128>e)b[d++]=String.fromCharCode(e);else if(191<e&&224>e){var f=a[c++];b[d++]=String.fromCharCode((e&31)<<6|f&63);}else if(239<e&&365>e){var f=a[c++],g=a[c++],h=a[c++],e=((e&7)<<18|(f&63)<<12|(g&63)<<6|h&63)-65536;b[d++]=String.fromCharCode(55296+(e>>10));b[d++]=String.fromCharCode(56320+(e&1023));}else f=a[c++],g=a[c++],b[d++]=String.fromCharCode((e&15)<<12|(f&63)<<6|g&63);}return b.join("")};
    goog.crypt.xorByteArray=function(a,b){goog.asserts.assert(a.length==b.length,"XOR array lengths must match");for(var c=[],d=0;d<a.length;d++)c.push(a[d]^b[d]);return c};goog.labs={};goog.labs.userAgent={};goog.labs.userAgent.util={};goog.labs.userAgent.util.getNativeUserAgentString_=function(){var a=goog.labs.userAgent.util.getNavigator_();return a&&(a=a.userAgent)?a:""};goog.labs.userAgent.util.getNavigator_=function(){return goog.global.navigator};goog.labs.userAgent.util.userAgent_=goog.labs.userAgent.util.getNativeUserAgentString_();goog.labs.userAgent.util.setUserAgent=function(a){goog.labs.userAgent.util.userAgent_=a||goog.labs.userAgent.util.getNativeUserAgentString_();};
    goog.labs.userAgent.util.getUserAgent=function(){return goog.labs.userAgent.util.userAgent_};goog.labs.userAgent.util.matchUserAgent=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.contains(b,a)};goog.labs.userAgent.util.matchUserAgentIgnoreCase=function(a){var b=goog.labs.userAgent.util.getUserAgent();return goog.string.caseInsensitiveContains(b,a)};
    goog.labs.userAgent.util.extractVersionTuples=function(a){for(var b=RegExp("(\\w[\\w ]+)/([^\\s]+)\\s*(?:\\((.*?)\\))?","g"),c=[],d;d=b.exec(a);)c.push([d[1],d[2],d[3]||void 0]);return c};goog.labs.userAgent.platform={};goog.labs.userAgent.platform.isAndroid=function(){return goog.labs.userAgent.util.matchUserAgent("Android")};goog.labs.userAgent.platform.isIpod=function(){return goog.labs.userAgent.util.matchUserAgent("iPod")};goog.labs.userAgent.platform.isIphone=function(){return goog.labs.userAgent.util.matchUserAgent("iPhone")&&!goog.labs.userAgent.util.matchUserAgent("iPod")&&!goog.labs.userAgent.util.matchUserAgent("iPad")};goog.labs.userAgent.platform.isIpad=function(){return goog.labs.userAgent.util.matchUserAgent("iPad")};
    goog.labs.userAgent.platform.isIos=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpad()||goog.labs.userAgent.platform.isIpod()};goog.labs.userAgent.platform.isMacintosh=function(){return goog.labs.userAgent.util.matchUserAgent("Macintosh")};goog.labs.userAgent.platform.isLinux=function(){return goog.labs.userAgent.util.matchUserAgent("Linux")};goog.labs.userAgent.platform.isWindows=function(){return goog.labs.userAgent.util.matchUserAgent("Windows")};
    goog.labs.userAgent.platform.isChromeOS=function(){return goog.labs.userAgent.util.matchUserAgent("CrOS")};
    goog.labs.userAgent.platform.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent(),b="";goog.labs.userAgent.platform.isWindows()?(b=/Windows (?:NT|Phone) ([0-9.]+)/,b=(a=b.exec(a))?a[1]:"0.0"):goog.labs.userAgent.platform.isIos()?(b=/(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/,b=(a=b.exec(a))&&a[1].replace(/_/g,".")):goog.labs.userAgent.platform.isMacintosh()?(b=/Mac OS X ([0-9_.]+)/,b=(a=b.exec(a))?a[1].replace(/_/g,"."):"10"):goog.labs.userAgent.platform.isAndroid()?(b=/Android\s+([^\);]+)(\)|;)/,
    b=(a=b.exec(a))&&a[1]):goog.labs.userAgent.platform.isChromeOS()&&(b=/(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/,b=(a=b.exec(a))&&a[1]);return b||""};goog.labs.userAgent.platform.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(),a)};goog.object={};goog.object.forEach=function(a,b,c){for(var d in a)b.call(c,a[d],d,a);};goog.object.filter=function(a,b,c){var d={},e;for(e in a)b.call(c,a[e],e,a)&&(d[e]=a[e]);return d};goog.object.map=function(a,b,c){var d={},e;for(e in a)d[e]=b.call(c,a[e],e,a);return d};goog.object.some=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return !0;return !1};goog.object.every=function(a,b,c){for(var d in a)if(!b.call(c,a[d],d,a))return !1;return !0};
    goog.object.getCount=function(a){var b=0,c;for(c in a)b++;return b};goog.object.getAnyKey=function(a){for(var b in a)return b};goog.object.getAnyValue=function(a){for(var b in a)return a[b]};goog.object.contains=function(a,b){return goog.object.containsValue(a,b)};goog.object.getValues=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b};goog.object.getKeys=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b};
    goog.object.getValueByKeys=function(a,b){for(var c=goog.isArrayLike(b),d=c?b:arguments,c=c?0:1;c<d.length&&(a=a[d[c]],goog.isDef(a));c++);return a};goog.object.containsKey=function(a,b){return null!==a&&b in a};goog.object.containsValue=function(a,b){for(var c in a)if(a[c]==b)return !0;return !1};goog.object.findKey=function(a,b,c){for(var d in a)if(b.call(c,a[d],d,a))return d};goog.object.findValue=function(a,b,c){return (b=goog.object.findKey(a,b,c))&&a[b]};
    goog.object.isEmpty=function(a){for(var b in a)return !1;return !0};goog.object.clear=function(a){for(var b in a)delete a[b];};goog.object.remove=function(a,b){var c;(c=b in a)&&delete a[b];return c};goog.object.add=function(a,b,c){if(null!==a&&b in a)throw Error('The object already contains the key "'+b+'"');goog.object.set(a,b,c);};goog.object.get=function(a,b,c){return null!==a&&b in a?a[b]:c};goog.object.set=function(a,b,c){a[b]=c;};
    goog.object.setIfUndefined=function(a,b,c){return b in a?a[b]:a[b]=c};goog.object.setWithReturnValueIfNotSet=function(a,b,c){if(b in a)return a[b];c=c();return a[b]=c};goog.object.equals=function(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return !1;for(c in b)if(!(c in a))return !1;return !0};goog.object.clone=function(a){var b={},c;for(c in a)b[c]=a[c];return b};
    goog.object.unsafeClone=function(a){var b=goog.typeOf(a);if("object"==b||"array"==b){if(goog.isFunction(a.clone))return a.clone();var b="array"==b?[]:{},c;for(c in a)b[c]=goog.object.unsafeClone(a[c]);return b}return a};goog.object.transpose=function(a){var b={},c;for(c in a)b[a[c]]=c;return b};goog.object.PROTOTYPE_FIELDS_="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.object.extend=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<goog.object.PROTOTYPE_FIELDS_.length;f++)c=goog.object.PROTOTYPE_FIELDS_[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c]);}};
    goog.object.create=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.create.apply(null,arguments[0]);if(b%2)throw Error("Uneven number of arguments");for(var c={},d=0;d<b;d+=2)c[arguments[d]]=arguments[d+1];return c};goog.object.createSet=function(a){var b=arguments.length;if(1==b&&goog.isArray(arguments[0]))return goog.object.createSet.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};
    goog.object.createImmutableView=function(a){var b=a;Object.isFrozen&&!Object.isFrozen(a)&&(b=Object.create(a),Object.freeze(b));return b};goog.object.isImmutableView=function(a){return !!Object.isFrozen&&Object.isFrozen(a)};goog.labs.userAgent.browser={};goog.labs.userAgent.browser.matchOpera_=function(){return goog.labs.userAgent.util.matchUserAgent("Opera")||goog.labs.userAgent.util.matchUserAgent("OPR")};goog.labs.userAgent.browser.matchIE_=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.browser.matchEdge_=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};goog.labs.userAgent.browser.matchFirefox_=function(){return goog.labs.userAgent.util.matchUserAgent("Firefox")};
    goog.labs.userAgent.browser.matchSafari_=function(){return goog.labs.userAgent.util.matchUserAgent("Safari")&&!(goog.labs.userAgent.browser.matchChrome_()||goog.labs.userAgent.browser.matchCoast_()||goog.labs.userAgent.browser.matchOpera_()||goog.labs.userAgent.browser.matchEdge_()||goog.labs.userAgent.browser.isSilk()||goog.labs.userAgent.util.matchUserAgent("Android"))};goog.labs.userAgent.browser.matchCoast_=function(){return goog.labs.userAgent.util.matchUserAgent("Coast")};
    goog.labs.userAgent.browser.matchIosWebview_=function(){return (goog.labs.userAgent.util.matchUserAgent("iPad")||goog.labs.userAgent.util.matchUserAgent("iPhone"))&&!goog.labs.userAgent.browser.matchSafari_()&&!goog.labs.userAgent.browser.matchChrome_()&&!goog.labs.userAgent.browser.matchCoast_()&&goog.labs.userAgent.util.matchUserAgent("AppleWebKit")};
    goog.labs.userAgent.browser.matchChrome_=function(){return (goog.labs.userAgent.util.matchUserAgent("Chrome")||goog.labs.userAgent.util.matchUserAgent("CriOS"))&&!goog.labs.userAgent.browser.matchOpera_()&&!goog.labs.userAgent.browser.matchEdge_()};goog.labs.userAgent.browser.matchAndroidBrowser_=function(){return goog.labs.userAgent.util.matchUserAgent("Android")&&!(goog.labs.userAgent.browser.isChrome()||goog.labs.userAgent.browser.isFirefox()||goog.labs.userAgent.browser.isOpera()||goog.labs.userAgent.browser.isSilk())};
    goog.labs.userAgent.browser.isOpera=goog.labs.userAgent.browser.matchOpera_;goog.labs.userAgent.browser.isIE=goog.labs.userAgent.browser.matchIE_;goog.labs.userAgent.browser.isEdge=goog.labs.userAgent.browser.matchEdge_;goog.labs.userAgent.browser.isFirefox=goog.labs.userAgent.browser.matchFirefox_;goog.labs.userAgent.browser.isSafari=goog.labs.userAgent.browser.matchSafari_;goog.labs.userAgent.browser.isCoast=goog.labs.userAgent.browser.matchCoast_;goog.labs.userAgent.browser.isIosWebview=goog.labs.userAgent.browser.matchIosWebview_;
    goog.labs.userAgent.browser.isChrome=goog.labs.userAgent.browser.matchChrome_;goog.labs.userAgent.browser.isAndroidBrowser=goog.labs.userAgent.browser.matchAndroidBrowser_;goog.labs.userAgent.browser.isSilk=function(){return goog.labs.userAgent.util.matchUserAgent("Silk")};
    goog.labs.userAgent.browser.getVersion=function(){function a(a){a=goog.array.find(a,d);return c[a]||""}var b=goog.labs.userAgent.util.getUserAgent();if(goog.labs.userAgent.browser.isIE())return goog.labs.userAgent.browser.getIEVersion_(b);var b=goog.labs.userAgent.util.extractVersionTuples(b),c={};goog.array.forEach(b,function(a){c[a[0]]=a[1];});var d=goog.partial(goog.object.containsKey,c);return goog.labs.userAgent.browser.isOpera()?a(["Version","Opera","OPR"]):goog.labs.userAgent.browser.isEdge()?
    a(["Edge"]):goog.labs.userAgent.browser.isChrome()?a(["Chrome","CriOS"]):(b=b[2])&&b[1]||""};goog.labs.userAgent.browser.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(),a)};
    goog.labs.userAgent.browser.getIEVersion_=function(a){var b=/rv: *([\d\.]*)/.exec(a);if(b&&b[1])return b[1];var b="",c=/MSIE +([\d\.]+)/.exec(a);if(c&&c[1])if(a=/Trident\/(\d.\d)/.exec(a),"7.0"==c[1])if(a&&a[1])switch(a[1]){case "4.0":b="8.0";break;case "5.0":b="9.0";break;case "6.0":b="10.0";break;case "7.0":b="11.0";}else b="7.0";else b=c[1];return b};goog.labs.userAgent.engine={};goog.labs.userAgent.engine.isPresto=function(){return goog.labs.userAgent.util.matchUserAgent("Presto")};goog.labs.userAgent.engine.isTrident=function(){return goog.labs.userAgent.util.matchUserAgent("Trident")||goog.labs.userAgent.util.matchUserAgent("MSIE")};goog.labs.userAgent.engine.isEdge=function(){return goog.labs.userAgent.util.matchUserAgent("Edge")};
    goog.labs.userAgent.engine.isWebKit=function(){return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit")&&!goog.labs.userAgent.engine.isEdge()};goog.labs.userAgent.engine.isGecko=function(){return goog.labs.userAgent.util.matchUserAgent("Gecko")&&!goog.labs.userAgent.engine.isWebKit()&&!goog.labs.userAgent.engine.isTrident()&&!goog.labs.userAgent.engine.isEdge()};
    goog.labs.userAgent.engine.getVersion=function(){var a=goog.labs.userAgent.util.getUserAgent();if(a){var a=goog.labs.userAgent.util.extractVersionTuples(a),b=goog.labs.userAgent.engine.getEngineTuple_(a);if(b)return "Gecko"==b[0]?goog.labs.userAgent.engine.getVersionForKey_(a,"Firefox"):b[1];var a=a[0],c;if(a&&(c=a[2])&&(c=/Trident\/([^\s;]+)/.exec(c)))return c[1]}return ""};
    goog.labs.userAgent.engine.getEngineTuple_=function(a){if(!goog.labs.userAgent.engine.isEdge())return a[1];for(var b=0;b<a.length;b++){var c=a[b];if("Edge"==c[0])return c}};goog.labs.userAgent.engine.isVersionOrHigher=function(a){return 0<=goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),a)};goog.labs.userAgent.engine.getVersionForKey_=function(a,b){var c=goog.array.find(a,function(a){return b==a[0]});return c&&c[1]||""};goog.userAgent={};goog.userAgent.ASSUME_IE=!1;goog.userAgent.ASSUME_EDGE=!1;goog.userAgent.ASSUME_GECKO=!1;goog.userAgent.ASSUME_WEBKIT=!1;goog.userAgent.ASSUME_MOBILE_WEBKIT=!1;goog.userAgent.ASSUME_OPERA=!1;goog.userAgent.ASSUME_ANY_VERSION=!1;goog.userAgent.BROWSER_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_GECKO||goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_OPERA;goog.userAgent.getUserAgentString=function(){return goog.labs.userAgent.util.getUserAgent()};
    goog.userAgent.getNavigator=function(){return goog.global.navigator||null};goog.userAgent.OPERA=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_OPERA:goog.labs.userAgent.browser.isOpera();goog.userAgent.IE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_IE:goog.labs.userAgent.browser.isIE();goog.userAgent.EDGE=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_EDGE:goog.labs.userAgent.engine.isEdge();goog.userAgent.EDGE_OR_IE=goog.userAgent.EDGE||goog.userAgent.IE;
    goog.userAgent.GECKO=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_GECKO:goog.labs.userAgent.engine.isGecko();goog.userAgent.WEBKIT=goog.userAgent.BROWSER_KNOWN_?goog.userAgent.ASSUME_WEBKIT||goog.userAgent.ASSUME_MOBILE_WEBKIT:goog.labs.userAgent.engine.isWebKit();goog.userAgent.isMobile_=function(){return goog.userAgent.WEBKIT&&goog.labs.userAgent.util.matchUserAgent("Mobile")};goog.userAgent.MOBILE=goog.userAgent.ASSUME_MOBILE_WEBKIT||goog.userAgent.isMobile_();goog.userAgent.SAFARI=goog.userAgent.WEBKIT;
    goog.userAgent.determinePlatform_=function(){var a=goog.userAgent.getNavigator();return a&&a.platform||""};goog.userAgent.PLATFORM=goog.userAgent.determinePlatform_();goog.userAgent.ASSUME_MAC=!1;goog.userAgent.ASSUME_WINDOWS=!1;goog.userAgent.ASSUME_LINUX=!1;goog.userAgent.ASSUME_X11=!1;goog.userAgent.ASSUME_ANDROID=!1;goog.userAgent.ASSUME_IPHONE=!1;goog.userAgent.ASSUME_IPAD=!1;
    goog.userAgent.PLATFORM_KNOWN_=goog.userAgent.ASSUME_MAC||goog.userAgent.ASSUME_WINDOWS||goog.userAgent.ASSUME_LINUX||goog.userAgent.ASSUME_X11||goog.userAgent.ASSUME_ANDROID||goog.userAgent.ASSUME_IPHONE||goog.userAgent.ASSUME_IPAD;goog.userAgent.MAC=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_MAC:goog.labs.userAgent.platform.isMacintosh();goog.userAgent.WINDOWS=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_WINDOWS:goog.labs.userAgent.platform.isWindows();
    goog.userAgent.isLegacyLinux_=function(){return goog.labs.userAgent.platform.isLinux()||goog.labs.userAgent.platform.isChromeOS()};goog.userAgent.LINUX=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_LINUX:goog.userAgent.isLegacyLinux_();goog.userAgent.isX11_=function(){var a=goog.userAgent.getNavigator();return !!a&&goog.string.contains(a.appVersion||"","X11")};goog.userAgent.X11=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_X11:goog.userAgent.isX11_();
    goog.userAgent.ANDROID=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_ANDROID:goog.labs.userAgent.platform.isAndroid();goog.userAgent.IPHONE=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPHONE:goog.labs.userAgent.platform.isIphone();goog.userAgent.IPAD=goog.userAgent.PLATFORM_KNOWN_?goog.userAgent.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.operaVersion_=function(){var a=goog.global.opera.version;try{return a()}catch(b){return a}};
    goog.userAgent.determineVersion_=function(){if(goog.userAgent.OPERA&&goog.global.opera)return goog.userAgent.operaVersion_();var a="",b=goog.userAgent.getVersionRegexResult_();b&&(a=b?b[1]:"");return goog.userAgent.IE&&(b=goog.userAgent.getDocumentMode_(),b>parseFloat(a))?String(b):a};
    goog.userAgent.getVersionRegexResult_=function(){var a=goog.userAgent.getUserAgentString();if(goog.userAgent.GECKO)return /rv\:([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.EDGE)return /Edge\/([\d\.]+)/.exec(a);if(goog.userAgent.IE)return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(goog.userAgent.WEBKIT)return /WebKit\/(\S+)/.exec(a)};goog.userAgent.getDocumentMode_=function(){var a=goog.global.document;return a?a.documentMode:void 0};goog.userAgent.VERSION=goog.userAgent.determineVersion_();
    goog.userAgent.compare=function(a,b){return goog.string.compareVersions(a,b)};goog.userAgent.isVersionOrHigherCache_={};goog.userAgent.isVersionOrHigher=function(a){return goog.userAgent.ASSUME_ANY_VERSION||goog.userAgent.isVersionOrHigherCache_[a]||(goog.userAgent.isVersionOrHigherCache_[a]=0<=goog.string.compareVersions(goog.userAgent.VERSION,a))};goog.userAgent.isVersion=goog.userAgent.isVersionOrHigher;
    goog.userAgent.isDocumentModeOrHigher=function(a){return Number(goog.userAgent.DOCUMENT_MODE)>=a};goog.userAgent.isDocumentMode=goog.userAgent.isDocumentModeOrHigher;goog.userAgent.DOCUMENT_MODE=function(){var a=goog.global.document,b=goog.userAgent.getDocumentMode_();return a&&goog.userAgent.IE?b||("CSS1Compat"==a.compatMode?parseInt(goog.userAgent.VERSION,10):5):void 0}();goog.userAgent.product={};goog.userAgent.product.ASSUME_FIREFOX=!1;goog.userAgent.product.ASSUME_IPHONE=!1;goog.userAgent.product.ASSUME_IPAD=!1;goog.userAgent.product.ASSUME_ANDROID=!1;goog.userAgent.product.ASSUME_CHROME=!1;goog.userAgent.product.ASSUME_SAFARI=!1;
    goog.userAgent.product.PRODUCT_KNOWN_=goog.userAgent.ASSUME_IE||goog.userAgent.ASSUME_EDGE||goog.userAgent.ASSUME_OPERA||goog.userAgent.product.ASSUME_FIREFOX||goog.userAgent.product.ASSUME_IPHONE||goog.userAgent.product.ASSUME_IPAD||goog.userAgent.product.ASSUME_ANDROID||goog.userAgent.product.ASSUME_CHROME||goog.userAgent.product.ASSUME_SAFARI;goog.userAgent.product.OPERA=goog.userAgent.OPERA;goog.userAgent.product.IE=goog.userAgent.IE;goog.userAgent.product.EDGE=goog.userAgent.EDGE;
    goog.userAgent.product.FIREFOX=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_FIREFOX:goog.labs.userAgent.browser.isFirefox();goog.userAgent.product.isIphoneOrIpod_=function(){return goog.labs.userAgent.platform.isIphone()||goog.labs.userAgent.platform.isIpod()};goog.userAgent.product.IPHONE=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPHONE:goog.userAgent.product.isIphoneOrIpod_();
    goog.userAgent.product.IPAD=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_IPAD:goog.labs.userAgent.platform.isIpad();goog.userAgent.product.ANDROID=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_ANDROID:goog.labs.userAgent.browser.isAndroidBrowser();goog.userAgent.product.CHROME=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_CHROME:goog.labs.userAgent.browser.isChrome();
    goog.userAgent.product.isSafariDesktop_=function(){return goog.labs.userAgent.browser.isSafari()&&!goog.labs.userAgent.platform.isIos()};goog.userAgent.product.SAFARI=goog.userAgent.product.PRODUCT_KNOWN_?goog.userAgent.product.ASSUME_SAFARI:goog.userAgent.product.isSafariDesktop_();goog.crypt.base64={};goog.crypt.base64.byteToCharMap_=null;goog.crypt.base64.charToByteMap_=null;goog.crypt.base64.byteToCharMapWebSafe_=null;goog.crypt.base64.ENCODED_VALS_BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";goog.crypt.base64.ENCODED_VALS=goog.crypt.base64.ENCODED_VALS_BASE+"+/=";goog.crypt.base64.ENCODED_VALS_WEBSAFE=goog.crypt.base64.ENCODED_VALS_BASE+"-_.";
    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_=goog.userAgent.GECKO||goog.userAgent.WEBKIT&&!goog.userAgent.product.SAFARI||goog.userAgent.OPERA;goog.crypt.base64.HAS_NATIVE_ENCODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||"function"==typeof goog.global.btoa;goog.crypt.base64.HAS_NATIVE_DECODE_=goog.crypt.base64.ASSUME_NATIVE_SUPPORT_||!goog.userAgent.product.SAFARI&&!goog.userAgent.IE&&"function"==typeof goog.global.atob;
    goog.crypt.base64.encodeByteArray=function(a,b){goog.asserts.assert(goog.isArrayLike(a),"encodeByteArray takes an array as a parameter");goog.crypt.base64.init_();for(var c=b?goog.crypt.base64.byteToCharMapWebSafe_:goog.crypt.base64.byteToCharMap_,d=[],e=0;e<a.length;e+=3){var f=a[e],g=e+1<a.length,h=g?a[e+1]:0,k=e+2<a.length,l=k?a[e+2]:0,p=f>>2,f=(f&3)<<4|h>>4,h=(h&15)<<2|l>>6,l=l&63;k||(l=64,g||(h=64));d.push(c[p],c[f],c[h],c[l]);}return d.join("")};
    goog.crypt.base64.encodeString=function(a,b){return goog.crypt.base64.HAS_NATIVE_ENCODE_&&!b?goog.global.btoa(a):goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a),b)};goog.crypt.base64.decodeString=function(a,b){if(goog.crypt.base64.HAS_NATIVE_DECODE_&&!b)return goog.global.atob(a);var c="";goog.crypt.base64.decodeStringInternal_(a,function(a){c+=String.fromCharCode(a);});return c};
    goog.crypt.base64.decodeStringToByteArray=function(a,b){var c=[];goog.crypt.base64.decodeStringInternal_(a,function(a){c.push(a);});return c};goog.crypt.base64.decodeStringToUint8Array=function(a){goog.asserts.assert(!goog.userAgent.IE||goog.userAgent.isVersionOrHigher("10"),"Browser does not support typed arrays");var b=new Uint8Array(Math.ceil(3*a.length/4)),c=0;goog.crypt.base64.decodeStringInternal_(a,function(a){b[c++]=a;});return b.subarray(0,c)};
    goog.crypt.base64.decodeStringInternal_=function(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=goog.crypt.base64.charToByteMap_[c];if(null!=e)return e;if(!goog.string.isEmptyOrWhitespace(c))throw Error("Unknown base64 encoding at char: "+c);}return b}goog.crypt.base64.init_();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),h=c(64);if(64===h&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=h&&b(g<<6&192|h));}};
    goog.crypt.base64.init_=function(){if(!goog.crypt.base64.byteToCharMap_){goog.crypt.base64.byteToCharMap_={};goog.crypt.base64.charToByteMap_={};goog.crypt.base64.byteToCharMapWebSafe_={};for(var a=0;a<goog.crypt.base64.ENCODED_VALS.length;a++)goog.crypt.base64.byteToCharMap_[a]=goog.crypt.base64.ENCODED_VALS.charAt(a),goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[a]]=a,goog.crypt.base64.byteToCharMapWebSafe_[a]=goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a),a>=goog.crypt.base64.ENCODED_VALS_BASE.length&&
    (goog.crypt.base64.charToByteMap_[goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a)]=a);}};jspb.ExtensionFieldInfo=function(a,b,c,d,e){this.fieldIndex=a;this.fieldName=b;this.ctor=c;this.toObjectFn=d;this.isRepeated=e;};jspb.ExtensionFieldBinaryInfo=function(a,b,c,d,e,f){this.fieldInfo=a;this.binaryReaderFn=b;this.binaryWriterFn=c;this.binaryMessageSerializeFn=d;this.binaryMessageDeserializeFn=e;this.isPacked=f;};jspb.ExtensionFieldInfo.prototype.isMessageType=function(){return !!this.ctor};jspb.Message=function(){};jspb.Message.GENERATE_TO_OBJECT=!0;jspb.Message.GENERATE_FROM_OBJECT=!goog.DISALLOW_TEST_ONLY_CODE;
    jspb.Message.GENERATE_TO_STRING=!0;jspb.Message.ASSUME_LOCAL_ARRAYS=!1;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS=!0;jspb.Message.SUPPORTS_UINT8ARRAY_="function"==typeof Uint8Array;jspb.Message.prototype.getJsPbMessageId=function(){return this.messageId_};jspb.Message.getIndex_=function(a,b){return b+a.arrayIndexOffset_};jspb.Message.getFieldNumber_=function(a,b){return b-a.arrayIndexOffset_};
    jspb.Message.initialize=function(a,b,c,d,e,f){a.wrappers_=null;b||(b=c?[c]:[]);a.messageId_=c?String(c):void 0;a.arrayIndexOffset_=0===c?-1:0;a.array=b;jspb.Message.initPivotAndExtensionObject_(a,d);a.convertedFloatingPointFields_={};jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS||(a.repeatedFields=e);if(e)for(b=0;b<e.length;b++)c=e[b],c<a.pivot_?(c=jspb.Message.getIndex_(a,c),a.array[c]=a.array[c]||jspb.Message.EMPTY_LIST_SENTINEL_):(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[c]=
    a.extensionObject_[c]||jspb.Message.EMPTY_LIST_SENTINEL_);if(f&&f.length)for(b=0;b<f.length;b++)jspb.Message.computeOneofCase(a,f[b]);};jspb.Message.EMPTY_LIST_SENTINEL_=goog.DEBUG&&Object.freeze?Object.freeze([]):[];jspb.Message.isArray_=function(a){return jspb.Message.ASSUME_LOCAL_ARRAYS?a instanceof Array:goog.isArray(a)};
    jspb.Message.initPivotAndExtensionObject_=function(a,b){if(a.array.length){var c=a.array.length-1,d=a.array[c];if(d&&"object"==typeof d&&!jspb.Message.isArray_(d)&&!(jspb.Message.SUPPORTS_UINT8ARRAY_&&d instanceof Uint8Array)){a.pivot_=jspb.Message.getFieldNumber_(a,c);a.extensionObject_=d;return}}-1<b?(a.pivot_=b,a.extensionObject_=null):a.pivot_=Number.MAX_VALUE;};
    jspb.Message.maybeInitEmptyExtensionObject_=function(a){var b=jspb.Message.getIndex_(a,a.pivot_);a.array[b]||(a.extensionObject_=a.array[b]={});};jspb.Message.toObjectList=function(a,b,c){for(var d=[],e=0;e<a.length;e++)d[e]=b.call(a[e],c,a[e]);return d};
    jspb.Message.toObjectExtension=function(a,b,c,d,e){for(var f in c){var g=c[f],h=d.call(a,g);if(null!=h){for(var k in g.fieldName)if(g.fieldName.hasOwnProperty(k))break;b[k]=g.toObjectFn?g.isRepeated?jspb.Message.toObjectList(h,g.toObjectFn,e):g.toObjectFn(e,h):h;}}};
    jspb.Message.serializeBinaryExtensions=function(a,b,c,d){for(var e in c){var f=c[e],g=f.fieldInfo;if(!f.binaryWriterFn)throw Error("Message extension present that was generated without binary serialization support");var h=d.call(a,g);if(null!=h)if(g.isMessageType())if(f.binaryMessageSerializeFn)f.binaryWriterFn.call(b,g.fieldIndex,h,f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
    else f.binaryWriterFn.call(b,g.fieldIndex,h);}};jspb.Message.readBinaryExtension=function(a,b,c,d,e){var f=c[b.getFieldNumber()];if(f){c=f.fieldInfo;if(!f.binaryReaderFn)throw Error("Deserializing extension whose generated code does not support binary format");var g;c.isMessageType()?(g=new c.ctor,f.binaryReaderFn.call(b,g,f.binaryMessageDeserializeFn)):g=f.binaryReaderFn.call(b);c.isRepeated&&!f.isPacked?(b=d.call(a,c))?b.push(g):e.call(a,c,[g]):e.call(a,c,g);}else b.skipField();};
    jspb.Message.getField=function(a,b){if(b<a.pivot_){var c=jspb.Message.getIndex_(a,b),d=a.array[c];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[c]=[]:d}if(a.extensionObject_)return d=a.extensionObject_[b],d===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:d};
    jspb.Message.getRepeatedField=function(a,b){if(b<a.pivot_){var c=jspb.Message.getIndex_(a,b),d=a.array[c];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.array[c]=[]:d}d=a.extensionObject_[b];return d===jspb.Message.EMPTY_LIST_SENTINEL_?a.extensionObject_[b]=[]:d};jspb.Message.getOptionalFloatingPointField=function(a,b){var c=jspb.Message.getField(a,b);return null==c?c:+c};
    jspb.Message.getRepeatedFloatingPointField=function(a,b){var c=jspb.Message.getRepeatedField(a,b);a.convertedFloatingPointFields_||(a.convertedFloatingPointFields_={});if(!a.convertedFloatingPointFields_[b]){for(var d=0;d<c.length;d++)c[d]=+c[d];a.convertedFloatingPointFields_[b]=!0;}return c};
    jspb.Message.bytesAsB64=function(a){if(null==a||goog.isString(a))return a;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return goog.crypt.base64.encodeByteArray(a);goog.asserts.fail("Cannot coerce to b64 string: "+goog.typeOf(a));return null};jspb.Message.bytesAsU8=function(a){if(null==a||a instanceof Uint8Array)return a;if(goog.isString(a))return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Cannot coerce to Uint8Array: "+goog.typeOf(a));return null};
    jspb.Message.bytesListAsB64=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||goog.isString(a[0])?a:goog.array.map(a,jspb.Message.bytesAsB64)};jspb.Message.bytesListAsU8=function(a){jspb.Message.assertConsistentTypes_(a);return !a.length||a[0]instanceof Uint8Array?a:goog.array.map(a,jspb.Message.bytesAsU8)};
    jspb.Message.assertConsistentTypes_=function(a){if(goog.DEBUG&&a&&1<a.length){var b=goog.typeOf(a[0]);goog.array.forEach(a,function(a){goog.typeOf(a)!=b&&goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got "+goog.typeOf(a)+" expected "+b);});}};jspb.Message.getFieldWithDefault=function(a,b,c){a=jspb.Message.getField(a,b);return null==a?c:a};jspb.Message.getFieldProto3=jspb.Message.getFieldWithDefault;
    jspb.Message.getMapField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(b in a.wrappers_)return a.wrappers_[b];if(!c)return c=jspb.Message.getField(a,b),c||(c=[],jspb.Message.setField(a,b,c)),a.wrappers_[b]=new jspb.Map(c,d)};jspb.Message.setField=function(a,b,c){b<a.pivot_?a.array[jspb.Message.getIndex_(a,b)]=c:(jspb.Message.maybeInitEmptyExtensionObject_(a),a.extensionObject_[b]=c);};jspb.Message.setProto3IntField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};
    jspb.Message.setProto3StringIntField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"0");};jspb.Message.setProto3FloatField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};jspb.Message.setProto3BooleanField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,!1);};jspb.Message.setProto3StringField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"");};jspb.Message.setProto3BytesField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,"");};
    jspb.Message.setProto3EnumField=function(a,b,c){jspb.Message.setFieldIgnoringDefault_(a,b,c,0);};jspb.Message.setFieldIgnoringDefault_=function(a,b,c,d){c!=d?jspb.Message.setField(a,b,c):a.array[jspb.Message.getIndex_(a,b)]=null;};jspb.Message.addToRepeatedField=function(a,b,c,d){a=jspb.Message.getRepeatedField(a,b);void 0!=d?a.splice(d,0,c):a.push(c);};
    jspb.Message.setOneofField=function(a,b,c,d){(c=jspb.Message.computeOneofCase(a,c))&&c!==b&&void 0!==d&&(a.wrappers_&&c in a.wrappers_&&(a.wrappers_[c]=void 0),jspb.Message.setField(a,c,void 0));jspb.Message.setField(a,b,d);};jspb.Message.computeOneofCase=function(a,b){for(var c,d,e=0;e<b.length;e++){var f=b[e],g=jspb.Message.getField(a,f);null!=g&&(c=f,d=g,jspb.Message.setField(a,f,void 0));}return c?(jspb.Message.setField(a,c,d),c):0};
    jspb.Message.getWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){var e=jspb.Message.getField(a,c);if(d||e)a.wrappers_[c]=new b(e);}return a.wrappers_[c]};jspb.Message.getRepeatedWrapperField=function(a,b,c){jspb.Message.wrapRepeatedField_(a,b,c);b=a.wrappers_[c];b==jspb.Message.EMPTY_LIST_SENTINEL_&&(b=a.wrappers_[c]=[]);return b};
    jspb.Message.wrapRepeatedField_=function(a,b,c){a.wrappers_||(a.wrappers_={});if(!a.wrappers_[c]){for(var d=jspb.Message.getRepeatedField(a,c),e=[],f=0;f<d.length;f++)e[f]=new b(d[f]);a.wrappers_[c]=e;}};jspb.Message.setWrapperField=function(a,b,c){a.wrappers_||(a.wrappers_={});var d=c?c.toArray():c;a.wrappers_[b]=c;jspb.Message.setField(a,b,d);};
    jspb.Message.setOneofWrapperField=function(a,b,c,d){a.wrappers_||(a.wrappers_={});var e=d?d.toArray():d;a.wrappers_[b]=d;jspb.Message.setOneofField(a,b,c,e);};jspb.Message.setRepeatedWrapperField=function(a,b,c){a.wrappers_||(a.wrappers_={});c=c||[];for(var d=[],e=0;e<c.length;e++)d[e]=c[e].toArray();a.wrappers_[b]=c;jspb.Message.setField(a,b,d);};
    jspb.Message.addToRepeatedWrapperField=function(a,b,c,d,e){jspb.Message.wrapRepeatedField_(a,d,b);var f=a.wrappers_[b];f||(f=a.wrappers_[b]=[]);c=c?c:new d;a=jspb.Message.getRepeatedField(a,b);void 0!=e?(f.splice(e,0,c),a.splice(e,0,c.toArray())):(f.push(c),a.push(c.toArray()));return c};jspb.Message.toMap=function(a,b,c,d){for(var e={},f=0;f<a.length;f++)e[b.call(a[f])]=c?c.call(a[f],d,a[f]):a[f];return e};
    jspb.Message.prototype.syncMapFields_=function(){if(this.wrappers_)for(var a in this.wrappers_){var b=this.wrappers_[a];if(goog.isArray(b))for(var c=0;c<b.length;c++)b[c]&&b[c].toArray();else b&&b.toArray();}};jspb.Message.prototype.toArray=function(){this.syncMapFields_();return this.array};jspb.Message.GENERATE_TO_STRING&&(jspb.Message.prototype.toString=function(){this.syncMapFields_();return this.array.toString()});
    jspb.Message.prototype.getExtension=function(a){if(this.extensionObject_){this.wrappers_||(this.wrappers_={});var b=a.fieldIndex;if(a.isRepeated){if(a.isMessageType())return this.wrappers_[b]||(this.wrappers_[b]=goog.array.map(this.extensionObject_[b]||[],function(b){return new a.ctor(b)})),this.wrappers_[b]}else if(a.isMessageType())return !this.wrappers_[b]&&this.extensionObject_[b]&&(this.wrappers_[b]=new a.ctor(this.extensionObject_[b])),this.wrappers_[b];return this.extensionObject_[b]}};
    jspb.Message.prototype.setExtension=function(a,b){this.wrappers_||(this.wrappers_={});jspb.Message.maybeInitEmptyExtensionObject_(this);var c=a.fieldIndex;a.isRepeated?(b=b||[],a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=goog.array.map(b,function(a){return a.toArray()})):this.extensionObject_[c]=b):a.isMessageType()?(this.wrappers_[c]=b,this.extensionObject_[c]=b?b.toArray():b):this.extensionObject_[c]=b;return this};
    jspb.Message.difference=function(a,b){if(!(a instanceof b.constructor))throw Error("Messages have different types.");var c=a.toArray(),d=b.toArray(),e=[],f=0,g=c.length>d.length?c.length:d.length;a.getJsPbMessageId()&&(e[0]=a.getJsPbMessageId(),f=1);for(;f<g;f++)jspb.Message.compareFields(c[f],d[f])||(e[f]=d[f]);return new a.constructor(e)};jspb.Message.equals=function(a,b){return a==b||!(!a||!b)&&a instanceof b.constructor&&jspb.Message.compareFields(a.toArray(),b.toArray())};
    jspb.Message.compareExtensions=function(a,b){a=a||{};b=b||{};var c={},d;for(d in a)c[d]=0;for(d in b)c[d]=0;for(d in c)if(!jspb.Message.compareFields(a[d],b[d]))return !1;return !0};
    jspb.Message.compareFields=function(a,b){if(a==b)return !0;if(!goog.isObject(a)||!goog.isObject(b))return goog.isNumber(a)&&isNaN(a)||goog.isNumber(b)&&isNaN(b)?String(a)==String(b):!1;if(a.constructor!=b.constructor)return !1;if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a.constructor===Uint8Array){if(a.length!=b.length)return !1;for(var c=0;c<a.length;c++)if(a[c]!=b[c])return !1;return !0}if(a.constructor===Array){for(var d=void 0,e=void 0,f=Math.max(a.length,b.length),c=0;c<f;c++){var g=a[c],h=b[c];g&&g.constructor==
    Object&&(goog.asserts.assert(void 0===d),goog.asserts.assert(c===a.length-1),d=g,g=void 0);h&&h.constructor==Object&&(goog.asserts.assert(void 0===e),goog.asserts.assert(c===b.length-1),e=h,h=void 0);if(!jspb.Message.compareFields(g,h))return !1}return d||e?(d=d||{},e=e||{},jspb.Message.compareExtensions(d,e)):!0}if(a.constructor===Object)return jspb.Message.compareExtensions(a,b);throw Error("Invalid type in JSPB array");};jspb.Message.prototype.cloneMessage=function(){return jspb.Message.cloneMessage(this)};
    jspb.Message.prototype.clone=function(){return jspb.Message.cloneMessage(this)};jspb.Message.clone=function(a){return jspb.Message.cloneMessage(a)};jspb.Message.cloneMessage=function(a){return new a.constructor(jspb.Message.clone_(a.toArray()))};
    jspb.Message.copyInto=function(a,b){goog.asserts.assertInstanceof(a,jspb.Message);goog.asserts.assertInstanceof(b,jspb.Message);goog.asserts.assert(a.constructor==b.constructor,"Copy source and target message should have the same type.");for(var c=jspb.Message.clone(a),d=b.toArray(),e=c.toArray(),f=d.length=0;f<e.length;f++)d[f]=e[f];b.wrappers_=c.wrappers_;b.extensionObject_=c.extensionObject_;};
    jspb.Message.clone_=function(a){var b;if(goog.isArray(a)){for(var c=Array(a.length),d=0;d<a.length;d++)b=a[d],null!=b&&(c[d]="object"==typeof b?jspb.Message.clone_(goog.asserts.assert(b)):b);return c}if(jspb.Message.SUPPORTS_UINT8ARRAY_&&a instanceof Uint8Array)return new Uint8Array(a);c={};for(d in a)b=a[d],null!=b&&(c[d]="object"==typeof b?jspb.Message.clone_(goog.asserts.assert(b)):b);return c};jspb.Message.registerMessageType=function(a,b){jspb.Message.registry_[a]=b;b.messageId=a;};
    jspb.Message.registry_={};jspb.Message.messageSetExtensions={};jspb.Message.messageSetExtensionsBinary={};jspb.arith={};jspb.arith.UInt64=function(a,b){this.lo=a;this.hi=b;};jspb.arith.UInt64.prototype.cmp=function(a){return this.hi<a.hi||this.hi==a.hi&&this.lo<a.lo?-1:this.hi==a.hi&&this.lo==a.lo?0:1};jspb.arith.UInt64.prototype.rightShift=function(){return new jspb.arith.UInt64((this.lo>>>1|(this.hi&1)<<31)>>>0,this.hi>>>1>>>0)};jspb.arith.UInt64.prototype.leftShift=function(){return new jspb.arith.UInt64(this.lo<<1>>>0,(this.hi<<1|this.lo>>>31)>>>0)};
    jspb.arith.UInt64.prototype.msb=function(){return !!(this.hi&2147483648)};jspb.arith.UInt64.prototype.lsb=function(){return !!(this.lo&1)};jspb.arith.UInt64.prototype.zero=function(){return 0==this.lo&&0==this.hi};jspb.arith.UInt64.prototype.add=function(a){return new jspb.arith.UInt64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};
    jspb.arith.UInt64.prototype.sub=function(a){return new jspb.arith.UInt64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.UInt64.mul32x32=function(a,b){for(var c=a&65535,d=a>>>16,e=b&65535,f=b>>>16,g=c*e+65536*(c*f&65535)+65536*(d*e&65535),c=d*f+(c*f>>>16)+(d*e>>>16);4294967296<=g;)g-=4294967296,c+=1;return new jspb.arith.UInt64(g>>>0,c>>>0)};
    jspb.arith.UInt64.prototype.mul=function(a){var b=jspb.arith.UInt64.mul32x32(this.lo,a);a=jspb.arith.UInt64.mul32x32(this.hi,a);a.hi=a.lo;a.lo=0;return b.add(a)};
    jspb.arith.UInt64.prototype.div=function(a){if(0==a)return [];var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(this.lo,this.hi);a=new jspb.arith.UInt64(a,0);for(var d=new jspb.arith.UInt64(1,0);!a.msb();)a=a.leftShift(),d=d.leftShift();for(;!d.zero();)0>=a.cmp(c)&&(b=b.add(d),c=c.sub(a)),a=a.rightShift(),d=d.rightShift();return [b,c]};jspb.arith.UInt64.prototype.toString=function(){for(var a="",b=this;!b.zero();)var b=b.div(10),c=b[0],a=b[1].lo+a,b=c;""==a&&(a="0");return a};
    jspb.arith.UInt64.fromString=function(a){for(var b=new jspb.arith.UInt64(0,0),c=new jspb.arith.UInt64(0,0),d=0;d<a.length;d++){if("0">a[d]||"9"<a[d])return null;var e=parseInt(a[d],10);c.lo=e;b=b.mul(10).add(c);}return b};jspb.arith.UInt64.prototype.clone=function(){return new jspb.arith.UInt64(this.lo,this.hi)};jspb.arith.Int64=function(a,b){this.lo=a;this.hi=b;};
    jspb.arith.Int64.prototype.add=function(a){return new jspb.arith.Int64((this.lo+a.lo&4294967295)>>>0>>>0,((this.hi+a.hi&4294967295)>>>0)+(4294967296<=this.lo+a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.sub=function(a){return new jspb.arith.Int64((this.lo-a.lo&4294967295)>>>0>>>0,((this.hi-a.hi&4294967295)>>>0)-(0>this.lo-a.lo?1:0)>>>0)};jspb.arith.Int64.prototype.clone=function(){return new jspb.arith.Int64(this.lo,this.hi)};
    jspb.arith.Int64.prototype.toString=function(){var a=0!=(this.hi&2147483648),b=new jspb.arith.UInt64(this.lo,this.hi);a&&(b=(new jspb.arith.UInt64(0,0)).sub(b));return (a?"-":"")+b.toString()};jspb.arith.Int64.fromString=function(a){var b=0<a.length&&"-"==a[0];b&&(a=a.substring(1));a=jspb.arith.UInt64.fromString(a);if(null===a)return null;b&&(a=(new jspb.arith.UInt64(0,0)).sub(a));return new jspb.arith.Int64(a.lo,a.hi)};jspb.BinaryConstants={};jspb.ConstBinaryMessage=function(){};jspb.BinaryMessage=function(){};jspb.BinaryConstants.FieldType={INVALID:-1,DOUBLE:1,FLOAT:2,INT64:3,UINT64:4,INT32:5,FIXED64:6,FIXED32:7,BOOL:8,STRING:9,GROUP:10,MESSAGE:11,BYTES:12,UINT32:13,ENUM:14,SFIXED32:15,SFIXED64:16,SINT32:17,SINT64:18,FHASH64:30,VHASH64:31};jspb.BinaryConstants.WireType={INVALID:-1,VARINT:0,FIXED64:1,DELIMITED:2,START_GROUP:3,END_GROUP:4,FIXED32:5};
    jspb.BinaryConstants.FieldTypeToWireType=function(a){var b=jspb.BinaryConstants.FieldType,c=jspb.BinaryConstants.WireType;switch(a){case b.INT32:case b.INT64:case b.UINT32:case b.UINT64:case b.SINT32:case b.SINT64:case b.BOOL:case b.ENUM:case b.VHASH64:return c.VARINT;case b.DOUBLE:case b.FIXED64:case b.SFIXED64:case b.FHASH64:return c.FIXED64;case b.STRING:case b.MESSAGE:case b.BYTES:return c.DELIMITED;case b.FLOAT:case b.FIXED32:case b.SFIXED32:return c.FIXED32;default:return c.INVALID}};
    jspb.BinaryConstants.INVALID_FIELD_NUMBER=-1;jspb.BinaryConstants.FLOAT32_EPS=1.401298464324817E-45;jspb.BinaryConstants.FLOAT32_MIN=1.1754943508222875E-38;jspb.BinaryConstants.FLOAT32_MAX=3.4028234663852886E38;jspb.BinaryConstants.FLOAT64_EPS=4.9E-324;jspb.BinaryConstants.FLOAT64_MIN=2.2250738585072014E-308;jspb.BinaryConstants.FLOAT64_MAX=1.7976931348623157E308;jspb.BinaryConstants.TWO_TO_20=1048576;jspb.BinaryConstants.TWO_TO_23=8388608;jspb.BinaryConstants.TWO_TO_31=2147483648;
    jspb.BinaryConstants.TWO_TO_32=4294967296;jspb.BinaryConstants.TWO_TO_52=4503599627370496;jspb.BinaryConstants.TWO_TO_63=0x7fffffffffffffff;jspb.BinaryConstants.TWO_TO_64=1.8446744073709552E19;jspb.BinaryConstants.ZERO_HASH="\x00\x00\x00\x00\x00\x00\x00\x00";jspb.utils={};jspb.utils.split64Low=0;jspb.utils.split64High=0;jspb.utils.splitUint64=function(a){var b=a>>>0;a=Math.floor((a-b)/jspb.BinaryConstants.TWO_TO_32)>>>0;jspb.utils.split64Low=b;jspb.utils.split64High=a;};jspb.utils.splitInt64=function(a){var b=0>a;a=Math.abs(a);var c=a>>>0;a=Math.floor((a-c)/jspb.BinaryConstants.TWO_TO_32);a>>>=0;b&&(a=~a>>>0,c=(~c>>>0)+1,4294967295<c&&(c=0,a++,4294967295<a&&(a=0)));jspb.utils.split64Low=c;jspb.utils.split64High=a;};
    jspb.utils.splitZigzag64=function(a){var b=0>a;a=2*Math.abs(a);jspb.utils.splitUint64(a);a=jspb.utils.split64Low;var c=jspb.utils.split64High;b&&(0==a?0==c?c=a=4294967295:(c--,a=4294967295):a--);jspb.utils.split64Low=a;jspb.utils.split64High=c;};
    jspb.utils.splitFloat32=function(a){var b=0>a?1:0;a=b?-a:a;var c;0===a?0<1/a?(jspb.utils.split64High=0,jspb.utils.split64Low=0):(jspb.utils.split64High=0,jspb.utils.split64Low=2147483648):isNaN(a)?(jspb.utils.split64High=0,jspb.utils.split64Low=2147483647):a>jspb.BinaryConstants.FLOAT32_MAX?(jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|2139095040)>>>0):a<jspb.BinaryConstants.FLOAT32_MIN?(a=Math.round(a/Math.pow(2,-149)),jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|a)>>>0):(c=Math.floor(Math.log(a)/
    Math.LN2),a*=Math.pow(2,-c),a=Math.round(a*jspb.BinaryConstants.TWO_TO_23)&8388607,jspb.utils.split64High=0,jspb.utils.split64Low=(b<<31|c+127<<23|a)>>>0);};
    jspb.utils.splitFloat64=function(a){var b=0>a?1:0;a=b?-a:a;if(0===a)jspb.utils.split64High=0<1/a?0:2147483648,jspb.utils.split64Low=0;else if(isNaN(a))jspb.utils.split64High=2147483647,jspb.utils.split64Low=4294967295;else if(a>jspb.BinaryConstants.FLOAT64_MAX)jspb.utils.split64High=(b<<31|2146435072)>>>0,jspb.utils.split64Low=0;else if(a<jspb.BinaryConstants.FLOAT64_MIN){var c=a/Math.pow(2,-1074);a=c/jspb.BinaryConstants.TWO_TO_32;jspb.utils.split64High=(b<<31|a)>>>0;jspb.utils.split64Low=c>>>0;}else{var d=
    Math.floor(Math.log(a)/Math.LN2);1024==d&&(d=1023);c=a*Math.pow(2,-d);a=c*jspb.BinaryConstants.TWO_TO_20&1048575;c=c*jspb.BinaryConstants.TWO_TO_52>>>0;jspb.utils.split64High=(b<<31|d+1023<<20|a)>>>0;jspb.utils.split64Low=c;}};
    jspb.utils.splitHash64=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=a.charCodeAt(4),g=a.charCodeAt(5),h=a.charCodeAt(6);a=a.charCodeAt(7);jspb.utils.split64Low=b+(c<<8)+(d<<16)+(e<<24)>>>0;jspb.utils.split64High=f+(g<<8)+(h<<16)+(a<<24)>>>0;};jspb.utils.joinUint64=function(a,b){return b*jspb.BinaryConstants.TWO_TO_32+a};
    jspb.utils.joinInt64=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b>>>0,0==a&&(b=b+1>>>0));var d=jspb.utils.joinUint64(a,b);return c?-d:d};jspb.utils.joinZigzag64=function(a,b){var c=a&1;a=(a>>>1|b<<31)>>>0;b>>>=1;c&&(a=a+1>>>0,0==a&&(b=b+1>>>0));var d=jspb.utils.joinUint64(a,b);return c?-d:d};jspb.utils.joinFloat32=function(a,b){var c=2*(a>>31)+1,d=a>>>23&255,e=a&8388607;return 255==d?e?NaN:Infinity*c:0==d?c*Math.pow(2,-149)*e:c*Math.pow(2,d-150)*(e+Math.pow(2,23))};
    jspb.utils.joinFloat64=function(a,b){var c=2*(b>>31)+1,d=b>>>20&2047,e=jspb.BinaryConstants.TWO_TO_32*(b&1048575)+a;return 2047==d?e?NaN:Infinity*c:0==d?c*Math.pow(2,-1074)*e:c*Math.pow(2,d-1075)*(e+jspb.BinaryConstants.TWO_TO_52)};jspb.utils.joinHash64=function(a,b){return String.fromCharCode(a>>>0&255,a>>>8&255,a>>>16&255,a>>>24&255,b>>>0&255,b>>>8&255,b>>>16&255,b>>>24&255)};jspb.utils.DIGITS="0123456789abcdef".split("");
    jspb.utils.joinUnsignedDecimalString=function(a,b){function c(a){for(var b=1E7,c=0;7>c;c++){var b=b/10,d=a/b%10>>>0;if(0!=d||h)h=!0,k+=g[d];}}if(2097151>=b)return ""+(jspb.BinaryConstants.TWO_TO_32*b+a);var d=(a>>>24|b<<8)>>>0&16777215,e=b>>16&65535,f=(a&16777215)+6777216*d+6710656*e,d=d+8147497*e,e=2*e;1E7<=f&&(d+=Math.floor(f/1E7),f%=1E7);1E7<=d&&(e+=Math.floor(d/1E7),d%=1E7);var g=jspb.utils.DIGITS,h=!1,k="";(e||h)&&c(e);(d||h)&&c(d);(f||h)&&c(f);return k};
    jspb.utils.joinSignedDecimalString=function(a,b){var c=b&2147483648;c&&(a=~a+1>>>0,b=~b+(0==a?1:0)>>>0);var d=jspb.utils.joinUnsignedDecimalString(a,b);return c?"-"+d:d};jspb.utils.hash64ToDecimalString=function(a,b){jspb.utils.splitHash64(a);var c=jspb.utils.split64Low,d=jspb.utils.split64High;return b?jspb.utils.joinSignedDecimalString(c,d):jspb.utils.joinUnsignedDecimalString(c,d)};
    jspb.utils.hash64ArrayToDecimalStrings=function(a,b){for(var c=Array(a.length),d=0;d<a.length;d++)c[d]=jspb.utils.hash64ToDecimalString(a[d],b);return c};
    jspb.utils.decimalStringToHash64=function(a){function b(a,b){for(var c=0;8>c&&(1!==a||0<b);c++){var d=a*e[c]+b;e[c]=d&255;b=d>>>8;}}function c(){for(var a=0;8>a;a++)e[a]=~e[a]&255;}goog.asserts.assert(0<a.length);var d=!1;"-"===a[0]&&(d=!0,a=a.slice(1));for(var e=[0,0,0,0,0,0,0,0],f=0;f<a.length;f++)b(10,jspb.utils.DIGITS.indexOf(a[f]));d&&(c(),b(1,1));return goog.crypt.byteArrayToString(e)};jspb.utils.splitDecimalString=function(a){jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));};
    jspb.utils.hash64ToHexString=function(a){var b=Array(18);b[0]="0";b[1]="x";for(var c=0;8>c;c++){var d=a.charCodeAt(7-c);b[2*c+2]=jspb.utils.DIGITS[d>>4];b[2*c+3]=jspb.utils.DIGITS[d&15];}return b.join("")};jspb.utils.hexStringToHash64=function(a){a=a.toLowerCase();goog.asserts.assert(18==a.length);goog.asserts.assert("0"==a[0]);goog.asserts.assert("x"==a[1]);for(var b="",c=0;8>c;c++)var d=jspb.utils.DIGITS.indexOf(a[2*c+2]),e=jspb.utils.DIGITS.indexOf(a[2*c+3]),b=String.fromCharCode(16*d+e)+b;return b};
    jspb.utils.hash64ToNumber=function(a,b){jspb.utils.splitHash64(a);var c=jspb.utils.split64Low,d=jspb.utils.split64High;return b?jspb.utils.joinInt64(c,d):jspb.utils.joinUint64(c,d)};jspb.utils.numberToHash64=function(a){jspb.utils.splitInt64(a);return jspb.utils.joinHash64(jspb.utils.split64Low,jspb.utils.split64High)};jspb.utils.countVarints=function(a,b,c){for(var d=0,e=b;e<c;e++)d+=a[e]>>7;return c-b-d};
    jspb.utils.countVarintFields=function(a,b,c,d){var e=0;d=8*d+jspb.BinaryConstants.WireType.VARINT;if(128>d)for(;b<c&&a[b++]==d;)for(e++;;){var f=a[b++];if(0==(f&128))break}else for(;b<c;){for(f=d;128<f;){if(a[b]!=(f&127|128))return e;b++;f>>=7;}if(a[b++]!=f)break;for(e++;f=a[b++],0!=(f&128););}return e};jspb.utils.countFixedFields_=function(a,b,c,d,e){var f=0;if(128>d)for(;b<c&&a[b++]==d;)f++,b+=e;else for(;b<c;){for(var g=d;128<g;){if(a[b++]!=(g&127|128))return f;g>>=7;}if(a[b++]!=g)break;f++;b+=e;}return f};
    jspb.utils.countFixed32Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED32,4)};jspb.utils.countFixed64Fields=function(a,b,c,d){return jspb.utils.countFixedFields_(a,b,c,8*d+jspb.BinaryConstants.WireType.FIXED64,8)};
    jspb.utils.countDelimitedFields=function(a,b,c,d){var e=0;for(d=8*d+jspb.BinaryConstants.WireType.DELIMITED;b<c;){for(var f=d;128<f;){if(a[b++]!=(f&127|128))return e;f>>=7;}if(a[b++]!=f)break;e++;for(var g=0,h=1;f=a[b++],g+=(f&127)*h,h*=128,0!=(f&128););b+=g;}return e};jspb.utils.debugBytesToTextFormat=function(a){var b='"';if(a){a=jspb.utils.byteSourceToUint8Array(a);for(var c=0;c<a.length;c++)b+="\\x",16>a[c]&&(b+="0"),b+=a[c].toString(16);}return b+'"'};
    jspb.utils.debugScalarToTextFormat=function(a){return goog.isString(a)?goog.string.quote(a):a.toString()};jspb.utils.stringToByteArray=function(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;c++){var d=a.charCodeAt(c);if(255<d)throw Error("Conversion error: string contains codepoint outside of byte range");b[c]=d;}return b};
    jspb.utils.byteSourceToUint8Array=function(a){if(a.constructor===Uint8Array)return a;if(a.constructor===ArrayBuffer||a.constructor===Buffer||a.constructor===Array)return new Uint8Array(a);if(a.constructor===String)return goog.crypt.base64.decodeStringToUint8Array(a);goog.asserts.fail("Type not convertible to Uint8Array.");return new Uint8Array(0)};jspb.BinaryEncoder=function(){this.buffer_=[];};jspb.BinaryEncoder.prototype.length=function(){return this.buffer_.length};jspb.BinaryEncoder.prototype.end=function(){var a=this.buffer_;this.buffer_=[];return a};
    jspb.BinaryEncoder.prototype.writeSplitVarint64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);for(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);0<b||127<a;)this.buffer_.push(a&127|128),a=(a>>>7|b<<25)>>>0,b>>>=7;this.buffer_.push(a);};
    jspb.BinaryEncoder.prototype.writeSplitFixed64=function(a,b){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(b==Math.floor(b));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32);this.writeUint32(a);this.writeUint32(b);};
    jspb.BinaryEncoder.prototype.writeUnsignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));for(goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);127<a;)this.buffer_.push(a&127|128),a>>>=7;this.buffer_.push(a);};
    jspb.BinaryEncoder.prototype.writeSignedVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);if(0<=a)this.writeUnsignedVarint32(a);else{for(var b=0;9>b;b++)this.buffer_.push(a&127|128),a>>=7;this.buffer_.push(1);}};
    jspb.BinaryEncoder.prototype.writeUnsignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeSignedVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeZigzagVarint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeUnsignedVarint32((a<<1^a>>31)>>>0);};jspb.BinaryEncoder.prototype.writeZigzagVarint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitZigzag64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeZigzagVarint64String=function(a){this.writeZigzagVarint64(parseInt(a,10));};jspb.BinaryEncoder.prototype.writeUint8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&256>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeUint16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&65536>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
    jspb.BinaryEncoder.prototype.writeUint32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_32);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};jspb.BinaryEncoder.prototype.writeUint64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(0<=a&&a<jspb.BinaryConstants.TWO_TO_64);jspb.utils.splitUint64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeInt8=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-128<=a&&128>a);this.buffer_.push(a>>>0&255);};jspb.BinaryEncoder.prototype.writeInt16=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(-32768<=a&&32768>a);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);};
    jspb.BinaryEncoder.prototype.writeInt32=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.buffer_.push(a>>>0&255);this.buffer_.push(a>>>8&255);this.buffer_.push(a>>>16&255);this.buffer_.push(a>>>24&255);};
    jspb.BinaryEncoder.prototype.writeInt64=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_63&&a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitInt64(a);this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeInt64String=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(+a>=-jspb.BinaryConstants.TWO_TO_63&&+a<jspb.BinaryConstants.TWO_TO_63);jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));this.writeSplitFixed64(jspb.utils.split64Low,jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeFloat=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT32_MAX&&a<=jspb.BinaryConstants.FLOAT32_MAX);jspb.utils.splitFloat32(a);this.writeUint32(jspb.utils.split64Low);};
    jspb.BinaryEncoder.prototype.writeDouble=function(a){goog.asserts.assert(a>=-jspb.BinaryConstants.FLOAT64_MAX&&a<=jspb.BinaryConstants.FLOAT64_MAX);jspb.utils.splitFloat64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};jspb.BinaryEncoder.prototype.writeBool=function(a){goog.asserts.assert(goog.isBoolean(a)||goog.isNumber(a));this.buffer_.push(a?1:0);};
    jspb.BinaryEncoder.prototype.writeEnum=function(a){goog.asserts.assert(a==Math.floor(a));goog.asserts.assert(a>=-jspb.BinaryConstants.TWO_TO_31&&a<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32(a);};jspb.BinaryEncoder.prototype.writeBytes=function(a){this.buffer_.push.apply(this.buffer_,a);};jspb.BinaryEncoder.prototype.writeVarintHash64=function(a){jspb.utils.splitHash64(a);this.writeSplitVarint64(jspb.utils.split64Low,jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeFixedHash64=function(a){jspb.utils.splitHash64(a);this.writeUint32(jspb.utils.split64Low);this.writeUint32(jspb.utils.split64High);};
    jspb.BinaryEncoder.prototype.writeString=function(a){for(var b=this.buffer_.length,c=0;c<a.length;c++){var d=a.charCodeAt(c);if(128>d)this.buffer_.push(d);else if(2048>d)this.buffer_.push(d>>6|192),this.buffer_.push(d&63|128);else if(65536>d)if(55296<=d&&56319>=d&&c+1<a.length){var e=a.charCodeAt(c+1);56320<=e&&57343>=e&&(d=1024*(d-55296)+e-56320+65536,this.buffer_.push(d>>18|240),this.buffer_.push(d>>12&63|128),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128),c++);}else this.buffer_.push(d>>
    12|224),this.buffer_.push(d>>6&63|128),this.buffer_.push(d&63|128);}return this.buffer_.length-b};jspb.BinaryWriter=function(){this.blocks_=[];this.totalLength_=0;this.encoder_=new jspb.BinaryEncoder;this.bookmarks_=[];};jspb.BinaryWriter.prototype.appendUint8Array_=function(a){var b=this.encoder_.end();this.blocks_.push(b);this.blocks_.push(a);this.totalLength_+=b.length+a.length;};
    jspb.BinaryWriter.prototype.beginDelimited_=function(a){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);a=this.encoder_.end();this.blocks_.push(a);this.totalLength_+=a.length;a.push(this.totalLength_);return a};jspb.BinaryWriter.prototype.endDelimited_=function(a){var b=a.pop(),b=this.totalLength_+this.encoder_.length()-b;for(goog.asserts.assert(0<=b);127<b;)a.push(b&127|128),b>>>=7,this.totalLength_++;a.push(b);this.totalLength_++;};
    jspb.BinaryWriter.prototype.writeSerializedMessage=function(a,b,c){this.appendUint8Array_(a.subarray(b,c));};jspb.BinaryWriter.prototype.maybeWriteSerializedMessage=function(a,b,c){null!=a&&null!=b&&null!=c&&this.writeSerializedMessage(a,b,c);};jspb.BinaryWriter.prototype.reset=function(){this.blocks_=[];this.encoder_.end();this.totalLength_=0;this.bookmarks_=[];};
    jspb.BinaryWriter.prototype.getResultBuffer=function(){goog.asserts.assert(0==this.bookmarks_.length);for(var a=new Uint8Array(this.totalLength_+this.encoder_.length()),b=this.blocks_,c=b.length,d=0,e=0;e<c;e++){var f=b[e];a.set(f,d);d+=f.length;}b=this.encoder_.end();a.set(b,d);d+=b.length;goog.asserts.assert(d==a.length);this.blocks_=[a];return a};jspb.BinaryWriter.prototype.getResultBase64String=function(a){return goog.crypt.base64.encodeByteArray(this.getResultBuffer(),a)};
    jspb.BinaryWriter.prototype.beginSubMessage=function(a){this.bookmarks_.push(this.beginDelimited_(a));};jspb.BinaryWriter.prototype.endSubMessage=function(){goog.asserts.assert(0<=this.bookmarks_.length);this.endDelimited_(this.bookmarks_.pop());};jspb.BinaryWriter.prototype.writeFieldHeader_=function(a,b){goog.asserts.assert(1<=a&&a==Math.floor(a));this.encoder_.writeUnsignedVarint32(8*a+b);};
    jspb.BinaryWriter.prototype.writeAny=function(a,b,c){var d=jspb.BinaryConstants.FieldType;switch(a){case d.DOUBLE:this.writeDouble(b,c);break;case d.FLOAT:this.writeFloat(b,c);break;case d.INT64:this.writeInt64(b,c);break;case d.UINT64:this.writeUint64(b,c);break;case d.INT32:this.writeInt32(b,c);break;case d.FIXED64:this.writeFixed64(b,c);break;case d.FIXED32:this.writeFixed32(b,c);break;case d.BOOL:this.writeBool(b,c);break;case d.STRING:this.writeString(b,c);break;case d.GROUP:goog.asserts.fail("Group field type not supported in writeAny()");
    break;case d.MESSAGE:goog.asserts.fail("Message field type not supported in writeAny()");break;case d.BYTES:this.writeBytes(b,c);break;case d.UINT32:this.writeUint32(b,c);break;case d.ENUM:this.writeEnum(b,c);break;case d.SFIXED32:this.writeSfixed32(b,c);break;case d.SFIXED64:this.writeSfixed64(b,c);break;case d.SINT32:this.writeSint32(b,c);break;case d.SINT64:this.writeSint64(b,c);break;case d.FHASH64:this.writeFixedHash64(b,c);break;case d.VHASH64:this.writeVarintHash64(b,c);break;default:goog.asserts.fail("Invalid field type in writeAny()");}};
    jspb.BinaryWriter.prototype.writeUnsignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint32(b));};jspb.BinaryWriter.prototype.writeSignedVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeUnsignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeUnsignedVarint64(b));};
    jspb.BinaryWriter.prototype.writeSignedVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint64(b));};jspb.BinaryWriter.prototype.writeZigzagVarint32_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint32(b));};jspb.BinaryWriter.prototype.writeZigzagVarint64_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64(b));};
    jspb.BinaryWriter.prototype.writeZigzagVarint64String_=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeZigzagVarint64String(b));};jspb.BinaryWriter.prototype.writeInt32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeSignedVarint32_(a,b));};
    jspb.BinaryWriter.prototype.writeInt32String=function(a,b){if(null!=b){var c=parseInt(b,10);goog.asserts.assert(c>=-jspb.BinaryConstants.TWO_TO_31&&c<jspb.BinaryConstants.TWO_TO_31);this.writeSignedVarint32_(a,c);}};jspb.BinaryWriter.prototype.writeInt64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeSignedVarint64_(a,b));};
    jspb.BinaryWriter.prototype.writeInt64String=function(a,b){if(null!=b){var c=jspb.arith.Int64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeUint32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeUnsignedVarint32_(a,b));};
    jspb.BinaryWriter.prototype.writeUint32String=function(a,b){if(null!=b){var c=parseInt(b,10);goog.asserts.assert(0<=c&&c<jspb.BinaryConstants.TWO_TO_32);this.writeUnsignedVarint32_(a,c);}};jspb.BinaryWriter.prototype.writeUint64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeUnsignedVarint64_(a,b));};
    jspb.BinaryWriter.prototype.writeUint64String=function(a,b){if(null!=b){var c=jspb.arith.UInt64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT);this.encoder_.writeSplitVarint64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeSint32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeZigzagVarint32_(a,b));};
    jspb.BinaryWriter.prototype.writeSint64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64_(a,b));};jspb.BinaryWriter.prototype.writeSint64String=function(a,b){null!=b&&(goog.asserts.assert(+b>=-jspb.BinaryConstants.TWO_TO_63&&+b<jspb.BinaryConstants.TWO_TO_63),this.writeZigzagVarint64String_(a,b));};
    jspb.BinaryWriter.prototype.writeFixed32=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_32),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeUint32(b));};jspb.BinaryWriter.prototype.writeFixed64=function(a,b){null!=b&&(goog.asserts.assert(0<=b&&b<jspb.BinaryConstants.TWO_TO_64),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeUint64(b));};
    jspb.BinaryWriter.prototype.writeFixed64String=function(a,b){if(null!=b){var c=jspb.arith.UInt64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};jspb.BinaryWriter.prototype.writeSfixed32=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeInt32(b));};
    jspb.BinaryWriter.prototype.writeSfixed64=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_63&&b<jspb.BinaryConstants.TWO_TO_63),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeInt64(b));};jspb.BinaryWriter.prototype.writeSfixed64String=function(a,b){if(null!=b){var c=jspb.arith.Int64.fromString(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64);this.encoder_.writeSplitFixed64(c.lo,c.hi);}};
    jspb.BinaryWriter.prototype.writeFloat=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED32),this.encoder_.writeFloat(b));};jspb.BinaryWriter.prototype.writeDouble=function(a,b){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeDouble(b));};jspb.BinaryWriter.prototype.writeBool=function(a,b){null!=b&&(goog.asserts.assert(goog.isBoolean(b)||goog.isNumber(b)),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeBool(b));};
    jspb.BinaryWriter.prototype.writeEnum=function(a,b){null!=b&&(goog.asserts.assert(b>=-jspb.BinaryConstants.TWO_TO_31&&b<jspb.BinaryConstants.TWO_TO_31),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeSignedVarint32(b));};jspb.BinaryWriter.prototype.writeString=function(a,b){if(null!=b){var c=this.beginDelimited_(a);this.encoder_.writeString(b);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writeBytes=function(a,b){if(null!=b){var c=jspb.utils.byteSourceToUint8Array(b);this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(c.length);this.appendUint8Array_(c);}};jspb.BinaryWriter.prototype.writeMessage=function(a,b,c){null!=b&&(a=this.beginDelimited_(a),c(b,this),this.endDelimited_(a));};
    jspb.BinaryWriter.prototype.writeGroup=function(a,b,c){null!=b&&(this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b,this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP));};jspb.BinaryWriter.prototype.writeFixedHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.FIXED64),this.encoder_.writeFixedHash64(b));};
    jspb.BinaryWriter.prototype.writeVarintHash64=function(a,b){null!=b&&(goog.asserts.assert(8==b.length),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.VARINT),this.encoder_.writeVarintHash64(b));};jspb.BinaryWriter.prototype.writeRepeatedInt32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt32String(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedInt64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedInt64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeInt64String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint32_(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedUint32String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint32String(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUnsignedVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedUint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeUint64String(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedSint32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint32_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64_(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSint64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeZigzagVarint64String_(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedFixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedFixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixed64String(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedSfixed32=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed32(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedSfixed64String=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeSfixed64String(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedFloat=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFloat(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedDouble=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeDouble(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBool=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBool(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedEnum=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeEnum(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedString=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeString(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedBytes=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeBytes(a,b[c]);};jspb.BinaryWriter.prototype.writeRepeatedMessage=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++){var e=this.beginDelimited_(a);c(b[d],this);this.endDelimited_(e);}};
    jspb.BinaryWriter.prototype.writeRepeatedGroup=function(a,b,c){if(null!=b)for(var d=0;d<b.length;d++)this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.START_GROUP),c(b[d],this),this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.END_GROUP);};jspb.BinaryWriter.prototype.writeRepeatedFixedHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeFixedHash64(a,b[c]);};
    jspb.BinaryWriter.prototype.writeRepeatedVarintHash64=function(a,b){if(null!=b)for(var c=0;c<b.length;c++)this.writeVarintHash64(a,b[c]);};jspb.BinaryWriter.prototype.writePackedInt32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint32(b[d]);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedInt32String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint32(parseInt(b[d],10));this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedInt64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeSignedVarint64(b[d]);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedInt64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++){var e=jspb.arith.Int64.fromString(b[d]);this.encoder_.writeSplitVarint64(e.lo,e.hi);}this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedUint32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint32(b[d]);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedUint32String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint32(parseInt(b[d],10));this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedUint64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeUnsignedVarint64(b[d]);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedUint64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++){var e=jspb.arith.UInt64.fromString(b[d]);this.encoder_.writeSplitVarint64(e.lo,e.hi);}this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedSint32=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint32(b[d]);this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedSint64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint64(b[d]);this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedSint64String=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeZigzagVarint64(parseInt(b[d],10));this.endDelimited_(c);}};
    jspb.BinaryWriter.prototype.writePackedFixed32=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeUint32(b[c]);}};jspb.BinaryWriter.prototype.writePackedFixed64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeUint64(b[c]);}};
    jspb.BinaryWriter.prototype.writePackedFixed64String=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++){var d=jspb.arith.UInt64.fromString(b[c]);this.encoder_.writeSplitFixed64(d.lo,d.hi);}}};
    jspb.BinaryWriter.prototype.writePackedSfixed32=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt32(b[c]);}};jspb.BinaryWriter.prototype.writePackedSfixed64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt64(b[c]);}};
    jspb.BinaryWriter.prototype.writePackedSfixed64String=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeInt64String(b[c]);}};jspb.BinaryWriter.prototype.writePackedFloat=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(4*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeFloat(b[c]);}};
    jspb.BinaryWriter.prototype.writePackedDouble=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeDouble(b[c]);}};jspb.BinaryWriter.prototype.writePackedBool=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(b.length);for(var c=0;c<b.length;c++)this.encoder_.writeBool(b[c]);}};
    jspb.BinaryWriter.prototype.writePackedEnum=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeEnum(b[d]);this.endDelimited_(c);}};jspb.BinaryWriter.prototype.writePackedFixedHash64=function(a,b){if(null!=b&&b.length){this.writeFieldHeader_(a,jspb.BinaryConstants.WireType.DELIMITED);this.encoder_.writeUnsignedVarint32(8*b.length);for(var c=0;c<b.length;c++)this.encoder_.writeFixedHash64(b[c]);}};
    jspb.BinaryWriter.prototype.writePackedVarintHash64=function(a,b){if(null!=b&&b.length){for(var c=this.beginDelimited_(a),d=0;d<b.length;d++)this.encoder_.writeVarintHash64(b[d]);this.endDelimited_(c);}};jspb.BinaryIterator=function(a,b,c){this.elements_=this.nextMethod_=this.decoder_=null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!0;this.init_(a,b,c);};jspb.BinaryIterator.prototype.init_=function(a,b,c){a&&b&&(this.decoder_=a,this.nextMethod_=b);this.elements_=c||null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!this.decoder_&&!this.elements_;this.next();};jspb.BinaryIterator.instanceCache_=[];
    jspb.BinaryIterator.alloc=function(a,b,c){if(jspb.BinaryIterator.instanceCache_.length){var d=jspb.BinaryIterator.instanceCache_.pop();d.init_(a,b,c);return d}return new jspb.BinaryIterator(a,b,c)};jspb.BinaryIterator.prototype.free=function(){this.clear();100>jspb.BinaryIterator.instanceCache_.length&&jspb.BinaryIterator.instanceCache_.push(this);};
    jspb.BinaryIterator.prototype.clear=function(){this.decoder_&&this.decoder_.free();this.elements_=this.nextMethod_=this.decoder_=null;this.cursor_=0;this.nextValue_=null;this.atEnd_=!0;};jspb.BinaryIterator.prototype.get=function(){return this.nextValue_};jspb.BinaryIterator.prototype.atEnd=function(){return this.atEnd_};
    jspb.BinaryIterator.prototype.next=function(){var a=this.nextValue_;this.decoder_?this.decoder_.atEnd()?(this.nextValue_=null,this.atEnd_=!0):this.nextValue_=this.nextMethod_.call(this.decoder_):this.elements_&&(this.cursor_==this.elements_.length?(this.nextValue_=null,this.atEnd_=!0):this.nextValue_=this.elements_[this.cursor_++]);return a};jspb.BinaryDecoder=function(a,b,c){this.bytes_=null;this.tempHigh_=this.tempLow_=this.cursor_=this.end_=this.start_=0;this.error_=!1;a&&this.setBlock(a,b,c);};
    jspb.BinaryDecoder.instanceCache_=[];jspb.BinaryDecoder.alloc=function(a,b,c){if(jspb.BinaryDecoder.instanceCache_.length){var d=jspb.BinaryDecoder.instanceCache_.pop();a&&d.setBlock(a,b,c);return d}return new jspb.BinaryDecoder(a,b,c)};jspb.BinaryDecoder.prototype.free=function(){this.clear();100>jspb.BinaryDecoder.instanceCache_.length&&jspb.BinaryDecoder.instanceCache_.push(this);};jspb.BinaryDecoder.prototype.clone=function(){return jspb.BinaryDecoder.alloc(this.bytes_,this.start_,this.end_-this.start_)};
    jspb.BinaryDecoder.prototype.clear=function(){this.bytes_=null;this.cursor_=this.end_=this.start_=0;this.error_=!1;};jspb.BinaryDecoder.prototype.getBuffer=function(){return this.bytes_};jspb.BinaryDecoder.prototype.setBlock=function(a,b,c){this.bytes_=jspb.utils.byteSourceToUint8Array(a);this.start_=goog.isDef(b)?b:0;this.end_=goog.isDef(c)?this.start_+c:this.bytes_.length;this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getEnd=function(){return this.end_};
    jspb.BinaryDecoder.prototype.setEnd=function(a){this.end_=a;};jspb.BinaryDecoder.prototype.reset=function(){this.cursor_=this.start_;};jspb.BinaryDecoder.prototype.getCursor=function(){return this.cursor_};jspb.BinaryDecoder.prototype.setCursor=function(a){this.cursor_=a;};jspb.BinaryDecoder.prototype.advance=function(a){this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);};jspb.BinaryDecoder.prototype.atEnd=function(){return this.cursor_==this.end_};
    jspb.BinaryDecoder.prototype.pastEnd=function(){return this.cursor_>this.end_};jspb.BinaryDecoder.prototype.getError=function(){return this.error_||0>this.cursor_||this.cursor_>this.end_};
    jspb.BinaryDecoder.prototype.readSplitVarint64_=function(){for(var a,b=0,c,d=0;4>d;d++)if(a=this.bytes_[this.cursor_++],b|=(a&127)<<7*d,128>a){this.tempLow_=b>>>0;this.tempHigh_=0;return}a=this.bytes_[this.cursor_++];b|=(a&127)<<28;c=0|(a&127)>>4;if(128>a)this.tempLow_=b>>>0,this.tempHigh_=c>>>0;else{for(d=0;5>d;d++)if(a=this.bytes_[this.cursor_++],c|=(a&127)<<7*d+3,128>a){this.tempLow_=b>>>0;this.tempHigh_=c>>>0;return}goog.asserts.fail("Failed to read varint, encoding is invalid.");this.error_=
    !0;}};jspb.BinaryDecoder.prototype.skipVarint=function(){for(;this.bytes_[this.cursor_]&128;)this.cursor_++;this.cursor_++;};jspb.BinaryDecoder.prototype.unskipVarint=function(a){for(;128<a;)this.cursor_--,a>>>=7;this.cursor_--;};
    jspb.BinaryDecoder.prototype.readUnsignedVarint32=function(){var a,b=this.bytes_;a=b[this.cursor_+0];var c=a&127;if(128>a)return this.cursor_+=1,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+1];c|=(a&127)<<7;if(128>a)return this.cursor_+=2,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+2];c|=(a&127)<<14;if(128>a)return this.cursor_+=3,goog.asserts.assert(this.cursor_<=this.end_),c;a=b[this.cursor_+3];c|=(a&127)<<21;if(128>a)return this.cursor_+=4,goog.asserts.assert(this.cursor_<=
    this.end_),c;a=b[this.cursor_+4];c|=(a&15)<<28;if(128>a)return this.cursor_+=5,goog.asserts.assert(this.cursor_<=this.end_),c>>>0;this.cursor_+=5;128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&128<=b[this.cursor_++]&&goog.asserts.assert(!1);goog.asserts.assert(this.cursor_<=this.end_);return c};jspb.BinaryDecoder.prototype.readSignedVarint32=jspb.BinaryDecoder.prototype.readUnsignedVarint32;jspb.BinaryDecoder.prototype.readUnsignedVarint32String=function(){return this.readUnsignedVarint32().toString()};
    jspb.BinaryDecoder.prototype.readSignedVarint32String=function(){return this.readSignedVarint32().toString()};jspb.BinaryDecoder.prototype.readZigzagVarint32=function(){var a=this.readUnsignedVarint32();return a>>>1^-(a&1)};jspb.BinaryDecoder.prototype.readUnsignedVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinUint64(this.tempLow_,this.tempHigh_)};
    jspb.BinaryDecoder.prototype.readUnsignedVarint64String=function(){this.readSplitVarint64_();return jspb.utils.joinUnsignedDecimalString(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readSignedVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinInt64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readSignedVarint64String=function(){this.readSplitVarint64_();return jspb.utils.joinSignedDecimalString(this.tempLow_,this.tempHigh_)};
    jspb.BinaryDecoder.prototype.readZigzagVarint64=function(){this.readSplitVarint64_();return jspb.utils.joinZigzag64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readZigzagVarint64String=function(){return this.readZigzagVarint64().toString()};jspb.BinaryDecoder.prototype.readUint8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a};
    jspb.BinaryDecoder.prototype.readUint16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8};jspb.BinaryDecoder.prototype.readUint32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8|c<<16|d<<24)>>>0};
    jspb.BinaryDecoder.prototype.readUint64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUint64(a,b)};jspb.BinaryDecoder.prototype.readUint64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinUnsignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readInt8=function(){var a=this.bytes_[this.cursor_+0];this.cursor_+=1;goog.asserts.assert(this.cursor_<=this.end_);return a<<24>>24};
    jspb.BinaryDecoder.prototype.readInt16=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1];this.cursor_+=2;goog.asserts.assert(this.cursor_<=this.end_);return (a<<0|b<<8)<<16>>16};jspb.BinaryDecoder.prototype.readInt32=function(){var a=this.bytes_[this.cursor_+0],b=this.bytes_[this.cursor_+1],c=this.bytes_[this.cursor_+2],d=this.bytes_[this.cursor_+3];this.cursor_+=4;goog.asserts.assert(this.cursor_<=this.end_);return a<<0|b<<8|c<<16|d<<24};
    jspb.BinaryDecoder.prototype.readInt64=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinInt64(a,b)};jspb.BinaryDecoder.prototype.readInt64String=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinSignedDecimalString(a,b)};jspb.BinaryDecoder.prototype.readFloat=function(){var a=this.readUint32();return jspb.utils.joinFloat32(a,0)};
    jspb.BinaryDecoder.prototype.readDouble=function(){var a=this.readUint32(),b=this.readUint32();return jspb.utils.joinFloat64(a,b)};jspb.BinaryDecoder.prototype.readBool=function(){return !!this.bytes_[this.cursor_++]};jspb.BinaryDecoder.prototype.readEnum=function(){return this.readSignedVarint32()};
    jspb.BinaryDecoder.prototype.readString=function(a){var b=this.bytes_,c=this.cursor_;a=c+a;for(var d=[],e="";c<a;){var f=b[c++];if(128>f)d.push(f);else if(192>f)continue;else if(224>f){var g=b[c++];d.push((f&31)<<6|g&63);}else if(240>f){var g=b[c++],h=b[c++];d.push((f&15)<<12|(g&63)<<6|h&63);}else if(248>f){var g=b[c++],h=b[c++],k=b[c++],f=(f&7)<<18|(g&63)<<12|(h&63)<<6|k&63,f=f-65536;d.push((f>>10&1023)+55296,(f&1023)+56320);}8192<=d.length&&(e+=String.fromCharCode.apply(null,d),d.length=0);}e+=goog.crypt.byteArrayToString(d);
    this.cursor_=c;return e};jspb.BinaryDecoder.prototype.readStringWithLength=function(){var a=this.readUnsignedVarint32();return this.readString(a)};jspb.BinaryDecoder.prototype.readBytes=function(a){if(0>a||this.cursor_+a>this.bytes_.length)return this.error_=!0,goog.asserts.fail("Invalid byte length!"),new Uint8Array(0);var b=this.bytes_.subarray(this.cursor_,this.cursor_+a);this.cursor_+=a;goog.asserts.assert(this.cursor_<=this.end_);return b};
    jspb.BinaryDecoder.prototype.readVarintHash64=function(){this.readSplitVarint64_();return jspb.utils.joinHash64(this.tempLow_,this.tempHigh_)};jspb.BinaryDecoder.prototype.readFixedHash64=function(){var a=this.bytes_,b=this.cursor_,c=a[b+0],d=a[b+1],e=a[b+2],f=a[b+3],g=a[b+4],h=a[b+5],k=a[b+6],a=a[b+7];this.cursor_+=8;return String.fromCharCode(c,d,e,f,g,h,k,a)};jspb.BinaryReader=function(a,b,c){this.decoder_=jspb.BinaryDecoder.alloc(a,b,c);this.fieldCursor_=this.decoder_.getCursor();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;};jspb.BinaryReader.instanceCache_=[];
    jspb.BinaryReader.alloc=function(a,b,c){if(jspb.BinaryReader.instanceCache_.length){var d=jspb.BinaryReader.instanceCache_.pop();a&&d.decoder_.setBlock(a,b,c);return d}return new jspb.BinaryReader(a,b,c)};jspb.BinaryReader.prototype.alloc=jspb.BinaryReader.alloc;
    jspb.BinaryReader.prototype.free=function(){this.decoder_.clear();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;this.error_=!1;this.readCallbacks_=null;100>jspb.BinaryReader.instanceCache_.length&&jspb.BinaryReader.instanceCache_.push(this);};jspb.BinaryReader.prototype.getFieldCursor=function(){return this.fieldCursor_};jspb.BinaryReader.prototype.getCursor=function(){return this.decoder_.getCursor()};
    jspb.BinaryReader.prototype.getBuffer=function(){return this.decoder_.getBuffer()};jspb.BinaryReader.prototype.getFieldNumber=function(){return this.nextField_};jspb.BinaryReader.prototype.getWireType=function(){return this.nextWireType_};jspb.BinaryReader.prototype.isEndGroup=function(){return this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP};jspb.BinaryReader.prototype.getError=function(){return this.error_||this.decoder_.getError()};
    jspb.BinaryReader.prototype.setBlock=function(a,b,c){this.decoder_.setBlock(a,b,c);this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.reset=function(){this.decoder_.reset();this.nextField_=jspb.BinaryConstants.INVALID_FIELD_NUMBER;this.nextWireType_=jspb.BinaryConstants.WireType.INVALID;};jspb.BinaryReader.prototype.advance=function(a){this.decoder_.advance(a);};
    jspb.BinaryReader.prototype.nextField=function(){if(this.decoder_.atEnd())return !1;if(this.getError())return goog.asserts.fail("Decoder hit an error"),!1;this.fieldCursor_=this.decoder_.getCursor();var a=this.decoder_.readUnsignedVarint32(),b=a>>>3,a=a&7;if(a!=jspb.BinaryConstants.WireType.VARINT&&a!=jspb.BinaryConstants.WireType.FIXED32&&a!=jspb.BinaryConstants.WireType.FIXED64&&a!=jspb.BinaryConstants.WireType.DELIMITED&&a!=jspb.BinaryConstants.WireType.START_GROUP&&a!=jspb.BinaryConstants.WireType.END_GROUP)return goog.asserts.fail("Invalid wire type"),
    this.error_=!0,!1;this.nextField_=b;this.nextWireType_=a;return !0};jspb.BinaryReader.prototype.unskipHeader=function(){this.decoder_.unskipVarint(this.nextField_<<3|this.nextWireType_);};jspb.BinaryReader.prototype.skipMatchingFields=function(){var a=this.nextField_;for(this.unskipHeader();this.nextField()&&this.getFieldNumber()==a;)this.skipField();this.decoder_.atEnd()||this.unskipHeader();};
    jspb.BinaryReader.prototype.skipVarintField=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.VARINT?(goog.asserts.fail("Invalid wire type for skipVarintField"),this.skipField()):this.decoder_.skipVarint();};jspb.BinaryReader.prototype.skipDelimitedField=function(){if(this.nextWireType_!=jspb.BinaryConstants.WireType.DELIMITED)goog.asserts.fail("Invalid wire type for skipDelimitedField"),this.skipField();else{var a=this.decoder_.readUnsignedVarint32();this.decoder_.advance(a);}};
    jspb.BinaryReader.prototype.skipFixed32Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED32?(goog.asserts.fail("Invalid wire type for skipFixed32Field"),this.skipField()):this.decoder_.advance(4);};jspb.BinaryReader.prototype.skipFixed64Field=function(){this.nextWireType_!=jspb.BinaryConstants.WireType.FIXED64?(goog.asserts.fail("Invalid wire type for skipFixed64Field"),this.skipField()):this.decoder_.advance(8);};
    jspb.BinaryReader.prototype.skipGroup=function(){var a=[this.nextField_];do{if(!this.nextField()){goog.asserts.fail("Unmatched start-group tag: stream EOF");this.error_=!0;break}if(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP)a.push(this.nextField_);else if(this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP&&this.nextField_!=a.pop()){goog.asserts.fail("Unmatched end-group tag");this.error_=!0;break}}while(0<a.length)};
    jspb.BinaryReader.prototype.skipField=function(){switch(this.nextWireType_){case jspb.BinaryConstants.WireType.VARINT:this.skipVarintField();break;case jspb.BinaryConstants.WireType.FIXED64:this.skipFixed64Field();break;case jspb.BinaryConstants.WireType.DELIMITED:this.skipDelimitedField();break;case jspb.BinaryConstants.WireType.FIXED32:this.skipFixed32Field();break;case jspb.BinaryConstants.WireType.START_GROUP:this.skipGroup();break;default:goog.asserts.fail("Invalid wire encoding for field.");}};
    jspb.BinaryReader.prototype.registerReadCallback=function(a,b){goog.isNull(this.readCallbacks_)&&(this.readCallbacks_={});goog.asserts.assert(!this.readCallbacks_[a]);this.readCallbacks_[a]=b;};jspb.BinaryReader.prototype.runReadCallback=function(a){goog.asserts.assert(!goog.isNull(this.readCallbacks_));a=this.readCallbacks_[a];goog.asserts.assert(a);return a(this)};
    jspb.BinaryReader.prototype.readAny=function(a){this.nextWireType_=jspb.BinaryConstants.FieldTypeToWireType(a);var b=jspb.BinaryConstants.FieldType;switch(a){case b.DOUBLE:return this.readDouble();case b.FLOAT:return this.readFloat();case b.INT64:return this.readInt64();case b.UINT64:return this.readUint64();case b.INT32:return this.readInt32();case b.FIXED64:return this.readFixed64();case b.FIXED32:return this.readFixed32();case b.BOOL:return this.readBool();case b.STRING:return this.readString();
    case b.GROUP:goog.asserts.fail("Group field type not supported in readAny()");case b.MESSAGE:goog.asserts.fail("Message field type not supported in readAny()");case b.BYTES:return this.readBytes();case b.UINT32:return this.readUint32();case b.ENUM:return this.readEnum();case b.SFIXED32:return this.readSfixed32();case b.SFIXED64:return this.readSfixed64();case b.SINT32:return this.readSint32();case b.SINT64:return this.readSint64();case b.FHASH64:return this.readFixedHash64();case b.VHASH64:return this.readVarintHash64();
    default:goog.asserts.fail("Invalid field type in readAny()");}return 0};jspb.BinaryReader.prototype.readMessage=function(a,b){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var c=this.decoder_.getEnd(),d=this.decoder_.readUnsignedVarint32(),d=this.decoder_.getCursor()+d;this.decoder_.setEnd(d);b(a,this);this.decoder_.setCursor(d);this.decoder_.setEnd(c);};
    jspb.BinaryReader.prototype.readGroup=function(a,b,c){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.START_GROUP);goog.asserts.assert(this.nextField_==a);c(b,this);this.error_||this.nextWireType_==jspb.BinaryConstants.WireType.END_GROUP||(goog.asserts.fail("Group submessage did not end with an END_GROUP tag"),this.error_=!0);};
    jspb.BinaryReader.prototype.getFieldDecoder=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor(),c=b+a,a=jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(),b,a);this.decoder_.setCursor(c);return a};jspb.BinaryReader.prototype.readInt32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32()};
    jspb.BinaryReader.prototype.readInt32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint32String()};jspb.BinaryReader.prototype.readInt64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};jspb.BinaryReader.prototype.readInt64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64String()};
    jspb.BinaryReader.prototype.readUint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readUint32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint32String()};jspb.BinaryReader.prototype.readUint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64()};
    jspb.BinaryReader.prototype.readUint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readUnsignedVarint64String()};jspb.BinaryReader.prototype.readSint32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint32()};jspb.BinaryReader.prototype.readSint64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64()};
    jspb.BinaryReader.prototype.readSint64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readZigzagVarint64String()};jspb.BinaryReader.prototype.readFixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readUint32()};jspb.BinaryReader.prototype.readFixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64()};
    jspb.BinaryReader.prototype.readFixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readUint64String()};jspb.BinaryReader.prototype.readSfixed32=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32()};jspb.BinaryReader.prototype.readSfixed32String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readInt32().toString()};
    jspb.BinaryReader.prototype.readSfixed64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64()};jspb.BinaryReader.prototype.readSfixed64String=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readInt64String()};jspb.BinaryReader.prototype.readFloat=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED32);return this.decoder_.readFloat()};
    jspb.BinaryReader.prototype.readDouble=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readDouble()};jspb.BinaryReader.prototype.readBool=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return !!this.decoder_.readUnsignedVarint32()};jspb.BinaryReader.prototype.readEnum=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readSignedVarint64()};
    jspb.BinaryReader.prototype.readString=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readString(a)};jspb.BinaryReader.prototype.readBytes=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);var a=this.decoder_.readUnsignedVarint32();return this.decoder_.readBytes(a)};
    jspb.BinaryReader.prototype.readVarintHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.VARINT);return this.decoder_.readVarintHash64()};jspb.BinaryReader.prototype.readFixedHash64=function(){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.FIXED64);return this.decoder_.readFixedHash64()};
    jspb.BinaryReader.prototype.readPackedField_=function(a){goog.asserts.assert(this.nextWireType_==jspb.BinaryConstants.WireType.DELIMITED);for(var b=this.decoder_.readUnsignedVarint32(),b=this.decoder_.getCursor()+b,c=[];this.decoder_.getCursor()<b;)c.push(a.call(this.decoder_));return c};jspb.BinaryReader.prototype.readPackedInt32=function(){return this.readPackedField_(this.decoder_.readSignedVarint32)};jspb.BinaryReader.prototype.readPackedInt32String=function(){return this.readPackedField_(this.decoder_.readSignedVarint32String)};
    jspb.BinaryReader.prototype.readPackedInt64=function(){return this.readPackedField_(this.decoder_.readSignedVarint64)};jspb.BinaryReader.prototype.readPackedInt64String=function(){return this.readPackedField_(this.decoder_.readSignedVarint64String)};jspb.BinaryReader.prototype.readPackedUint32=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32)};jspb.BinaryReader.prototype.readPackedUint32String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint32String)};
    jspb.BinaryReader.prototype.readPackedUint64=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64)};jspb.BinaryReader.prototype.readPackedUint64String=function(){return this.readPackedField_(this.decoder_.readUnsignedVarint64String)};jspb.BinaryReader.prototype.readPackedSint32=function(){return this.readPackedField_(this.decoder_.readZigzagVarint32)};jspb.BinaryReader.prototype.readPackedSint64=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64)};
    jspb.BinaryReader.prototype.readPackedSint64String=function(){return this.readPackedField_(this.decoder_.readZigzagVarint64String)};jspb.BinaryReader.prototype.readPackedFixed32=function(){return this.readPackedField_(this.decoder_.readUint32)};jspb.BinaryReader.prototype.readPackedFixed64=function(){return this.readPackedField_(this.decoder_.readUint64)};jspb.BinaryReader.prototype.readPackedFixed64String=function(){return this.readPackedField_(this.decoder_.readUint64String)};
    jspb.BinaryReader.prototype.readPackedSfixed32=function(){return this.readPackedField_(this.decoder_.readInt32)};jspb.BinaryReader.prototype.readPackedSfixed64=function(){return this.readPackedField_(this.decoder_.readInt64)};jspb.BinaryReader.prototype.readPackedSfixed64String=function(){return this.readPackedField_(this.decoder_.readInt64String)};jspb.BinaryReader.prototype.readPackedFloat=function(){return this.readPackedField_(this.decoder_.readFloat)};
    jspb.BinaryReader.prototype.readPackedDouble=function(){return this.readPackedField_(this.decoder_.readDouble)};jspb.BinaryReader.prototype.readPackedBool=function(){return this.readPackedField_(this.decoder_.readBool)};jspb.BinaryReader.prototype.readPackedEnum=function(){return this.readPackedField_(this.decoder_.readEnum)};jspb.BinaryReader.prototype.readPackedVarintHash64=function(){return this.readPackedField_(this.decoder_.readVarintHash64)};
    jspb.BinaryReader.prototype.readPackedFixedHash64=function(){return this.readPackedField_(this.decoder_.readFixedHash64)};jspb.Export={};var Map$1=jspb.Map;var Message=jspb.Message;var BinaryReader=jspb.BinaryReader;var BinaryWriter=jspb.BinaryWriter;var ExtensionFieldInfo=jspb.ExtensionFieldInfo;var ExtensionFieldBinaryInfo=jspb.ExtensionFieldBinaryInfo;var exportSymbol=goog.exportSymbol;var inherits=goog.inherits;var object={extend:goog.object.extend};var typeOf=goog.typeOf;

    var googleProtobuf = {
    	Map: Map$1,
    	Message: Message,
    	BinaryReader: BinaryReader,
    	BinaryWriter: BinaryWriter,
    	ExtensionFieldInfo: ExtensionFieldInfo,
    	ExtensionFieldBinaryInfo: ExtensionFieldBinaryInfo,
    	exportSymbol: exportSymbol,
    	inherits: inherits,
    	object: object,
    	typeOf: typeOf
    };

    var descriptor_pb = createCommonjsModule(function (module, exports) {
    /**
     * @fileoverview
     * @enhanceable
     * @suppress {messageConventions} JS Compiler reports an error if a variable or
     *     field starts with 'MSG_' and isn't a translatable message.
     * @public
     */
    // GENERATED CODE -- DO NOT EDIT!


    var goog = googleProtobuf;
    var global = Function('return this')();

    goog.exportSymbol('proto.google.protobuf.DescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.DescriptorProto.ExtensionRange', null, global);
    goog.exportSymbol('proto.google.protobuf.DescriptorProto.ReservedRange', null, global);
    goog.exportSymbol('proto.google.protobuf.EnumDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.EnumDescriptorProto.EnumReservedRange', null, global);
    goog.exportSymbol('proto.google.protobuf.EnumOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.EnumValueDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.EnumValueOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.ExtensionRangeOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldDescriptorProto.Label', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldDescriptorProto.Type', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldOptions.CType', null, global);
    goog.exportSymbol('proto.google.protobuf.FieldOptions.JSType', null, global);
    goog.exportSymbol('proto.google.protobuf.FileDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.FileDescriptorSet', null, global);
    goog.exportSymbol('proto.google.protobuf.FileOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.FileOptions.OptimizeMode', null, global);
    goog.exportSymbol('proto.google.protobuf.GeneratedCodeInfo', null, global);
    goog.exportSymbol('proto.google.protobuf.GeneratedCodeInfo.Annotation', null, global);
    goog.exportSymbol('proto.google.protobuf.MessageOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.MethodDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.MethodOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.MethodOptions.IdempotencyLevel', null, global);
    goog.exportSymbol('proto.google.protobuf.OneofDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.OneofOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.ServiceDescriptorProto', null, global);
    goog.exportSymbol('proto.google.protobuf.ServiceOptions', null, global);
    goog.exportSymbol('proto.google.protobuf.SourceCodeInfo', null, global);
    goog.exportSymbol('proto.google.protobuf.SourceCodeInfo.Location', null, global);
    goog.exportSymbol('proto.google.protobuf.UninterpretedOption', null, global);
    goog.exportSymbol('proto.google.protobuf.UninterpretedOption.NamePart', null, global);

    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.FileDescriptorSet = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.FileDescriptorSet.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.FileDescriptorSet, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.FileDescriptorSet.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.FileDescriptorSet.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.FileDescriptorSet.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.FileDescriptorSet} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileDescriptorSet.toObject = function(includeInstance, msg) {
      var obj = {
        fileList: googleProtobuf.Message.toObjectList(msg.getFileList(),
        proto.google.protobuf.FileDescriptorProto.toObject, includeInstance)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.FileDescriptorSet}
     */
    proto.google.protobuf.FileDescriptorSet.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.FileDescriptorSet;
      return proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.FileDescriptorSet} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.FileDescriptorSet}
     */
    proto.google.protobuf.FileDescriptorSet.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.google.protobuf.FileDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader);
          msg.addFile(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.FileDescriptorSet.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.FileDescriptorSet} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileDescriptorSet.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getFileList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter
        );
      }
    };


    /**
     * repeated FileDescriptorProto file = 1;
     * @return {!Array<!proto.google.protobuf.FileDescriptorProto>}
     */
    proto.google.protobuf.FileDescriptorSet.prototype.getFileList = function() {
      return /** @type{!Array<!proto.google.protobuf.FileDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.FileDescriptorProto, 1));
    };


    /** @param {!Array<!proto.google.protobuf.FileDescriptorProto>} value */
    proto.google.protobuf.FileDescriptorSet.prototype.setFileList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.google.protobuf.FileDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.FileDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorSet.prototype.addFile = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.google.protobuf.FileDescriptorProto, opt_index);
    };


    proto.google.protobuf.FileDescriptorSet.prototype.clearFileList = function() {
      this.setFileList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.FileDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.FileDescriptorProto.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.FileDescriptorProto, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.FileDescriptorProto.repeatedFields_ = [3,10,11,4,5,6,7];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.FileDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.FileDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        pb_package: googleProtobuf.Message.getField(msg, 2),
        dependencyList: googleProtobuf.Message.getRepeatedField(msg, 3),
        publicDependencyList: googleProtobuf.Message.getRepeatedField(msg, 10),
        weakDependencyList: googleProtobuf.Message.getRepeatedField(msg, 11),
        messageTypeList: googleProtobuf.Message.toObjectList(msg.getMessageTypeList(),
        proto.google.protobuf.DescriptorProto.toObject, includeInstance),
        enumTypeList: googleProtobuf.Message.toObjectList(msg.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject, includeInstance),
        serviceList: googleProtobuf.Message.toObjectList(msg.getServiceList(),
        proto.google.protobuf.ServiceDescriptorProto.toObject, includeInstance),
        extensionList: googleProtobuf.Message.toObjectList(msg.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject, includeInstance),
        options: (f = msg.getOptions()) && proto.google.protobuf.FileOptions.toObject(includeInstance, f),
        sourceCodeInfo: (f = msg.getSourceCodeInfo()) && proto.google.protobuf.SourceCodeInfo.toObject(includeInstance, f),
        syntax: googleProtobuf.Message.getField(msg, 12)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.FileDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.FileDescriptorProto;
      return proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.FileDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.FileDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setPackage(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.addDependency(value);
          break;
        case 10:
          var value = /** @type {number} */ (reader.readInt32());
          msg.addPublicDependency(value);
          break;
        case 11:
          var value = /** @type {number} */ (reader.readInt32());
          msg.addWeakDependency(value);
          break;
        case 4:
          var value = new proto.google.protobuf.DescriptorProto;
          reader.readMessage(value,proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader);
          msg.addMessageType(value);
          break;
        case 5:
          var value = new proto.google.protobuf.EnumDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader);
          msg.addEnumType(value);
          break;
        case 6:
          var value = new proto.google.protobuf.ServiceDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader);
          msg.addService(value);
          break;
        case 7:
          var value = new proto.google.protobuf.FieldDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader);
          msg.addExtension$(value);
          break;
        case 8:
          var value = new proto.google.protobuf.FileOptions;
          reader.readMessage(value,proto.google.protobuf.FileOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        case 9:
          var value = new proto.google.protobuf.SourceCodeInfo;
          reader.readMessage(value,proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader);
          msg.setSourceCodeInfo(value);
          break;
        case 12:
          var value = /** @type {string} */ (reader.readString());
          msg.setSyntax(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.FileDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = message.getDependencyList();
      if (f.length > 0) {
        writer.writeRepeatedString(
          3,
          f
        );
      }
      f = message.getPublicDependencyList();
      if (f.length > 0) {
        writer.writeRepeatedInt32(
          10,
          f
        );
      }
      f = message.getWeakDependencyList();
      if (f.length > 0) {
        writer.writeRepeatedInt32(
          11,
          f
        );
      }
      f = message.getMessageTypeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          4,
          f,
          proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getEnumTypeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f,
          proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getServiceList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          6,
          f,
          proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getExtensionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          7,
          f,
          proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          8,
          f,
          proto.google.protobuf.FileOptions.serializeBinaryToWriter
        );
      }
      f = message.getSourceCodeInfo();
      if (f != null) {
        writer.writeMessage(
          9,
          f,
          proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 12));
      if (f != null) {
        writer.writeString(
          12,
          f
        );
      }
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string package = 2;
     * @return {string}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getPackage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setPackage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearPackage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.hasPackage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * repeated string dependency = 3;
     * @return {!Array<string>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getDependencyList = function() {
      return /** @type {!Array<string>} */ (googleProtobuf.Message.getRepeatedField(this, 3));
    };


    /** @param {!Array<string>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setDependencyList = function(value) {
      googleProtobuf.Message.setField(this, 3, value || []);
    };


    /**
     * @param {!string} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addDependency = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 3, value, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearDependencyList = function() {
      this.setDependencyList([]);
    };


    /**
     * repeated int32 public_dependency = 10;
     * @return {!Array<number>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getPublicDependencyList = function() {
      return /** @type {!Array<number>} */ (googleProtobuf.Message.getRepeatedField(this, 10));
    };


    /** @param {!Array<number>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setPublicDependencyList = function(value) {
      googleProtobuf.Message.setField(this, 10, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addPublicDependency = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 10, value, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearPublicDependencyList = function() {
      this.setPublicDependencyList([]);
    };


    /**
     * repeated int32 weak_dependency = 11;
     * @return {!Array<number>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getWeakDependencyList = function() {
      return /** @type {!Array<number>} */ (googleProtobuf.Message.getRepeatedField(this, 11));
    };


    /** @param {!Array<number>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setWeakDependencyList = function(value) {
      googleProtobuf.Message.setField(this, 11, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addWeakDependency = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 11, value, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearWeakDependencyList = function() {
      this.setWeakDependencyList([]);
    };


    /**
     * repeated DescriptorProto message_type = 4;
     * @return {!Array<!proto.google.protobuf.DescriptorProto>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getMessageTypeList = function() {
      return /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 4));
    };


    /** @param {!Array<!proto.google.protobuf.DescriptorProto>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setMessageTypeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
    };


    /**
     * @param {!proto.google.protobuf.DescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.DescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addMessageType = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.google.protobuf.DescriptorProto, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearMessageTypeList = function() {
      this.setMessageTypeList([]);
    };


    /**
     * repeated EnumDescriptorProto enum_type = 5;
     * @return {!Array<!proto.google.protobuf.EnumDescriptorProto>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getEnumTypeList = function() {
      return /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 5));
    };


    /** @param {!Array<!proto.google.protobuf.EnumDescriptorProto>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setEnumTypeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 5, value);
    };


    /**
     * @param {!proto.google.protobuf.EnumDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.EnumDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addEnumType = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.google.protobuf.EnumDescriptorProto, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearEnumTypeList = function() {
      this.setEnumTypeList([]);
    };


    /**
     * repeated ServiceDescriptorProto service = 6;
     * @return {!Array<!proto.google.protobuf.ServiceDescriptorProto>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getServiceList = function() {
      return /** @type{!Array<!proto.google.protobuf.ServiceDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.ServiceDescriptorProto, 6));
    };


    /** @param {!Array<!proto.google.protobuf.ServiceDescriptorProto>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setServiceList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 6, value);
    };


    /**
     * @param {!proto.google.protobuf.ServiceDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.ServiceDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addService = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.google.protobuf.ServiceDescriptorProto, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearServiceList = function() {
      this.setServiceList([]);
    };


    /**
     * repeated FieldDescriptorProto extension = 7;
     * @return {!Array<!proto.google.protobuf.FieldDescriptorProto>}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getExtensionList = function() {
      return /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 7));
    };


    /** @param {!Array<!proto.google.protobuf.FieldDescriptorProto>} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setExtensionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 7, value);
    };


    /**
     * @param {!proto.google.protobuf.FieldDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.FieldDescriptorProto}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.addExtension$ = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 7, opt_value, proto.google.protobuf.FieldDescriptorProto, opt_index);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearExtensionList = function() {
      this.setExtensionList([]);
    };


    /**
     * optional FileOptions options = 8;
     * @return {?proto.google.protobuf.FileOptions}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.FileOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.FileOptions, 8));
    };


    /** @param {?proto.google.protobuf.FileOptions|undefined} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 8, value);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional SourceCodeInfo source_code_info = 9;
     * @return {?proto.google.protobuf.SourceCodeInfo}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getSourceCodeInfo = function() {
      return /** @type{?proto.google.protobuf.SourceCodeInfo} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.SourceCodeInfo, 9));
    };


    /** @param {?proto.google.protobuf.SourceCodeInfo|undefined} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setSourceCodeInfo = function(value) {
      googleProtobuf.Message.setWrapperField(this, 9, value);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearSourceCodeInfo = function() {
      this.setSourceCodeInfo(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.hasSourceCodeInfo = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional string syntax = 12;
     * @return {string}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.getSyntax = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 12, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileDescriptorProto.prototype.setSyntax = function(value) {
      googleProtobuf.Message.setField(this, 12, value);
    };


    proto.google.protobuf.FileDescriptorProto.prototype.clearSyntax = function() {
      googleProtobuf.Message.setField(this, 12, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileDescriptorProto.prototype.hasSyntax = function() {
      return googleProtobuf.Message.getField(this, 12) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.DescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.DescriptorProto.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.DescriptorProto, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.DescriptorProto.repeatedFields_ = [2,6,3,4,5,8,9,10];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.DescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.DescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.DescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        fieldList: googleProtobuf.Message.toObjectList(msg.getFieldList(),
        proto.google.protobuf.FieldDescriptorProto.toObject, includeInstance),
        extensionList: googleProtobuf.Message.toObjectList(msg.getExtensionList(),
        proto.google.protobuf.FieldDescriptorProto.toObject, includeInstance),
        nestedTypeList: googleProtobuf.Message.toObjectList(msg.getNestedTypeList(),
        proto.google.protobuf.DescriptorProto.toObject, includeInstance),
        enumTypeList: googleProtobuf.Message.toObjectList(msg.getEnumTypeList(),
        proto.google.protobuf.EnumDescriptorProto.toObject, includeInstance),
        extensionRangeList: googleProtobuf.Message.toObjectList(msg.getExtensionRangeList(),
        proto.google.protobuf.DescriptorProto.ExtensionRange.toObject, includeInstance),
        oneofDeclList: googleProtobuf.Message.toObjectList(msg.getOneofDeclList(),
        proto.google.protobuf.OneofDescriptorProto.toObject, includeInstance),
        options: (f = msg.getOptions()) && proto.google.protobuf.MessageOptions.toObject(includeInstance, f),
        reservedRangeList: googleProtobuf.Message.toObjectList(msg.getReservedRangeList(),
        proto.google.protobuf.DescriptorProto.ReservedRange.toObject, includeInstance),
        reservedNameList: googleProtobuf.Message.getRepeatedField(msg, 10)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.DescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.DescriptorProto;
      return proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.DescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.DescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = new proto.google.protobuf.FieldDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader);
          msg.addField(value);
          break;
        case 6:
          var value = new proto.google.protobuf.FieldDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader);
          msg.addExtension$(value);
          break;
        case 3:
          var value = new proto.google.protobuf.DescriptorProto;
          reader.readMessage(value,proto.google.protobuf.DescriptorProto.deserializeBinaryFromReader);
          msg.addNestedType(value);
          break;
        case 4:
          var value = new proto.google.protobuf.EnumDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader);
          msg.addEnumType(value);
          break;
        case 5:
          var value = new proto.google.protobuf.DescriptorProto.ExtensionRange;
          reader.readMessage(value,proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader);
          msg.addExtensionRange(value);
          break;
        case 8:
          var value = new proto.google.protobuf.OneofDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader);
          msg.addOneofDecl(value);
          break;
        case 7:
          var value = new proto.google.protobuf.MessageOptions;
          reader.readMessage(value,proto.google.protobuf.MessageOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        case 9:
          var value = new proto.google.protobuf.DescriptorProto.ReservedRange;
          reader.readMessage(value,proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader);
          msg.addReservedRange(value);
          break;
        case 10:
          var value = /** @type {string} */ (reader.readString());
          msg.addReservedName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.DescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.DescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.DescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getFieldList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f,
          proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getExtensionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          6,
          f,
          proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getNestedTypeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          3,
          f,
          proto.google.protobuf.DescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getEnumTypeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          4,
          f,
          proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getExtensionRangeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f,
          proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter
        );
      }
      f = message.getOneofDeclList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          8,
          f,
          proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          7,
          f,
          proto.google.protobuf.MessageOptions.serializeBinaryToWriter
        );
      }
      f = message.getReservedRangeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          9,
          f,
          proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter
        );
      }
      f = message.getReservedNameList();
      if (f.length > 0) {
        writer.writeRepeatedString(
          10,
          f
        );
      }
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.DescriptorProto.ExtensionRange, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.DescriptorProto.ExtensionRange.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.DescriptorProto.ExtensionRange} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.toObject = function(includeInstance, msg) {
      var f, obj = {
        start: googleProtobuf.Message.getField(msg, 1),
        end: googleProtobuf.Message.getField(msg, 2),
        options: (f = msg.getOptions()) && proto.google.protobuf.ExtensionRangeOptions.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.DescriptorProto.ExtensionRange}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.DescriptorProto.ExtensionRange;
      return proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.DescriptorProto.ExtensionRange} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.DescriptorProto.ExtensionRange}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setStart(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setEnd(value);
          break;
        case 3:
          var value = new proto.google.protobuf.ExtensionRangeOptions;
          reader.readMessage(value,proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.DescriptorProto.ExtensionRange} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeInt32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeInt32(
          2,
          f
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional int32 start = 1;
     * @return {number}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getStart = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setStart = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearStart = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasStart = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional int32 end = 2;
     * @return {number}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getEnd = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setEnd = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearEnd = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasEnd = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional ExtensionRangeOptions options = 3;
     * @return {?proto.google.protobuf.ExtensionRangeOptions}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.ExtensionRangeOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.ExtensionRangeOptions, 3));
    };


    /** @param {?proto.google.protobuf.ExtensionRangeOptions|undefined} value */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.ExtensionRange.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.DescriptorProto.ReservedRange = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.DescriptorProto.ReservedRange, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.DescriptorProto.ReservedRange.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.DescriptorProto.ReservedRange} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.toObject = function(includeInstance, msg) {
      var obj = {
        start: googleProtobuf.Message.getField(msg, 1),
        end: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.DescriptorProto.ReservedRange}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.DescriptorProto.ReservedRange;
      return proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.DescriptorProto.ReservedRange} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.DescriptorProto.ReservedRange}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setStart(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setEnd(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.DescriptorProto.ReservedRange} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeInt32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeInt32(
          2,
          f
        );
      }
    };


    /**
     * optional int32 start = 1;
     * @return {number}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getStart = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setStart = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearStart = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasStart = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional int32 end = 2;
     * @return {number}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.getEnd = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.setEnd = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.clearEnd = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.ReservedRange.prototype.hasEnd = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.DescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.DescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated FieldDescriptorProto field = 2;
     * @return {!Array<!proto.google.protobuf.FieldDescriptorProto>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getFieldList = function() {
      return /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 2));
    };


    /** @param {!Array<!proto.google.protobuf.FieldDescriptorProto>} value */
    proto.google.protobuf.DescriptorProto.prototype.setFieldList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
    };


    /**
     * @param {!proto.google.protobuf.FieldDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.FieldDescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.prototype.addField = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.google.protobuf.FieldDescriptorProto, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearFieldList = function() {
      this.setFieldList([]);
    };


    /**
     * repeated FieldDescriptorProto extension = 6;
     * @return {!Array<!proto.google.protobuf.FieldDescriptorProto>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getExtensionList = function() {
      return /** @type{!Array<!proto.google.protobuf.FieldDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.FieldDescriptorProto, 6));
    };


    /** @param {!Array<!proto.google.protobuf.FieldDescriptorProto>} value */
    proto.google.protobuf.DescriptorProto.prototype.setExtensionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 6, value);
    };


    /**
     * @param {!proto.google.protobuf.FieldDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.FieldDescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.prototype.addExtension$ = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.google.protobuf.FieldDescriptorProto, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearExtensionList = function() {
      this.setExtensionList([]);
    };


    /**
     * repeated DescriptorProto nested_type = 3;
     * @return {!Array<!proto.google.protobuf.DescriptorProto>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getNestedTypeList = function() {
      return /** @type{!Array<!proto.google.protobuf.DescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto, 3));
    };


    /** @param {!Array<!proto.google.protobuf.DescriptorProto>} value */
    proto.google.protobuf.DescriptorProto.prototype.setNestedTypeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 3, value);
    };


    /**
     * @param {!proto.google.protobuf.DescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.DescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.prototype.addNestedType = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.google.protobuf.DescriptorProto, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearNestedTypeList = function() {
      this.setNestedTypeList([]);
    };


    /**
     * repeated EnumDescriptorProto enum_type = 4;
     * @return {!Array<!proto.google.protobuf.EnumDescriptorProto>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getEnumTypeList = function() {
      return /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto, 4));
    };


    /** @param {!Array<!proto.google.protobuf.EnumDescriptorProto>} value */
    proto.google.protobuf.DescriptorProto.prototype.setEnumTypeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
    };


    /**
     * @param {!proto.google.protobuf.EnumDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.EnumDescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.prototype.addEnumType = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.google.protobuf.EnumDescriptorProto, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearEnumTypeList = function() {
      this.setEnumTypeList([]);
    };


    /**
     * repeated ExtensionRange extension_range = 5;
     * @return {!Array<!proto.google.protobuf.DescriptorProto.ExtensionRange>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getExtensionRangeList = function() {
      return /** @type{!Array<!proto.google.protobuf.DescriptorProto.ExtensionRange>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ExtensionRange, 5));
    };


    /** @param {!Array<!proto.google.protobuf.DescriptorProto.ExtensionRange>} value */
    proto.google.protobuf.DescriptorProto.prototype.setExtensionRangeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 5, value);
    };


    /**
     * @param {!proto.google.protobuf.DescriptorProto.ExtensionRange=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.DescriptorProto.ExtensionRange}
     */
    proto.google.protobuf.DescriptorProto.prototype.addExtensionRange = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.google.protobuf.DescriptorProto.ExtensionRange, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearExtensionRangeList = function() {
      this.setExtensionRangeList([]);
    };


    /**
     * repeated OneofDescriptorProto oneof_decl = 8;
     * @return {!Array<!proto.google.protobuf.OneofDescriptorProto>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getOneofDeclList = function() {
      return /** @type{!Array<!proto.google.protobuf.OneofDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.OneofDescriptorProto, 8));
    };


    /** @param {!Array<!proto.google.protobuf.OneofDescriptorProto>} value */
    proto.google.protobuf.DescriptorProto.prototype.setOneofDeclList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 8, value);
    };


    /**
     * @param {!proto.google.protobuf.OneofDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.OneofDescriptorProto}
     */
    proto.google.protobuf.DescriptorProto.prototype.addOneofDecl = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 8, opt_value, proto.google.protobuf.OneofDescriptorProto, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearOneofDeclList = function() {
      this.setOneofDeclList([]);
    };


    /**
     * optional MessageOptions options = 7;
     * @return {?proto.google.protobuf.MessageOptions}
     */
    proto.google.protobuf.DescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.MessageOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.MessageOptions, 7));
    };


    /** @param {?proto.google.protobuf.MessageOptions|undefined} value */
    proto.google.protobuf.DescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 7, value);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.DescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * repeated ReservedRange reserved_range = 9;
     * @return {!Array<!proto.google.protobuf.DescriptorProto.ReservedRange>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getReservedRangeList = function() {
      return /** @type{!Array<!proto.google.protobuf.DescriptorProto.ReservedRange>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.DescriptorProto.ReservedRange, 9));
    };


    /** @param {!Array<!proto.google.protobuf.DescriptorProto.ReservedRange>} value */
    proto.google.protobuf.DescriptorProto.prototype.setReservedRangeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 9, value);
    };


    /**
     * @param {!proto.google.protobuf.DescriptorProto.ReservedRange=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.DescriptorProto.ReservedRange}
     */
    proto.google.protobuf.DescriptorProto.prototype.addReservedRange = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 9, opt_value, proto.google.protobuf.DescriptorProto.ReservedRange, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearReservedRangeList = function() {
      this.setReservedRangeList([]);
    };


    /**
     * repeated string reserved_name = 10;
     * @return {!Array<string>}
     */
    proto.google.protobuf.DescriptorProto.prototype.getReservedNameList = function() {
      return /** @type {!Array<string>} */ (googleProtobuf.Message.getRepeatedField(this, 10));
    };


    /** @param {!Array<string>} value */
    proto.google.protobuf.DescriptorProto.prototype.setReservedNameList = function(value) {
      googleProtobuf.Message.setField(this, 10, value || []);
    };


    /**
     * @param {!string} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.DescriptorProto.prototype.addReservedName = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 10, value, opt_index);
    };


    proto.google.protobuf.DescriptorProto.prototype.clearReservedNameList = function() {
      this.setReservedNameList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.ExtensionRangeOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.ExtensionRangeOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.ExtensionRangeOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.ExtensionRangeOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.ExtensionRangeOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.ExtensionRangeOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.ExtensionRangeOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ExtensionRangeOptions.toObject = function(includeInstance, msg) {
      var obj = {
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.ExtensionRangeOptions.extensions, proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.ExtensionRangeOptions}
     */
    proto.google.protobuf.ExtensionRangeOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.ExtensionRangeOptions;
      return proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.ExtensionRangeOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.ExtensionRangeOptions}
     */
    proto.google.protobuf.ExtensionRangeOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.ExtensionRangeOptions.extensionsBinary,
            proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension,
            proto.google.protobuf.ExtensionRangeOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.ExtensionRangeOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.ExtensionRangeOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ExtensionRangeOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.ExtensionRangeOptions.extensionsBinary, proto.google.protobuf.ExtensionRangeOptions.prototype.getExtension);
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.ExtensionRangeOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.ExtensionRangeOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.ExtensionRangeOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.ExtensionRangeOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.ExtensionRangeOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.ExtensionRangeOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.FieldDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.FieldDescriptorProto, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.FieldDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.FieldDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FieldDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        number: googleProtobuf.Message.getField(msg, 3),
        label: googleProtobuf.Message.getField(msg, 4),
        type: googleProtobuf.Message.getField(msg, 5),
        typeName: googleProtobuf.Message.getField(msg, 6),
        extendee: googleProtobuf.Message.getField(msg, 2),
        defaultValue: googleProtobuf.Message.getField(msg, 7),
        oneofIndex: googleProtobuf.Message.getField(msg, 9),
        jsonName: googleProtobuf.Message.getField(msg, 10),
        options: (f = msg.getOptions()) && proto.google.protobuf.FieldOptions.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.FieldDescriptorProto}
     */
    proto.google.protobuf.FieldDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.FieldDescriptorProto;
      return proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.FieldDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.FieldDescriptorProto}
     */
    proto.google.protobuf.FieldDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setNumber(value);
          break;
        case 4:
          var value = /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */ (reader.readEnum());
          msg.setLabel(value);
          break;
        case 5:
          var value = /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */ (reader.readEnum());
          msg.setType(value);
          break;
        case 6:
          var value = /** @type {string} */ (reader.readString());
          msg.setTypeName(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setExtendee(value);
          break;
        case 7:
          var value = /** @type {string} */ (reader.readString());
          msg.setDefaultValue(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setOneofIndex(value);
          break;
        case 10:
          var value = /** @type {string} */ (reader.readString());
          msg.setJsonName(value);
          break;
        case 8:
          var value = new proto.google.protobuf.FieldOptions;
          reader.readMessage(value,proto.google.protobuf.FieldOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.FieldDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FieldDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeInt32(
          3,
          f
        );
      }
      f = /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeEnum(
          4,
          f
        );
      }
      f = /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeEnum(
          5,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeString(
          6,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeString(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeInt32(
          9,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeString(
          10,
          f
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          8,
          f,
          proto.google.protobuf.FieldOptions.serializeBinaryToWriter
        );
      }
    };


    /**
     * @enum {number}
     */
    proto.google.protobuf.FieldDescriptorProto.Type = {
      TYPE_DOUBLE: 1,
      TYPE_FLOAT: 2,
      TYPE_INT64: 3,
      TYPE_UINT64: 4,
      TYPE_INT32: 5,
      TYPE_FIXED64: 6,
      TYPE_FIXED32: 7,
      TYPE_BOOL: 8,
      TYPE_STRING: 9,
      TYPE_GROUP: 10,
      TYPE_MESSAGE: 11,
      TYPE_BYTES: 12,
      TYPE_UINT32: 13,
      TYPE_ENUM: 14,
      TYPE_SFIXED32: 15,
      TYPE_SFIXED64: 16,
      TYPE_SINT32: 17,
      TYPE_SINT64: 18
    };

    /**
     * @enum {number}
     */
    proto.google.protobuf.FieldDescriptorProto.Label = {
      LABEL_OPTIONAL: 1,
      LABEL_REQUIRED: 2,
      LABEL_REPEATED: 3
    };

    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional int32 number = 3;
     * @return {number}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getNumber = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setNumber = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearNumber = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasNumber = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional Label label = 4;
     * @return {!proto.google.protobuf.FieldDescriptorProto.Label}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getLabel = function() {
      return /** @type {!proto.google.protobuf.FieldDescriptorProto.Label} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 1));
    };


    /** @param {!proto.google.protobuf.FieldDescriptorProto.Label} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional Type type = 5;
     * @return {!proto.google.protobuf.FieldDescriptorProto.Type}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getType = function() {
      return /** @type {!proto.google.protobuf.FieldDescriptorProto.Type} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 1));
    };


    /** @param {!proto.google.protobuf.FieldDescriptorProto.Type} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setType = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearType = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasType = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional string type_name = 6;
     * @return {string}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getTypeName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setTypeName = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearTypeName = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasTypeName = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional string extendee = 2;
     * @return {string}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getExtendee = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setExtendee = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearExtendee = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasExtendee = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string default_value = 7;
     * @return {string}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getDefaultValue = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setDefaultValue = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearDefaultValue = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasDefaultValue = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional int32 oneof_index = 9;
     * @return {number}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getOneofIndex = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setOneofIndex = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearOneofIndex = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasOneofIndex = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional string json_name = 10;
     * @return {string}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getJsonName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setJsonName = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearJsonName = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasJsonName = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * optional FieldOptions options = 8;
     * @return {?proto.google.protobuf.FieldOptions}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.FieldOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.FieldOptions, 8));
    };


    /** @param {?proto.google.protobuf.FieldOptions|undefined} value */
    proto.google.protobuf.FieldDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 8, value);
    };


    proto.google.protobuf.FieldDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.OneofDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.OneofDescriptorProto, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.OneofDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.OneofDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.OneofDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        options: (f = msg.getOptions()) && proto.google.protobuf.OneofOptions.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.OneofDescriptorProto}
     */
    proto.google.protobuf.OneofDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.OneofDescriptorProto;
      return proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.OneofDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.OneofDescriptorProto}
     */
    proto.google.protobuf.OneofDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = new proto.google.protobuf.OneofOptions;
          reader.readMessage(value,proto.google.protobuf.OneofOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.OneofDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.OneofDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          2,
          f,
          proto.google.protobuf.OneofOptions.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.OneofDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.OneofDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional OneofOptions options = 2;
     * @return {?proto.google.protobuf.OneofOptions}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.OneofOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.OneofOptions, 2));
    };


    /** @param {?proto.google.protobuf.OneofOptions|undefined} value */
    proto.google.protobuf.OneofDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 2, value);
    };


    proto.google.protobuf.OneofDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.OneofDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.EnumDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.EnumDescriptorProto.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.EnumDescriptorProto, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.EnumDescriptorProto.repeatedFields_ = [2,4,5];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.EnumDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.EnumDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        valueList: googleProtobuf.Message.toObjectList(msg.getValueList(),
        proto.google.protobuf.EnumValueDescriptorProto.toObject, includeInstance),
        options: (f = msg.getOptions()) && proto.google.protobuf.EnumOptions.toObject(includeInstance, f),
        reservedRangeList: googleProtobuf.Message.toObjectList(msg.getReservedRangeList(),
        proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject, includeInstance),
        reservedNameList: googleProtobuf.Message.getRepeatedField(msg, 5)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.EnumDescriptorProto}
     */
    proto.google.protobuf.EnumDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.EnumDescriptorProto;
      return proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.EnumDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.EnumDescriptorProto}
     */
    proto.google.protobuf.EnumDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = new proto.google.protobuf.EnumValueDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader);
          msg.addValue(value);
          break;
        case 3:
          var value = new proto.google.protobuf.EnumOptions;
          reader.readMessage(value,proto.google.protobuf.EnumOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        case 4:
          var value = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange;
          reader.readMessage(value,proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader);
          msg.addReservedRange(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.addReservedName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.EnumDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getValueList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f,
          proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          proto.google.protobuf.EnumOptions.serializeBinaryToWriter
        );
      }
      f = message.getReservedRangeList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          4,
          f,
          proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter
        );
      }
      f = message.getReservedNameList();
      if (f.length > 0) {
        writer.writeRepeatedString(
          5,
          f
        );
      }
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject = function(includeInstance, msg) {
      var obj = {
        start: googleProtobuf.Message.getField(msg, 1),
        end: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.EnumDescriptorProto.EnumReservedRange;
      return proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setStart(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setEnd(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeInt32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeInt32(
          2,
          f
        );
      }
    };


    /**
     * optional int32 start = 1;
     * @return {number}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getStart = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setStart = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearStart = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasStart = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional int32 end = 2;
     * @return {number}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.getEnd = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.setEnd = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.clearEnd = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumDescriptorProto.EnumReservedRange.prototype.hasEnd = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.EnumDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.EnumDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated EnumValueDescriptorProto value = 2;
     * @return {!Array<!proto.google.protobuf.EnumValueDescriptorProto>}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.getValueList = function() {
      return /** @type{!Array<!proto.google.protobuf.EnumValueDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumValueDescriptorProto, 2));
    };


    /** @param {!Array<!proto.google.protobuf.EnumValueDescriptorProto>} value */
    proto.google.protobuf.EnumDescriptorProto.prototype.setValueList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
    };


    /**
     * @param {!proto.google.protobuf.EnumValueDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.EnumValueDescriptorProto}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.addValue = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.google.protobuf.EnumValueDescriptorProto, opt_index);
    };


    proto.google.protobuf.EnumDescriptorProto.prototype.clearValueList = function() {
      this.setValueList([]);
    };


    /**
     * optional EnumOptions options = 3;
     * @return {?proto.google.protobuf.EnumOptions}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.EnumOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.EnumOptions, 3));
    };


    /** @param {?proto.google.protobuf.EnumOptions|undefined} value */
    proto.google.protobuf.EnumDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.google.protobuf.EnumDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * repeated EnumReservedRange reserved_range = 4;
     * @return {!Array<!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange>}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.getReservedRangeList = function() {
      return /** @type{!Array<!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, 4));
    };


    /** @param {!Array<!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange>} value */
    proto.google.protobuf.EnumDescriptorProto.prototype.setReservedRangeList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 4, value);
    };


    /**
     * @param {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.EnumDescriptorProto.EnumReservedRange}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.addReservedRange = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.google.protobuf.EnumDescriptorProto.EnumReservedRange, opt_index);
    };


    proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedRangeList = function() {
      this.setReservedRangeList([]);
    };


    /**
     * repeated string reserved_name = 5;
     * @return {!Array<string>}
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.getReservedNameList = function() {
      return /** @type {!Array<string>} */ (googleProtobuf.Message.getRepeatedField(this, 5));
    };


    /** @param {!Array<string>} value */
    proto.google.protobuf.EnumDescriptorProto.prototype.setReservedNameList = function(value) {
      googleProtobuf.Message.setField(this, 5, value || []);
    };


    /**
     * @param {!string} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.EnumDescriptorProto.prototype.addReservedName = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 5, value, opt_index);
    };


    proto.google.protobuf.EnumDescriptorProto.prototype.clearReservedNameList = function() {
      this.setReservedNameList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.EnumValueDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.EnumValueDescriptorProto, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.EnumValueDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.EnumValueDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumValueDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        number: googleProtobuf.Message.getField(msg, 2),
        options: (f = msg.getOptions()) && proto.google.protobuf.EnumValueOptions.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.EnumValueDescriptorProto}
     */
    proto.google.protobuf.EnumValueDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.EnumValueDescriptorProto;
      return proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.EnumValueDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.EnumValueDescriptorProto}
     */
    proto.google.protobuf.EnumValueDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setNumber(value);
          break;
        case 3:
          var value = new proto.google.protobuf.EnumValueOptions;
          reader.readMessage(value,proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.EnumValueDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumValueDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeInt32(
          2,
          f
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.EnumValueDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional int32 number = 2;
     * @return {number}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.getNumber = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.setNumber = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.EnumValueDescriptorProto.prototype.clearNumber = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.hasNumber = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional EnumValueOptions options = 3;
     * @return {?proto.google.protobuf.EnumValueOptions}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.EnumValueOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.EnumValueOptions, 3));
    };


    /** @param {?proto.google.protobuf.EnumValueOptions|undefined} value */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.google.protobuf.EnumValueDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumValueDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.ServiceDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.ServiceDescriptorProto.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.ServiceDescriptorProto, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.ServiceDescriptorProto.repeatedFields_ = [2];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.ServiceDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.ServiceDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ServiceDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        methodList: googleProtobuf.Message.toObjectList(msg.getMethodList(),
        proto.google.protobuf.MethodDescriptorProto.toObject, includeInstance),
        options: (f = msg.getOptions()) && proto.google.protobuf.ServiceOptions.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.ServiceDescriptorProto}
     */
    proto.google.protobuf.ServiceDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.ServiceDescriptorProto;
      return proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.ServiceDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.ServiceDescriptorProto}
     */
    proto.google.protobuf.ServiceDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = new proto.google.protobuf.MethodDescriptorProto;
          reader.readMessage(value,proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader);
          msg.addMethod(value);
          break;
        case 3:
          var value = new proto.google.protobuf.ServiceOptions;
          reader.readMessage(value,proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.ServiceDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ServiceDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getMethodList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f,
          proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          proto.google.protobuf.ServiceOptions.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.ServiceDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.ServiceDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated MethodDescriptorProto method = 2;
     * @return {!Array<!proto.google.protobuf.MethodDescriptorProto>}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.getMethodList = function() {
      return /** @type{!Array<!proto.google.protobuf.MethodDescriptorProto>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.MethodDescriptorProto, 2));
    };


    /** @param {!Array<!proto.google.protobuf.MethodDescriptorProto>} value */
    proto.google.protobuf.ServiceDescriptorProto.prototype.setMethodList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
    };


    /**
     * @param {!proto.google.protobuf.MethodDescriptorProto=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.MethodDescriptorProto}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.addMethod = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.google.protobuf.MethodDescriptorProto, opt_index);
    };


    proto.google.protobuf.ServiceDescriptorProto.prototype.clearMethodList = function() {
      this.setMethodList([]);
    };


    /**
     * optional ServiceOptions options = 3;
     * @return {?proto.google.protobuf.ServiceOptions}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.ServiceOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.ServiceOptions, 3));
    };


    /** @param {?proto.google.protobuf.ServiceOptions|undefined} value */
    proto.google.protobuf.ServiceDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.google.protobuf.ServiceDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.ServiceDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.MethodDescriptorProto = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.MethodDescriptorProto, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.MethodDescriptorProto.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.MethodDescriptorProto} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MethodDescriptorProto.toObject = function(includeInstance, msg) {
      var f, obj = {
        name: googleProtobuf.Message.getField(msg, 1),
        inputType: googleProtobuf.Message.getField(msg, 2),
        outputType: googleProtobuf.Message.getField(msg, 3),
        options: (f = msg.getOptions()) && proto.google.protobuf.MethodOptions.toObject(includeInstance, f),
        clientStreaming: googleProtobuf.Message.getFieldWithDefault(msg, 5, false),
        serverStreaming: googleProtobuf.Message.getFieldWithDefault(msg, 6, false)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.MethodDescriptorProto}
     */
    proto.google.protobuf.MethodDescriptorProto.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.MethodDescriptorProto;
      return proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.MethodDescriptorProto} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.MethodDescriptorProto}
     */
    proto.google.protobuf.MethodDescriptorProto.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setName(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setInputType(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setOutputType(value);
          break;
        case 4:
          var value = new proto.google.protobuf.MethodOptions;
          reader.readMessage(value,proto.google.protobuf.MethodOptions.deserializeBinaryFromReader);
          msg.setOptions(value);
          break;
        case 5:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setClientStreaming(value);
          break;
        case 6:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setServerStreaming(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.MethodDescriptorProto} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MethodDescriptorProto.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = message.getOptions();
      if (f != null) {
        writer.writeMessage(
          4,
          f,
          proto.google.protobuf.MethodOptions.serializeBinaryToWriter
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBool(
          5,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBool(
          6,
          f
        );
      }
    };


    /**
     * optional string name = 1;
     * @return {string}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string input_type = 2;
     * @return {string}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getInputType = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setInputType = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearInputType = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasInputType = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string output_type = 3;
     * @return {string}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getOutputType = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setOutputType = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearOutputType = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasOutputType = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional MethodOptions options = 4;
     * @return {?proto.google.protobuf.MethodOptions}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getOptions = function() {
      return /** @type{?proto.google.protobuf.MethodOptions} */ (
        googleProtobuf.Message.getWrapperField(this, proto.google.protobuf.MethodOptions, 4));
    };


    /** @param {?proto.google.protobuf.MethodOptions|undefined} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setOptions = function(value) {
      googleProtobuf.Message.setWrapperField(this, 4, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearOptions = function() {
      this.setOptions(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasOptions = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bool client_streaming = 5;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getClientStreaming = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setClientStreaming = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearClientStreaming = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasClientStreaming = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bool server_streaming = 6;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.getServerStreaming = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MethodDescriptorProto.prototype.setServerStreaming = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.google.protobuf.MethodDescriptorProto.prototype.clearServerStreaming = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodDescriptorProto.prototype.hasServerStreaming = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.FileOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.FileOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.FileOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.FileOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.FileOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.FileOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.FileOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileOptions.toObject = function(includeInstance, msg) {
      var obj = {
        javaPackage: googleProtobuf.Message.getField(msg, 1),
        javaOuterClassname: googleProtobuf.Message.getField(msg, 8),
        javaMultipleFiles: googleProtobuf.Message.getFieldWithDefault(msg, 10, false),
        javaGenerateEqualsAndHash: googleProtobuf.Message.getField(msg, 20),
        javaStringCheckUtf8: googleProtobuf.Message.getFieldWithDefault(msg, 27, false),
        optimizeFor: googleProtobuf.Message.getFieldWithDefault(msg, 9, 1),
        goPackage: googleProtobuf.Message.getField(msg, 11),
        ccGenericServices: googleProtobuf.Message.getFieldWithDefault(msg, 16, false),
        javaGenericServices: googleProtobuf.Message.getFieldWithDefault(msg, 17, false),
        pyGenericServices: googleProtobuf.Message.getFieldWithDefault(msg, 18, false),
        phpGenericServices: googleProtobuf.Message.getFieldWithDefault(msg, 42, false),
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 23, false),
        ccEnableArenas: googleProtobuf.Message.getFieldWithDefault(msg, 31, false),
        objcClassPrefix: googleProtobuf.Message.getField(msg, 36),
        csharpNamespace: googleProtobuf.Message.getField(msg, 37),
        swiftPrefix: googleProtobuf.Message.getField(msg, 39),
        phpClassPrefix: googleProtobuf.Message.getField(msg, 40),
        phpNamespace: googleProtobuf.Message.getField(msg, 41),
        phpMetadataNamespace: googleProtobuf.Message.getField(msg, 44),
        rubyPackage: googleProtobuf.Message.getField(msg, 45),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.FileOptions.extensions, proto.google.protobuf.FileOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.FileOptions}
     */
    proto.google.protobuf.FileOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.FileOptions;
      return proto.google.protobuf.FileOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.FileOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.FileOptions}
     */
    proto.google.protobuf.FileOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setJavaPackage(value);
          break;
        case 8:
          var value = /** @type {string} */ (reader.readString());
          msg.setJavaOuterClassname(value);
          break;
        case 10:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setJavaMultipleFiles(value);
          break;
        case 20:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setJavaGenerateEqualsAndHash(value);
          break;
        case 27:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setJavaStringCheckUtf8(value);
          break;
        case 9:
          var value = /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */ (reader.readEnum());
          msg.setOptimizeFor(value);
          break;
        case 11:
          var value = /** @type {string} */ (reader.readString());
          msg.setGoPackage(value);
          break;
        case 16:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setCcGenericServices(value);
          break;
        case 17:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setJavaGenericServices(value);
          break;
        case 18:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPyGenericServices(value);
          break;
        case 42:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPhpGenericServices(value);
          break;
        case 23:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 31:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setCcEnableArenas(value);
          break;
        case 36:
          var value = /** @type {string} */ (reader.readString());
          msg.setObjcClassPrefix(value);
          break;
        case 37:
          var value = /** @type {string} */ (reader.readString());
          msg.setCsharpNamespace(value);
          break;
        case 39:
          var value = /** @type {string} */ (reader.readString());
          msg.setSwiftPrefix(value);
          break;
        case 40:
          var value = /** @type {string} */ (reader.readString());
          msg.setPhpClassPrefix(value);
          break;
        case 41:
          var value = /** @type {string} */ (reader.readString());
          msg.setPhpNamespace(value);
          break;
        case 44:
          var value = /** @type {string} */ (reader.readString());
          msg.setPhpMetadataNamespace(value);
          break;
        case 45:
          var value = /** @type {string} */ (reader.readString());
          msg.setRubyPackage(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.FileOptions.extensionsBinary,
            proto.google.protobuf.FileOptions.prototype.getExtension,
            proto.google.protobuf.FileOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.FileOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.FileOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.FileOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FileOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeString(
          8,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeBool(
          10,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 20));
      if (f != null) {
        writer.writeBool(
          20,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 27));
      if (f != null) {
        writer.writeBool(
          27,
          f
        );
      }
      f = /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeEnum(
          9,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 11));
      if (f != null) {
        writer.writeString(
          11,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 16));
      if (f != null) {
        writer.writeBool(
          16,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 17));
      if (f != null) {
        writer.writeBool(
          17,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 18));
      if (f != null) {
        writer.writeBool(
          18,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 42));
      if (f != null) {
        writer.writeBool(
          42,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 23));
      if (f != null) {
        writer.writeBool(
          23,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 31));
      if (f != null) {
        writer.writeBool(
          31,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 36));
      if (f != null) {
        writer.writeString(
          36,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 37));
      if (f != null) {
        writer.writeString(
          37,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 39));
      if (f != null) {
        writer.writeString(
          39,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 40));
      if (f != null) {
        writer.writeString(
          40,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 41));
      if (f != null) {
        writer.writeString(
          41,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 44));
      if (f != null) {
        writer.writeString(
          44,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 45));
      if (f != null) {
        writer.writeString(
          45,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.FileOptions.extensionsBinary, proto.google.protobuf.FileOptions.prototype.getExtension);
    };


    /**
     * @enum {number}
     */
    proto.google.protobuf.FileOptions.OptimizeMode = {
      SPEED: 1,
      CODE_SIZE: 2,
      LITE_RUNTIME: 3
    };

    /**
     * optional string java_package = 1;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaPackage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setJavaPackage = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaPackage = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaPackage = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string java_outer_classname = 8;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaOuterClassname = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setJavaOuterClassname = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaOuterClassname = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaOuterClassname = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional bool java_multiple_files = 10;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaMultipleFiles = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setJavaMultipleFiles = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaMultipleFiles = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaMultipleFiles = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * optional bool java_generate_equals_and_hash = 20;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaGenerateEqualsAndHash = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 20, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setJavaGenerateEqualsAndHash = function(value) {
      googleProtobuf.Message.setField(this, 20, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaGenerateEqualsAndHash = function() {
      googleProtobuf.Message.setField(this, 20, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaGenerateEqualsAndHash = function() {
      return googleProtobuf.Message.getField(this, 20) != null;
    };


    /**
     * optional bool java_string_check_utf8 = 27;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaStringCheckUtf8 = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 27, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setJavaStringCheckUtf8 = function(value) {
      googleProtobuf.Message.setField(this, 27, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaStringCheckUtf8 = function() {
      googleProtobuf.Message.setField(this, 27, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaStringCheckUtf8 = function() {
      return googleProtobuf.Message.getField(this, 27) != null;
    };


    /**
     * optional OptimizeMode optimize_for = 9;
     * @return {!proto.google.protobuf.FileOptions.OptimizeMode}
     */
    proto.google.protobuf.FileOptions.prototype.getOptimizeFor = function() {
      return /** @type {!proto.google.protobuf.FileOptions.OptimizeMode} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 1));
    };


    /** @param {!proto.google.protobuf.FileOptions.OptimizeMode} value */
    proto.google.protobuf.FileOptions.prototype.setOptimizeFor = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearOptimizeFor = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasOptimizeFor = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional string go_package = 11;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getGoPackage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 11, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setGoPackage = function(value) {
      googleProtobuf.Message.setField(this, 11, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearGoPackage = function() {
      googleProtobuf.Message.setField(this, 11, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasGoPackage = function() {
      return googleProtobuf.Message.getField(this, 11) != null;
    };


    /**
     * optional bool cc_generic_services = 16;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getCcGenericServices = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 16, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setCcGenericServices = function(value) {
      googleProtobuf.Message.setField(this, 16, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearCcGenericServices = function() {
      googleProtobuf.Message.setField(this, 16, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasCcGenericServices = function() {
      return googleProtobuf.Message.getField(this, 16) != null;
    };


    /**
     * optional bool java_generic_services = 17;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getJavaGenericServices = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 17, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setJavaGenericServices = function(value) {
      googleProtobuf.Message.setField(this, 17, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearJavaGenericServices = function() {
      googleProtobuf.Message.setField(this, 17, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasJavaGenericServices = function() {
      return googleProtobuf.Message.getField(this, 17) != null;
    };


    /**
     * optional bool py_generic_services = 18;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getPyGenericServices = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 18, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setPyGenericServices = function(value) {
      googleProtobuf.Message.setField(this, 18, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearPyGenericServices = function() {
      googleProtobuf.Message.setField(this, 18, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasPyGenericServices = function() {
      return googleProtobuf.Message.getField(this, 18) != null;
    };


    /**
     * optional bool php_generic_services = 42;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getPhpGenericServices = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 42, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setPhpGenericServices = function(value) {
      googleProtobuf.Message.setField(this, 42, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearPhpGenericServices = function() {
      googleProtobuf.Message.setField(this, 42, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasPhpGenericServices = function() {
      return googleProtobuf.Message.getField(this, 42) != null;
    };


    /**
     * optional bool deprecated = 23;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 23, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 23, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 23, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 23) != null;
    };


    /**
     * optional bool cc_enable_arenas = 31;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FileOptions.prototype.getCcEnableArenas = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 31, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FileOptions.prototype.setCcEnableArenas = function(value) {
      googleProtobuf.Message.setField(this, 31, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearCcEnableArenas = function() {
      googleProtobuf.Message.setField(this, 31, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasCcEnableArenas = function() {
      return googleProtobuf.Message.getField(this, 31) != null;
    };


    /**
     * optional string objc_class_prefix = 36;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getObjcClassPrefix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 36, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setObjcClassPrefix = function(value) {
      googleProtobuf.Message.setField(this, 36, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearObjcClassPrefix = function() {
      googleProtobuf.Message.setField(this, 36, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasObjcClassPrefix = function() {
      return googleProtobuf.Message.getField(this, 36) != null;
    };


    /**
     * optional string csharp_namespace = 37;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getCsharpNamespace = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 37, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setCsharpNamespace = function(value) {
      googleProtobuf.Message.setField(this, 37, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearCsharpNamespace = function() {
      googleProtobuf.Message.setField(this, 37, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasCsharpNamespace = function() {
      return googleProtobuf.Message.getField(this, 37) != null;
    };


    /**
     * optional string swift_prefix = 39;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getSwiftPrefix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 39, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setSwiftPrefix = function(value) {
      googleProtobuf.Message.setField(this, 39, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearSwiftPrefix = function() {
      googleProtobuf.Message.setField(this, 39, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasSwiftPrefix = function() {
      return googleProtobuf.Message.getField(this, 39) != null;
    };


    /**
     * optional string php_class_prefix = 40;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getPhpClassPrefix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 40, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setPhpClassPrefix = function(value) {
      googleProtobuf.Message.setField(this, 40, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearPhpClassPrefix = function() {
      googleProtobuf.Message.setField(this, 40, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasPhpClassPrefix = function() {
      return googleProtobuf.Message.getField(this, 40) != null;
    };


    /**
     * optional string php_namespace = 41;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getPhpNamespace = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 41, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setPhpNamespace = function(value) {
      googleProtobuf.Message.setField(this, 41, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearPhpNamespace = function() {
      googleProtobuf.Message.setField(this, 41, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasPhpNamespace = function() {
      return googleProtobuf.Message.getField(this, 41) != null;
    };


    /**
     * optional string php_metadata_namespace = 44;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getPhpMetadataNamespace = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 44, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setPhpMetadataNamespace = function(value) {
      googleProtobuf.Message.setField(this, 44, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearPhpMetadataNamespace = function() {
      googleProtobuf.Message.setField(this, 44, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasPhpMetadataNamespace = function() {
      return googleProtobuf.Message.getField(this, 44) != null;
    };


    /**
     * optional string ruby_package = 45;
     * @return {string}
     */
    proto.google.protobuf.FileOptions.prototype.getRubyPackage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 45, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.FileOptions.prototype.setRubyPackage = function(value) {
      googleProtobuf.Message.setField(this, 45, value);
    };


    proto.google.protobuf.FileOptions.prototype.clearRubyPackage = function() {
      googleProtobuf.Message.setField(this, 45, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FileOptions.prototype.hasRubyPackage = function() {
      return googleProtobuf.Message.getField(this, 45) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.FileOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.FileOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.FileOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.FileOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.FileOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.FileOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.MessageOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.MessageOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.MessageOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.MessageOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.MessageOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.MessageOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.MessageOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MessageOptions.toObject = function(includeInstance, msg) {
      var obj = {
        messageSetWireFormat: googleProtobuf.Message.getFieldWithDefault(msg, 1, false),
        noStandardDescriptorAccessor: googleProtobuf.Message.getFieldWithDefault(msg, 2, false),
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 3, false),
        mapEntry: googleProtobuf.Message.getField(msg, 7),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.MessageOptions.extensions, proto.google.protobuf.MessageOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.MessageOptions}
     */
    proto.google.protobuf.MessageOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.MessageOptions;
      return proto.google.protobuf.MessageOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.MessageOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.MessageOptions}
     */
    proto.google.protobuf.MessageOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setMessageSetWireFormat(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setNoStandardDescriptorAccessor(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setMapEntry(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.MessageOptions.extensionsBinary,
            proto.google.protobuf.MessageOptions.prototype.getExtension,
            proto.google.protobuf.MessageOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.MessageOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.MessageOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.MessageOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MessageOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBool(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.MessageOptions.extensionsBinary, proto.google.protobuf.MessageOptions.prototype.getExtension);
    };


    /**
     * optional bool message_set_wire_format = 1;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.getMessageSetWireFormat = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MessageOptions.prototype.setMessageSetWireFormat = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.MessageOptions.prototype.clearMessageSetWireFormat = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.hasMessageSetWireFormat = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool no_standard_descriptor_accessor = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.getNoStandardDescriptorAccessor = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MessageOptions.prototype.setNoStandardDescriptorAccessor = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.MessageOptions.prototype.clearNoStandardDescriptorAccessor = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.hasNoStandardDescriptorAccessor = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool deprecated = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MessageOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.MessageOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool map_entry = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.getMapEntry = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MessageOptions.prototype.setMapEntry = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.google.protobuf.MessageOptions.prototype.clearMapEntry = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MessageOptions.prototype.hasMapEntry = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.MessageOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.MessageOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.MessageOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.MessageOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.MessageOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.MessageOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.FieldOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.FieldOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.FieldOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.FieldOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.FieldOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.FieldOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.FieldOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FieldOptions.toObject = function(includeInstance, msg) {
      var obj = {
        ctype: googleProtobuf.Message.getFieldWithDefault(msg, 1, 0),
        packed: googleProtobuf.Message.getField(msg, 2),
        jstype: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
        lazy: googleProtobuf.Message.getFieldWithDefault(msg, 5, false),
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 3, false),
        weak: googleProtobuf.Message.getFieldWithDefault(msg, 10, false),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.FieldOptions.extensions, proto.google.protobuf.FieldOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.FieldOptions}
     */
    proto.google.protobuf.FieldOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.FieldOptions;
      return proto.google.protobuf.FieldOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.FieldOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.FieldOptions}
     */
    proto.google.protobuf.FieldOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!proto.google.protobuf.FieldOptions.CType} */ (reader.readEnum());
          msg.setCtype(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPacked(value);
          break;
        case 6:
          var value = /** @type {!proto.google.protobuf.FieldOptions.JSType} */ (reader.readEnum());
          msg.setJstype(value);
          break;
        case 5:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setLazy(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 10:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setWeak(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.FieldOptions.extensionsBinary,
            proto.google.protobuf.FieldOptions.prototype.getExtension,
            proto.google.protobuf.FieldOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.FieldOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.FieldOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.FieldOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.FieldOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!proto.google.protobuf.FieldOptions.CType} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeEnum(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {!proto.google.protobuf.FieldOptions.JSType} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeEnum(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBool(
          5,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeBool(
          10,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.FieldOptions.extensionsBinary, proto.google.protobuf.FieldOptions.prototype.getExtension);
    };


    /**
     * @enum {number}
     */
    proto.google.protobuf.FieldOptions.CType = {
      STRING: 0,
      CORD: 1,
      STRING_PIECE: 2
    };

    /**
     * @enum {number}
     */
    proto.google.protobuf.FieldOptions.JSType = {
      JS_NORMAL: 0,
      JS_STRING: 1,
      JS_NUMBER: 2
    };

    /**
     * optional CType ctype = 1;
     * @return {!proto.google.protobuf.FieldOptions.CType}
     */
    proto.google.protobuf.FieldOptions.prototype.getCtype = function() {
      return /** @type {!proto.google.protobuf.FieldOptions.CType} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {!proto.google.protobuf.FieldOptions.CType} value */
    proto.google.protobuf.FieldOptions.prototype.setCtype = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearCtype = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasCtype = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool packed = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.getPacked = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FieldOptions.prototype.setPacked = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearPacked = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasPacked = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional JSType jstype = 6;
     * @return {!proto.google.protobuf.FieldOptions.JSType}
     */
    proto.google.protobuf.FieldOptions.prototype.getJstype = function() {
      return /** @type {!proto.google.protobuf.FieldOptions.JSType} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {!proto.google.protobuf.FieldOptions.JSType} value */
    proto.google.protobuf.FieldOptions.prototype.setJstype = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearJstype = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasJstype = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool lazy = 5;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.getLazy = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FieldOptions.prototype.setLazy = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearLazy = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasLazy = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bool deprecated = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FieldOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool weak = 10;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.getWeak = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.FieldOptions.prototype.setWeak = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.google.protobuf.FieldOptions.prototype.clearWeak = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.FieldOptions.prototype.hasWeak = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.FieldOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.FieldOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.FieldOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.FieldOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.FieldOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.FieldOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.OneofOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.OneofOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.OneofOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.OneofOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.OneofOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.OneofOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.OneofOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.OneofOptions.toObject = function(includeInstance, msg) {
      var obj = {
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.OneofOptions.extensions, proto.google.protobuf.OneofOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.OneofOptions}
     */
    proto.google.protobuf.OneofOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.OneofOptions;
      return proto.google.protobuf.OneofOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.OneofOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.OneofOptions}
     */
    proto.google.protobuf.OneofOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.OneofOptions.extensionsBinary,
            proto.google.protobuf.OneofOptions.prototype.getExtension,
            proto.google.protobuf.OneofOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.OneofOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.OneofOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.OneofOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.OneofOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.OneofOptions.extensionsBinary, proto.google.protobuf.OneofOptions.prototype.getExtension);
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.OneofOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.OneofOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.OneofOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.OneofOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.OneofOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.OneofOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.EnumOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.EnumOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.EnumOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.EnumOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.EnumOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.EnumOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.EnumOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumOptions.toObject = function(includeInstance, msg) {
      var obj = {
        allowAlias: googleProtobuf.Message.getField(msg, 2),
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 3, false),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.EnumOptions.extensions, proto.google.protobuf.EnumOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.EnumOptions}
     */
    proto.google.protobuf.EnumOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.EnumOptions;
      return proto.google.protobuf.EnumOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.EnumOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.EnumOptions}
     */
    proto.google.protobuf.EnumOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setAllowAlias(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.EnumOptions.extensionsBinary,
            proto.google.protobuf.EnumOptions.prototype.getExtension,
            proto.google.protobuf.EnumOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.EnumOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.EnumOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.EnumOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.EnumOptions.extensionsBinary, proto.google.protobuf.EnumOptions.prototype.getExtension);
    };


    /**
     * optional bool allow_alias = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.EnumOptions.prototype.getAllowAlias = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.EnumOptions.prototype.setAllowAlias = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.EnumOptions.prototype.clearAllowAlias = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumOptions.prototype.hasAllowAlias = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool deprecated = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.EnumOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.EnumOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.EnumOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.EnumOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.EnumOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.EnumOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.EnumOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.EnumOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.EnumOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.EnumValueOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.EnumValueOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.EnumValueOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.EnumValueOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.EnumValueOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.EnumValueOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.EnumValueOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumValueOptions.toObject = function(includeInstance, msg) {
      var obj = {
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 1, false),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.EnumValueOptions.extensions, proto.google.protobuf.EnumValueOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.EnumValueOptions}
     */
    proto.google.protobuf.EnumValueOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.EnumValueOptions;
      return proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.EnumValueOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.EnumValueOptions}
     */
    proto.google.protobuf.EnumValueOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.EnumValueOptions.extensionsBinary,
            proto.google.protobuf.EnumValueOptions.prototype.getExtension,
            proto.google.protobuf.EnumValueOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.EnumValueOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.EnumValueOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.EnumValueOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBool(
          1,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.EnumValueOptions.extensionsBinary, proto.google.protobuf.EnumValueOptions.prototype.getExtension);
    };


    /**
     * optional bool deprecated = 1;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.EnumValueOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.EnumValueOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.EnumValueOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.EnumValueOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.EnumValueOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.EnumValueOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.EnumValueOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.EnumValueOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.EnumValueOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.EnumValueOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.ServiceOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.ServiceOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.ServiceOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.ServiceOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.ServiceOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.ServiceOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.ServiceOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ServiceOptions.toObject = function(includeInstance, msg) {
      var obj = {
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 33, false),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.ServiceOptions.extensions, proto.google.protobuf.ServiceOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.ServiceOptions}
     */
    proto.google.protobuf.ServiceOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.ServiceOptions;
      return proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.ServiceOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.ServiceOptions}
     */
    proto.google.protobuf.ServiceOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 33:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.ServiceOptions.extensionsBinary,
            proto.google.protobuf.ServiceOptions.prototype.getExtension,
            proto.google.protobuf.ServiceOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.ServiceOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.ServiceOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.ServiceOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.ServiceOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 33));
      if (f != null) {
        writer.writeBool(
          33,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.ServiceOptions.extensionsBinary, proto.google.protobuf.ServiceOptions.prototype.getExtension);
    };


    /**
     * optional bool deprecated = 33;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.ServiceOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 33, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.ServiceOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 33, value);
    };


    proto.google.protobuf.ServiceOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 33, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.ServiceOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 33) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.ServiceOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.ServiceOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.ServiceOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.ServiceOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.ServiceOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.ServiceOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.MethodOptions = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, 500, proto.google.protobuf.MethodOptions.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.MethodOptions, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.MethodOptions.repeatedFields_ = [999];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.MethodOptions.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.MethodOptions.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.MethodOptions} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MethodOptions.toObject = function(includeInstance, msg) {
      var obj = {
        deprecated: googleProtobuf.Message.getFieldWithDefault(msg, 33, false),
        idempotencyLevel: googleProtobuf.Message.getFieldWithDefault(msg, 34, 0),
        uninterpretedOptionList: googleProtobuf.Message.toObjectList(msg.getUninterpretedOptionList(),
        proto.google.protobuf.UninterpretedOption.toObject, includeInstance)
      };

      googleProtobuf.Message.toObjectExtension(/** @type {!jspb.Message} */ (msg), obj,
          proto.google.protobuf.MethodOptions.extensions, proto.google.protobuf.MethodOptions.prototype.getExtension,
          includeInstance);
      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.MethodOptions}
     */
    proto.google.protobuf.MethodOptions.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.MethodOptions;
      return proto.google.protobuf.MethodOptions.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.MethodOptions} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.MethodOptions}
     */
    proto.google.protobuf.MethodOptions.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 33:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDeprecated(value);
          break;
        case 34:
          var value = /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */ (reader.readEnum());
          msg.setIdempotencyLevel(value);
          break;
        case 999:
          var value = new proto.google.protobuf.UninterpretedOption;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader);
          msg.addUninterpretedOption(value);
          break;
        default:
          googleProtobuf.Message.readBinaryExtension(msg, reader, proto.google.protobuf.MethodOptions.extensionsBinary,
            proto.google.protobuf.MethodOptions.prototype.getExtension,
            proto.google.protobuf.MethodOptions.prototype.setExtension);
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.MethodOptions.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.MethodOptions.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.MethodOptions} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.MethodOptions.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 33));
      if (f != null) {
        writer.writeBool(
          33,
          f
        );
      }
      f = /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */ (googleProtobuf.Message.getField(message, 34));
      if (f != null) {
        writer.writeEnum(
          34,
          f
        );
      }
      f = message.getUninterpretedOptionList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          999,
          f,
          proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter
        );
      }
      googleProtobuf.Message.serializeBinaryExtensions(message, writer,
        proto.google.protobuf.MethodOptions.extensionsBinary, proto.google.protobuf.MethodOptions.prototype.getExtension);
    };


    /**
     * @enum {number}
     */
    proto.google.protobuf.MethodOptions.IdempotencyLevel = {
      IDEMPOTENCY_UNKNOWN: 0,
      NO_SIDE_EFFECTS: 1,
      IDEMPOTENT: 2
    };

    /**
     * optional bool deprecated = 33;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.MethodOptions.prototype.getDeprecated = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 33, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.MethodOptions.prototype.setDeprecated = function(value) {
      googleProtobuf.Message.setField(this, 33, value);
    };


    proto.google.protobuf.MethodOptions.prototype.clearDeprecated = function() {
      googleProtobuf.Message.setField(this, 33, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodOptions.prototype.hasDeprecated = function() {
      return googleProtobuf.Message.getField(this, 33) != null;
    };


    /**
     * optional IdempotencyLevel idempotency_level = 34;
     * @return {!proto.google.protobuf.MethodOptions.IdempotencyLevel}
     */
    proto.google.protobuf.MethodOptions.prototype.getIdempotencyLevel = function() {
      return /** @type {!proto.google.protobuf.MethodOptions.IdempotencyLevel} */ (googleProtobuf.Message.getFieldWithDefault(this, 34, 0));
    };


    /** @param {!proto.google.protobuf.MethodOptions.IdempotencyLevel} value */
    proto.google.protobuf.MethodOptions.prototype.setIdempotencyLevel = function(value) {
      googleProtobuf.Message.setField(this, 34, value);
    };


    proto.google.protobuf.MethodOptions.prototype.clearIdempotencyLevel = function() {
      googleProtobuf.Message.setField(this, 34, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.MethodOptions.prototype.hasIdempotencyLevel = function() {
      return googleProtobuf.Message.getField(this, 34) != null;
    };


    /**
     * repeated UninterpretedOption uninterpreted_option = 999;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption>}
     */
    proto.google.protobuf.MethodOptions.prototype.getUninterpretedOptionList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption, 999));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption>} value */
    proto.google.protobuf.MethodOptions.prototype.setUninterpretedOptionList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 999, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.MethodOptions.prototype.addUninterpretedOption = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 999, opt_value, proto.google.protobuf.UninterpretedOption, opt_index);
    };


    proto.google.protobuf.MethodOptions.prototype.clearUninterpretedOptionList = function() {
      this.setUninterpretedOptionList([]);
    };



    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldInfo>}
     */
    proto.google.protobuf.MethodOptions.extensions = {};


    /**
     * The extensions registered with this message class. This is a map of
     * extension field number to fieldInfo object.
     *
     * For example:
     *     { 123: {fieldIndex: 123, fieldName: {my_field_name: 0}, ctor: proto.example.MyMessage} }
     *
     * fieldName contains the JsCompiler renamed field name property so that it
     * works in OPTIMIZED mode.
     *
     * @type {!Object<number, jspb.ExtensionFieldBinaryInfo>}
     */
    proto.google.protobuf.MethodOptions.extensionsBinary = {};


    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.UninterpretedOption = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.UninterpretedOption.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.UninterpretedOption, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.UninterpretedOption.repeatedFields_ = [2];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.UninterpretedOption.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.UninterpretedOption.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.UninterpretedOption} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.UninterpretedOption.toObject = function(includeInstance, msg) {
      var obj = {
        nameList: googleProtobuf.Message.toObjectList(msg.getNameList(),
        proto.google.protobuf.UninterpretedOption.NamePart.toObject, includeInstance),
        identifierValue: googleProtobuf.Message.getField(msg, 3),
        positiveIntValue: googleProtobuf.Message.getField(msg, 4),
        negativeIntValue: googleProtobuf.Message.getField(msg, 5),
        doubleValue: googleProtobuf.Message.getOptionalFloatingPointField(msg, 6),
        stringValue: msg.getStringValue_asB64(),
        aggregateValue: googleProtobuf.Message.getField(msg, 8)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.UninterpretedOption.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.UninterpretedOption;
      return proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.UninterpretedOption} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.UninterpretedOption}
     */
    proto.google.protobuf.UninterpretedOption.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 2:
          var value = new proto.google.protobuf.UninterpretedOption.NamePart;
          reader.readMessage(value,proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader);
          msg.addName(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setIdentifierValue(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setPositiveIntValue(value);
          break;
        case 5:
          var value = /** @type {number} */ (reader.readInt64());
          msg.setNegativeIntValue(value);
          break;
        case 6:
          var value = /** @type {number} */ (reader.readDouble());
          msg.setDoubleValue(value);
          break;
        case 7:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setStringValue(value);
          break;
        case 8:
          var value = /** @type {string} */ (reader.readString());
          msg.setAggregateValue(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.UninterpretedOption.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.UninterpretedOption} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.UninterpretedOption.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getNameList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f,
          proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint64(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeInt64(
          5,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeDouble(
          6,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBytes(
          7,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeString(
          8,
          f
        );
      }
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.UninterpretedOption.NamePart = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.google.protobuf.UninterpretedOption.NamePart, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.UninterpretedOption.NamePart.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.UninterpretedOption.NamePart} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.UninterpretedOption.NamePart.toObject = function(includeInstance, msg) {
      var obj = {
        namePart: googleProtobuf.Message.getField(msg, 1),
        isExtension: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.UninterpretedOption.NamePart}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.UninterpretedOption.NamePart;
      return proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.UninterpretedOption.NamePart} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.UninterpretedOption.NamePart}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setNamePart(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setIsExtension(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.UninterpretedOption.NamePart} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.UninterpretedOption.NamePart.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
    };


    /**
     * required string name_part = 1;
     * @return {string}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.getNamePart = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.setNamePart = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearNamePart = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasNamePart = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required bool is_extension = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.getIsExtension = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.setIsExtension = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.UninterpretedOption.NamePart.prototype.clearIsExtension = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.NamePart.prototype.hasIsExtension = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * repeated NamePart name = 2;
     * @return {!Array<!proto.google.protobuf.UninterpretedOption.NamePart>}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getNameList = function() {
      return /** @type{!Array<!proto.google.protobuf.UninterpretedOption.NamePart>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.UninterpretedOption.NamePart, 2));
    };


    /** @param {!Array<!proto.google.protobuf.UninterpretedOption.NamePart>} value */
    proto.google.protobuf.UninterpretedOption.prototype.setNameList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
    };


    /**
     * @param {!proto.google.protobuf.UninterpretedOption.NamePart=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.UninterpretedOption.NamePart}
     */
    proto.google.protobuf.UninterpretedOption.prototype.addName = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.google.protobuf.UninterpretedOption.NamePart, opt_index);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearNameList = function() {
      this.setNameList([]);
    };


    /**
     * optional string identifier_value = 3;
     * @return {string}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getIdentifierValue = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.UninterpretedOption.prototype.setIdentifierValue = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearIdentifierValue = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasIdentifierValue = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint64 positive_int_value = 4;
     * @return {number}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getPositiveIntValue = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.UninterpretedOption.prototype.setPositiveIntValue = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearPositiveIntValue = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasPositiveIntValue = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional int64 negative_int_value = 5;
     * @return {number}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getNegativeIntValue = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.UninterpretedOption.prototype.setNegativeIntValue = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearNegativeIntValue = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasNegativeIntValue = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional double double_value = 6;
     * @return {number}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getDoubleValue = function() {
      return /** @type {number} */ (+googleProtobuf.Message.getFieldWithDefault(this, 6, 0.0));
    };


    /** @param {number} value */
    proto.google.protobuf.UninterpretedOption.prototype.setDoubleValue = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearDoubleValue = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasDoubleValue = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bytes string_value = 7;
     * @return {!(string|Uint8Array)}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getStringValue = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, ""));
    };


    /**
     * optional bytes string_value = 7;
     * This is a type-conversion wrapper around `getStringValue()`
     * @return {string}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getStringValue()));
    };


    /**
     * optional bytes string_value = 7;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getStringValue()`
     * @return {!Uint8Array}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getStringValue_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getStringValue()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.google.protobuf.UninterpretedOption.prototype.setStringValue = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearStringValue = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasStringValue = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional string aggregate_value = 8;
     * @return {string}
     */
    proto.google.protobuf.UninterpretedOption.prototype.getAggregateValue = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.UninterpretedOption.prototype.setAggregateValue = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.google.protobuf.UninterpretedOption.prototype.clearAggregateValue = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.UninterpretedOption.prototype.hasAggregateValue = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.SourceCodeInfo = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.SourceCodeInfo.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.SourceCodeInfo, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.SourceCodeInfo.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.SourceCodeInfo.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.SourceCodeInfo.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.SourceCodeInfo} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.SourceCodeInfo.toObject = function(includeInstance, msg) {
      var obj = {
        locationList: googleProtobuf.Message.toObjectList(msg.getLocationList(),
        proto.google.protobuf.SourceCodeInfo.Location.toObject, includeInstance)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.SourceCodeInfo}
     */
    proto.google.protobuf.SourceCodeInfo.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.SourceCodeInfo;
      return proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.SourceCodeInfo} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.SourceCodeInfo}
     */
    proto.google.protobuf.SourceCodeInfo.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.google.protobuf.SourceCodeInfo.Location;
          reader.readMessage(value,proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader);
          msg.addLocation(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.SourceCodeInfo.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.SourceCodeInfo} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.SourceCodeInfo.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getLocationList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter
        );
      }
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.SourceCodeInfo.Location = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.SourceCodeInfo.Location, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.SourceCodeInfo.Location.repeatedFields_ = [1,2,6];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.SourceCodeInfo.Location.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.SourceCodeInfo.Location} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.SourceCodeInfo.Location.toObject = function(includeInstance, msg) {
      var obj = {
        pathList: googleProtobuf.Message.getRepeatedField(msg, 1),
        spanList: googleProtobuf.Message.getRepeatedField(msg, 2),
        leadingComments: googleProtobuf.Message.getField(msg, 3),
        trailingComments: googleProtobuf.Message.getField(msg, 4),
        leadingDetachedCommentsList: googleProtobuf.Message.getRepeatedField(msg, 6)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.SourceCodeInfo.Location}
     */
    proto.google.protobuf.SourceCodeInfo.Location.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.SourceCodeInfo.Location;
      return proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.SourceCodeInfo.Location} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.SourceCodeInfo.Location}
     */
    proto.google.protobuf.SourceCodeInfo.Location.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
          msg.setPathList(value);
          break;
        case 2:
          var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
          msg.setSpanList(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setLeadingComments(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setTrailingComments(value);
          break;
        case 6:
          var value = /** @type {string} */ (reader.readString());
          msg.addLeadingDetachedComments(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.SourceCodeInfo.Location} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.SourceCodeInfo.Location.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getPathList();
      if (f.length > 0) {
        writer.writePackedInt32(
          1,
          f
        );
      }
      f = message.getSpanList();
      if (f.length > 0) {
        writer.writePackedInt32(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
      f = message.getLeadingDetachedCommentsList();
      if (f.length > 0) {
        writer.writeRepeatedString(
          6,
          f
        );
      }
    };


    /**
     * repeated int32 path = 1;
     * @return {!Array<number>}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.getPathList = function() {
      return /** @type {!Array<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array<number>} value */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.setPathList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.addPath = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.google.protobuf.SourceCodeInfo.Location.prototype.clearPathList = function() {
      this.setPathList([]);
    };


    /**
     * repeated int32 span = 2;
     * @return {!Array<number>}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.getSpanList = function() {
      return /** @type {!Array<number>} */ (googleProtobuf.Message.getRepeatedField(this, 2));
    };


    /** @param {!Array<number>} value */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.setSpanList = function(value) {
      googleProtobuf.Message.setField(this, 2, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.addSpan = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
    };


    proto.google.protobuf.SourceCodeInfo.Location.prototype.clearSpanList = function() {
      this.setSpanList([]);
    };


    /**
     * optional string leading_comments = 3;
     * @return {string}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingComments = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingComments = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingComments = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.hasLeadingComments = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string trailing_comments = 4;
     * @return {string}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.getTrailingComments = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.setTrailingComments = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.google.protobuf.SourceCodeInfo.Location.prototype.clearTrailingComments = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.hasTrailingComments = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * repeated string leading_detached_comments = 6;
     * @return {!Array<string>}
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.getLeadingDetachedCommentsList = function() {
      return /** @type {!Array<string>} */ (googleProtobuf.Message.getRepeatedField(this, 6));
    };


    /** @param {!Array<string>} value */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.setLeadingDetachedCommentsList = function(value) {
      googleProtobuf.Message.setField(this, 6, value || []);
    };


    /**
     * @param {!string} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.SourceCodeInfo.Location.prototype.addLeadingDetachedComments = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 6, value, opt_index);
    };


    proto.google.protobuf.SourceCodeInfo.Location.prototype.clearLeadingDetachedCommentsList = function() {
      this.setLeadingDetachedCommentsList([]);
    };


    /**
     * repeated Location location = 1;
     * @return {!Array<!proto.google.protobuf.SourceCodeInfo.Location>}
     */
    proto.google.protobuf.SourceCodeInfo.prototype.getLocationList = function() {
      return /** @type{!Array<!proto.google.protobuf.SourceCodeInfo.Location>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.SourceCodeInfo.Location, 1));
    };


    /** @param {!Array<!proto.google.protobuf.SourceCodeInfo.Location>} value */
    proto.google.protobuf.SourceCodeInfo.prototype.setLocationList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.google.protobuf.SourceCodeInfo.Location=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.SourceCodeInfo.Location}
     */
    proto.google.protobuf.SourceCodeInfo.prototype.addLocation = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.google.protobuf.SourceCodeInfo.Location, opt_index);
    };


    proto.google.protobuf.SourceCodeInfo.prototype.clearLocationList = function() {
      this.setLocationList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.GeneratedCodeInfo = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.GeneratedCodeInfo.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.GeneratedCodeInfo, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.GeneratedCodeInfo.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.GeneratedCodeInfo.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.GeneratedCodeInfo.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.GeneratedCodeInfo} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.GeneratedCodeInfo.toObject = function(includeInstance, msg) {
      var obj = {
        annotationList: googleProtobuf.Message.toObjectList(msg.getAnnotationList(),
        proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject, includeInstance)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.GeneratedCodeInfo}
     */
    proto.google.protobuf.GeneratedCodeInfo.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.GeneratedCodeInfo;
      return proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.GeneratedCodeInfo} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.GeneratedCodeInfo}
     */
    proto.google.protobuf.GeneratedCodeInfo.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.google.protobuf.GeneratedCodeInfo.Annotation;
          reader.readMessage(value,proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader);
          msg.addAnnotation(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.GeneratedCodeInfo.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.GeneratedCodeInfo} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.GeneratedCodeInfo.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAnnotationList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter
        );
      }
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_, null);
    };
    goog.inherits(proto.google.protobuf.GeneratedCodeInfo.Annotation, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.toObject = function(opt_includeInstance) {
      return proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.google.protobuf.GeneratedCodeInfo.Annotation} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.toObject = function(includeInstance, msg) {
      var obj = {
        pathList: googleProtobuf.Message.getRepeatedField(msg, 1),
        sourceFile: googleProtobuf.Message.getField(msg, 2),
        begin: googleProtobuf.Message.getField(msg, 3),
        end: googleProtobuf.Message.getField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.google.protobuf.GeneratedCodeInfo.Annotation}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.google.protobuf.GeneratedCodeInfo.Annotation;
      return proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.google.protobuf.GeneratedCodeInfo.Annotation} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.google.protobuf.GeneratedCodeInfo.Annotation}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Array<number>} */ (reader.readPackedInt32());
          msg.setPathList(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setSourceFile(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setBegin(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readInt32());
          msg.setEnd(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.google.protobuf.GeneratedCodeInfo.Annotation} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getPathList();
      if (f.length > 0) {
        writer.writePackedInt32(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeInt32(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeInt32(
          4,
          f
        );
      }
    };


    /**
     * repeated int32 path = 1;
     * @return {!Array<number>}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getPathList = function() {
      return /** @type {!Array<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array<number>} value */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setPathList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.addPath = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearPathList = function() {
      this.setPathList([]);
    };


    /**
     * optional string source_file = 2;
     * @return {string}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getSourceFile = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setSourceFile = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearSourceFile = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasSourceFile = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional int32 begin = 3;
     * @return {number}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getBegin = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setBegin = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearBegin = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasBegin = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional int32 end = 4;
     * @return {number}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.getEnd = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.setEnd = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.clearEnd = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.google.protobuf.GeneratedCodeInfo.Annotation.prototype.hasEnd = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * repeated Annotation annotation = 1;
     * @return {!Array<!proto.google.protobuf.GeneratedCodeInfo.Annotation>}
     */
    proto.google.protobuf.GeneratedCodeInfo.prototype.getAnnotationList = function() {
      return /** @type{!Array<!proto.google.protobuf.GeneratedCodeInfo.Annotation>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.google.protobuf.GeneratedCodeInfo.Annotation, 1));
    };


    /** @param {!Array<!proto.google.protobuf.GeneratedCodeInfo.Annotation>} value */
    proto.google.protobuf.GeneratedCodeInfo.prototype.setAnnotationList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.google.protobuf.GeneratedCodeInfo.Annotation=} opt_value
     * @param {number=} opt_index
     * @return {!proto.google.protobuf.GeneratedCodeInfo.Annotation}
     */
    proto.google.protobuf.GeneratedCodeInfo.prototype.addAnnotation = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.google.protobuf.GeneratedCodeInfo.Annotation, opt_index);
    };


    proto.google.protobuf.GeneratedCodeInfo.prototype.clearAnnotationList = function() {
      this.setAnnotationList([]);
    };


    goog.object.extend(exports, proto.google.protobuf);
    });

    var exchange_pb = createCommonjsModule(function (module, exports) {
    /**
     * @fileoverview
     * @enhanceable
     * @suppress {messageConventions} JS Compiler reports an error if a variable or
     *     field starts with 'MSG_' and isn't a translatable message.
     * @public
     */
    // GENERATED CODE -- DO NOT EDIT!


    var goog = googleProtobuf;
    var global = Function('return this')();

    goog.exportSymbol('proto.ExchangeAddress', null, global);
    goog.exportSymbol('proto.ExchangeResponse', null, global);
    goog.exportSymbol('proto.ExchangeResponseV2', null, global);
    goog.exportSymbol('proto.SignedExchangeResponse', null, global);

    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ExchangeAddress = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ExchangeAddress, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ExchangeAddress.prototype.toObject = function(opt_includeInstance) {
      return proto.ExchangeAddress.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ExchangeAddress} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeAddress.toObject = function(includeInstance, msg) {
      var obj = {
        coinType: googleProtobuf.Message.getField(msg, 1),
        address: googleProtobuf.Message.getField(msg, 2),
        destTag: googleProtobuf.Message.getField(msg, 3),
        rsAddress: googleProtobuf.Message.getField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ExchangeAddress}
     */
    proto.ExchangeAddress.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ExchangeAddress;
      return proto.ExchangeAddress.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ExchangeAddress} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ExchangeAddress}
     */
    proto.ExchangeAddress.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinType(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setDestTag(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setRsAddress(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ExchangeAddress.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ExchangeAddress.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ExchangeAddress} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeAddress.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
    };


    /**
     * optional string coin_type = 1;
     * @return {string}
     */
    proto.ExchangeAddress.prototype.getCoinType = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.ExchangeAddress.prototype.setCoinType = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.ExchangeAddress.prototype.clearCoinType = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeAddress.prototype.hasCoinType = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string address = 2;
     * @return {string}
     */
    proto.ExchangeAddress.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.ExchangeAddress.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ExchangeAddress.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeAddress.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string dest_tag = 3;
     * @return {string}
     */
    proto.ExchangeAddress.prototype.getDestTag = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.ExchangeAddress.prototype.setDestTag = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.ExchangeAddress.prototype.clearDestTag = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeAddress.prototype.hasDestTag = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string rs_address = 4;
     * @return {string}
     */
    proto.ExchangeAddress.prototype.getRsAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /** @param {string} value */
    proto.ExchangeAddress.prototype.setRsAddress = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.ExchangeAddress.prototype.clearRsAddress = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeAddress.prototype.hasRsAddress = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ExchangeResponseV2 = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ExchangeResponseV2, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ExchangeResponseV2.prototype.toObject = function(opt_includeInstance) {
      return proto.ExchangeResponseV2.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ExchangeResponseV2} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeResponseV2.toObject = function(includeInstance, msg) {
      var f, obj = {
        depositAddress: (f = msg.getDepositAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        depositAmount: msg.getDepositAmount_asB64(),
        expiration: googleProtobuf.Message.getField(msg, 3),
        quotedRate: msg.getQuotedRate_asB64(),
        withdrawalAddress: (f = msg.getWithdrawalAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        withdrawalAmount: msg.getWithdrawalAmount_asB64(),
        returnAddress: (f = msg.getReturnAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        apiKey: msg.getApiKey_asB64(),
        minerFee: msg.getMinerFee_asB64(),
        orderId: msg.getOrderId_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ExchangeResponseV2}
     */
    proto.ExchangeResponseV2.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ExchangeResponseV2;
      return proto.ExchangeResponseV2.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ExchangeResponseV2} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ExchangeResponseV2}
     */
    proto.ExchangeResponseV2.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setDepositAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setDepositAmount(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readInt64());
          msg.setExpiration(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setQuotedRate(value);
          break;
        case 5:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setWithdrawalAddress(value);
          break;
        case 6:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setWithdrawalAmount(value);
          break;
        case 7:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setReturnAddress(value);
          break;
        case 8:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setApiKey(value);
          break;
        case 9:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMinerFee(value);
          break;
        case 10:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setOrderId(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ExchangeResponseV2.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ExchangeResponseV2} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeResponseV2.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getDepositAddress();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeInt64(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
      f = message.getWithdrawalAddress();
      if (f != null) {
        writer.writeMessage(
          5,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBytes(
          6,
          f
        );
      }
      f = message.getReturnAddress();
      if (f != null) {
        writer.writeMessage(
          7,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeBytes(
          8,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeBytes(
          9,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeBytes(
          10,
          f
        );
      }
    };


    /**
     * optional ExchangeAddress deposit_address = 1;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponseV2.prototype.getDepositAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 1));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponseV2.prototype.setDepositAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.ExchangeResponseV2.prototype.clearDepositAddress = function() {
      this.setDepositAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasDepositAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes deposit_amount = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getDepositAmount = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes deposit_amount = 2;
     * This is a type-conversion wrapper around `getDepositAmount()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getDepositAmount_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getDepositAmount()));
    };


    /**
     * optional bytes deposit_amount = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getDepositAmount()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getDepositAmount_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getDepositAmount()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setDepositAmount = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ExchangeResponseV2.prototype.clearDepositAmount = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasDepositAmount = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional int64 expiration = 3;
     * @return {number}
     */
    proto.ExchangeResponseV2.prototype.getExpiration = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponseV2.prototype.setExpiration = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.ExchangeResponseV2.prototype.clearExpiration = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasExpiration = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bytes quoted_rate = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getQuotedRate = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * optional bytes quoted_rate = 4;
     * This is a type-conversion wrapper around `getQuotedRate()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getQuotedRate_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getQuotedRate()));
    };


    /**
     * optional bytes quoted_rate = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getQuotedRate()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getQuotedRate_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getQuotedRate()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setQuotedRate = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.ExchangeResponseV2.prototype.clearQuotedRate = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasQuotedRate = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional ExchangeAddress withdrawal_address = 5;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponseV2.prototype.getWithdrawalAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 5));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponseV2.prototype.setWithdrawalAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 5, value);
    };


    proto.ExchangeResponseV2.prototype.clearWithdrawalAddress = function() {
      this.setWithdrawalAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasWithdrawalAddress = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bytes withdrawal_amount = 6;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getWithdrawalAmount = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /**
     * optional bytes withdrawal_amount = 6;
     * This is a type-conversion wrapper around `getWithdrawalAmount()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getWithdrawalAmount_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getWithdrawalAmount()));
    };


    /**
     * optional bytes withdrawal_amount = 6;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getWithdrawalAmount()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getWithdrawalAmount_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getWithdrawalAmount()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setWithdrawalAmount = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.ExchangeResponseV2.prototype.clearWithdrawalAmount = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasWithdrawalAmount = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional ExchangeAddress return_address = 7;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponseV2.prototype.getReturnAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 7));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponseV2.prototype.setReturnAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 7, value);
    };


    proto.ExchangeResponseV2.prototype.clearReturnAddress = function() {
      this.setReturnAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasReturnAddress = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional bytes api_key = 8;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getApiKey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /**
     * optional bytes api_key = 8;
     * This is a type-conversion wrapper around `getApiKey()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getApiKey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getApiKey()));
    };


    /**
     * optional bytes api_key = 8;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getApiKey()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getApiKey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getApiKey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setApiKey = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.ExchangeResponseV2.prototype.clearApiKey = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasApiKey = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional bytes miner_fee = 9;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getMinerFee = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, ""));
    };


    /**
     * optional bytes miner_fee = 9;
     * This is a type-conversion wrapper around `getMinerFee()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getMinerFee_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMinerFee()));
    };


    /**
     * optional bytes miner_fee = 9;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMinerFee()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getMinerFee_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMinerFee()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setMinerFee = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.ExchangeResponseV2.prototype.clearMinerFee = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasMinerFee = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional bytes order_id = 10;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponseV2.prototype.getOrderId = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, ""));
    };


    /**
     * optional bytes order_id = 10;
     * This is a type-conversion wrapper around `getOrderId()`
     * @return {string}
     */
    proto.ExchangeResponseV2.prototype.getOrderId_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getOrderId()));
    };


    /**
     * optional bytes order_id = 10;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getOrderId()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponseV2.prototype.getOrderId_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getOrderId()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponseV2.prototype.setOrderId = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.ExchangeResponseV2.prototype.clearOrderId = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponseV2.prototype.hasOrderId = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SignedExchangeResponse = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.SignedExchangeResponse, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SignedExchangeResponse.prototype.toObject = function(opt_includeInstance) {
      return proto.SignedExchangeResponse.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SignedExchangeResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignedExchangeResponse.toObject = function(includeInstance, msg) {
      var f, obj = {
        response: (f = msg.getResponse()) && proto.ExchangeResponse.toObject(includeInstance, f),
        signature: msg.getSignature_asB64(),
        responsev2: (f = msg.getResponsev2()) && proto.ExchangeResponseV2.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SignedExchangeResponse}
     */
    proto.SignedExchangeResponse.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SignedExchangeResponse;
      return proto.SignedExchangeResponse.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SignedExchangeResponse} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SignedExchangeResponse}
     */
    proto.SignedExchangeResponse.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.ExchangeResponse;
          reader.readMessage(value,proto.ExchangeResponse.deserializeBinaryFromReader);
          msg.setResponse(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        case 3:
          var value = new proto.ExchangeResponseV2;
          reader.readMessage(value,proto.ExchangeResponseV2.deserializeBinaryFromReader);
          msg.setResponsev2(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SignedExchangeResponse.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SignedExchangeResponse.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SignedExchangeResponse} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignedExchangeResponse.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getResponse();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          proto.ExchangeResponse.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = message.getResponsev2();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          proto.ExchangeResponseV2.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional ExchangeResponse response = 1;
     * @return {?proto.ExchangeResponse}
     */
    proto.SignedExchangeResponse.prototype.getResponse = function() {
      return /** @type{?proto.ExchangeResponse} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeResponse, 1));
    };


    /** @param {?proto.ExchangeResponse|undefined} value */
    proto.SignedExchangeResponse.prototype.setResponse = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.SignedExchangeResponse.prototype.clearResponse = function() {
      this.setResponse(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedExchangeResponse.prototype.hasResponse = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.SignedExchangeResponse.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.SignedExchangeResponse.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.SignedExchangeResponse.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.SignedExchangeResponse.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.SignedExchangeResponse.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedExchangeResponse.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional ExchangeResponseV2 responseV2 = 3;
     * @return {?proto.ExchangeResponseV2}
     */
    proto.SignedExchangeResponse.prototype.getResponsev2 = function() {
      return /** @type{?proto.ExchangeResponseV2} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeResponseV2, 3));
    };


    /** @param {?proto.ExchangeResponseV2|undefined} value */
    proto.SignedExchangeResponse.prototype.setResponsev2 = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.SignedExchangeResponse.prototype.clearResponsev2 = function() {
      this.setResponsev2(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedExchangeResponse.prototype.hasResponsev2 = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ExchangeResponse = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ExchangeResponse, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ExchangeResponse.prototype.toObject = function(opt_includeInstance) {
      return proto.ExchangeResponse.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ExchangeResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeResponse.toObject = function(includeInstance, msg) {
      var f, obj = {
        depositAddress: (f = msg.getDepositAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        depositAmount: googleProtobuf.Message.getField(msg, 2),
        expiration: googleProtobuf.Message.getField(msg, 3),
        quotedRate: googleProtobuf.Message.getField(msg, 4),
        withdrawalAddress: (f = msg.getWithdrawalAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        withdrawalAmount: googleProtobuf.Message.getField(msg, 6),
        returnAddress: (f = msg.getReturnAddress()) && proto.ExchangeAddress.toObject(includeInstance, f),
        apiKey: msg.getApiKey_asB64(),
        minerFee: googleProtobuf.Message.getField(msg, 9),
        orderId: msg.getOrderId_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ExchangeResponse}
     */
    proto.ExchangeResponse.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ExchangeResponse;
      return proto.ExchangeResponse.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ExchangeResponse} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ExchangeResponse}
     */
    proto.ExchangeResponse.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setDepositAddress(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setDepositAmount(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readInt64());
          msg.setExpiration(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setQuotedRate(value);
          break;
        case 5:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setWithdrawalAddress(value);
          break;
        case 6:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setWithdrawalAmount(value);
          break;
        case 7:
          var value = new proto.ExchangeAddress;
          reader.readMessage(value,proto.ExchangeAddress.deserializeBinaryFromReader);
          msg.setReturnAddress(value);
          break;
        case 8:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setApiKey(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setMinerFee(value);
          break;
        case 10:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setOrderId(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ExchangeResponse.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ExchangeResponse.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ExchangeResponse} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeResponse.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getDepositAddress();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint64(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeInt64(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint64(
          4,
          f
        );
      }
      f = message.getWithdrawalAddress();
      if (f != null) {
        writer.writeMessage(
          5,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeUint64(
          6,
          f
        );
      }
      f = message.getReturnAddress();
      if (f != null) {
        writer.writeMessage(
          7,
          f,
          proto.ExchangeAddress.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeBytes(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint64(
          9,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeBytes(
          10,
          f
        );
      }
    };


    /**
     * optional ExchangeAddress deposit_address = 1;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponse.prototype.getDepositAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 1));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponse.prototype.setDepositAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.ExchangeResponse.prototype.clearDepositAddress = function() {
      this.setDepositAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasDepositAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint64 deposit_amount = 2;
     * @return {number}
     */
    proto.ExchangeResponse.prototype.getDepositAmount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponse.prototype.setDepositAmount = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ExchangeResponse.prototype.clearDepositAmount = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasDepositAmount = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional int64 expiration = 3;
     * @return {number}
     */
    proto.ExchangeResponse.prototype.getExpiration = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponse.prototype.setExpiration = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.ExchangeResponse.prototype.clearExpiration = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasExpiration = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint64 quoted_rate = 4;
     * @return {number}
     */
    proto.ExchangeResponse.prototype.getQuotedRate = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponse.prototype.setQuotedRate = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.ExchangeResponse.prototype.clearQuotedRate = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasQuotedRate = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional ExchangeAddress withdrawal_address = 5;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponse.prototype.getWithdrawalAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 5));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponse.prototype.setWithdrawalAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 5, value);
    };


    proto.ExchangeResponse.prototype.clearWithdrawalAddress = function() {
      this.setWithdrawalAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasWithdrawalAddress = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional uint64 withdrawal_amount = 6;
     * @return {number}
     */
    proto.ExchangeResponse.prototype.getWithdrawalAmount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponse.prototype.setWithdrawalAmount = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.ExchangeResponse.prototype.clearWithdrawalAmount = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasWithdrawalAmount = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional ExchangeAddress return_address = 7;
     * @return {?proto.ExchangeAddress}
     */
    proto.ExchangeResponse.prototype.getReturnAddress = function() {
      return /** @type{?proto.ExchangeAddress} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeAddress, 7));
    };


    /** @param {?proto.ExchangeAddress|undefined} value */
    proto.ExchangeResponse.prototype.setReturnAddress = function(value) {
      googleProtobuf.Message.setWrapperField(this, 7, value);
    };


    proto.ExchangeResponse.prototype.clearReturnAddress = function() {
      this.setReturnAddress(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasReturnAddress = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional bytes api_key = 8;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponse.prototype.getApiKey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /**
     * optional bytes api_key = 8;
     * This is a type-conversion wrapper around `getApiKey()`
     * @return {string}
     */
    proto.ExchangeResponse.prototype.getApiKey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getApiKey()));
    };


    /**
     * optional bytes api_key = 8;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getApiKey()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponse.prototype.getApiKey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getApiKey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponse.prototype.setApiKey = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.ExchangeResponse.prototype.clearApiKey = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasApiKey = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint64 miner_fee = 9;
     * @return {number}
     */
    proto.ExchangeResponse.prototype.getMinerFee = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.ExchangeResponse.prototype.setMinerFee = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.ExchangeResponse.prototype.clearMinerFee = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasMinerFee = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional bytes order_id = 10;
     * @return {!(string|Uint8Array)}
     */
    proto.ExchangeResponse.prototype.getOrderId = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, ""));
    };


    /**
     * optional bytes order_id = 10;
     * This is a type-conversion wrapper around `getOrderId()`
     * @return {string}
     */
    proto.ExchangeResponse.prototype.getOrderId_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getOrderId()));
    };


    /**
     * optional bytes order_id = 10;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getOrderId()`
     * @return {!Uint8Array}
     */
    proto.ExchangeResponse.prototype.getOrderId_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getOrderId()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.ExchangeResponse.prototype.setOrderId = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.ExchangeResponse.prototype.clearOrderId = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeResponse.prototype.hasOrderId = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    goog.object.extend(exports, proto);
    });

    var types_pb = createCommonjsModule(function (module, exports) {
    /**
     * @fileoverview
     * @enhanceable
     * @suppress {messageConventions} JS Compiler reports an error if a variable or
     *     field starts with 'MSG_' and isn't a translatable message.
     * @public
     */
    // GENERATED CODE -- DO NOT EDIT!


    var goog = googleProtobuf;
    var global = Function('return this')();



    goog.exportSymbol('proto.ButtonRequestType', null, global);
    goog.exportSymbol('proto.CoinType', null, global);
    goog.exportSymbol('proto.ExchangeType', null, global);
    goog.exportSymbol('proto.FailureType', null, global);
    goog.exportSymbol('proto.HDNodePathType', null, global);
    goog.exportSymbol('proto.HDNodeType', null, global);
    goog.exportSymbol('proto.IdentityType', null, global);
    goog.exportSymbol('proto.InputScriptType', null, global);
    goog.exportSymbol('proto.MultisigRedeemScriptType', null, global);
    goog.exportSymbol('proto.OutputAddressType', null, global);
    goog.exportSymbol('proto.OutputScriptType', null, global);
    goog.exportSymbol('proto.PinMatrixRequestType', null, global);
    goog.exportSymbol('proto.PolicyType', null, global);
    goog.exportSymbol('proto.RawTransactionType', null, global);
    goog.exportSymbol('proto.RequestType', null, global);
    goog.exportSymbol('proto.TransactionType', null, global);
    goog.exportSymbol('proto.TxInputType', null, global);
    goog.exportSymbol('proto.TxOutputBinType', null, global);
    goog.exportSymbol('proto.TxOutputType', null, global);
    goog.exportSymbol('proto.TxRequestDetailsType', null, global);
    goog.exportSymbol('proto.TxRequestSerializedType', null, global);
    goog.exportSymbol('proto.wireDebugIn', null, global);
    goog.exportSymbol('proto.wireDebugOut', null, global);
    goog.exportSymbol('proto.wireIn', null, global);
    goog.exportSymbol('proto.wireOut', null, global);

    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.HDNodeType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.HDNodeType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.HDNodeType.prototype.toObject = function(opt_includeInstance) {
      return proto.HDNodeType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.HDNodeType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.HDNodeType.toObject = function(includeInstance, msg) {
      var obj = {
        depth: googleProtobuf.Message.getField(msg, 1),
        fingerprint: googleProtobuf.Message.getField(msg, 2),
        childNum: googleProtobuf.Message.getField(msg, 3),
        chainCode: msg.getChainCode_asB64(),
        privateKey: msg.getPrivateKey_asB64(),
        publicKey: msg.getPublicKey_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.HDNodeType}
     */
    proto.HDNodeType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.HDNodeType;
      return proto.HDNodeType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.HDNodeType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.HDNodeType}
     */
    proto.HDNodeType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDepth(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setFingerprint(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setChildNum(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setChainCode(value);
          break;
        case 5:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPrivateKey(value);
          break;
        case 6:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPublicKey(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.HDNodeType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.HDNodeType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.HDNodeType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.HDNodeType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBytes(
          5,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBytes(
          6,
          f
        );
      }
    };


    /**
     * required uint32 depth = 1;
     * @return {number}
     */
    proto.HDNodeType.prototype.getDepth = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.HDNodeType.prototype.setDepth = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.HDNodeType.prototype.clearDepth = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasDepth = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required uint32 fingerprint = 2;
     * @return {number}
     */
    proto.HDNodeType.prototype.getFingerprint = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.HDNodeType.prototype.setFingerprint = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.HDNodeType.prototype.clearFingerprint = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasFingerprint = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * required uint32 child_num = 3;
     * @return {number}
     */
    proto.HDNodeType.prototype.getChildNum = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.HDNodeType.prototype.setChildNum = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.HDNodeType.prototype.clearChildNum = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasChildNum = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * required bytes chain_code = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.HDNodeType.prototype.getChainCode = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * required bytes chain_code = 4;
     * This is a type-conversion wrapper around `getChainCode()`
     * @return {string}
     */
    proto.HDNodeType.prototype.getChainCode_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getChainCode()));
    };


    /**
     * required bytes chain_code = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getChainCode()`
     * @return {!Uint8Array}
     */
    proto.HDNodeType.prototype.getChainCode_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getChainCode()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.HDNodeType.prototype.setChainCode = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.HDNodeType.prototype.clearChainCode = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasChainCode = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bytes private_key = 5;
     * @return {!(string|Uint8Array)}
     */
    proto.HDNodeType.prototype.getPrivateKey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, ""));
    };


    /**
     * optional bytes private_key = 5;
     * This is a type-conversion wrapper around `getPrivateKey()`
     * @return {string}
     */
    proto.HDNodeType.prototype.getPrivateKey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPrivateKey()));
    };


    /**
     * optional bytes private_key = 5;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPrivateKey()`
     * @return {!Uint8Array}
     */
    proto.HDNodeType.prototype.getPrivateKey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPrivateKey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.HDNodeType.prototype.setPrivateKey = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.HDNodeType.prototype.clearPrivateKey = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasPrivateKey = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bytes public_key = 6;
     * @return {!(string|Uint8Array)}
     */
    proto.HDNodeType.prototype.getPublicKey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /**
     * optional bytes public_key = 6;
     * This is a type-conversion wrapper around `getPublicKey()`
     * @return {string}
     */
    proto.HDNodeType.prototype.getPublicKey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPublicKey()));
    };


    /**
     * optional bytes public_key = 6;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPublicKey()`
     * @return {!Uint8Array}
     */
    proto.HDNodeType.prototype.getPublicKey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPublicKey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.HDNodeType.prototype.setPublicKey = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.HDNodeType.prototype.clearPublicKey = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodeType.prototype.hasPublicKey = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.HDNodePathType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.HDNodePathType.repeatedFields_, null);
    };
    goog.inherits(proto.HDNodePathType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.HDNodePathType.repeatedFields_ = [2];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.HDNodePathType.prototype.toObject = function(opt_includeInstance) {
      return proto.HDNodePathType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.HDNodePathType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.HDNodePathType.toObject = function(includeInstance, msg) {
      var f, obj = {
        node: (f = msg.getNode()) && proto.HDNodeType.toObject(includeInstance, f),
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.HDNodePathType}
     */
    proto.HDNodePathType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.HDNodePathType;
      return proto.HDNodePathType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.HDNodePathType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.HDNodePathType}
     */
    proto.HDNodePathType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.HDNodeType;
          reader.readMessage(value,proto.HDNodeType.deserializeBinaryFromReader);
          msg.setNode(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.HDNodePathType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.HDNodePathType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.HDNodePathType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.HDNodePathType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getNode();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          proto.HDNodeType.serializeBinaryToWriter
        );
      }
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          2,
          f
        );
      }
    };


    /**
     * required HDNodeType node = 1;
     * @return {!proto.HDNodeType}
     */
    proto.HDNodePathType.prototype.getNode = function() {
      return /** @type{!proto.HDNodeType} */ (
        googleProtobuf.Message.getWrapperField(this, proto.HDNodeType, 1, 1));
    };


    /** @param {!proto.HDNodeType} value */
    proto.HDNodePathType.prototype.setNode = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.HDNodePathType.prototype.clearNode = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.HDNodePathType.prototype.hasNode = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated uint32 address_n = 2;
     * @return {!Array.<number>}
     */
    proto.HDNodePathType.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 2));
    };


    /** @param {!Array.<number>} value */
    proto.HDNodePathType.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 2, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.HDNodePathType.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
    };


    proto.HDNodePathType.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CoinType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.CoinType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CoinType.prototype.toObject = function(opt_includeInstance) {
      return proto.CoinType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CoinType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CoinType.toObject = function(includeInstance, msg) {
      var obj = {
        coinName: googleProtobuf.Message.getField(msg, 1),
        coinShortcut: googleProtobuf.Message.getField(msg, 2),
        addressType: googleProtobuf.Message.getFieldWithDefault(msg, 3, 0),
        maxfeeKb: googleProtobuf.Message.getField(msg, 4),
        addressTypeP2sh: googleProtobuf.Message.getFieldWithDefault(msg, 5, 5),
        signedMessageHeader: googleProtobuf.Message.getField(msg, 8),
        bip44AccountPath: googleProtobuf.Message.getField(msg, 9),
        forkid: googleProtobuf.Message.getField(msg, 12),
        decimals: googleProtobuf.Message.getField(msg, 13),
        contractAddress: msg.getContractAddress_asB64(),
        xpubMagic: googleProtobuf.Message.getFieldWithDefault(msg, 16, 76067358),
        segwit: googleProtobuf.Message.getField(msg, 18),
        forceBip143: googleProtobuf.Message.getField(msg, 19),
        curveName: googleProtobuf.Message.getField(msg, 20),
        cashaddrPrefix: googleProtobuf.Message.getField(msg, 21),
        bech32Prefix: googleProtobuf.Message.getField(msg, 22),
        decred: googleProtobuf.Message.getField(msg, 23),
        xpubMagicSegwitP2sh: googleProtobuf.Message.getField(msg, 25),
        xpubMagicSegwitNative: googleProtobuf.Message.getField(msg, 26)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CoinType}
     */
    proto.CoinType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CoinType;
      return proto.CoinType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CoinType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CoinType}
     */
    proto.CoinType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinShortcut(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAddressType(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setMaxfeeKb(value);
          break;
        case 5:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAddressTypeP2sh(value);
          break;
        case 8:
          var value = /** @type {string} */ (reader.readString());
          msg.setSignedMessageHeader(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setBip44AccountPath(value);
          break;
        case 12:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setForkid(value);
          break;
        case 13:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDecimals(value);
          break;
        case 14:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setContractAddress(value);
          break;
        case 16:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setXpubMagic(value);
          break;
        case 18:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setSegwit(value);
          break;
        case 19:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setForceBip143(value);
          break;
        case 20:
          var value = /** @type {string} */ (reader.readString());
          msg.setCurveName(value);
          break;
        case 21:
          var value = /** @type {string} */ (reader.readString());
          msg.setCashaddrPrefix(value);
          break;
        case 22:
          var value = /** @type {string} */ (reader.readString());
          msg.setBech32Prefix(value);
          break;
        case 23:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDecred(value);
          break;
        case 25:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setXpubMagicSegwitP2sh(value);
          break;
        case 26:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setXpubMagicSegwitNative(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CoinType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CoinType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CoinType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CoinType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint64(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeUint32(
          5,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeString(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 12));
      if (f != null) {
        writer.writeUint32(
          12,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 13));
      if (f != null) {
        writer.writeUint32(
          13,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 14));
      if (f != null) {
        writer.writeBytes(
          14,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 16));
      if (f != null) {
        writer.writeUint32(
          16,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 18));
      if (f != null) {
        writer.writeBool(
          18,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 19));
      if (f != null) {
        writer.writeBool(
          19,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 20));
      if (f != null) {
        writer.writeString(
          20,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 21));
      if (f != null) {
        writer.writeString(
          21,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 22));
      if (f != null) {
        writer.writeString(
          22,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 23));
      if (f != null) {
        writer.writeBool(
          23,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 25));
      if (f != null) {
        writer.writeUint32(
          25,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 26));
      if (f != null) {
        writer.writeUint32(
          26,
          f
        );
      }
    };


    /**
     * optional string coin_name = 1;
     * @return {string}
     */
    proto.CoinType.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.CoinType.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string coin_shortcut = 2;
     * @return {string}
     */
    proto.CoinType.prototype.getCoinShortcut = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setCoinShortcut = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.CoinType.prototype.clearCoinShortcut = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasCoinShortcut = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional uint32 address_type = 3;
     * @return {number}
     */
    proto.CoinType.prototype.getAddressType = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setAddressType = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.CoinType.prototype.clearAddressType = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasAddressType = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint64 maxfee_kb = 4;
     * @return {number}
     */
    proto.CoinType.prototype.getMaxfeeKb = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setMaxfeeKb = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.CoinType.prototype.clearMaxfeeKb = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasMaxfeeKb = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional uint32 address_type_p2sh = 5;
     * @return {number}
     */
    proto.CoinType.prototype.getAddressTypeP2sh = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 5));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setAddressTypeP2sh = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.CoinType.prototype.clearAddressTypeP2sh = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasAddressTypeP2sh = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional string signed_message_header = 8;
     * @return {string}
     */
    proto.CoinType.prototype.getSignedMessageHeader = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setSignedMessageHeader = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.CoinType.prototype.clearSignedMessageHeader = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasSignedMessageHeader = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 bip44_account_path = 9;
     * @return {number}
     */
    proto.CoinType.prototype.getBip44AccountPath = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setBip44AccountPath = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.CoinType.prototype.clearBip44AccountPath = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasBip44AccountPath = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional uint32 forkid = 12;
     * @return {number}
     */
    proto.CoinType.prototype.getForkid = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 12, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setForkid = function(value) {
      googleProtobuf.Message.setField(this, 12, value);
    };


    proto.CoinType.prototype.clearForkid = function() {
      googleProtobuf.Message.setField(this, 12, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasForkid = function() {
      return googleProtobuf.Message.getField(this, 12) != null;
    };


    /**
     * optional uint32 decimals = 13;
     * @return {number}
     */
    proto.CoinType.prototype.getDecimals = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 13, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setDecimals = function(value) {
      googleProtobuf.Message.setField(this, 13, value);
    };


    proto.CoinType.prototype.clearDecimals = function() {
      googleProtobuf.Message.setField(this, 13, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasDecimals = function() {
      return googleProtobuf.Message.getField(this, 13) != null;
    };


    /**
     * optional bytes contract_address = 14;
     * @return {!(string|Uint8Array)}
     */
    proto.CoinType.prototype.getContractAddress = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 14, ""));
    };


    /**
     * optional bytes contract_address = 14;
     * This is a type-conversion wrapper around `getContractAddress()`
     * @return {string}
     */
    proto.CoinType.prototype.getContractAddress_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getContractAddress()));
    };


    /**
     * optional bytes contract_address = 14;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getContractAddress()`
     * @return {!Uint8Array}
     */
    proto.CoinType.prototype.getContractAddress_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getContractAddress()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.CoinType.prototype.setContractAddress = function(value) {
      googleProtobuf.Message.setField(this, 14, value);
    };


    proto.CoinType.prototype.clearContractAddress = function() {
      googleProtobuf.Message.setField(this, 14, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasContractAddress = function() {
      return googleProtobuf.Message.getField(this, 14) != null;
    };


    /**
     * optional uint32 xpub_magic = 16;
     * @return {number}
     */
    proto.CoinType.prototype.getXpubMagic = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 16, 76067358));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setXpubMagic = function(value) {
      googleProtobuf.Message.setField(this, 16, value);
    };


    proto.CoinType.prototype.clearXpubMagic = function() {
      googleProtobuf.Message.setField(this, 16, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasXpubMagic = function() {
      return googleProtobuf.Message.getField(this, 16) != null;
    };


    /**
     * optional bool segwit = 18;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CoinType.prototype.getSegwit = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 18, false));
    };


    /** @param {boolean} value */
    proto.CoinType.prototype.setSegwit = function(value) {
      googleProtobuf.Message.setField(this, 18, value);
    };


    proto.CoinType.prototype.clearSegwit = function() {
      googleProtobuf.Message.setField(this, 18, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasSegwit = function() {
      return googleProtobuf.Message.getField(this, 18) != null;
    };


    /**
     * optional bool force_bip143 = 19;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CoinType.prototype.getForceBip143 = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 19, false));
    };


    /** @param {boolean} value */
    proto.CoinType.prototype.setForceBip143 = function(value) {
      googleProtobuf.Message.setField(this, 19, value);
    };


    proto.CoinType.prototype.clearForceBip143 = function() {
      googleProtobuf.Message.setField(this, 19, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasForceBip143 = function() {
      return googleProtobuf.Message.getField(this, 19) != null;
    };


    /**
     * optional string curve_name = 20;
     * @return {string}
     */
    proto.CoinType.prototype.getCurveName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 20, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setCurveName = function(value) {
      googleProtobuf.Message.setField(this, 20, value);
    };


    proto.CoinType.prototype.clearCurveName = function() {
      googleProtobuf.Message.setField(this, 20, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasCurveName = function() {
      return googleProtobuf.Message.getField(this, 20) != null;
    };


    /**
     * optional string cashaddr_prefix = 21;
     * @return {string}
     */
    proto.CoinType.prototype.getCashaddrPrefix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 21, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setCashaddrPrefix = function(value) {
      googleProtobuf.Message.setField(this, 21, value);
    };


    proto.CoinType.prototype.clearCashaddrPrefix = function() {
      googleProtobuf.Message.setField(this, 21, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasCashaddrPrefix = function() {
      return googleProtobuf.Message.getField(this, 21) != null;
    };


    /**
     * optional string bech32_prefix = 22;
     * @return {string}
     */
    proto.CoinType.prototype.getBech32Prefix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 22, ""));
    };


    /** @param {string} value */
    proto.CoinType.prototype.setBech32Prefix = function(value) {
      googleProtobuf.Message.setField(this, 22, value);
    };


    proto.CoinType.prototype.clearBech32Prefix = function() {
      googleProtobuf.Message.setField(this, 22, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasBech32Prefix = function() {
      return googleProtobuf.Message.getField(this, 22) != null;
    };


    /**
     * optional bool decred = 23;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CoinType.prototype.getDecred = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 23, false));
    };


    /** @param {boolean} value */
    proto.CoinType.prototype.setDecred = function(value) {
      googleProtobuf.Message.setField(this, 23, value);
    };


    proto.CoinType.prototype.clearDecred = function() {
      googleProtobuf.Message.setField(this, 23, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasDecred = function() {
      return googleProtobuf.Message.getField(this, 23) != null;
    };


    /**
     * optional uint32 xpub_magic_segwit_p2sh = 25;
     * @return {number}
     */
    proto.CoinType.prototype.getXpubMagicSegwitP2sh = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 25, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setXpubMagicSegwitP2sh = function(value) {
      googleProtobuf.Message.setField(this, 25, value);
    };


    proto.CoinType.prototype.clearXpubMagicSegwitP2sh = function() {
      googleProtobuf.Message.setField(this, 25, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasXpubMagicSegwitP2sh = function() {
      return googleProtobuf.Message.getField(this, 25) != null;
    };


    /**
     * optional uint32 xpub_magic_segwit_native = 26;
     * @return {number}
     */
    proto.CoinType.prototype.getXpubMagicSegwitNative = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 26, 0));
    };


    /** @param {number} value */
    proto.CoinType.prototype.setXpubMagicSegwitNative = function(value) {
      googleProtobuf.Message.setField(this, 26, value);
    };


    proto.CoinType.prototype.clearXpubMagicSegwitNative = function() {
      googleProtobuf.Message.setField(this, 26, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinType.prototype.hasXpubMagicSegwitNative = function() {
      return googleProtobuf.Message.getField(this, 26) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.MultisigRedeemScriptType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.MultisigRedeemScriptType.repeatedFields_, null);
    };
    goog.inherits(proto.MultisigRedeemScriptType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.MultisigRedeemScriptType.repeatedFields_ = [1,2];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.MultisigRedeemScriptType.prototype.toObject = function(opt_includeInstance) {
      return proto.MultisigRedeemScriptType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.MultisigRedeemScriptType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.MultisigRedeemScriptType.toObject = function(includeInstance, msg) {
      var obj = {
        pubkeysList: googleProtobuf.Message.toObjectList(msg.getPubkeysList(),
        proto.HDNodePathType.toObject, includeInstance),
        signaturesList: msg.getSignaturesList_asB64(),
        m: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.MultisigRedeemScriptType}
     */
    proto.MultisigRedeemScriptType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.MultisigRedeemScriptType;
      return proto.MultisigRedeemScriptType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.MultisigRedeemScriptType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.MultisigRedeemScriptType}
     */
    proto.MultisigRedeemScriptType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new proto.HDNodePathType;
          reader.readMessage(value,proto.HDNodePathType.deserializeBinaryFromReader);
          msg.addPubkeys(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.addSignatures(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setM(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.MultisigRedeemScriptType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.MultisigRedeemScriptType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.MultisigRedeemScriptType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.MultisigRedeemScriptType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getPubkeysList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          proto.HDNodePathType.serializeBinaryToWriter
        );
      }
      f = message.getSignaturesList_asU8();
      if (f.length > 0) {
        writer.writeRepeatedBytes(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
    };


    /**
     * repeated HDNodePathType pubkeys = 1;
     * @return {!Array.<!proto.HDNodePathType>}
     */
    proto.MultisigRedeemScriptType.prototype.getPubkeysList = function() {
      return /** @type{!Array.<!proto.HDNodePathType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.HDNodePathType, 1));
    };


    /** @param {!Array.<!proto.HDNodePathType>} value */
    proto.MultisigRedeemScriptType.prototype.setPubkeysList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.HDNodePathType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.HDNodePathType}
     */
    proto.MultisigRedeemScriptType.prototype.addPubkeys = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.HDNodePathType, opt_index);
    };


    proto.MultisigRedeemScriptType.prototype.clearPubkeysList = function() {
      this.setPubkeysList([]);
    };


    /**
     * repeated bytes signatures = 2;
     * @return {!(Array<!Uint8Array>|Array<string>)}
     */
    proto.MultisigRedeemScriptType.prototype.getSignaturesList = function() {
      return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (googleProtobuf.Message.getRepeatedField(this, 2));
    };


    /**
     * repeated bytes signatures = 2;
     * This is a type-conversion wrapper around `getSignaturesList()`
     * @return {!Array.<string>}
     */
    proto.MultisigRedeemScriptType.prototype.getSignaturesList_asB64 = function() {
      return /** @type {!Array.<string>} */ (googleProtobuf.Message.bytesListAsB64(
          this.getSignaturesList()));
    };


    /**
     * repeated bytes signatures = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignaturesList()`
     * @return {!Array.<!Uint8Array>}
     */
    proto.MultisigRedeemScriptType.prototype.getSignaturesList_asU8 = function() {
      return /** @type {!Array.<!Uint8Array>} */ (googleProtobuf.Message.bytesListAsU8(
          this.getSignaturesList()));
    };


    /** @param {!(Array<!Uint8Array>|Array<string>)} value */
    proto.MultisigRedeemScriptType.prototype.setSignaturesList = function(value) {
      googleProtobuf.Message.setField(this, 2, value || []);
    };


    /**
     * @param {!(string|Uint8Array)} value
     * @param {number=} opt_index
     */
    proto.MultisigRedeemScriptType.prototype.addSignatures = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
    };


    proto.MultisigRedeemScriptType.prototype.clearSignaturesList = function() {
      this.setSignaturesList([]);
    };


    /**
     * optional uint32 m = 3;
     * @return {number}
     */
    proto.MultisigRedeemScriptType.prototype.getM = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.MultisigRedeemScriptType.prototype.setM = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.MultisigRedeemScriptType.prototype.clearM = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.MultisigRedeemScriptType.prototype.hasM = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxInputType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.TxInputType.repeatedFields_, null);
    };
    goog.inherits(proto.TxInputType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.TxInputType.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxInputType.prototype.toObject = function(opt_includeInstance) {
      return proto.TxInputType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxInputType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxInputType.toObject = function(includeInstance, msg) {
      var f, obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        prevHash: msg.getPrevHash_asB64(),
        prevIndex: googleProtobuf.Message.getField(msg, 3),
        scriptSig: msg.getScriptSig_asB64(),
        sequence: googleProtobuf.Message.getFieldWithDefault(msg, 5, -1),
        scriptType: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0),
        multisig: (f = msg.getMultisig()) && proto.MultisigRedeemScriptType.toObject(includeInstance, f),
        amount: googleProtobuf.Message.getField(msg, 8),
        decredTree: googleProtobuf.Message.getField(msg, 9),
        decredScriptVersion: googleProtobuf.Message.getField(msg, 10)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxInputType}
     */
    proto.TxInputType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxInputType;
      return proto.TxInputType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxInputType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxInputType}
     */
    proto.TxInputType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPrevHash(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setPrevIndex(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setScriptSig(value);
          break;
        case 5:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setSequence(value);
          break;
        case 6:
          var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
          msg.setScriptType(value);
          break;
        case 7:
          var value = new proto.MultisigRedeemScriptType;
          reader.readMessage(value,proto.MultisigRedeemScriptType.deserializeBinaryFromReader);
          msg.setMultisig(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setAmount(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDecredTree(value);
          break;
        case 10:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDecredScriptVersion(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxInputType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxInputType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxInputType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxInputType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeUint32(
          5,
          f
        );
      }
      f = /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeEnum(
          6,
          f
        );
      }
      f = message.getMultisig();
      if (f != null) {
        writer.writeMessage(
          7,
          f,
          proto.MultisigRedeemScriptType.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint64(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeUint32(
          10,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.TxInputType.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.TxInputType.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.TxInputType.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.TxInputType.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * required bytes prev_hash = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.TxInputType.prototype.getPrevHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * required bytes prev_hash = 2;
     * This is a type-conversion wrapper around `getPrevHash()`
     * @return {string}
     */
    proto.TxInputType.prototype.getPrevHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPrevHash()));
    };


    /**
     * required bytes prev_hash = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPrevHash()`
     * @return {!Uint8Array}
     */
    proto.TxInputType.prototype.getPrevHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPrevHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxInputType.prototype.setPrevHash = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.TxInputType.prototype.clearPrevHash = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasPrevHash = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * required uint32 prev_index = 3;
     * @return {number}
     */
    proto.TxInputType.prototype.getPrevIndex = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.TxInputType.prototype.setPrevIndex = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.TxInputType.prototype.clearPrevIndex = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasPrevIndex = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bytes script_sig = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.TxInputType.prototype.getScriptSig = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * optional bytes script_sig = 4;
     * This is a type-conversion wrapper around `getScriptSig()`
     * @return {string}
     */
    proto.TxInputType.prototype.getScriptSig_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getScriptSig()));
    };


    /**
     * optional bytes script_sig = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getScriptSig()`
     * @return {!Uint8Array}
     */
    proto.TxInputType.prototype.getScriptSig_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getScriptSig()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxInputType.prototype.setScriptSig = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.TxInputType.prototype.clearScriptSig = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasScriptSig = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional uint32 sequence = 5;
     * @return {number}
     */
    proto.TxInputType.prototype.getSequence = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, -1));
    };


    /** @param {number} value */
    proto.TxInputType.prototype.setSequence = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.TxInputType.prototype.clearSequence = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasSequence = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional InputScriptType script_type = 6;
     * @return {!proto.InputScriptType}
     */
    proto.TxInputType.prototype.getScriptType = function() {
      return /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {!proto.InputScriptType} value */
    proto.TxInputType.prototype.setScriptType = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.TxInputType.prototype.clearScriptType = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasScriptType = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional MultisigRedeemScriptType multisig = 7;
     * @return {?proto.MultisigRedeemScriptType}
     */
    proto.TxInputType.prototype.getMultisig = function() {
      return /** @type{?proto.MultisigRedeemScriptType} */ (
        googleProtobuf.Message.getWrapperField(this, proto.MultisigRedeemScriptType, 7));
    };


    /** @param {?proto.MultisigRedeemScriptType|undefined} value */
    proto.TxInputType.prototype.setMultisig = function(value) {
      googleProtobuf.Message.setWrapperField(this, 7, value);
    };


    proto.TxInputType.prototype.clearMultisig = function() {
      this.setMultisig(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasMultisig = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint64 amount = 8;
     * @return {number}
     */
    proto.TxInputType.prototype.getAmount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.TxInputType.prototype.setAmount = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.TxInputType.prototype.clearAmount = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasAmount = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 decred_tree = 9;
     * @return {number}
     */
    proto.TxInputType.prototype.getDecredTree = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.TxInputType.prototype.setDecredTree = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.TxInputType.prototype.clearDecredTree = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasDecredTree = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional uint32 decred_script_version = 10;
     * @return {number}
     */
    proto.TxInputType.prototype.getDecredScriptVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, 0));
    };


    /** @param {number} value */
    proto.TxInputType.prototype.setDecredScriptVersion = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.TxInputType.prototype.clearDecredScriptVersion = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxInputType.prototype.hasDecredScriptVersion = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxOutputType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.TxOutputType.repeatedFields_, null);
    };
    goog.inherits(proto.TxOutputType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.TxOutputType.repeatedFields_ = [2];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxOutputType.prototype.toObject = function(opt_includeInstance) {
      return proto.TxOutputType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxOutputType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxOutputType.toObject = function(includeInstance, msg) {
      var f, obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 2),
        amount: googleProtobuf.Message.getField(msg, 3),
        scriptType: googleProtobuf.Message.getField(msg, 4),
        multisig: (f = msg.getMultisig()) && proto.MultisigRedeemScriptType.toObject(includeInstance, f),
        opReturnData: msg.getOpReturnData_asB64(),
        addressType: googleProtobuf.Message.getField(msg, 7),
        exchangeType: (f = msg.getExchangeType()) && proto.ExchangeType.toObject(includeInstance, f),
        decredScriptVersion: googleProtobuf.Message.getField(msg, 9)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxOutputType}
     */
    proto.TxOutputType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxOutputType;
      return proto.TxOutputType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxOutputType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxOutputType}
     */
    proto.TxOutputType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setAmount(value);
          break;
        case 4:
          var value = /** @type {!proto.OutputScriptType} */ (reader.readEnum());
          msg.setScriptType(value);
          break;
        case 5:
          var value = new proto.MultisigRedeemScriptType;
          reader.readMessage(value,proto.MultisigRedeemScriptType.deserializeBinaryFromReader);
          msg.setMultisig(value);
          break;
        case 6:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setOpReturnData(value);
          break;
        case 7:
          var value = /** @type {!proto.OutputAddressType} */ (reader.readEnum());
          msg.setAddressType(value);
          break;
        case 8:
          var value = new proto.ExchangeType;
          reader.readMessage(value,proto.ExchangeType.deserializeBinaryFromReader);
          msg.setExchangeType(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDecredScriptVersion(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxOutputType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxOutputType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxOutputType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxOutputType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint64(
          3,
          f
        );
      }
      f = /** @type {!proto.OutputScriptType} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeEnum(
          4,
          f
        );
      }
      f = message.getMultisig();
      if (f != null) {
        writer.writeMessage(
          5,
          f,
          proto.MultisigRedeemScriptType.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBytes(
          6,
          f
        );
      }
      f = /** @type {!proto.OutputAddressType} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeEnum(
          7,
          f
        );
      }
      f = message.getExchangeType();
      if (f != null) {
        writer.writeMessage(
          8,
          f,
          proto.ExchangeType.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
    };


    /**
     * optional string address = 1;
     * @return {string}
     */
    proto.TxOutputType.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.TxOutputType.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxOutputType.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated uint32 address_n = 2;
     * @return {!Array.<number>}
     */
    proto.TxOutputType.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 2));
    };


    /** @param {!Array.<number>} value */
    proto.TxOutputType.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 2, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.TxOutputType.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 2, value, opt_index);
    };


    proto.TxOutputType.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * required uint64 amount = 3;
     * @return {number}
     */
    proto.TxOutputType.prototype.getAmount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.TxOutputType.prototype.setAmount = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.TxOutputType.prototype.clearAmount = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasAmount = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * required OutputScriptType script_type = 4;
     * @return {!proto.OutputScriptType}
     */
    proto.TxOutputType.prototype.getScriptType = function() {
      return /** @type {!proto.OutputScriptType} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {!proto.OutputScriptType} value */
    proto.TxOutputType.prototype.setScriptType = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.TxOutputType.prototype.clearScriptType = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasScriptType = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional MultisigRedeemScriptType multisig = 5;
     * @return {?proto.MultisigRedeemScriptType}
     */
    proto.TxOutputType.prototype.getMultisig = function() {
      return /** @type{?proto.MultisigRedeemScriptType} */ (
        googleProtobuf.Message.getWrapperField(this, proto.MultisigRedeemScriptType, 5));
    };


    /** @param {?proto.MultisigRedeemScriptType|undefined} value */
    proto.TxOutputType.prototype.setMultisig = function(value) {
      googleProtobuf.Message.setWrapperField(this, 5, value);
    };


    proto.TxOutputType.prototype.clearMultisig = function() {
      this.setMultisig(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasMultisig = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bytes op_return_data = 6;
     * @return {!(string|Uint8Array)}
     */
    proto.TxOutputType.prototype.getOpReturnData = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /**
     * optional bytes op_return_data = 6;
     * This is a type-conversion wrapper around `getOpReturnData()`
     * @return {string}
     */
    proto.TxOutputType.prototype.getOpReturnData_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getOpReturnData()));
    };


    /**
     * optional bytes op_return_data = 6;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getOpReturnData()`
     * @return {!Uint8Array}
     */
    proto.TxOutputType.prototype.getOpReturnData_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getOpReturnData()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxOutputType.prototype.setOpReturnData = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.TxOutputType.prototype.clearOpReturnData = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasOpReturnData = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional OutputAddressType address_type = 7;
     * @return {!proto.OutputAddressType}
     */
    proto.TxOutputType.prototype.getAddressType = function() {
      return /** @type {!proto.OutputAddressType} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, 0));
    };


    /** @param {!proto.OutputAddressType} value */
    proto.TxOutputType.prototype.setAddressType = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.TxOutputType.prototype.clearAddressType = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasAddressType = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional ExchangeType exchange_type = 8;
     * @return {?proto.ExchangeType}
     */
    proto.TxOutputType.prototype.getExchangeType = function() {
      return /** @type{?proto.ExchangeType} */ (
        googleProtobuf.Message.getWrapperField(this, proto.ExchangeType, 8));
    };


    /** @param {?proto.ExchangeType|undefined} value */
    proto.TxOutputType.prototype.setExchangeType = function(value) {
      googleProtobuf.Message.setWrapperField(this, 8, value);
    };


    proto.TxOutputType.prototype.clearExchangeType = function() {
      this.setExchangeType(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasExchangeType = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 decred_script_version = 9;
     * @return {number}
     */
    proto.TxOutputType.prototype.getDecredScriptVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.TxOutputType.prototype.setDecredScriptVersion = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.TxOutputType.prototype.clearDecredScriptVersion = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputType.prototype.hasDecredScriptVersion = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxOutputBinType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxOutputBinType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxOutputBinType.prototype.toObject = function(opt_includeInstance) {
      return proto.TxOutputBinType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxOutputBinType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxOutputBinType.toObject = function(includeInstance, msg) {
      var obj = {
        amount: googleProtobuf.Message.getField(msg, 1),
        scriptPubkey: msg.getScriptPubkey_asB64(),
        decredScriptVersion: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxOutputBinType}
     */
    proto.TxOutputBinType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxOutputBinType;
      return proto.TxOutputBinType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxOutputBinType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxOutputBinType}
     */
    proto.TxOutputBinType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint64());
          msg.setAmount(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setScriptPubkey(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDecredScriptVersion(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxOutputBinType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxOutputBinType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxOutputBinType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxOutputBinType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint64(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
    };


    /**
     * required uint64 amount = 1;
     * @return {number}
     */
    proto.TxOutputBinType.prototype.getAmount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.TxOutputBinType.prototype.setAmount = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxOutputBinType.prototype.clearAmount = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputBinType.prototype.hasAmount = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required bytes script_pubkey = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.TxOutputBinType.prototype.getScriptPubkey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * required bytes script_pubkey = 2;
     * This is a type-conversion wrapper around `getScriptPubkey()`
     * @return {string}
     */
    proto.TxOutputBinType.prototype.getScriptPubkey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getScriptPubkey()));
    };


    /**
     * required bytes script_pubkey = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getScriptPubkey()`
     * @return {!Uint8Array}
     */
    proto.TxOutputBinType.prototype.getScriptPubkey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getScriptPubkey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxOutputBinType.prototype.setScriptPubkey = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.TxOutputBinType.prototype.clearScriptPubkey = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputBinType.prototype.hasScriptPubkey = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional uint32 decred_script_version = 3;
     * @return {number}
     */
    proto.TxOutputBinType.prototype.getDecredScriptVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.TxOutputBinType.prototype.setDecredScriptVersion = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.TxOutputBinType.prototype.clearDecredScriptVersion = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxOutputBinType.prototype.hasDecredScriptVersion = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TransactionType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.TransactionType.repeatedFields_, null);
    };
    goog.inherits(proto.TransactionType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.TransactionType.repeatedFields_ = [2,3,5];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TransactionType.prototype.toObject = function(opt_includeInstance) {
      return proto.TransactionType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TransactionType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TransactionType.toObject = function(includeInstance, msg) {
      var obj = {
        version: googleProtobuf.Message.getField(msg, 1),
        inputsList: googleProtobuf.Message.toObjectList(msg.getInputsList(),
        proto.TxInputType.toObject, includeInstance),
        binOutputsList: googleProtobuf.Message.toObjectList(msg.getBinOutputsList(),
        proto.TxOutputBinType.toObject, includeInstance),
        outputsList: googleProtobuf.Message.toObjectList(msg.getOutputsList(),
        proto.TxOutputType.toObject, includeInstance),
        lockTime: googleProtobuf.Message.getField(msg, 4),
        inputsCnt: googleProtobuf.Message.getField(msg, 6),
        outputsCnt: googleProtobuf.Message.getField(msg, 7),
        extraData: msg.getExtraData_asB64(),
        extraDataLen: googleProtobuf.Message.getField(msg, 9),
        expiry: googleProtobuf.Message.getField(msg, 10),
        overwintered: googleProtobuf.Message.getField(msg, 11)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TransactionType}
     */
    proto.TransactionType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TransactionType;
      return proto.TransactionType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TransactionType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TransactionType}
     */
    proto.TransactionType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setVersion(value);
          break;
        case 2:
          var value = new proto.TxInputType;
          reader.readMessage(value,proto.TxInputType.deserializeBinaryFromReader);
          msg.addInputs(value);
          break;
        case 3:
          var value = new proto.TxOutputBinType;
          reader.readMessage(value,proto.TxOutputBinType.deserializeBinaryFromReader);
          msg.addBinOutputs(value);
          break;
        case 5:
          var value = new proto.TxOutputType;
          reader.readMessage(value,proto.TxOutputType.deserializeBinaryFromReader);
          msg.addOutputs(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setLockTime(value);
          break;
        case 6:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setInputsCnt(value);
          break;
        case 7:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setOutputsCnt(value);
          break;
        case 8:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setExtraData(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setExtraDataLen(value);
          break;
        case 10:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setExpiry(value);
          break;
        case 11:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setOverwintered(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TransactionType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TransactionType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TransactionType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TransactionType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = message.getInputsList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f,
          proto.TxInputType.serializeBinaryToWriter
        );
      }
      f = message.getBinOutputsList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          3,
          f,
          proto.TxOutputBinType.serializeBinaryToWriter
        );
      }
      f = message.getOutputsList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          5,
          f,
          proto.TxOutputType.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint32(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeUint32(
          6,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeUint32(
          7,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeBytes(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeUint32(
          10,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 11));
      if (f != null) {
        writer.writeBool(
          11,
          f
        );
      }
    };


    /**
     * optional uint32 version = 1;
     * @return {number}
     */
    proto.TransactionType.prototype.getVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setVersion = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TransactionType.prototype.clearVersion = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasVersion = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * repeated TxInputType inputs = 2;
     * @return {!Array.<!proto.TxInputType>}
     */
    proto.TransactionType.prototype.getInputsList = function() {
      return /** @type{!Array.<!proto.TxInputType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.TxInputType, 2));
    };


    /** @param {!Array.<!proto.TxInputType>} value */
    proto.TransactionType.prototype.setInputsList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 2, value);
    };


    /**
     * @param {!proto.TxInputType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.TxInputType}
     */
    proto.TransactionType.prototype.addInputs = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.TxInputType, opt_index);
    };


    proto.TransactionType.prototype.clearInputsList = function() {
      this.setInputsList([]);
    };


    /**
     * repeated TxOutputBinType bin_outputs = 3;
     * @return {!Array.<!proto.TxOutputBinType>}
     */
    proto.TransactionType.prototype.getBinOutputsList = function() {
      return /** @type{!Array.<!proto.TxOutputBinType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.TxOutputBinType, 3));
    };


    /** @param {!Array.<!proto.TxOutputBinType>} value */
    proto.TransactionType.prototype.setBinOutputsList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 3, value);
    };


    /**
     * @param {!proto.TxOutputBinType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.TxOutputBinType}
     */
    proto.TransactionType.prototype.addBinOutputs = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.TxOutputBinType, opt_index);
    };


    proto.TransactionType.prototype.clearBinOutputsList = function() {
      this.setBinOutputsList([]);
    };


    /**
     * repeated TxOutputType outputs = 5;
     * @return {!Array.<!proto.TxOutputType>}
     */
    proto.TransactionType.prototype.getOutputsList = function() {
      return /** @type{!Array.<!proto.TxOutputType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, proto.TxOutputType, 5));
    };


    /** @param {!Array.<!proto.TxOutputType>} value */
    proto.TransactionType.prototype.setOutputsList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 5, value);
    };


    /**
     * @param {!proto.TxOutputType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.TxOutputType}
     */
    proto.TransactionType.prototype.addOutputs = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.TxOutputType, opt_index);
    };


    proto.TransactionType.prototype.clearOutputsList = function() {
      this.setOutputsList([]);
    };


    /**
     * optional uint32 lock_time = 4;
     * @return {number}
     */
    proto.TransactionType.prototype.getLockTime = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setLockTime = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.TransactionType.prototype.clearLockTime = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasLockTime = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional uint32 inputs_cnt = 6;
     * @return {number}
     */
    proto.TransactionType.prototype.getInputsCnt = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setInputsCnt = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.TransactionType.prototype.clearInputsCnt = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasInputsCnt = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional uint32 outputs_cnt = 7;
     * @return {number}
     */
    proto.TransactionType.prototype.getOutputsCnt = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setOutputsCnt = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.TransactionType.prototype.clearOutputsCnt = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasOutputsCnt = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional bytes extra_data = 8;
     * @return {!(string|Uint8Array)}
     */
    proto.TransactionType.prototype.getExtraData = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /**
     * optional bytes extra_data = 8;
     * This is a type-conversion wrapper around `getExtraData()`
     * @return {string}
     */
    proto.TransactionType.prototype.getExtraData_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getExtraData()));
    };


    /**
     * optional bytes extra_data = 8;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getExtraData()`
     * @return {!Uint8Array}
     */
    proto.TransactionType.prototype.getExtraData_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getExtraData()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TransactionType.prototype.setExtraData = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.TransactionType.prototype.clearExtraData = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasExtraData = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 extra_data_len = 9;
     * @return {number}
     */
    proto.TransactionType.prototype.getExtraDataLen = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setExtraDataLen = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.TransactionType.prototype.clearExtraDataLen = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasExtraDataLen = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional uint32 expiry = 10;
     * @return {number}
     */
    proto.TransactionType.prototype.getExpiry = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, 0));
    };


    /** @param {number} value */
    proto.TransactionType.prototype.setExpiry = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.TransactionType.prototype.clearExpiry = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasExpiry = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * optional bool overwintered = 11;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.TransactionType.prototype.getOverwintered = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 11, false));
    };


    /** @param {boolean} value */
    proto.TransactionType.prototype.setOverwintered = function(value) {
      googleProtobuf.Message.setField(this, 11, value);
    };


    proto.TransactionType.prototype.clearOverwintered = function() {
      googleProtobuf.Message.setField(this, 11, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TransactionType.prototype.hasOverwintered = function() {
      return googleProtobuf.Message.getField(this, 11) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.RawTransactionType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.RawTransactionType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.RawTransactionType.prototype.toObject = function(opt_includeInstance) {
      return proto.RawTransactionType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.RawTransactionType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RawTransactionType.toObject = function(includeInstance, msg) {
      var obj = {
        payload: msg.getPayload_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.RawTransactionType}
     */
    proto.RawTransactionType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.RawTransactionType;
      return proto.RawTransactionType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.RawTransactionType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.RawTransactionType}
     */
    proto.RawTransactionType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPayload(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.RawTransactionType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.RawTransactionType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.RawTransactionType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RawTransactionType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * required bytes payload = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.RawTransactionType.prototype.getPayload = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * required bytes payload = 1;
     * This is a type-conversion wrapper around `getPayload()`
     * @return {string}
     */
    proto.RawTransactionType.prototype.getPayload_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPayload()));
    };


    /**
     * required bytes payload = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPayload()`
     * @return {!Uint8Array}
     */
    proto.RawTransactionType.prototype.getPayload_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPayload()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.RawTransactionType.prototype.setPayload = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.RawTransactionType.prototype.clearPayload = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RawTransactionType.prototype.hasPayload = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxRequestDetailsType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxRequestDetailsType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxRequestDetailsType.prototype.toObject = function(opt_includeInstance) {
      return proto.TxRequestDetailsType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxRequestDetailsType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequestDetailsType.toObject = function(includeInstance, msg) {
      var obj = {
        requestIndex: googleProtobuf.Message.getField(msg, 1),
        txHash: msg.getTxHash_asB64(),
        extraDataLen: googleProtobuf.Message.getField(msg, 3),
        extraDataOffset: googleProtobuf.Message.getField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxRequestDetailsType}
     */
    proto.TxRequestDetailsType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxRequestDetailsType;
      return proto.TxRequestDetailsType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxRequestDetailsType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxRequestDetailsType}
     */
    proto.TxRequestDetailsType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setRequestIndex(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setTxHash(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setExtraDataLen(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setExtraDataOffset(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxRequestDetailsType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxRequestDetailsType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxRequestDetailsType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequestDetailsType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint32(
          4,
          f
        );
      }
    };


    /**
     * optional uint32 request_index = 1;
     * @return {number}
     */
    proto.TxRequestDetailsType.prototype.getRequestIndex = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.TxRequestDetailsType.prototype.setRequestIndex = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxRequestDetailsType.prototype.clearRequestIndex = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestDetailsType.prototype.hasRequestIndex = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes tx_hash = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.TxRequestDetailsType.prototype.getTxHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes tx_hash = 2;
     * This is a type-conversion wrapper around `getTxHash()`
     * @return {string}
     */
    proto.TxRequestDetailsType.prototype.getTxHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getTxHash()));
    };


    /**
     * optional bytes tx_hash = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getTxHash()`
     * @return {!Uint8Array}
     */
    proto.TxRequestDetailsType.prototype.getTxHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getTxHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxRequestDetailsType.prototype.setTxHash = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.TxRequestDetailsType.prototype.clearTxHash = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestDetailsType.prototype.hasTxHash = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional uint32 extra_data_len = 3;
     * @return {number}
     */
    proto.TxRequestDetailsType.prototype.getExtraDataLen = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.TxRequestDetailsType.prototype.setExtraDataLen = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.TxRequestDetailsType.prototype.clearExtraDataLen = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestDetailsType.prototype.hasExtraDataLen = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint32 extra_data_offset = 4;
     * @return {number}
     */
    proto.TxRequestDetailsType.prototype.getExtraDataOffset = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.TxRequestDetailsType.prototype.setExtraDataOffset = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.TxRequestDetailsType.prototype.clearExtraDataOffset = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestDetailsType.prototype.hasExtraDataOffset = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxRequestSerializedType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxRequestSerializedType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxRequestSerializedType.prototype.toObject = function(opt_includeInstance) {
      return proto.TxRequestSerializedType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxRequestSerializedType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequestSerializedType.toObject = function(includeInstance, msg) {
      var obj = {
        signatureIndex: googleProtobuf.Message.getField(msg, 1),
        signature: msg.getSignature_asB64(),
        serializedTx: msg.getSerializedTx_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxRequestSerializedType}
     */
    proto.TxRequestSerializedType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxRequestSerializedType;
      return proto.TxRequestSerializedType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxRequestSerializedType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxRequestSerializedType}
     */
    proto.TxRequestSerializedType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setSignatureIndex(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSerializedTx(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxRequestSerializedType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxRequestSerializedType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxRequestSerializedType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequestSerializedType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
    };


    /**
     * optional uint32 signature_index = 1;
     * @return {number}
     */
    proto.TxRequestSerializedType.prototype.getSignatureIndex = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.TxRequestSerializedType.prototype.setSignatureIndex = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxRequestSerializedType.prototype.clearSignatureIndex = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestSerializedType.prototype.hasSignatureIndex = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.TxRequestSerializedType.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.TxRequestSerializedType.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.TxRequestSerializedType.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxRequestSerializedType.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.TxRequestSerializedType.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestSerializedType.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes serialized_tx = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.TxRequestSerializedType.prototype.getSerializedTx = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes serialized_tx = 3;
     * This is a type-conversion wrapper around `getSerializedTx()`
     * @return {string}
     */
    proto.TxRequestSerializedType.prototype.getSerializedTx_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSerializedTx()));
    };


    /**
     * optional bytes serialized_tx = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSerializedTx()`
     * @return {!Uint8Array}
     */
    proto.TxRequestSerializedType.prototype.getSerializedTx_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSerializedTx()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.TxRequestSerializedType.prototype.setSerializedTx = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.TxRequestSerializedType.prototype.clearSerializedTx = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequestSerializedType.prototype.hasSerializedTx = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.IdentityType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.IdentityType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.IdentityType.prototype.toObject = function(opt_includeInstance) {
      return proto.IdentityType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.IdentityType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.IdentityType.toObject = function(includeInstance, msg) {
      var obj = {
        proto: googleProtobuf.Message.getField(msg, 1),
        user: googleProtobuf.Message.getField(msg, 2),
        host: googleProtobuf.Message.getField(msg, 3),
        port: googleProtobuf.Message.getField(msg, 4),
        path: googleProtobuf.Message.getField(msg, 5),
        index: googleProtobuf.Message.getFieldWithDefault(msg, 6, 0)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.IdentityType}
     */
    proto.IdentityType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.IdentityType;
      return proto.IdentityType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.IdentityType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.IdentityType}
     */
    proto.IdentityType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setProto(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setUser(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setHost(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setPort(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.setPath(value);
          break;
        case 6:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setIndex(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.IdentityType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.IdentityType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.IdentityType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.IdentityType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeString(
          5,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeUint32(
          6,
          f
        );
      }
    };


    /**
     * optional string proto = 1;
     * @return {string}
     */
    proto.IdentityType.prototype.getProto = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.IdentityType.prototype.setProto = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.IdentityType.prototype.clearProto = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasProto = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string user = 2;
     * @return {string}
     */
    proto.IdentityType.prototype.getUser = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.IdentityType.prototype.setUser = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.IdentityType.prototype.clearUser = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasUser = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string host = 3;
     * @return {string}
     */
    proto.IdentityType.prototype.getHost = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.IdentityType.prototype.setHost = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.IdentityType.prototype.clearHost = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasHost = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string port = 4;
     * @return {string}
     */
    proto.IdentityType.prototype.getPort = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /** @param {string} value */
    proto.IdentityType.prototype.setPort = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.IdentityType.prototype.clearPort = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasPort = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional string path = 5;
     * @return {string}
     */
    proto.IdentityType.prototype.getPath = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, ""));
    };


    /** @param {string} value */
    proto.IdentityType.prototype.setPath = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.IdentityType.prototype.clearPath = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasPath = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional uint32 index = 6;
     * @return {number}
     */
    proto.IdentityType.prototype.getIndex = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {number} value */
    proto.IdentityType.prototype.setIndex = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.IdentityType.prototype.clearIndex = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.IdentityType.prototype.hasIndex = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PolicyType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PolicyType, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PolicyType.prototype.toObject = function(opt_includeInstance) {
      return proto.PolicyType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PolicyType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PolicyType.toObject = function(includeInstance, msg) {
      var obj = {
        policyName: googleProtobuf.Message.getField(msg, 1),
        enabled: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PolicyType}
     */
    proto.PolicyType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PolicyType;
      return proto.PolicyType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PolicyType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PolicyType}
     */
    proto.PolicyType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setPolicyName(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setEnabled(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PolicyType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PolicyType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PolicyType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PolicyType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
    };


    /**
     * optional string policy_name = 1;
     * @return {string}
     */
    proto.PolicyType.prototype.getPolicyName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.PolicyType.prototype.setPolicyName = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.PolicyType.prototype.clearPolicyName = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PolicyType.prototype.hasPolicyName = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool enabled = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.PolicyType.prototype.getEnabled = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.PolicyType.prototype.setEnabled = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.PolicyType.prototype.clearEnabled = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PolicyType.prototype.hasEnabled = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ExchangeType = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.ExchangeType.repeatedFields_, null);
    };
    goog.inherits(proto.ExchangeType, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.ExchangeType.repeatedFields_ = [3,4];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ExchangeType.prototype.toObject = function(opt_includeInstance) {
      return proto.ExchangeType.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ExchangeType} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeType.toObject = function(includeInstance, msg) {
      var f, obj = {
        signedExchangeResponse: (f = msg.getSignedExchangeResponse()) && exchange_pb.SignedExchangeResponse.toObject(includeInstance, f),
        withdrawalCoinName: googleProtobuf.Message.getFieldWithDefault(msg, 2, "Bitcoin"),
        withdrawalAddressNList: googleProtobuf.Message.getRepeatedField(msg, 3),
        returnAddressNList: googleProtobuf.Message.getRepeatedField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ExchangeType}
     */
    proto.ExchangeType.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ExchangeType;
      return proto.ExchangeType.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ExchangeType} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ExchangeType}
     */
    proto.ExchangeType.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new exchange_pb.SignedExchangeResponse;
          reader.readMessage(value,exchange_pb.SignedExchangeResponse.deserializeBinaryFromReader);
          msg.setSignedExchangeResponse(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setWithdrawalCoinName(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addWithdrawalAddressN(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addReturnAddressN(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ExchangeType.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ExchangeType.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ExchangeType} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ExchangeType.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getSignedExchangeResponse();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          exchange_pb.SignedExchangeResponse.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = message.getWithdrawalAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          3,
          f
        );
      }
      f = message.getReturnAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          4,
          f
        );
      }
    };


    /**
     * optional SignedExchangeResponse signed_exchange_response = 1;
     * @return {?proto.SignedExchangeResponse}
     */
    proto.ExchangeType.prototype.getSignedExchangeResponse = function() {
      return /** @type{?proto.SignedExchangeResponse} */ (
        googleProtobuf.Message.getWrapperField(this, exchange_pb.SignedExchangeResponse, 1));
    };


    /** @param {?proto.SignedExchangeResponse|undefined} value */
    proto.ExchangeType.prototype.setSignedExchangeResponse = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.ExchangeType.prototype.clearSignedExchangeResponse = function() {
      this.setSignedExchangeResponse(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeType.prototype.hasSignedExchangeResponse = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string withdrawal_coin_name = 2;
     * @return {string}
     */
    proto.ExchangeType.prototype.getWithdrawalCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, "Bitcoin"));
    };


    /** @param {string} value */
    proto.ExchangeType.prototype.setWithdrawalCoinName = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ExchangeType.prototype.clearWithdrawalCoinName = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ExchangeType.prototype.hasWithdrawalCoinName = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * repeated uint32 withdrawal_address_n = 3;
     * @return {!Array.<number>}
     */
    proto.ExchangeType.prototype.getWithdrawalAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 3));
    };


    /** @param {!Array.<number>} value */
    proto.ExchangeType.prototype.setWithdrawalAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 3, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.ExchangeType.prototype.addWithdrawalAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 3, value, opt_index);
    };


    proto.ExchangeType.prototype.clearWithdrawalAddressNList = function() {
      this.setWithdrawalAddressNList([]);
    };


    /**
     * repeated uint32 return_address_n = 4;
     * @return {!Array.<number>}
     */
    proto.ExchangeType.prototype.getReturnAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 4));
    };


    /** @param {!Array.<number>} value */
    proto.ExchangeType.prototype.setReturnAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 4, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.ExchangeType.prototype.addReturnAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 4, value, opt_index);
    };


    proto.ExchangeType.prototype.clearReturnAddressNList = function() {
      this.setReturnAddressNList([]);
    };


    /**
     * @enum {number}
     */
    proto.FailureType = {
      FAILURE_UNEXPECTEDMESSAGE: 1,
      FAILURE_BUTTONEXPECTED: 2,
      FAILURE_SYNTAXERROR: 3,
      FAILURE_ACTIONCANCELLED: 4,
      FAILURE_PINEXPECTED: 5,
      FAILURE_PINCANCELLED: 6,
      FAILURE_PININVALID: 7,
      FAILURE_INVALIDSIGNATURE: 8,
      FAILURE_OTHER: 9,
      FAILURE_NOTENOUGHFUNDS: 10,
      FAILURE_NOTINITIALIZED: 11,
      FAILURE_PINMISMATCH: 12,
      FAILURE_FIRMWAREERROR: 99
    };

    /**
     * @enum {number}
     */
    proto.OutputScriptType = {
      PAYTOADDRESS: 0,
      PAYTOSCRIPTHASH: 1,
      PAYTOMULTISIG: 2,
      PAYTOOPRETURN: 3,
      PAYTOWITNESS: 4,
      PAYTOP2SHWITNESS: 5
    };

    /**
     * @enum {number}
     */
    proto.InputScriptType = {
      SPENDADDRESS: 0,
      SPENDMULTISIG: 1,
      EXTERNAL: 2,
      SPENDWITNESS: 3,
      SPENDP2SHWITNESS: 4
    };

    /**
     * @enum {number}
     */
    proto.RequestType = {
      TXINPUT: 0,
      TXOUTPUT: 1,
      TXMETA: 2,
      TXFINISHED: 3,
      TXEXTRADATA: 4
    };

    /**
     * @enum {number}
     */
    proto.OutputAddressType = {
      SPEND: 0,
      TRANSFER: 1,
      CHANGE: 2,
      EXCHANGE: 3
    };

    /**
     * @enum {number}
     */
    proto.ButtonRequestType = {
      BUTTONREQUEST_OTHER: 1,
      BUTTONREQUEST_FEEOVERTHRESHOLD: 2,
      BUTTONREQUEST_CONFIRMOUTPUT: 3,
      BUTTONREQUEST_RESETDEVICE: 4,
      BUTTONREQUEST_CONFIRMWORD: 5,
      BUTTONREQUEST_WIPEDEVICE: 6,
      BUTTONREQUEST_PROTECTCALL: 7,
      BUTTONREQUEST_SIGNTX: 8,
      BUTTONREQUEST_FIRMWARECHECK: 9,
      BUTTONREQUEST_ADDRESS: 10,
      BUTTONREQUEST_FIRMWAREERASE: 11,
      BUTTONREQUEST_CONFIRMTRANSFERTOACCOUNT: 12,
      BUTTONREQUEST_CONFIRMTRANSFERTONODEPATH: 13,
      BUTTONREQUEST_CHANGELABEL: 14,
      BUTTONREQUEST_CHANGELANGUAGE: 15,
      BUTTONREQUEST_ENABLEPASSPHRASE: 16,
      BUTTONREQUEST_DISABLEPASSPHRASE: 17,
      BUTTONREQUEST_ENCRYPTANDSIGNMESSAGE: 18,
      BUTTONREQUEST_ENCRYPTMESSAGE: 19,
      BUTTONREQUEST_IMPORTPRIVATEKEY: 20,
      BUTTONREQUEST_IMPORTRECOVERYSENTENCE: 21,
      BUTTONREQUEST_SIGNIDENTITY: 22,
      BUTTONREQUEST_PING: 23,
      BUTTONREQUEST_REMOVEPIN: 24,
      BUTTONREQUEST_CHANGEPIN: 25,
      BUTTONREQUEST_CREATEPIN: 26,
      BUTTONREQUEST_GETENTROPY: 27,
      BUTTONREQUEST_SIGNMESSAGE: 28,
      BUTTONREQUEST_APPLYPOLICIES: 29,
      BUTTONREQUEST_SIGNEXCHANGE: 30,
      BUTTONREQUEST_AUTOLOCKDELAYMS: 31,
      BUTTONREQUEST_U2FCOUNTER: 32,
      BUTTONREQUEST_CONFIRMEOSACTION: 33,
      BUTTONREQUEST_CONFIRMEOSBUDGET: 34,
      BUTTONREQUEST_CONFIRMMEMO: 35
    };

    /**
     * @enum {number}
     */
    proto.PinMatrixRequestType = {
      PINMATRIXREQUESTTYPE_CURRENT: 1,
      PINMATRIXREQUESTTYPE_NEWFIRST: 2,
      PINMATRIXREQUESTTYPE_NEWSECOND: 3
    };


    /**
     * A tuple of {field number, class constructor} for the extension
     * field named `wireIn`.
     * @type {!jspb.ExtensionFieldInfo.<boolean>}
     */
    proto.wireIn = new googleProtobuf.ExtensionFieldInfo(
        50002,
        {wireIn: 0},
        null,
         /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
             null),
        0);

    descriptor_pb.EnumValueOptions.extensionsBinary[50002] = new googleProtobuf.ExtensionFieldBinaryInfo(
        proto.wireIn,
        googleProtobuf.BinaryReader.prototype.readBool,
        googleProtobuf.BinaryWriter.prototype.writeBool,
        undefined,
        undefined,
        false);
    // This registers the extension field with the extended class, so that
    // toObject() will function correctly.
    descriptor_pb.EnumValueOptions.extensions[50002] = proto.wireIn;


    /**
     * A tuple of {field number, class constructor} for the extension
     * field named `wireOut`.
     * @type {!jspb.ExtensionFieldInfo.<boolean>}
     */
    proto.wireOut = new googleProtobuf.ExtensionFieldInfo(
        50003,
        {wireOut: 0},
        null,
         /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
             null),
        0);

    descriptor_pb.EnumValueOptions.extensionsBinary[50003] = new googleProtobuf.ExtensionFieldBinaryInfo(
        proto.wireOut,
        googleProtobuf.BinaryReader.prototype.readBool,
        googleProtobuf.BinaryWriter.prototype.writeBool,
        undefined,
        undefined,
        false);
    // This registers the extension field with the extended class, so that
    // toObject() will function correctly.
    descriptor_pb.EnumValueOptions.extensions[50003] = proto.wireOut;


    /**
     * A tuple of {field number, class constructor} for the extension
     * field named `wireDebugIn`.
     * @type {!jspb.ExtensionFieldInfo.<boolean>}
     */
    proto.wireDebugIn = new googleProtobuf.ExtensionFieldInfo(
        50004,
        {wireDebugIn: 0},
        null,
         /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
             null),
        0);

    descriptor_pb.EnumValueOptions.extensionsBinary[50004] = new googleProtobuf.ExtensionFieldBinaryInfo(
        proto.wireDebugIn,
        googleProtobuf.BinaryReader.prototype.readBool,
        googleProtobuf.BinaryWriter.prototype.writeBool,
        undefined,
        undefined,
        false);
    // This registers the extension field with the extended class, so that
    // toObject() will function correctly.
    descriptor_pb.EnumValueOptions.extensions[50004] = proto.wireDebugIn;


    /**
     * A tuple of {field number, class constructor} for the extension
     * field named `wireDebugOut`.
     * @type {!jspb.ExtensionFieldInfo.<boolean>}
     */
    proto.wireDebugOut = new googleProtobuf.ExtensionFieldInfo(
        50005,
        {wireDebugOut: 0},
        null,
         /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
             null),
        0);

    descriptor_pb.EnumValueOptions.extensionsBinary[50005] = new googleProtobuf.ExtensionFieldBinaryInfo(
        proto.wireDebugOut,
        googleProtobuf.BinaryReader.prototype.readBool,
        googleProtobuf.BinaryWriter.prototype.writeBool,
        undefined,
        undefined,
        false);
    // This registers the extension field with the extended class, so that
    // toObject() will function correctly.
    descriptor_pb.EnumValueOptions.extensions[50005] = proto.wireDebugOut;

    goog.object.extend(exports, proto);
    });

    var messages_pb = createCommonjsModule(function (module, exports) {
    /**
     * @fileoverview
     * @enhanceable
     * @suppress {messageConventions} JS Compiler reports an error if a variable or
     *     field starts with 'MSG_' and isn't a translatable message.
     * @public
     */
    // GENERATED CODE -- DO NOT EDIT!


    var goog = googleProtobuf;
    var global = Function('return this')();


    goog.exportSymbol('proto.Address', null, global);
    goog.exportSymbol('proto.ApplyPolicies', null, global);
    goog.exportSymbol('proto.ApplySettings', null, global);
    goog.exportSymbol('proto.ButtonAck', null, global);
    goog.exportSymbol('proto.ButtonRequest', null, global);
    goog.exportSymbol('proto.Cancel', null, global);
    goog.exportSymbol('proto.ChangePin', null, global);
    goog.exportSymbol('proto.CharacterAck', null, global);
    goog.exportSymbol('proto.CharacterRequest', null, global);
    goog.exportSymbol('proto.CipherKeyValue', null, global);
    goog.exportSymbol('proto.CipheredKeyValue', null, global);
    goog.exportSymbol('proto.ClearSession', null, global);
    goog.exportSymbol('proto.CoinTable', null, global);
    goog.exportSymbol('proto.DebugLinkDecision', null, global);
    goog.exportSymbol('proto.DebugLinkFillConfig', null, global);
    goog.exportSymbol('proto.DebugLinkFlashDump', null, global);
    goog.exportSymbol('proto.DebugLinkFlashDumpResponse', null, global);
    goog.exportSymbol('proto.DebugLinkGetState', null, global);
    goog.exportSymbol('proto.DebugLinkLog', null, global);
    goog.exportSymbol('proto.DebugLinkState', null, global);
    goog.exportSymbol('proto.DebugLinkStop', null, global);
    goog.exportSymbol('proto.DecryptMessage', null, global);
    goog.exportSymbol('proto.DecryptedMessage', null, global);
    goog.exportSymbol('proto.EncryptMessage', null, global);
    goog.exportSymbol('proto.EncryptedMessage', null, global);
    goog.exportSymbol('proto.Entropy', null, global);
    goog.exportSymbol('proto.EntropyAck', null, global);
    goog.exportSymbol('proto.EntropyRequest', null, global);
    goog.exportSymbol('proto.EstimateTxSize', null, global);
    goog.exportSymbol('proto.EthereumAddress', null, global);
    goog.exportSymbol('proto.EthereumGetAddress', null, global);
    goog.exportSymbol('proto.EthereumMessageSignature', null, global);
    goog.exportSymbol('proto.EthereumSignMessage', null, global);
    goog.exportSymbol('proto.EthereumSignTx', null, global);
    goog.exportSymbol('proto.EthereumTxAck', null, global);
    goog.exportSymbol('proto.EthereumTxRequest', null, global);
    goog.exportSymbol('proto.EthereumVerifyMessage', null, global);
    goog.exportSymbol('proto.Failure', null, global);
    goog.exportSymbol('proto.Features', null, global);
    goog.exportSymbol('proto.FirmwareErase', null, global);
    goog.exportSymbol('proto.FirmwareUpload', null, global);
    goog.exportSymbol('proto.FlashHash', null, global);
    goog.exportSymbol('proto.FlashHashResponse', null, global);
    goog.exportSymbol('proto.FlashWrite', null, global);
    goog.exportSymbol('proto.GetAddress', null, global);
    goog.exportSymbol('proto.GetCoinTable', null, global);
    goog.exportSymbol('proto.GetEntropy', null, global);
    goog.exportSymbol('proto.GetFeatures', null, global);
    goog.exportSymbol('proto.GetPublicKey', null, global);
    goog.exportSymbol('proto.Initialize', null, global);
    goog.exportSymbol('proto.LoadDevice', null, global);
    goog.exportSymbol('proto.MessageSignature', null, global);
    goog.exportSymbol('proto.MessageType', null, global);
    goog.exportSymbol('proto.PassphraseAck', null, global);
    goog.exportSymbol('proto.PassphraseRequest', null, global);
    goog.exportSymbol('proto.PinMatrixAck', null, global);
    goog.exportSymbol('proto.PinMatrixRequest', null, global);
    goog.exportSymbol('proto.Ping', null, global);
    goog.exportSymbol('proto.PublicKey', null, global);
    goog.exportSymbol('proto.RawTxAck', null, global);
    goog.exportSymbol('proto.RecoveryDevice', null, global);
    goog.exportSymbol('proto.ResetDevice', null, global);
    goog.exportSymbol('proto.SignIdentity', null, global);
    goog.exportSymbol('proto.SignMessage', null, global);
    goog.exportSymbol('proto.SignTx', null, global);
    goog.exportSymbol('proto.SignedIdentity', null, global);
    goog.exportSymbol('proto.SoftReset', null, global);
    goog.exportSymbol('proto.Success', null, global);
    goog.exportSymbol('proto.TxAck', null, global);
    goog.exportSymbol('proto.TxRequest', null, global);
    goog.exportSymbol('proto.TxSize', null, global);
    goog.exportSymbol('proto.VerifyMessage', null, global);
    goog.exportSymbol('proto.WipeDevice', null, global);
    goog.exportSymbol('proto.WordAck', null, global);
    goog.exportSymbol('proto.WordRequest', null, global);

    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Initialize = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Initialize, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Initialize.prototype.toObject = function(opt_includeInstance) {
      return proto.Initialize.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Initialize} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Initialize.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Initialize}
     */
    proto.Initialize.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Initialize;
      return proto.Initialize.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Initialize} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Initialize}
     */
    proto.Initialize.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Initialize.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Initialize.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Initialize} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Initialize.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.GetFeatures = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.GetFeatures, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.GetFeatures.prototype.toObject = function(opt_includeInstance) {
      return proto.GetFeatures.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.GetFeatures} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetFeatures.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.GetFeatures}
     */
    proto.GetFeatures.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.GetFeatures;
      return proto.GetFeatures.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.GetFeatures} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.GetFeatures}
     */
    proto.GetFeatures.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.GetFeatures.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.GetFeatures.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.GetFeatures} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetFeatures.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Features = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.Features.repeatedFields_, null);
    };
    goog.inherits(proto.Features, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.Features.repeatedFields_ = [11,18];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Features.prototype.toObject = function(opt_includeInstance) {
      return proto.Features.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Features} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Features.toObject = function(includeInstance, msg) {
      var obj = {
        vendor: googleProtobuf.Message.getField(msg, 1),
        majorVersion: googleProtobuf.Message.getField(msg, 2),
        minorVersion: googleProtobuf.Message.getField(msg, 3),
        patchVersion: googleProtobuf.Message.getField(msg, 4),
        bootloaderMode: googleProtobuf.Message.getField(msg, 5),
        deviceId: googleProtobuf.Message.getField(msg, 6),
        pinProtection: googleProtobuf.Message.getField(msg, 7),
        passphraseProtection: googleProtobuf.Message.getField(msg, 8),
        language: googleProtobuf.Message.getField(msg, 9),
        label: googleProtobuf.Message.getField(msg, 10),
        coinsList: googleProtobuf.Message.toObjectList(msg.getCoinsList(),
        types_pb.CoinType.toObject, includeInstance),
        initialized: googleProtobuf.Message.getField(msg, 12),
        revision: msg.getRevision_asB64(),
        bootloaderHash: msg.getBootloaderHash_asB64(),
        imported: googleProtobuf.Message.getField(msg, 15),
        pinCached: googleProtobuf.Message.getField(msg, 16),
        passphraseCached: googleProtobuf.Message.getField(msg, 17),
        policiesList: googleProtobuf.Message.toObjectList(msg.getPoliciesList(),
        types_pb.PolicyType.toObject, includeInstance),
        model: googleProtobuf.Message.getField(msg, 21),
        firmwareVariant: googleProtobuf.Message.getField(msg, 22),
        firmwareHash: msg.getFirmwareHash_asB64(),
        noBackup: googleProtobuf.Message.getField(msg, 24)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Features}
     */
    proto.Features.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Features;
      return proto.Features.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Features} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Features}
     */
    proto.Features.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setVendor(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setMajorVersion(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setMinorVersion(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setPatchVersion(value);
          break;
        case 5:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setBootloaderMode(value);
          break;
        case 6:
          var value = /** @type {string} */ (reader.readString());
          msg.setDeviceId(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPinProtection(value);
          break;
        case 8:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        case 9:
          var value = /** @type {string} */ (reader.readString());
          msg.setLanguage(value);
          break;
        case 10:
          var value = /** @type {string} */ (reader.readString());
          msg.setLabel(value);
          break;
        case 11:
          var value = new types_pb.CoinType;
          reader.readMessage(value,types_pb.CoinType.deserializeBinaryFromReader);
          msg.addCoins(value);
          break;
        case 12:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setInitialized(value);
          break;
        case 13:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setRevision(value);
          break;
        case 14:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setBootloaderHash(value);
          break;
        case 15:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setImported(value);
          break;
        case 16:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPinCached(value);
          break;
        case 17:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseCached(value);
          break;
        case 18:
          var value = new types_pb.PolicyType;
          reader.readMessage(value,types_pb.PolicyType.deserializeBinaryFromReader);
          msg.addPolicies(value);
          break;
        case 21:
          var value = /** @type {string} */ (reader.readString());
          msg.setModel(value);
          break;
        case 22:
          var value = /** @type {string} */ (reader.readString());
          msg.setFirmwareVariant(value);
          break;
        case 23:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setFirmwareHash(value);
          break;
        case 24:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setNoBackup(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Features.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Features.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Features} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Features.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint32(
          4,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBool(
          5,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeString(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeBool(
          8,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeString(
          9,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeString(
          10,
          f
        );
      }
      f = message.getCoinsList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          11,
          f,
          types_pb.CoinType.serializeBinaryToWriter
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 12));
      if (f != null) {
        writer.writeBool(
          12,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 13));
      if (f != null) {
        writer.writeBytes(
          13,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 14));
      if (f != null) {
        writer.writeBytes(
          14,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 15));
      if (f != null) {
        writer.writeBool(
          15,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 16));
      if (f != null) {
        writer.writeBool(
          16,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 17));
      if (f != null) {
        writer.writeBool(
          17,
          f
        );
      }
      f = message.getPoliciesList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          18,
          f,
          types_pb.PolicyType.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 21));
      if (f != null) {
        writer.writeString(
          21,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 22));
      if (f != null) {
        writer.writeString(
          22,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 23));
      if (f != null) {
        writer.writeBytes(
          23,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 24));
      if (f != null) {
        writer.writeBool(
          24,
          f
        );
      }
    };


    /**
     * optional string vendor = 1;
     * @return {string}
     */
    proto.Features.prototype.getVendor = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setVendor = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Features.prototype.clearVendor = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasVendor = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 major_version = 2;
     * @return {number}
     */
    proto.Features.prototype.getMajorVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.Features.prototype.setMajorVersion = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.Features.prototype.clearMajorVersion = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasMajorVersion = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional uint32 minor_version = 3;
     * @return {number}
     */
    proto.Features.prototype.getMinorVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.Features.prototype.setMinorVersion = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.Features.prototype.clearMinorVersion = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasMinorVersion = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint32 patch_version = 4;
     * @return {number}
     */
    proto.Features.prototype.getPatchVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.Features.prototype.setPatchVersion = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.Features.prototype.clearPatchVersion = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasPatchVersion = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bool bootloader_mode = 5;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getBootloaderMode = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setBootloaderMode = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.Features.prototype.clearBootloaderMode = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasBootloaderMode = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional string device_id = 6;
     * @return {string}
     */
    proto.Features.prototype.getDeviceId = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setDeviceId = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.Features.prototype.clearDeviceId = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasDeviceId = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool pin_protection = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getPinProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setPinProtection = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.Features.prototype.clearPinProtection = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasPinProtection = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional bool passphrase_protection = 8;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.Features.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional string language = 9;
     * @return {string}
     */
    proto.Features.prototype.getLanguage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setLanguage = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.Features.prototype.clearLanguage = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasLanguage = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional string label = 10;
     * @return {string}
     */
    proto.Features.prototype.getLabel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.Features.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * repeated CoinType coins = 11;
     * @return {!Array.<!proto.CoinType>}
     */
    proto.Features.prototype.getCoinsList = function() {
      return /** @type{!Array.<!proto.CoinType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.CoinType, 11));
    };


    /** @param {!Array.<!proto.CoinType>} value */
    proto.Features.prototype.setCoinsList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 11, value);
    };


    /**
     * @param {!proto.CoinType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.CoinType}
     */
    proto.Features.prototype.addCoins = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 11, opt_value, proto.CoinType, opt_index);
    };


    proto.Features.prototype.clearCoinsList = function() {
      this.setCoinsList([]);
    };


    /**
     * optional bool initialized = 12;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getInitialized = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 12, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setInitialized = function(value) {
      googleProtobuf.Message.setField(this, 12, value);
    };


    proto.Features.prototype.clearInitialized = function() {
      googleProtobuf.Message.setField(this, 12, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasInitialized = function() {
      return googleProtobuf.Message.getField(this, 12) != null;
    };


    /**
     * optional bytes revision = 13;
     * @return {!(string|Uint8Array)}
     */
    proto.Features.prototype.getRevision = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 13, ""));
    };


    /**
     * optional bytes revision = 13;
     * This is a type-conversion wrapper around `getRevision()`
     * @return {string}
     */
    proto.Features.prototype.getRevision_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getRevision()));
    };


    /**
     * optional bytes revision = 13;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getRevision()`
     * @return {!Uint8Array}
     */
    proto.Features.prototype.getRevision_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getRevision()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.Features.prototype.setRevision = function(value) {
      googleProtobuf.Message.setField(this, 13, value);
    };


    proto.Features.prototype.clearRevision = function() {
      googleProtobuf.Message.setField(this, 13, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasRevision = function() {
      return googleProtobuf.Message.getField(this, 13) != null;
    };


    /**
     * optional bytes bootloader_hash = 14;
     * @return {!(string|Uint8Array)}
     */
    proto.Features.prototype.getBootloaderHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 14, ""));
    };


    /**
     * optional bytes bootloader_hash = 14;
     * This is a type-conversion wrapper around `getBootloaderHash()`
     * @return {string}
     */
    proto.Features.prototype.getBootloaderHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getBootloaderHash()));
    };


    /**
     * optional bytes bootloader_hash = 14;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getBootloaderHash()`
     * @return {!Uint8Array}
     */
    proto.Features.prototype.getBootloaderHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getBootloaderHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.Features.prototype.setBootloaderHash = function(value) {
      googleProtobuf.Message.setField(this, 14, value);
    };


    proto.Features.prototype.clearBootloaderHash = function() {
      googleProtobuf.Message.setField(this, 14, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasBootloaderHash = function() {
      return googleProtobuf.Message.getField(this, 14) != null;
    };


    /**
     * optional bool imported = 15;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getImported = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 15, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setImported = function(value) {
      googleProtobuf.Message.setField(this, 15, value);
    };


    proto.Features.prototype.clearImported = function() {
      googleProtobuf.Message.setField(this, 15, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasImported = function() {
      return googleProtobuf.Message.getField(this, 15) != null;
    };


    /**
     * optional bool pin_cached = 16;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getPinCached = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 16, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setPinCached = function(value) {
      googleProtobuf.Message.setField(this, 16, value);
    };


    proto.Features.prototype.clearPinCached = function() {
      googleProtobuf.Message.setField(this, 16, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasPinCached = function() {
      return googleProtobuf.Message.getField(this, 16) != null;
    };


    /**
     * optional bool passphrase_cached = 17;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getPassphraseCached = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 17, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setPassphraseCached = function(value) {
      googleProtobuf.Message.setField(this, 17, value);
    };


    proto.Features.prototype.clearPassphraseCached = function() {
      googleProtobuf.Message.setField(this, 17, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasPassphraseCached = function() {
      return googleProtobuf.Message.getField(this, 17) != null;
    };


    /**
     * repeated PolicyType policies = 18;
     * @return {!Array.<!proto.PolicyType>}
     */
    proto.Features.prototype.getPoliciesList = function() {
      return /** @type{!Array.<!proto.PolicyType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.PolicyType, 18));
    };


    /** @param {!Array.<!proto.PolicyType>} value */
    proto.Features.prototype.setPoliciesList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 18, value);
    };


    /**
     * @param {!proto.PolicyType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.PolicyType}
     */
    proto.Features.prototype.addPolicies = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 18, opt_value, proto.PolicyType, opt_index);
    };


    proto.Features.prototype.clearPoliciesList = function() {
      this.setPoliciesList([]);
    };


    /**
     * optional string model = 21;
     * @return {string}
     */
    proto.Features.prototype.getModel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 21, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setModel = function(value) {
      googleProtobuf.Message.setField(this, 21, value);
    };


    proto.Features.prototype.clearModel = function() {
      googleProtobuf.Message.setField(this, 21, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasModel = function() {
      return googleProtobuf.Message.getField(this, 21) != null;
    };


    /**
     * optional string firmware_variant = 22;
     * @return {string}
     */
    proto.Features.prototype.getFirmwareVariant = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 22, ""));
    };


    /** @param {string} value */
    proto.Features.prototype.setFirmwareVariant = function(value) {
      googleProtobuf.Message.setField(this, 22, value);
    };


    proto.Features.prototype.clearFirmwareVariant = function() {
      googleProtobuf.Message.setField(this, 22, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasFirmwareVariant = function() {
      return googleProtobuf.Message.getField(this, 22) != null;
    };


    /**
     * optional bytes firmware_hash = 23;
     * @return {!(string|Uint8Array)}
     */
    proto.Features.prototype.getFirmwareHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 23, ""));
    };


    /**
     * optional bytes firmware_hash = 23;
     * This is a type-conversion wrapper around `getFirmwareHash()`
     * @return {string}
     */
    proto.Features.prototype.getFirmwareHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getFirmwareHash()));
    };


    /**
     * optional bytes firmware_hash = 23;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getFirmwareHash()`
     * @return {!Uint8Array}
     */
    proto.Features.prototype.getFirmwareHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getFirmwareHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.Features.prototype.setFirmwareHash = function(value) {
      googleProtobuf.Message.setField(this, 23, value);
    };


    proto.Features.prototype.clearFirmwareHash = function() {
      googleProtobuf.Message.setField(this, 23, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasFirmwareHash = function() {
      return googleProtobuf.Message.getField(this, 23) != null;
    };


    /**
     * optional bool no_backup = 24;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Features.prototype.getNoBackup = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 24, false));
    };


    /** @param {boolean} value */
    proto.Features.prototype.setNoBackup = function(value) {
      googleProtobuf.Message.setField(this, 24, value);
    };


    proto.Features.prototype.clearNoBackup = function() {
      googleProtobuf.Message.setField(this, 24, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Features.prototype.hasNoBackup = function() {
      return googleProtobuf.Message.getField(this, 24) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.GetCoinTable = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.GetCoinTable, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.GetCoinTable.prototype.toObject = function(opt_includeInstance) {
      return proto.GetCoinTable.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.GetCoinTable} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetCoinTable.toObject = function(includeInstance, msg) {
      var obj = {
        start: googleProtobuf.Message.getField(msg, 1),
        end: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.GetCoinTable}
     */
    proto.GetCoinTable.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.GetCoinTable;
      return proto.GetCoinTable.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.GetCoinTable} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.GetCoinTable}
     */
    proto.GetCoinTable.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setStart(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setEnd(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.GetCoinTable.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.GetCoinTable.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.GetCoinTable} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetCoinTable.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
    };


    /**
     * optional uint32 start = 1;
     * @return {number}
     */
    proto.GetCoinTable.prototype.getStart = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.GetCoinTable.prototype.setStart = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.GetCoinTable.prototype.clearStart = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetCoinTable.prototype.hasStart = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 end = 2;
     * @return {number}
     */
    proto.GetCoinTable.prototype.getEnd = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.GetCoinTable.prototype.setEnd = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.GetCoinTable.prototype.clearEnd = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetCoinTable.prototype.hasEnd = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CoinTable = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.CoinTable.repeatedFields_, null);
    };
    goog.inherits(proto.CoinTable, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.CoinTable.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CoinTable.prototype.toObject = function(opt_includeInstance) {
      return proto.CoinTable.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CoinTable} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CoinTable.toObject = function(includeInstance, msg) {
      var obj = {
        tableList: googleProtobuf.Message.toObjectList(msg.getTableList(),
        types_pb.CoinType.toObject, includeInstance),
        numCoins: googleProtobuf.Message.getField(msg, 2),
        chunkSize: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CoinTable}
     */
    proto.CoinTable.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CoinTable;
      return proto.CoinTable.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CoinTable} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CoinTable}
     */
    proto.CoinTable.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.CoinType;
          reader.readMessage(value,types_pb.CoinType.deserializeBinaryFromReader);
          msg.addTable(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setNumCoins(value);
          break;
        case 3:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setChunkSize(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CoinTable.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CoinTable.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CoinTable} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CoinTable.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getTableList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          types_pb.CoinType.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeUint32(
          3,
          f
        );
      }
    };


    /**
     * repeated CoinType table = 1;
     * @return {!Array.<!proto.CoinType>}
     */
    proto.CoinTable.prototype.getTableList = function() {
      return /** @type{!Array.<!proto.CoinType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.CoinType, 1));
    };


    /** @param {!Array.<!proto.CoinType>} value */
    proto.CoinTable.prototype.setTableList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.CoinType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.CoinType}
     */
    proto.CoinTable.prototype.addTable = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.CoinType, opt_index);
    };


    proto.CoinTable.prototype.clearTableList = function() {
      this.setTableList([]);
    };


    /**
     * optional uint32 num_coins = 2;
     * @return {number}
     */
    proto.CoinTable.prototype.getNumCoins = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.CoinTable.prototype.setNumCoins = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.CoinTable.prototype.clearNumCoins = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinTable.prototype.hasNumCoins = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional uint32 chunk_size = 3;
     * @return {number}
     */
    proto.CoinTable.prototype.getChunkSize = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, 0));
    };


    /** @param {number} value */
    proto.CoinTable.prototype.setChunkSize = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.CoinTable.prototype.clearChunkSize = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CoinTable.prototype.hasChunkSize = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ClearSession = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ClearSession, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ClearSession.prototype.toObject = function(opt_includeInstance) {
      return proto.ClearSession.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ClearSession} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ClearSession.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ClearSession}
     */
    proto.ClearSession.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ClearSession;
      return proto.ClearSession.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ClearSession} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ClearSession}
     */
    proto.ClearSession.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ClearSession.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ClearSession.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ClearSession} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ClearSession.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ApplySettings = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ApplySettings, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ApplySettings.prototype.toObject = function(opt_includeInstance) {
      return proto.ApplySettings.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ApplySettings} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ApplySettings.toObject = function(includeInstance, msg) {
      var obj = {
        language: googleProtobuf.Message.getField(msg, 1),
        label: googleProtobuf.Message.getField(msg, 2),
        usePassphrase: googleProtobuf.Message.getField(msg, 3),
        autoLockDelayMs: googleProtobuf.Message.getField(msg, 4),
        u2fCounter: googleProtobuf.Message.getField(msg, 5)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ApplySettings}
     */
    proto.ApplySettings.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ApplySettings;
      return proto.ApplySettings.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ApplySettings} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ApplySettings}
     */
    proto.ApplySettings.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setLanguage(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setLabel(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setUsePassphrase(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAutoLockDelayMs(value);
          break;
        case 5:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setU2fCounter(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ApplySettings.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ApplySettings.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ApplySettings} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ApplySettings.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint32(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeUint32(
          5,
          f
        );
      }
    };


    /**
     * optional string language = 1;
     * @return {string}
     */
    proto.ApplySettings.prototype.getLanguage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.ApplySettings.prototype.setLanguage = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.ApplySettings.prototype.clearLanguage = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ApplySettings.prototype.hasLanguage = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string label = 2;
     * @return {string}
     */
    proto.ApplySettings.prototype.getLabel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.ApplySettings.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ApplySettings.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ApplySettings.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool use_passphrase = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ApplySettings.prototype.getUsePassphrase = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.ApplySettings.prototype.setUsePassphrase = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.ApplySettings.prototype.clearUsePassphrase = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ApplySettings.prototype.hasUsePassphrase = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint32 auto_lock_delay_ms = 4;
     * @return {number}
     */
    proto.ApplySettings.prototype.getAutoLockDelayMs = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {number} value */
    proto.ApplySettings.prototype.setAutoLockDelayMs = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.ApplySettings.prototype.clearAutoLockDelayMs = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ApplySettings.prototype.hasAutoLockDelayMs = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional uint32 u2f_counter = 5;
     * @return {number}
     */
    proto.ApplySettings.prototype.getU2fCounter = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 0));
    };


    /** @param {number} value */
    proto.ApplySettings.prototype.setU2fCounter = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.ApplySettings.prototype.clearU2fCounter = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ApplySettings.prototype.hasU2fCounter = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ChangePin = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ChangePin, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ChangePin.prototype.toObject = function(opt_includeInstance) {
      return proto.ChangePin.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ChangePin} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ChangePin.toObject = function(includeInstance, msg) {
      var obj = {
        remove: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ChangePin}
     */
    proto.ChangePin.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ChangePin;
      return proto.ChangePin.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ChangePin} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ChangePin}
     */
    proto.ChangePin.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setRemove(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ChangePin.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ChangePin.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ChangePin} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ChangePin.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBool(
          1,
          f
        );
      }
    };


    /**
     * optional bool remove = 1;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ChangePin.prototype.getRemove = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, false));
    };


    /** @param {boolean} value */
    proto.ChangePin.prototype.setRemove = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.ChangePin.prototype.clearRemove = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ChangePin.prototype.hasRemove = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Ping = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Ping, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Ping.prototype.toObject = function(opt_includeInstance) {
      return proto.Ping.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Ping} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Ping.toObject = function(includeInstance, msg) {
      var obj = {
        message: googleProtobuf.Message.getField(msg, 1),
        buttonProtection: googleProtobuf.Message.getField(msg, 2),
        pinProtection: googleProtobuf.Message.getField(msg, 3),
        passphraseProtection: googleProtobuf.Message.getField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Ping}
     */
    proto.Ping.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Ping;
      return proto.Ping.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Ping} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Ping}
     */
    proto.Ping.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setMessage(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setButtonProtection(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPinProtection(value);
          break;
        case 4:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Ping.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Ping.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Ping} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Ping.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBool(
          4,
          f
        );
      }
    };


    /**
     * optional string message = 1;
     * @return {string}
     */
    proto.Ping.prototype.getMessage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.Ping.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Ping.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Ping.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool button_protection = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Ping.prototype.getButtonProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.Ping.prototype.setButtonProtection = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.Ping.prototype.clearButtonProtection = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Ping.prototype.hasButtonProtection = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool pin_protection = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Ping.prototype.getPinProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.Ping.prototype.setPinProtection = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.Ping.prototype.clearPinProtection = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Ping.prototype.hasPinProtection = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool passphrase_protection = 4;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.Ping.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, false));
    };


    /** @param {boolean} value */
    proto.Ping.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.Ping.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Ping.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Success = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Success, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Success.prototype.toObject = function(opt_includeInstance) {
      return proto.Success.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Success} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Success.toObject = function(includeInstance, msg) {
      var obj = {
        message: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Success}
     */
    proto.Success.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Success;
      return proto.Success.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Success} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Success}
     */
    proto.Success.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setMessage(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Success.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Success.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Success} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Success.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
    };


    /**
     * optional string message = 1;
     * @return {string}
     */
    proto.Success.prototype.getMessage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.Success.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Success.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Success.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Failure = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Failure, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Failure.prototype.toObject = function(opt_includeInstance) {
      return proto.Failure.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Failure} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Failure.toObject = function(includeInstance, msg) {
      var obj = {
        code: googleProtobuf.Message.getField(msg, 1),
        message: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Failure}
     */
    proto.Failure.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Failure;
      return proto.Failure.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Failure} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Failure}
     */
    proto.Failure.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!proto.FailureType} */ (reader.readEnum());
          msg.setCode(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setMessage(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Failure.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Failure.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Failure} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Failure.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!proto.FailureType} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeEnum(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
    };


    /**
     * optional FailureType code = 1;
     * @return {!proto.FailureType}
     */
    proto.Failure.prototype.getCode = function() {
      return /** @type {!proto.FailureType} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 1));
    };


    /** @param {!proto.FailureType} value */
    proto.Failure.prototype.setCode = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Failure.prototype.clearCode = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Failure.prototype.hasCode = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string message = 2;
     * @return {string}
     */
    proto.Failure.prototype.getMessage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.Failure.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.Failure.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Failure.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ButtonRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ButtonRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ButtonRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.ButtonRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ButtonRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ButtonRequest.toObject = function(includeInstance, msg) {
      var obj = {
        code: googleProtobuf.Message.getField(msg, 1),
        data: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ButtonRequest}
     */
    proto.ButtonRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ButtonRequest;
      return proto.ButtonRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ButtonRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ButtonRequest}
     */
    proto.ButtonRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!proto.ButtonRequestType} */ (reader.readEnum());
          msg.setCode(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setData(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ButtonRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ButtonRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ButtonRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ButtonRequest.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!proto.ButtonRequestType} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeEnum(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
    };


    /**
     * optional ButtonRequestType code = 1;
     * @return {!proto.ButtonRequestType}
     */
    proto.ButtonRequest.prototype.getCode = function() {
      return /** @type {!proto.ButtonRequestType} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 1));
    };


    /** @param {!proto.ButtonRequestType} value */
    proto.ButtonRequest.prototype.setCode = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.ButtonRequest.prototype.clearCode = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ButtonRequest.prototype.hasCode = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string data = 2;
     * @return {string}
     */
    proto.ButtonRequest.prototype.getData = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.ButtonRequest.prototype.setData = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ButtonRequest.prototype.clearData = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ButtonRequest.prototype.hasData = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ButtonAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ButtonAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ButtonAck.prototype.toObject = function(opt_includeInstance) {
      return proto.ButtonAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ButtonAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ButtonAck.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ButtonAck}
     */
    proto.ButtonAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ButtonAck;
      return proto.ButtonAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ButtonAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ButtonAck}
     */
    proto.ButtonAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ButtonAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ButtonAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ButtonAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ButtonAck.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PinMatrixRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PinMatrixRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PinMatrixRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.PinMatrixRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PinMatrixRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PinMatrixRequest.toObject = function(includeInstance, msg) {
      var obj = {
        type: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PinMatrixRequest}
     */
    proto.PinMatrixRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PinMatrixRequest;
      return proto.PinMatrixRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PinMatrixRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PinMatrixRequest}
     */
    proto.PinMatrixRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!proto.PinMatrixRequestType} */ (reader.readEnum());
          msg.setType(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PinMatrixRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PinMatrixRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PinMatrixRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PinMatrixRequest.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!proto.PinMatrixRequestType} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeEnum(
          1,
          f
        );
      }
    };


    /**
     * optional PinMatrixRequestType type = 1;
     * @return {!proto.PinMatrixRequestType}
     */
    proto.PinMatrixRequest.prototype.getType = function() {
      return /** @type {!proto.PinMatrixRequestType} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 1));
    };


    /** @param {!proto.PinMatrixRequestType} value */
    proto.PinMatrixRequest.prototype.setType = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.PinMatrixRequest.prototype.clearType = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PinMatrixRequest.prototype.hasType = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PinMatrixAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PinMatrixAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PinMatrixAck.prototype.toObject = function(opt_includeInstance) {
      return proto.PinMatrixAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PinMatrixAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PinMatrixAck.toObject = function(includeInstance, msg) {
      var obj = {
        pin: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PinMatrixAck}
     */
    proto.PinMatrixAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PinMatrixAck;
      return proto.PinMatrixAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PinMatrixAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PinMatrixAck}
     */
    proto.PinMatrixAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setPin(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PinMatrixAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PinMatrixAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PinMatrixAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PinMatrixAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
    };


    /**
     * required string pin = 1;
     * @return {string}
     */
    proto.PinMatrixAck.prototype.getPin = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.PinMatrixAck.prototype.setPin = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.PinMatrixAck.prototype.clearPin = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PinMatrixAck.prototype.hasPin = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Cancel = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Cancel, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Cancel.prototype.toObject = function(opt_includeInstance) {
      return proto.Cancel.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Cancel} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Cancel.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Cancel}
     */
    proto.Cancel.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Cancel;
      return proto.Cancel.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Cancel} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Cancel}
     */
    proto.Cancel.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Cancel.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Cancel.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Cancel} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Cancel.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PassphraseRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PassphraseRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PassphraseRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.PassphraseRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PassphraseRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PassphraseRequest.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PassphraseRequest}
     */
    proto.PassphraseRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PassphraseRequest;
      return proto.PassphraseRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PassphraseRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PassphraseRequest}
     */
    proto.PassphraseRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PassphraseRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PassphraseRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PassphraseRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PassphraseRequest.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PassphraseAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PassphraseAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PassphraseAck.prototype.toObject = function(opt_includeInstance) {
      return proto.PassphraseAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PassphraseAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PassphraseAck.toObject = function(includeInstance, msg) {
      var obj = {
        passphrase: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PassphraseAck}
     */
    proto.PassphraseAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PassphraseAck;
      return proto.PassphraseAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PassphraseAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PassphraseAck}
     */
    proto.PassphraseAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setPassphrase(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PassphraseAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PassphraseAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PassphraseAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PassphraseAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
    };


    /**
     * required string passphrase = 1;
     * @return {string}
     */
    proto.PassphraseAck.prototype.getPassphrase = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.PassphraseAck.prototype.setPassphrase = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.PassphraseAck.prototype.clearPassphrase = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PassphraseAck.prototype.hasPassphrase = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.GetEntropy = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.GetEntropy, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.GetEntropy.prototype.toObject = function(opt_includeInstance) {
      return proto.GetEntropy.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.GetEntropy} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetEntropy.toObject = function(includeInstance, msg) {
      var obj = {
        size: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.GetEntropy}
     */
    proto.GetEntropy.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.GetEntropy;
      return proto.GetEntropy.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.GetEntropy} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.GetEntropy}
     */
    proto.GetEntropy.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setSize(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.GetEntropy.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.GetEntropy.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.GetEntropy} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetEntropy.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
    };


    /**
     * required uint32 size = 1;
     * @return {number}
     */
    proto.GetEntropy.prototype.getSize = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.GetEntropy.prototype.setSize = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.GetEntropy.prototype.clearSize = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetEntropy.prototype.hasSize = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Entropy = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Entropy, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Entropy.prototype.toObject = function(opt_includeInstance) {
      return proto.Entropy.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Entropy} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Entropy.toObject = function(includeInstance, msg) {
      var obj = {
        entropy: msg.getEntropy_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Entropy}
     */
    proto.Entropy.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Entropy;
      return proto.Entropy.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Entropy} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Entropy}
     */
    proto.Entropy.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setEntropy(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Entropy.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Entropy.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Entropy} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Entropy.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * required bytes entropy = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.Entropy.prototype.getEntropy = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * required bytes entropy = 1;
     * This is a type-conversion wrapper around `getEntropy()`
     * @return {string}
     */
    proto.Entropy.prototype.getEntropy_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getEntropy()));
    };


    /**
     * required bytes entropy = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getEntropy()`
     * @return {!Uint8Array}
     */
    proto.Entropy.prototype.getEntropy_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getEntropy()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.Entropy.prototype.setEntropy = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Entropy.prototype.clearEntropy = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Entropy.prototype.hasEntropy = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.GetPublicKey = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.GetPublicKey.repeatedFields_, null);
    };
    goog.inherits(proto.GetPublicKey, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.GetPublicKey.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.GetPublicKey.prototype.toObject = function(opt_includeInstance) {
      return proto.GetPublicKey.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.GetPublicKey} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetPublicKey.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        ecdsaCurveName: googleProtobuf.Message.getField(msg, 2),
        showDisplay: googleProtobuf.Message.getField(msg, 3),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 4, "Bitcoin"),
        scriptType: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.GetPublicKey}
     */
    proto.GetPublicKey.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.GetPublicKey;
      return proto.GetPublicKey.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.GetPublicKey} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.GetPublicKey}
     */
    proto.GetPublicKey.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setEcdsaCurveName(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setShowDisplay(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        case 5:
          var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
          msg.setScriptType(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.GetPublicKey.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.GetPublicKey.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.GetPublicKey} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetPublicKey.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
      f = /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeEnum(
          5,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.GetPublicKey.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.GetPublicKey.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.GetPublicKey.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.GetPublicKey.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional string ecdsa_curve_name = 2;
     * @return {string}
     */
    proto.GetPublicKey.prototype.getEcdsaCurveName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.GetPublicKey.prototype.setEcdsaCurveName = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.GetPublicKey.prototype.clearEcdsaCurveName = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetPublicKey.prototype.hasEcdsaCurveName = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool show_display = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.GetPublicKey.prototype.getShowDisplay = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.GetPublicKey.prototype.setShowDisplay = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.GetPublicKey.prototype.clearShowDisplay = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetPublicKey.prototype.hasShowDisplay = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string coin_name = 4;
     * @return {string}
     */
    proto.GetPublicKey.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, "Bitcoin"));
    };


    /** @param {string} value */
    proto.GetPublicKey.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.GetPublicKey.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetPublicKey.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional InputScriptType script_type = 5;
     * @return {!proto.InputScriptType}
     */
    proto.GetPublicKey.prototype.getScriptType = function() {
      return /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 0));
    };


    /** @param {!proto.InputScriptType} value */
    proto.GetPublicKey.prototype.setScriptType = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.GetPublicKey.prototype.clearScriptType = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetPublicKey.prototype.hasScriptType = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.PublicKey = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.PublicKey, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.PublicKey.prototype.toObject = function(opt_includeInstance) {
      return proto.PublicKey.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.PublicKey} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PublicKey.toObject = function(includeInstance, msg) {
      var f, obj = {
        node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
        xpub: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.PublicKey}
     */
    proto.PublicKey.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.PublicKey;
      return proto.PublicKey.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.PublicKey} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.PublicKey}
     */
    proto.PublicKey.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.HDNodeType;
          reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
          msg.setNode(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setXpub(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.PublicKey.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.PublicKey.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.PublicKey} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.PublicKey.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getNode();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          types_pb.HDNodeType.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
    };


    /**
     * required HDNodeType node = 1;
     * @return {!proto.HDNodeType}
     */
    proto.PublicKey.prototype.getNode = function() {
      return /** @type{!proto.HDNodeType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.HDNodeType, 1, 1));
    };


    /** @param {!proto.HDNodeType} value */
    proto.PublicKey.prototype.setNode = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.PublicKey.prototype.clearNode = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PublicKey.prototype.hasNode = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string xpub = 2;
     * @return {string}
     */
    proto.PublicKey.prototype.getXpub = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.PublicKey.prototype.setXpub = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.PublicKey.prototype.clearXpub = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.PublicKey.prototype.hasXpub = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.GetAddress = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.GetAddress.repeatedFields_, null);
    };
    goog.inherits(proto.GetAddress, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.GetAddress.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.GetAddress.prototype.toObject = function(opt_includeInstance) {
      return proto.GetAddress.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.GetAddress} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetAddress.toObject = function(includeInstance, msg) {
      var f, obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 2, "Bitcoin"),
        showDisplay: googleProtobuf.Message.getField(msg, 3),
        multisig: (f = msg.getMultisig()) && types_pb.MultisigRedeemScriptType.toObject(includeInstance, f),
        scriptType: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.GetAddress}
     */
    proto.GetAddress.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.GetAddress;
      return proto.GetAddress.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.GetAddress} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.GetAddress}
     */
    proto.GetAddress.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setShowDisplay(value);
          break;
        case 4:
          var value = new types_pb.MultisigRedeemScriptType;
          reader.readMessage(value,types_pb.MultisigRedeemScriptType.deserializeBinaryFromReader);
          msg.setMultisig(value);
          break;
        case 5:
          var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
          msg.setScriptType(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.GetAddress.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.GetAddress.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.GetAddress} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.GetAddress.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = message.getMultisig();
      if (f != null) {
        writer.writeMessage(
          4,
          f,
          types_pb.MultisigRedeemScriptType.serializeBinaryToWriter
        );
      }
      f = /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeEnum(
          5,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.GetAddress.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.GetAddress.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.GetAddress.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.GetAddress.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional string coin_name = 2;
     * @return {string}
     */
    proto.GetAddress.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, "Bitcoin"));
    };


    /** @param {string} value */
    proto.GetAddress.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.GetAddress.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetAddress.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool show_display = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.GetAddress.prototype.getShowDisplay = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.GetAddress.prototype.setShowDisplay = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.GetAddress.prototype.clearShowDisplay = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetAddress.prototype.hasShowDisplay = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional MultisigRedeemScriptType multisig = 4;
     * @return {?proto.MultisigRedeemScriptType}
     */
    proto.GetAddress.prototype.getMultisig = function() {
      return /** @type{?proto.MultisigRedeemScriptType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.MultisigRedeemScriptType, 4));
    };


    /** @param {?proto.MultisigRedeemScriptType|undefined} value */
    proto.GetAddress.prototype.setMultisig = function(value) {
      googleProtobuf.Message.setWrapperField(this, 4, value);
    };


    proto.GetAddress.prototype.clearMultisig = function() {
      this.setMultisig(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetAddress.prototype.hasMultisig = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional InputScriptType script_type = 5;
     * @return {!proto.InputScriptType}
     */
    proto.GetAddress.prototype.getScriptType = function() {
      return /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 0));
    };


    /** @param {!proto.InputScriptType} value */
    proto.GetAddress.prototype.setScriptType = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.GetAddress.prototype.clearScriptType = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.GetAddress.prototype.hasScriptType = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumGetAddress = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.EthereumGetAddress.repeatedFields_, null);
    };
    goog.inherits(proto.EthereumGetAddress, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.EthereumGetAddress.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumGetAddress.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumGetAddress.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumGetAddress} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumGetAddress.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        showDisplay: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumGetAddress}
     */
    proto.EthereumGetAddress.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumGetAddress;
      return proto.EthereumGetAddress.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumGetAddress} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumGetAddress}
     */
    proto.EthereumGetAddress.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setShowDisplay(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumGetAddress.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumGetAddress.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumGetAddress} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumGetAddress.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.EthereumGetAddress.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.EthereumGetAddress.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.EthereumGetAddress.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.EthereumGetAddress.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional bool show_display = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.EthereumGetAddress.prototype.getShowDisplay = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.EthereumGetAddress.prototype.setShowDisplay = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumGetAddress.prototype.clearShowDisplay = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumGetAddress.prototype.hasShowDisplay = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.Address = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.Address, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.Address.prototype.toObject = function(opt_includeInstance) {
      return proto.Address.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.Address} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Address.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.Address}
     */
    proto.Address.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.Address;
      return proto.Address.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.Address} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.Address}
     */
    proto.Address.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.Address.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.Address.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.Address} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.Address.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
    };


    /**
     * required string address = 1;
     * @return {string}
     */
    proto.Address.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.Address.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.Address.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.Address.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumAddress = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EthereumAddress, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumAddress.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumAddress.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumAddress} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumAddress.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        addressStr: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumAddress}
     */
    proto.EthereumAddress.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumAddress;
      return proto.EthereumAddress.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumAddress} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumAddress}
     */
    proto.EthereumAddress.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddressStr(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumAddress.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumAddress.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumAddress} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumAddress.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
    };


    /**
     * required bytes address = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumAddress.prototype.getAddress = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * required bytes address = 1;
     * This is a type-conversion wrapper around `getAddress()`
     * @return {string}
     */
    proto.EthereumAddress.prototype.getAddress_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getAddress()));
    };


    /**
     * required bytes address = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getAddress()`
     * @return {!Uint8Array}
     */
    proto.EthereumAddress.prototype.getAddress_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getAddress()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumAddress.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EthereumAddress.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumAddress.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string address_str = 2;
     * @return {string}
     */
    proto.EthereumAddress.prototype.getAddressStr = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.EthereumAddress.prototype.setAddressStr = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumAddress.prototype.clearAddressStr = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumAddress.prototype.hasAddressStr = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.WipeDevice = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.WipeDevice, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.WipeDevice.prototype.toObject = function(opt_includeInstance) {
      return proto.WipeDevice.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.WipeDevice} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WipeDevice.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.WipeDevice}
     */
    proto.WipeDevice.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.WipeDevice;
      return proto.WipeDevice.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.WipeDevice} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.WipeDevice}
     */
    proto.WipeDevice.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.WipeDevice.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.WipeDevice.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.WipeDevice} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WipeDevice.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.LoadDevice = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.LoadDevice, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.LoadDevice.prototype.toObject = function(opt_includeInstance) {
      return proto.LoadDevice.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.LoadDevice} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.LoadDevice.toObject = function(includeInstance, msg) {
      var f, obj = {
        mnemonic: googleProtobuf.Message.getField(msg, 1),
        node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
        pin: googleProtobuf.Message.getField(msg, 3),
        passphraseProtection: googleProtobuf.Message.getField(msg, 4),
        language: googleProtobuf.Message.getFieldWithDefault(msg, 5, "english"),
        label: googleProtobuf.Message.getField(msg, 6),
        skipChecksum: googleProtobuf.Message.getField(msg, 7),
        u2fCounter: googleProtobuf.Message.getField(msg, 8)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.LoadDevice}
     */
    proto.LoadDevice.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.LoadDevice;
      return proto.LoadDevice.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.LoadDevice} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.LoadDevice}
     */
    proto.LoadDevice.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setMnemonic(value);
          break;
        case 2:
          var value = new types_pb.HDNodeType;
          reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
          msg.setNode(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setPin(value);
          break;
        case 4:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.setLanguage(value);
          break;
        case 6:
          var value = /** @type {string} */ (reader.readString());
          msg.setLabel(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setSkipChecksum(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setU2fCounter(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.LoadDevice.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.LoadDevice.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.LoadDevice} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.LoadDevice.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = message.getNode();
      if (f != null) {
        writer.writeMessage(
          2,
          f,
          types_pb.HDNodeType.serializeBinaryToWriter
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBool(
          4,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeString(
          5,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeString(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint32(
          8,
          f
        );
      }
    };


    /**
     * optional string mnemonic = 1;
     * @return {string}
     */
    proto.LoadDevice.prototype.getMnemonic = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.LoadDevice.prototype.setMnemonic = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.LoadDevice.prototype.clearMnemonic = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasMnemonic = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional HDNodeType node = 2;
     * @return {?proto.HDNodeType}
     */
    proto.LoadDevice.prototype.getNode = function() {
      return /** @type{?proto.HDNodeType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.HDNodeType, 2));
    };


    /** @param {?proto.HDNodeType|undefined} value */
    proto.LoadDevice.prototype.setNode = function(value) {
      googleProtobuf.Message.setWrapperField(this, 2, value);
    };


    proto.LoadDevice.prototype.clearNode = function() {
      this.setNode(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasNode = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string pin = 3;
     * @return {string}
     */
    proto.LoadDevice.prototype.getPin = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.LoadDevice.prototype.setPin = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.LoadDevice.prototype.clearPin = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasPin = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool passphrase_protection = 4;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.LoadDevice.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, false));
    };


    /** @param {boolean} value */
    proto.LoadDevice.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.LoadDevice.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional string language = 5;
     * @return {string}
     */
    proto.LoadDevice.prototype.getLanguage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, "english"));
    };


    /** @param {string} value */
    proto.LoadDevice.prototype.setLanguage = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.LoadDevice.prototype.clearLanguage = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasLanguage = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional string label = 6;
     * @return {string}
     */
    proto.LoadDevice.prototype.getLabel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /** @param {string} value */
    proto.LoadDevice.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.LoadDevice.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool skip_checksum = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.LoadDevice.prototype.getSkipChecksum = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.LoadDevice.prototype.setSkipChecksum = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.LoadDevice.prototype.clearSkipChecksum = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasSkipChecksum = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint32 u2f_counter = 8;
     * @return {number}
     */
    proto.LoadDevice.prototype.getU2fCounter = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.LoadDevice.prototype.setU2fCounter = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.LoadDevice.prototype.clearU2fCounter = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.LoadDevice.prototype.hasU2fCounter = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ResetDevice = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.ResetDevice, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ResetDevice.prototype.toObject = function(opt_includeInstance) {
      return proto.ResetDevice.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ResetDevice} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ResetDevice.toObject = function(includeInstance, msg) {
      var obj = {
        displayRandom: googleProtobuf.Message.getField(msg, 1),
        strength: googleProtobuf.Message.getFieldWithDefault(msg, 2, 256),
        passphraseProtection: googleProtobuf.Message.getField(msg, 3),
        pinProtection: googleProtobuf.Message.getField(msg, 4),
        language: googleProtobuf.Message.getFieldWithDefault(msg, 5, "english"),
        label: googleProtobuf.Message.getField(msg, 6),
        noBackup: googleProtobuf.Message.getField(msg, 7),
        autoLockDelayMs: googleProtobuf.Message.getField(msg, 8),
        u2fCounter: googleProtobuf.Message.getField(msg, 9)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ResetDevice}
     */
    proto.ResetDevice.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ResetDevice;
      return proto.ResetDevice.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ResetDevice} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ResetDevice}
     */
    proto.ResetDevice.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDisplayRandom(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setStrength(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        case 4:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPinProtection(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.setLanguage(value);
          break;
        case 6:
          var value = /** @type {string} */ (reader.readString());
          msg.setLabel(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setNoBackup(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAutoLockDelayMs(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setU2fCounter(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ResetDevice.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ResetDevice.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ResetDevice} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ResetDevice.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBool(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBool(
          4,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeString(
          5,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeString(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint32(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
    };


    /**
     * optional bool display_random = 1;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ResetDevice.prototype.getDisplayRandom = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, false));
    };


    /** @param {boolean} value */
    proto.ResetDevice.prototype.setDisplayRandom = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.ResetDevice.prototype.clearDisplayRandom = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasDisplayRandom = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 strength = 2;
     * @return {number}
     */
    proto.ResetDevice.prototype.getStrength = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 256));
    };


    /** @param {number} value */
    proto.ResetDevice.prototype.setStrength = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.ResetDevice.prototype.clearStrength = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasStrength = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool passphrase_protection = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ResetDevice.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.ResetDevice.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.ResetDevice.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool pin_protection = 4;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ResetDevice.prototype.getPinProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, false));
    };


    /** @param {boolean} value */
    proto.ResetDevice.prototype.setPinProtection = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.ResetDevice.prototype.clearPinProtection = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasPinProtection = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional string language = 5;
     * @return {string}
     */
    proto.ResetDevice.prototype.getLanguage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, "english"));
    };


    /** @param {string} value */
    proto.ResetDevice.prototype.setLanguage = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.ResetDevice.prototype.clearLanguage = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasLanguage = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional string label = 6;
     * @return {string}
     */
    proto.ResetDevice.prototype.getLabel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /** @param {string} value */
    proto.ResetDevice.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.ResetDevice.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool no_backup = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.ResetDevice.prototype.getNoBackup = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.ResetDevice.prototype.setNoBackup = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.ResetDevice.prototype.clearNoBackup = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasNoBackup = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint32 auto_lock_delay_ms = 8;
     * @return {number}
     */
    proto.ResetDevice.prototype.getAutoLockDelayMs = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.ResetDevice.prototype.setAutoLockDelayMs = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.ResetDevice.prototype.clearAutoLockDelayMs = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasAutoLockDelayMs = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 u2f_counter = 9;
     * @return {number}
     */
    proto.ResetDevice.prototype.getU2fCounter = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.ResetDevice.prototype.setU2fCounter = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.ResetDevice.prototype.clearU2fCounter = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.ResetDevice.prototype.hasU2fCounter = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EntropyRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EntropyRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EntropyRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.EntropyRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EntropyRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EntropyRequest.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EntropyRequest}
     */
    proto.EntropyRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EntropyRequest;
      return proto.EntropyRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EntropyRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EntropyRequest}
     */
    proto.EntropyRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EntropyRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EntropyRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EntropyRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EntropyRequest.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EntropyAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EntropyAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EntropyAck.prototype.toObject = function(opt_includeInstance) {
      return proto.EntropyAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EntropyAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EntropyAck.toObject = function(includeInstance, msg) {
      var obj = {
        entropy: msg.getEntropy_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EntropyAck}
     */
    proto.EntropyAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EntropyAck;
      return proto.EntropyAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EntropyAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EntropyAck}
     */
    proto.EntropyAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setEntropy(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EntropyAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EntropyAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EntropyAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EntropyAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * optional bytes entropy = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EntropyAck.prototype.getEntropy = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes entropy = 1;
     * This is a type-conversion wrapper around `getEntropy()`
     * @return {string}
     */
    proto.EntropyAck.prototype.getEntropy_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getEntropy()));
    };


    /**
     * optional bytes entropy = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getEntropy()`
     * @return {!Uint8Array}
     */
    proto.EntropyAck.prototype.getEntropy_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getEntropy()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EntropyAck.prototype.setEntropy = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EntropyAck.prototype.clearEntropy = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EntropyAck.prototype.hasEntropy = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.RecoveryDevice = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.RecoveryDevice, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.RecoveryDevice.prototype.toObject = function(opt_includeInstance) {
      return proto.RecoveryDevice.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.RecoveryDevice} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RecoveryDevice.toObject = function(includeInstance, msg) {
      var obj = {
        wordCount: googleProtobuf.Message.getField(msg, 1),
        passphraseProtection: googleProtobuf.Message.getField(msg, 2),
        pinProtection: googleProtobuf.Message.getField(msg, 3),
        language: googleProtobuf.Message.getFieldWithDefault(msg, 4, "english"),
        label: googleProtobuf.Message.getField(msg, 5),
        enforceWordlist: googleProtobuf.Message.getField(msg, 6),
        useCharacterCipher: googleProtobuf.Message.getField(msg, 7),
        autoLockDelayMs: googleProtobuf.Message.getField(msg, 8),
        u2fCounter: googleProtobuf.Message.getField(msg, 9),
        dryRun: googleProtobuf.Message.getField(msg, 10)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.RecoveryDevice}
     */
    proto.RecoveryDevice.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.RecoveryDevice;
      return proto.RecoveryDevice.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.RecoveryDevice} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.RecoveryDevice}
     */
    proto.RecoveryDevice.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setWordCount(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPinProtection(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setLanguage(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.setLabel(value);
          break;
        case 6:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setEnforceWordlist(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setUseCharacterCipher(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAutoLockDelayMs(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setU2fCounter(value);
          break;
        case 10:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDryRun(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.RecoveryDevice.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.RecoveryDevice.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.RecoveryDevice} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RecoveryDevice.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeString(
          5,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBool(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint32(
          8,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeUint32(
          9,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeBool(
          10,
          f
        );
      }
    };


    /**
     * optional uint32 word_count = 1;
     * @return {number}
     */
    proto.RecoveryDevice.prototype.getWordCount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.RecoveryDevice.prototype.setWordCount = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.RecoveryDevice.prototype.clearWordCount = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasWordCount = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool passphrase_protection = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.RecoveryDevice.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.RecoveryDevice.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.RecoveryDevice.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool pin_protection = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.RecoveryDevice.prototype.getPinProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.RecoveryDevice.prototype.setPinProtection = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.RecoveryDevice.prototype.clearPinProtection = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasPinProtection = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string language = 4;
     * @return {string}
     */
    proto.RecoveryDevice.prototype.getLanguage = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, "english"));
    };


    /** @param {string} value */
    proto.RecoveryDevice.prototype.setLanguage = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.RecoveryDevice.prototype.clearLanguage = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasLanguage = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional string label = 5;
     * @return {string}
     */
    proto.RecoveryDevice.prototype.getLabel = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, ""));
    };


    /** @param {string} value */
    proto.RecoveryDevice.prototype.setLabel = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.RecoveryDevice.prototype.clearLabel = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasLabel = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bool enforce_wordlist = 6;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.RecoveryDevice.prototype.getEnforceWordlist = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, false));
    };


    /** @param {boolean} value */
    proto.RecoveryDevice.prototype.setEnforceWordlist = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.RecoveryDevice.prototype.clearEnforceWordlist = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasEnforceWordlist = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool use_character_cipher = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.RecoveryDevice.prototype.getUseCharacterCipher = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.RecoveryDevice.prototype.setUseCharacterCipher = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.RecoveryDevice.prototype.clearUseCharacterCipher = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasUseCharacterCipher = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint32 auto_lock_delay_ms = 8;
     * @return {number}
     */
    proto.RecoveryDevice.prototype.getAutoLockDelayMs = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.RecoveryDevice.prototype.setAutoLockDelayMs = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.RecoveryDevice.prototype.clearAutoLockDelayMs = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasAutoLockDelayMs = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional uint32 u2f_counter = 9;
     * @return {number}
     */
    proto.RecoveryDevice.prototype.getU2fCounter = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, 0));
    };


    /** @param {number} value */
    proto.RecoveryDevice.prototype.setU2fCounter = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.RecoveryDevice.prototype.clearU2fCounter = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasU2fCounter = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional bool dry_run = 10;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.RecoveryDevice.prototype.getDryRun = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, false));
    };


    /** @param {boolean} value */
    proto.RecoveryDevice.prototype.setDryRun = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.RecoveryDevice.prototype.clearDryRun = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RecoveryDevice.prototype.hasDryRun = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.WordRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.WordRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.WordRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.WordRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.WordRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WordRequest.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.WordRequest}
     */
    proto.WordRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.WordRequest;
      return proto.WordRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.WordRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.WordRequest}
     */
    proto.WordRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.WordRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.WordRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.WordRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WordRequest.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.WordAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.WordAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.WordAck.prototype.toObject = function(opt_includeInstance) {
      return proto.WordAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.WordAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WordAck.toObject = function(includeInstance, msg) {
      var obj = {
        word: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.WordAck}
     */
    proto.WordAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.WordAck;
      return proto.WordAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.WordAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.WordAck}
     */
    proto.WordAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setWord(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.WordAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.WordAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.WordAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.WordAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
    };


    /**
     * required string word = 1;
     * @return {string}
     */
    proto.WordAck.prototype.getWord = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.WordAck.prototype.setWord = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.WordAck.prototype.clearWord = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.WordAck.prototype.hasWord = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CharacterRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.CharacterRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CharacterRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.CharacterRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CharacterRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CharacterRequest.toObject = function(includeInstance, msg) {
      var obj = {
        wordPos: googleProtobuf.Message.getField(msg, 1),
        characterPos: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CharacterRequest}
     */
    proto.CharacterRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CharacterRequest;
      return proto.CharacterRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CharacterRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CharacterRequest}
     */
    proto.CharacterRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setWordPos(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setCharacterPos(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CharacterRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CharacterRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CharacterRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CharacterRequest.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
    };


    /**
     * required uint32 word_pos = 1;
     * @return {number}
     */
    proto.CharacterRequest.prototype.getWordPos = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.CharacterRequest.prototype.setWordPos = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.CharacterRequest.prototype.clearWordPos = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CharacterRequest.prototype.hasWordPos = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required uint32 character_pos = 2;
     * @return {number}
     */
    proto.CharacterRequest.prototype.getCharacterPos = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.CharacterRequest.prototype.setCharacterPos = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.CharacterRequest.prototype.clearCharacterPos = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CharacterRequest.prototype.hasCharacterPos = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CharacterAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.CharacterAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CharacterAck.prototype.toObject = function(opt_includeInstance) {
      return proto.CharacterAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CharacterAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CharacterAck.toObject = function(includeInstance, msg) {
      var obj = {
        character: googleProtobuf.Message.getField(msg, 1),
        pb_delete: googleProtobuf.Message.getField(msg, 2),
        done: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CharacterAck}
     */
    proto.CharacterAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CharacterAck;
      return proto.CharacterAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CharacterAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CharacterAck}
     */
    proto.CharacterAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setCharacter(value);
          break;
        case 2:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDelete(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDone(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CharacterAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CharacterAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CharacterAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CharacterAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBool(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
    };


    /**
     * optional string character = 1;
     * @return {string}
     */
    proto.CharacterAck.prototype.getCharacter = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.CharacterAck.prototype.setCharacter = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.CharacterAck.prototype.clearCharacter = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CharacterAck.prototype.hasCharacter = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bool delete = 2;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CharacterAck.prototype.getDelete = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, false));
    };


    /** @param {boolean} value */
    proto.CharacterAck.prototype.setDelete = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.CharacterAck.prototype.clearDelete = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CharacterAck.prototype.hasDelete = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool done = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CharacterAck.prototype.getDone = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.CharacterAck.prototype.setDone = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.CharacterAck.prototype.clearDone = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CharacterAck.prototype.hasDone = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SignMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.SignMessage.repeatedFields_, null);
    };
    goog.inherits(proto.SignMessage, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.SignMessage.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SignMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.SignMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SignMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignMessage.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        message: msg.getMessage_asB64(),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 3, "Bitcoin"),
        scriptType: googleProtobuf.Message.getFieldWithDefault(msg, 4, 0)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SignMessage}
     */
    proto.SignMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SignMessage;
      return proto.SignMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SignMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SignMessage}
     */
    proto.SignMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        case 4:
          var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
          msg.setScriptType(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SignMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SignMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SignMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeEnum(
          4,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.SignMessage.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.SignMessage.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.SignMessage.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.SignMessage.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * required bytes message = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.SignMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * required bytes message = 2;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.SignMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * required bytes message = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.SignMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.SignMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.SignMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string coin_name = 3;
     * @return {string}
     */
    proto.SignMessage.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, "Bitcoin"));
    };


    /** @param {string} value */
    proto.SignMessage.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.SignMessage.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignMessage.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional InputScriptType script_type = 4;
     * @return {!proto.InputScriptType}
     */
    proto.SignMessage.prototype.getScriptType = function() {
      return /** @type {!proto.InputScriptType} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 0));
    };


    /** @param {!proto.InputScriptType} value */
    proto.SignMessage.prototype.setScriptType = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.SignMessage.prototype.clearScriptType = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignMessage.prototype.hasScriptType = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.VerifyMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.VerifyMessage, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.VerifyMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.VerifyMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.VerifyMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.VerifyMessage.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        signature: msg.getSignature_asB64(),
        message: msg.getMessage_asB64(),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 4, "Bitcoin")
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.VerifyMessage}
     */
    proto.VerifyMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.VerifyMessage;
      return proto.VerifyMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.VerifyMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.VerifyMessage}
     */
    proto.VerifyMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.VerifyMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.VerifyMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.VerifyMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.VerifyMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
    };


    /**
     * optional string address = 1;
     * @return {string}
     */
    proto.VerifyMessage.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.VerifyMessage.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.VerifyMessage.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.VerifyMessage.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.VerifyMessage.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.VerifyMessage.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.VerifyMessage.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.VerifyMessage.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.VerifyMessage.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.VerifyMessage.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes message = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.VerifyMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes message = 3;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.VerifyMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.VerifyMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.VerifyMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.VerifyMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.VerifyMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string coin_name = 4;
     * @return {string}
     */
    proto.VerifyMessage.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, "Bitcoin"));
    };


    /** @param {string} value */
    proto.VerifyMessage.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.VerifyMessage.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.VerifyMessage.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.MessageSignature = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.MessageSignature, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.MessageSignature.prototype.toObject = function(opt_includeInstance) {
      return proto.MessageSignature.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.MessageSignature} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.MessageSignature.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        signature: msg.getSignature_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.MessageSignature}
     */
    proto.MessageSignature.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.MessageSignature;
      return proto.MessageSignature.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.MessageSignature} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.MessageSignature}
     */
    proto.MessageSignature.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.MessageSignature.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.MessageSignature.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.MessageSignature} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.MessageSignature.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
    };


    /**
     * optional string address = 1;
     * @return {string}
     */
    proto.MessageSignature.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.MessageSignature.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.MessageSignature.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.MessageSignature.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.MessageSignature.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.MessageSignature.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.MessageSignature.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.MessageSignature.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.MessageSignature.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.MessageSignature.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EncryptMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.EncryptMessage.repeatedFields_, null);
    };
    goog.inherits(proto.EncryptMessage, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.EncryptMessage.repeatedFields_ = [4];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EncryptMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.EncryptMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EncryptMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EncryptMessage.toObject = function(includeInstance, msg) {
      var obj = {
        pubkey: msg.getPubkey_asB64(),
        message: msg.getMessage_asB64(),
        displayOnly: googleProtobuf.Message.getField(msg, 3),
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 4),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 5, "Bitcoin")
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EncryptMessage}
     */
    proto.EncryptMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EncryptMessage;
      return proto.EncryptMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EncryptMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EncryptMessage}
     */
    proto.EncryptMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPubkey(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setDisplayOnly(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 5:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EncryptMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EncryptMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EncryptMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EncryptMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          4,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeString(
          5,
          f
        );
      }
    };


    /**
     * optional bytes pubkey = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EncryptMessage.prototype.getPubkey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes pubkey = 1;
     * This is a type-conversion wrapper around `getPubkey()`
     * @return {string}
     */
    proto.EncryptMessage.prototype.getPubkey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPubkey()));
    };


    /**
     * optional bytes pubkey = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPubkey()`
     * @return {!Uint8Array}
     */
    proto.EncryptMessage.prototype.getPubkey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPubkey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EncryptMessage.prototype.setPubkey = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EncryptMessage.prototype.clearPubkey = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptMessage.prototype.hasPubkey = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes message = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EncryptMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes message = 2;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.EncryptMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.EncryptMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EncryptMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EncryptMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool display_only = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.EncryptMessage.prototype.getDisplayOnly = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.EncryptMessage.prototype.setDisplayOnly = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EncryptMessage.prototype.clearDisplayOnly = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptMessage.prototype.hasDisplayOnly = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * repeated uint32 address_n = 4;
     * @return {!Array.<number>}
     */
    proto.EncryptMessage.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 4));
    };


    /** @param {!Array.<number>} value */
    proto.EncryptMessage.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 4, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.EncryptMessage.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 4, value, opt_index);
    };


    proto.EncryptMessage.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional string coin_name = 5;
     * @return {string}
     */
    proto.EncryptMessage.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, "Bitcoin"));
    };


    /** @param {string} value */
    proto.EncryptMessage.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.EncryptMessage.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptMessage.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EncryptedMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EncryptedMessage, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EncryptedMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.EncryptedMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EncryptedMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EncryptedMessage.toObject = function(includeInstance, msg) {
      var obj = {
        nonce: msg.getNonce_asB64(),
        message: msg.getMessage_asB64(),
        hmac: msg.getHmac_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EncryptedMessage}
     */
    proto.EncryptedMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EncryptedMessage;
      return proto.EncryptedMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EncryptedMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EncryptedMessage}
     */
    proto.EncryptedMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setNonce(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setHmac(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EncryptedMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EncryptedMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EncryptedMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EncryptedMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
    };


    /**
     * optional bytes nonce = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EncryptedMessage.prototype.getNonce = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes nonce = 1;
     * This is a type-conversion wrapper around `getNonce()`
     * @return {string}
     */
    proto.EncryptedMessage.prototype.getNonce_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getNonce()));
    };


    /**
     * optional bytes nonce = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getNonce()`
     * @return {!Uint8Array}
     */
    proto.EncryptedMessage.prototype.getNonce_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getNonce()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EncryptedMessage.prototype.setNonce = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EncryptedMessage.prototype.clearNonce = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptedMessage.prototype.hasNonce = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes message = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EncryptedMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes message = 2;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.EncryptedMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.EncryptedMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EncryptedMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EncryptedMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptedMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes hmac = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.EncryptedMessage.prototype.getHmac = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes hmac = 3;
     * This is a type-conversion wrapper around `getHmac()`
     * @return {string}
     */
    proto.EncryptedMessage.prototype.getHmac_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getHmac()));
    };


    /**
     * optional bytes hmac = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getHmac()`
     * @return {!Uint8Array}
     */
    proto.EncryptedMessage.prototype.getHmac_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getHmac()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EncryptedMessage.prototype.setHmac = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EncryptedMessage.prototype.clearHmac = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EncryptedMessage.prototype.hasHmac = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DecryptMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.DecryptMessage.repeatedFields_, null);
    };
    goog.inherits(proto.DecryptMessage, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.DecryptMessage.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DecryptMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.DecryptMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DecryptMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DecryptMessage.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        nonce: msg.getNonce_asB64(),
        message: msg.getMessage_asB64(),
        hmac: msg.getHmac_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DecryptMessage}
     */
    proto.DecryptMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DecryptMessage;
      return proto.DecryptMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DecryptMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DecryptMessage}
     */
    proto.DecryptMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setNonce(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setHmac(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DecryptMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DecryptMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DecryptMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DecryptMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.DecryptMessage.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.DecryptMessage.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.DecryptMessage.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.DecryptMessage.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional bytes nonce = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.DecryptMessage.prototype.getNonce = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes nonce = 2;
     * This is a type-conversion wrapper around `getNonce()`
     * @return {string}
     */
    proto.DecryptMessage.prototype.getNonce_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getNonce()));
    };


    /**
     * optional bytes nonce = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getNonce()`
     * @return {!Uint8Array}
     */
    proto.DecryptMessage.prototype.getNonce_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getNonce()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DecryptMessage.prototype.setNonce = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.DecryptMessage.prototype.clearNonce = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DecryptMessage.prototype.hasNonce = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes message = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.DecryptMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes message = 3;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.DecryptMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.DecryptMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DecryptMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.DecryptMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DecryptMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bytes hmac = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.DecryptMessage.prototype.getHmac = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * optional bytes hmac = 4;
     * This is a type-conversion wrapper around `getHmac()`
     * @return {string}
     */
    proto.DecryptMessage.prototype.getHmac_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getHmac()));
    };


    /**
     * optional bytes hmac = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getHmac()`
     * @return {!Uint8Array}
     */
    proto.DecryptMessage.prototype.getHmac_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getHmac()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DecryptMessage.prototype.setHmac = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.DecryptMessage.prototype.clearHmac = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DecryptMessage.prototype.hasHmac = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DecryptedMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DecryptedMessage, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DecryptedMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.DecryptedMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DecryptedMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DecryptedMessage.toObject = function(includeInstance, msg) {
      var obj = {
        message: msg.getMessage_asB64(),
        address: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DecryptedMessage}
     */
    proto.DecryptedMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DecryptedMessage;
      return proto.DecryptedMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DecryptedMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DecryptedMessage}
     */
    proto.DecryptedMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DecryptedMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DecryptedMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DecryptedMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DecryptedMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
    };


    /**
     * optional bytes message = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.DecryptedMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes message = 1;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.DecryptedMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.DecryptedMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DecryptedMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DecryptedMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DecryptedMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string address = 2;
     * @return {string}
     */
    proto.DecryptedMessage.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.DecryptedMessage.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.DecryptedMessage.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DecryptedMessage.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CipherKeyValue = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.CipherKeyValue.repeatedFields_, null);
    };
    goog.inherits(proto.CipherKeyValue, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.CipherKeyValue.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CipherKeyValue.prototype.toObject = function(opt_includeInstance) {
      return proto.CipherKeyValue.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CipherKeyValue} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CipherKeyValue.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        key: googleProtobuf.Message.getField(msg, 2),
        value: msg.getValue_asB64(),
        encrypt: googleProtobuf.Message.getField(msg, 4),
        askOnEncrypt: googleProtobuf.Message.getField(msg, 5),
        askOnDecrypt: googleProtobuf.Message.getField(msg, 6),
        iv: msg.getIv_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CipherKeyValue}
     */
    proto.CipherKeyValue.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CipherKeyValue;
      return proto.CipherKeyValue.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CipherKeyValue} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CipherKeyValue}
     */
    proto.CipherKeyValue.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setKey(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setValue(value);
          break;
        case 4:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setEncrypt(value);
          break;
        case 5:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setAskOnEncrypt(value);
          break;
        case 6:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setAskOnDecrypt(value);
          break;
        case 7:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setIv(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CipherKeyValue.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CipherKeyValue.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CipherKeyValue} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CipherKeyValue.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBool(
          4,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBool(
          5,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBool(
          6,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBytes(
          7,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.CipherKeyValue.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.CipherKeyValue.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.CipherKeyValue.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.CipherKeyValue.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional string key = 2;
     * @return {string}
     */
    proto.CipherKeyValue.prototype.getKey = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.CipherKeyValue.prototype.setKey = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.CipherKeyValue.prototype.clearKey = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasKey = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes value = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.CipherKeyValue.prototype.getValue = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes value = 3;
     * This is a type-conversion wrapper around `getValue()`
     * @return {string}
     */
    proto.CipherKeyValue.prototype.getValue_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getValue()));
    };


    /**
     * optional bytes value = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getValue()`
     * @return {!Uint8Array}
     */
    proto.CipherKeyValue.prototype.getValue_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getValue()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.CipherKeyValue.prototype.setValue = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.CipherKeyValue.prototype.clearValue = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasValue = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bool encrypt = 4;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CipherKeyValue.prototype.getEncrypt = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, false));
    };


    /** @param {boolean} value */
    proto.CipherKeyValue.prototype.setEncrypt = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.CipherKeyValue.prototype.clearEncrypt = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasEncrypt = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bool ask_on_encrypt = 5;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CipherKeyValue.prototype.getAskOnEncrypt = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, false));
    };


    /** @param {boolean} value */
    proto.CipherKeyValue.prototype.setAskOnEncrypt = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.CipherKeyValue.prototype.clearAskOnEncrypt = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasAskOnEncrypt = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bool ask_on_decrypt = 6;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.CipherKeyValue.prototype.getAskOnDecrypt = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, false));
    };


    /** @param {boolean} value */
    proto.CipherKeyValue.prototype.setAskOnDecrypt = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.CipherKeyValue.prototype.clearAskOnDecrypt = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasAskOnDecrypt = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bytes iv = 7;
     * @return {!(string|Uint8Array)}
     */
    proto.CipherKeyValue.prototype.getIv = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, ""));
    };


    /**
     * optional bytes iv = 7;
     * This is a type-conversion wrapper around `getIv()`
     * @return {string}
     */
    proto.CipherKeyValue.prototype.getIv_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getIv()));
    };


    /**
     * optional bytes iv = 7;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getIv()`
     * @return {!Uint8Array}
     */
    proto.CipherKeyValue.prototype.getIv_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getIv()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.CipherKeyValue.prototype.setIv = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.CipherKeyValue.prototype.clearIv = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipherKeyValue.prototype.hasIv = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.CipheredKeyValue = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.CipheredKeyValue, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.CipheredKeyValue.prototype.toObject = function(opt_includeInstance) {
      return proto.CipheredKeyValue.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.CipheredKeyValue} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CipheredKeyValue.toObject = function(includeInstance, msg) {
      var obj = {
        value: msg.getValue_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.CipheredKeyValue}
     */
    proto.CipheredKeyValue.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.CipheredKeyValue;
      return proto.CipheredKeyValue.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.CipheredKeyValue} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.CipheredKeyValue}
     */
    proto.CipheredKeyValue.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setValue(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.CipheredKeyValue.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.CipheredKeyValue.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.CipheredKeyValue} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.CipheredKeyValue.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * optional bytes value = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.CipheredKeyValue.prototype.getValue = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes value = 1;
     * This is a type-conversion wrapper around `getValue()`
     * @return {string}
     */
    proto.CipheredKeyValue.prototype.getValue_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getValue()));
    };


    /**
     * optional bytes value = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getValue()`
     * @return {!Uint8Array}
     */
    proto.CipheredKeyValue.prototype.getValue_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getValue()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.CipheredKeyValue.prototype.setValue = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.CipheredKeyValue.prototype.clearValue = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.CipheredKeyValue.prototype.hasValue = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EstimateTxSize = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EstimateTxSize, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EstimateTxSize.prototype.toObject = function(opt_includeInstance) {
      return proto.EstimateTxSize.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EstimateTxSize} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EstimateTxSize.toObject = function(includeInstance, msg) {
      var obj = {
        outputsCount: googleProtobuf.Message.getField(msg, 1),
        inputsCount: googleProtobuf.Message.getField(msg, 2),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 3, "Bitcoin")
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EstimateTxSize}
     */
    proto.EstimateTxSize.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EstimateTxSize;
      return proto.EstimateTxSize.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EstimateTxSize} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EstimateTxSize}
     */
    proto.EstimateTxSize.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setOutputsCount(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setInputsCount(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EstimateTxSize.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EstimateTxSize.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EstimateTxSize} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EstimateTxSize.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
    };


    /**
     * required uint32 outputs_count = 1;
     * @return {number}
     */
    proto.EstimateTxSize.prototype.getOutputsCount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.EstimateTxSize.prototype.setOutputsCount = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EstimateTxSize.prototype.clearOutputsCount = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EstimateTxSize.prototype.hasOutputsCount = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required uint32 inputs_count = 2;
     * @return {number}
     */
    proto.EstimateTxSize.prototype.getInputsCount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.EstimateTxSize.prototype.setInputsCount = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EstimateTxSize.prototype.clearInputsCount = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EstimateTxSize.prototype.hasInputsCount = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string coin_name = 3;
     * @return {string}
     */
    proto.EstimateTxSize.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, "Bitcoin"));
    };


    /** @param {string} value */
    proto.EstimateTxSize.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EstimateTxSize.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EstimateTxSize.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxSize = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxSize, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxSize.prototype.toObject = function(opt_includeInstance) {
      return proto.TxSize.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxSize} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxSize.toObject = function(includeInstance, msg) {
      var obj = {
        txSize: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxSize}
     */
    proto.TxSize.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxSize;
      return proto.TxSize.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxSize} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxSize}
     */
    proto.TxSize.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setTxSize(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxSize.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxSize.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxSize} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxSize.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
    };


    /**
     * optional uint32 tx_size = 1;
     * @return {number}
     */
    proto.TxSize.prototype.getTxSize = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.TxSize.prototype.setTxSize = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxSize.prototype.clearTxSize = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxSize.prototype.hasTxSize = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SignTx = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.SignTx, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SignTx.prototype.toObject = function(opt_includeInstance) {
      return proto.SignTx.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SignTx} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignTx.toObject = function(includeInstance, msg) {
      var obj = {
        outputsCount: googleProtobuf.Message.getField(msg, 1),
        inputsCount: googleProtobuf.Message.getField(msg, 2),
        coinName: googleProtobuf.Message.getFieldWithDefault(msg, 3, "Bitcoin"),
        version: googleProtobuf.Message.getFieldWithDefault(msg, 4, 1),
        lockTime: googleProtobuf.Message.getFieldWithDefault(msg, 5, 0),
        expiry: googleProtobuf.Message.getField(msg, 6),
        overwintered: googleProtobuf.Message.getField(msg, 7),
        versionGroupId: googleProtobuf.Message.getField(msg, 8)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SignTx}
     */
    proto.SignTx.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SignTx;
      return proto.SignTx.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SignTx} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SignTx}
     */
    proto.SignTx.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setOutputsCount(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setInputsCount(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setCoinName(value);
          break;
        case 4:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setVersion(value);
          break;
        case 5:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setLockTime(value);
          break;
        case 6:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setExpiry(value);
          break;
        case 7:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setOverwintered(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setVersionGroupId(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SignTx.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SignTx.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SignTx} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignTx.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeUint32(
          4,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeUint32(
          5,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeUint32(
          6,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBool(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint32(
          8,
          f
        );
      }
    };


    /**
     * required uint32 outputs_count = 1;
     * @return {number}
     */
    proto.SignTx.prototype.getOutputsCount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setOutputsCount = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.SignTx.prototype.clearOutputsCount = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasOutputsCount = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required uint32 inputs_count = 2;
     * @return {number}
     */
    proto.SignTx.prototype.getInputsCount = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setInputsCount = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.SignTx.prototype.clearInputsCount = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasInputsCount = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string coin_name = 3;
     * @return {string}
     */
    proto.SignTx.prototype.getCoinName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, "Bitcoin"));
    };


    /** @param {string} value */
    proto.SignTx.prototype.setCoinName = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.SignTx.prototype.clearCoinName = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasCoinName = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional uint32 version = 4;
     * @return {number}
     */
    proto.SignTx.prototype.getVersion = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, 1));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setVersion = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.SignTx.prototype.clearVersion = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasVersion = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional uint32 lock_time = 5;
     * @return {number}
     */
    proto.SignTx.prototype.getLockTime = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, 0));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setLockTime = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.SignTx.prototype.clearLockTime = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasLockTime = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional uint32 expiry = 6;
     * @return {number}
     */
    proto.SignTx.prototype.getExpiry = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, 0));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setExpiry = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.SignTx.prototype.clearExpiry = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasExpiry = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bool overwintered = 7;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.SignTx.prototype.getOverwintered = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, false));
    };


    /** @param {boolean} value */
    proto.SignTx.prototype.setOverwintered = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.SignTx.prototype.clearOverwintered = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasOverwintered = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint32 version_group_id = 8;
     * @return {number}
     */
    proto.SignTx.prototype.getVersionGroupId = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.SignTx.prototype.setVersionGroupId = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.SignTx.prototype.clearVersionGroupId = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignTx.prototype.hasVersionGroupId = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.TxRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequest.toObject = function(includeInstance, msg) {
      var f, obj = {
        requestType: googleProtobuf.Message.getField(msg, 1),
        details: (f = msg.getDetails()) && types_pb.TxRequestDetailsType.toObject(includeInstance, f),
        serialized: (f = msg.getSerialized()) && types_pb.TxRequestSerializedType.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxRequest}
     */
    proto.TxRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxRequest;
      return proto.TxRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxRequest}
     */
    proto.TxRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!proto.RequestType} */ (reader.readEnum());
          msg.setRequestType(value);
          break;
        case 2:
          var value = new types_pb.TxRequestDetailsType;
          reader.readMessage(value,types_pb.TxRequestDetailsType.deserializeBinaryFromReader);
          msg.setDetails(value);
          break;
        case 3:
          var value = new types_pb.TxRequestSerializedType;
          reader.readMessage(value,types_pb.TxRequestSerializedType.deserializeBinaryFromReader);
          msg.setSerialized(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxRequest.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!proto.RequestType} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeEnum(
          1,
          f
        );
      }
      f = message.getDetails();
      if (f != null) {
        writer.writeMessage(
          2,
          f,
          types_pb.TxRequestDetailsType.serializeBinaryToWriter
        );
      }
      f = message.getSerialized();
      if (f != null) {
        writer.writeMessage(
          3,
          f,
          types_pb.TxRequestSerializedType.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional RequestType request_type = 1;
     * @return {!proto.RequestType}
     */
    proto.TxRequest.prototype.getRequestType = function() {
      return /** @type {!proto.RequestType} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {!proto.RequestType} value */
    proto.TxRequest.prototype.setRequestType = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.TxRequest.prototype.clearRequestType = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequest.prototype.hasRequestType = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional TxRequestDetailsType details = 2;
     * @return {?proto.TxRequestDetailsType}
     */
    proto.TxRequest.prototype.getDetails = function() {
      return /** @type{?proto.TxRequestDetailsType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.TxRequestDetailsType, 2));
    };


    /** @param {?proto.TxRequestDetailsType|undefined} value */
    proto.TxRequest.prototype.setDetails = function(value) {
      googleProtobuf.Message.setWrapperField(this, 2, value);
    };


    proto.TxRequest.prototype.clearDetails = function() {
      this.setDetails(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequest.prototype.hasDetails = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional TxRequestSerializedType serialized = 3;
     * @return {?proto.TxRequestSerializedType}
     */
    proto.TxRequest.prototype.getSerialized = function() {
      return /** @type{?proto.TxRequestSerializedType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.TxRequestSerializedType, 3));
    };


    /** @param {?proto.TxRequestSerializedType|undefined} value */
    proto.TxRequest.prototype.setSerialized = function(value) {
      googleProtobuf.Message.setWrapperField(this, 3, value);
    };


    proto.TxRequest.prototype.clearSerialized = function() {
      this.setSerialized(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxRequest.prototype.hasSerialized = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.TxAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.TxAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.TxAck.prototype.toObject = function(opt_includeInstance) {
      return proto.TxAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.TxAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxAck.toObject = function(includeInstance, msg) {
      var f, obj = {
        tx: (f = msg.getTx()) && types_pb.TransactionType.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.TxAck}
     */
    proto.TxAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.TxAck;
      return proto.TxAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.TxAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.TxAck}
     */
    proto.TxAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.TransactionType;
          reader.readMessage(value,types_pb.TransactionType.deserializeBinaryFromReader);
          msg.setTx(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.TxAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.TxAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.TxAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.TxAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getTx();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          types_pb.TransactionType.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional TransactionType tx = 1;
     * @return {?proto.TransactionType}
     */
    proto.TxAck.prototype.getTx = function() {
      return /** @type{?proto.TransactionType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.TransactionType, 1));
    };


    /** @param {?proto.TransactionType|undefined} value */
    proto.TxAck.prototype.setTx = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.TxAck.prototype.clearTx = function() {
      this.setTx(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.TxAck.prototype.hasTx = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.RawTxAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.RawTxAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.RawTxAck.prototype.toObject = function(opt_includeInstance) {
      return proto.RawTxAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.RawTxAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RawTxAck.toObject = function(includeInstance, msg) {
      var f, obj = {
        tx: (f = msg.getTx()) && types_pb.RawTransactionType.toObject(includeInstance, f)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.RawTxAck}
     */
    proto.RawTxAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.RawTxAck;
      return proto.RawTxAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.RawTxAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.RawTxAck}
     */
    proto.RawTxAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.RawTransactionType;
          reader.readMessage(value,types_pb.RawTransactionType.deserializeBinaryFromReader);
          msg.setTx(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.RawTxAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.RawTxAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.RawTxAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.RawTxAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getTx();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          types_pb.RawTransactionType.serializeBinaryToWriter
        );
      }
    };


    /**
     * optional RawTransactionType tx = 1;
     * @return {?proto.RawTransactionType}
     */
    proto.RawTxAck.prototype.getTx = function() {
      return /** @type{?proto.RawTransactionType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.RawTransactionType, 1));
    };


    /** @param {?proto.RawTransactionType|undefined} value */
    proto.RawTxAck.prototype.setTx = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.RawTxAck.prototype.clearTx = function() {
      this.setTx(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.RawTxAck.prototype.hasTx = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumSignTx = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.EthereumSignTx.repeatedFields_, null);
    };
    goog.inherits(proto.EthereumSignTx, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.EthereumSignTx.repeatedFields_ = [1,9];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumSignTx.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumSignTx.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumSignTx} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumSignTx.toObject = function(includeInstance, msg) {
      var f, obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        nonce: msg.getNonce_asB64(),
        gasPrice: msg.getGasPrice_asB64(),
        gasLimit: msg.getGasLimit_asB64(),
        to: msg.getTo_asB64(),
        value: msg.getValue_asB64(),
        dataInitialChunk: msg.getDataInitialChunk_asB64(),
        dataLength: googleProtobuf.Message.getField(msg, 8),
        toAddressNList: googleProtobuf.Message.getRepeatedField(msg, 9),
        addressType: googleProtobuf.Message.getField(msg, 10),
        exchangeType: (f = msg.getExchangeType()) && types_pb.ExchangeType.toObject(includeInstance, f),
        chainId: googleProtobuf.Message.getField(msg, 12),
        tokenValue: msg.getTokenValue_asB64(),
        tokenTo: msg.getTokenTo_asB64(),
        tokenShortcut: googleProtobuf.Message.getField(msg, 102),
        txType: googleProtobuf.Message.getField(msg, 103)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumSignTx}
     */
    proto.EthereumSignTx.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumSignTx;
      return proto.EthereumSignTx.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumSignTx} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumSignTx}
     */
    proto.EthereumSignTx.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setNonce(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setGasPrice(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setGasLimit(value);
          break;
        case 5:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setTo(value);
          break;
        case 6:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setValue(value);
          break;
        case 7:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setDataInitialChunk(value);
          break;
        case 8:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDataLength(value);
          break;
        case 9:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addToAddressN(value);
          break;
        case 10:
          var value = /** @type {!proto.OutputAddressType} */ (reader.readEnum());
          msg.setAddressType(value);
          break;
        case 11:
          var value = new types_pb.ExchangeType;
          reader.readMessage(value,types_pb.ExchangeType.deserializeBinaryFromReader);
          msg.setExchangeType(value);
          break;
        case 12:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setChainId(value);
          break;
        case 100:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setTokenValue(value);
          break;
        case 101:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setTokenTo(value);
          break;
        case 102:
          var value = /** @type {string} */ (reader.readString());
          msg.setTokenShortcut(value);
          break;
        case 103:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setTxType(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumSignTx.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumSignTx} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumSignTx.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBytes(
          5,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBytes(
          6,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeBytes(
          7,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeUint32(
          8,
          f
        );
      }
      f = message.getToAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          9,
          f
        );
      }
      f = /** @type {!proto.OutputAddressType} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeEnum(
          10,
          f
        );
      }
      f = message.getExchangeType();
      if (f != null) {
        writer.writeMessage(
          11,
          f,
          types_pb.ExchangeType.serializeBinaryToWriter
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 12));
      if (f != null) {
        writer.writeUint32(
          12,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 100));
      if (f != null) {
        writer.writeBytes(
          100,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 101));
      if (f != null) {
        writer.writeBytes(
          101,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 102));
      if (f != null) {
        writer.writeString(
          102,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 103));
      if (f != null) {
        writer.writeUint32(
          103,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.EthereumSignTx.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.EthereumSignTx.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.EthereumSignTx.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.EthereumSignTx.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * optional bytes nonce = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getNonce = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes nonce = 2;
     * This is a type-conversion wrapper around `getNonce()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getNonce_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getNonce()));
    };


    /**
     * optional bytes nonce = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getNonce()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getNonce_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getNonce()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setNonce = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumSignTx.prototype.clearNonce = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasNonce = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes gas_price = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getGasPrice = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes gas_price = 3;
     * This is a type-conversion wrapper around `getGasPrice()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getGasPrice_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getGasPrice()));
    };


    /**
     * optional bytes gas_price = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getGasPrice()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getGasPrice_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getGasPrice()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setGasPrice = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EthereumSignTx.prototype.clearGasPrice = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasGasPrice = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bytes gas_limit = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getGasLimit = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * optional bytes gas_limit = 4;
     * This is a type-conversion wrapper around `getGasLimit()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getGasLimit_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getGasLimit()));
    };


    /**
     * optional bytes gas_limit = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getGasLimit()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getGasLimit_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getGasLimit()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setGasLimit = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.EthereumSignTx.prototype.clearGasLimit = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasGasLimit = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bytes to = 5;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getTo = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, ""));
    };


    /**
     * optional bytes to = 5;
     * This is a type-conversion wrapper around `getTo()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getTo_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getTo()));
    };


    /**
     * optional bytes to = 5;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getTo()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getTo_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getTo()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setTo = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.EthereumSignTx.prototype.clearTo = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasTo = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bytes value = 6;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getValue = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /**
     * optional bytes value = 6;
     * This is a type-conversion wrapper around `getValue()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getValue_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getValue()));
    };


    /**
     * optional bytes value = 6;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getValue()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getValue_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getValue()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setValue = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.EthereumSignTx.prototype.clearValue = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasValue = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional bytes data_initial_chunk = 7;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getDataInitialChunk = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, ""));
    };


    /**
     * optional bytes data_initial_chunk = 7;
     * This is a type-conversion wrapper around `getDataInitialChunk()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getDataInitialChunk_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getDataInitialChunk()));
    };


    /**
     * optional bytes data_initial_chunk = 7;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getDataInitialChunk()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getDataInitialChunk_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getDataInitialChunk()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setDataInitialChunk = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.EthereumSignTx.prototype.clearDataInitialChunk = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasDataInitialChunk = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional uint32 data_length = 8;
     * @return {number}
     */
    proto.EthereumSignTx.prototype.getDataLength = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, 0));
    };


    /** @param {number} value */
    proto.EthereumSignTx.prototype.setDataLength = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.EthereumSignTx.prototype.clearDataLength = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasDataLength = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * repeated uint32 to_address_n = 9;
     * @return {!Array.<number>}
     */
    proto.EthereumSignTx.prototype.getToAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 9));
    };


    /** @param {!Array.<number>} value */
    proto.EthereumSignTx.prototype.setToAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 9, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.EthereumSignTx.prototype.addToAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 9, value, opt_index);
    };


    proto.EthereumSignTx.prototype.clearToAddressNList = function() {
      this.setToAddressNList([]);
    };


    /**
     * optional OutputAddressType address_type = 10;
     * @return {!proto.OutputAddressType}
     */
    proto.EthereumSignTx.prototype.getAddressType = function() {
      return /** @type {!proto.OutputAddressType} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, 0));
    };


    /** @param {!proto.OutputAddressType} value */
    proto.EthereumSignTx.prototype.setAddressType = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.EthereumSignTx.prototype.clearAddressType = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasAddressType = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * optional ExchangeType exchange_type = 11;
     * @return {?proto.ExchangeType}
     */
    proto.EthereumSignTx.prototype.getExchangeType = function() {
      return /** @type{?proto.ExchangeType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.ExchangeType, 11));
    };


    /** @param {?proto.ExchangeType|undefined} value */
    proto.EthereumSignTx.prototype.setExchangeType = function(value) {
      googleProtobuf.Message.setWrapperField(this, 11, value);
    };


    proto.EthereumSignTx.prototype.clearExchangeType = function() {
      this.setExchangeType(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasExchangeType = function() {
      return googleProtobuf.Message.getField(this, 11) != null;
    };


    /**
     * optional uint32 chain_id = 12;
     * @return {number}
     */
    proto.EthereumSignTx.prototype.getChainId = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 12, 0));
    };


    /** @param {number} value */
    proto.EthereumSignTx.prototype.setChainId = function(value) {
      googleProtobuf.Message.setField(this, 12, value);
    };


    proto.EthereumSignTx.prototype.clearChainId = function() {
      googleProtobuf.Message.setField(this, 12, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasChainId = function() {
      return googleProtobuf.Message.getField(this, 12) != null;
    };


    /**
     * optional bytes token_value = 100;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getTokenValue = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 100, ""));
    };


    /**
     * optional bytes token_value = 100;
     * This is a type-conversion wrapper around `getTokenValue()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getTokenValue_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getTokenValue()));
    };


    /**
     * optional bytes token_value = 100;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getTokenValue()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getTokenValue_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getTokenValue()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setTokenValue = function(value) {
      googleProtobuf.Message.setField(this, 100, value);
    };


    proto.EthereumSignTx.prototype.clearTokenValue = function() {
      googleProtobuf.Message.setField(this, 100, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasTokenValue = function() {
      return googleProtobuf.Message.getField(this, 100) != null;
    };


    /**
     * optional bytes token_to = 101;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignTx.prototype.getTokenTo = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 101, ""));
    };


    /**
     * optional bytes token_to = 101;
     * This is a type-conversion wrapper around `getTokenTo()`
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getTokenTo_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getTokenTo()));
    };


    /**
     * optional bytes token_to = 101;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getTokenTo()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignTx.prototype.getTokenTo_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getTokenTo()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignTx.prototype.setTokenTo = function(value) {
      googleProtobuf.Message.setField(this, 101, value);
    };


    proto.EthereumSignTx.prototype.clearTokenTo = function() {
      googleProtobuf.Message.setField(this, 101, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasTokenTo = function() {
      return googleProtobuf.Message.getField(this, 101) != null;
    };


    /**
     * optional string token_shortcut = 102;
     * @return {string}
     */
    proto.EthereumSignTx.prototype.getTokenShortcut = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 102, ""));
    };


    /** @param {string} value */
    proto.EthereumSignTx.prototype.setTokenShortcut = function(value) {
      googleProtobuf.Message.setField(this, 102, value);
    };


    proto.EthereumSignTx.prototype.clearTokenShortcut = function() {
      googleProtobuf.Message.setField(this, 102, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasTokenShortcut = function() {
      return googleProtobuf.Message.getField(this, 102) != null;
    };


    /**
     * optional uint32 tx_type = 103;
     * @return {number}
     */
    proto.EthereumSignTx.prototype.getTxType = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 103, 0));
    };


    /** @param {number} value */
    proto.EthereumSignTx.prototype.setTxType = function(value) {
      googleProtobuf.Message.setField(this, 103, value);
    };


    proto.EthereumSignTx.prototype.clearTxType = function() {
      googleProtobuf.Message.setField(this, 103, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignTx.prototype.hasTxType = function() {
      return googleProtobuf.Message.getField(this, 103) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumTxRequest = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EthereumTxRequest, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumTxRequest.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumTxRequest.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumTxRequest} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumTxRequest.toObject = function(includeInstance, msg) {
      var obj = {
        dataLength: googleProtobuf.Message.getField(msg, 1),
        signatureV: googleProtobuf.Message.getField(msg, 2),
        signatureR: msg.getSignatureR_asB64(),
        signatureS: msg.getSignatureS_asB64(),
        hash: msg.getHash_asB64(),
        signatureDer: msg.getSignatureDer_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumTxRequest}
     */
    proto.EthereumTxRequest.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumTxRequest;
      return proto.EthereumTxRequest.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumTxRequest} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumTxRequest}
     */
    proto.EthereumTxRequest.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setDataLength(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setSignatureV(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignatureR(value);
          break;
        case 4:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignatureS(value);
          break;
        case 5:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setHash(value);
          break;
        case 6:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignatureDer(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumTxRequest.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumTxRequest.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumTxRequest} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumTxRequest.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeBytes(
          4,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 5));
      if (f != null) {
        writer.writeBytes(
          5,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBytes(
          6,
          f
        );
      }
    };


    /**
     * optional uint32 data_length = 1;
     * @return {number}
     */
    proto.EthereumTxRequest.prototype.getDataLength = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.EthereumTxRequest.prototype.setDataLength = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EthereumTxRequest.prototype.clearDataLength = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasDataLength = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 signature_v = 2;
     * @return {number}
     */
    proto.EthereumTxRequest.prototype.getSignatureV = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.EthereumTxRequest.prototype.setSignatureV = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumTxRequest.prototype.clearSignatureV = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasSignatureV = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes signature_r = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumTxRequest.prototype.getSignatureR = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes signature_r = 3;
     * This is a type-conversion wrapper around `getSignatureR()`
     * @return {string}
     */
    proto.EthereumTxRequest.prototype.getSignatureR_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignatureR()));
    };


    /**
     * optional bytes signature_r = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignatureR()`
     * @return {!Uint8Array}
     */
    proto.EthereumTxRequest.prototype.getSignatureR_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignatureR()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumTxRequest.prototype.setSignatureR = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EthereumTxRequest.prototype.clearSignatureR = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasSignatureR = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional bytes signature_s = 4;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumTxRequest.prototype.getSignatureS = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /**
     * optional bytes signature_s = 4;
     * This is a type-conversion wrapper around `getSignatureS()`
     * @return {string}
     */
    proto.EthereumTxRequest.prototype.getSignatureS_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignatureS()));
    };


    /**
     * optional bytes signature_s = 4;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignatureS()`
     * @return {!Uint8Array}
     */
    proto.EthereumTxRequest.prototype.getSignatureS_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignatureS()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumTxRequest.prototype.setSignatureS = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.EthereumTxRequest.prototype.clearSignatureS = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasSignatureS = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional bytes hash = 5;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumTxRequest.prototype.getHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 5, ""));
    };


    /**
     * optional bytes hash = 5;
     * This is a type-conversion wrapper around `getHash()`
     * @return {string}
     */
    proto.EthereumTxRequest.prototype.getHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getHash()));
    };


    /**
     * optional bytes hash = 5;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getHash()`
     * @return {!Uint8Array}
     */
    proto.EthereumTxRequest.prototype.getHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumTxRequest.prototype.setHash = function(value) {
      googleProtobuf.Message.setField(this, 5, value);
    };


    proto.EthereumTxRequest.prototype.clearHash = function() {
      googleProtobuf.Message.setField(this, 5, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasHash = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bytes signature_der = 6;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumTxRequest.prototype.getSignatureDer = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, ""));
    };


    /**
     * optional bytes signature_der = 6;
     * This is a type-conversion wrapper around `getSignatureDer()`
     * @return {string}
     */
    proto.EthereumTxRequest.prototype.getSignatureDer_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignatureDer()));
    };


    /**
     * optional bytes signature_der = 6;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignatureDer()`
     * @return {!Uint8Array}
     */
    proto.EthereumTxRequest.prototype.getSignatureDer_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignatureDer()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumTxRequest.prototype.setSignatureDer = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.EthereumTxRequest.prototype.clearSignatureDer = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxRequest.prototype.hasSignatureDer = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumTxAck = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EthereumTxAck, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumTxAck.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumTxAck.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumTxAck} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumTxAck.toObject = function(includeInstance, msg) {
      var obj = {
        dataChunk: msg.getDataChunk_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumTxAck}
     */
    proto.EthereumTxAck.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumTxAck;
      return proto.EthereumTxAck.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumTxAck} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumTxAck}
     */
    proto.EthereumTxAck.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setDataChunk(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumTxAck.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumTxAck.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumTxAck} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumTxAck.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * optional bytes data_chunk = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumTxAck.prototype.getDataChunk = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes data_chunk = 1;
     * This is a type-conversion wrapper around `getDataChunk()`
     * @return {string}
     */
    proto.EthereumTxAck.prototype.getDataChunk_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getDataChunk()));
    };


    /**
     * optional bytes data_chunk = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getDataChunk()`
     * @return {!Uint8Array}
     */
    proto.EthereumTxAck.prototype.getDataChunk_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getDataChunk()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumTxAck.prototype.setDataChunk = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EthereumTxAck.prototype.clearDataChunk = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumTxAck.prototype.hasDataChunk = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumSignMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.EthereumSignMessage.repeatedFields_, null);
    };
    goog.inherits(proto.EthereumSignMessage, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.EthereumSignMessage.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumSignMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumSignMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumSignMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumSignMessage.toObject = function(includeInstance, msg) {
      var obj = {
        addressNList: googleProtobuf.Message.getRepeatedField(msg, 1),
        message: msg.getMessage_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumSignMessage}
     */
    proto.EthereumSignMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumSignMessage;
      return proto.EthereumSignMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumSignMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumSignMessage}
     */
    proto.EthereumSignMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.addAddressN(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumSignMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumSignMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumSignMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumSignMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getAddressNList();
      if (f.length > 0) {
        writer.writeRepeatedUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
    };


    /**
     * repeated uint32 address_n = 1;
     * @return {!Array.<number>}
     */
    proto.EthereumSignMessage.prototype.getAddressNList = function() {
      return /** @type {!Array.<number>} */ (googleProtobuf.Message.getRepeatedField(this, 1));
    };


    /** @param {!Array.<number>} value */
    proto.EthereumSignMessage.prototype.setAddressNList = function(value) {
      googleProtobuf.Message.setField(this, 1, value || []);
    };


    /**
     * @param {!number} value
     * @param {number=} opt_index
     */
    proto.EthereumSignMessage.prototype.addAddressN = function(value, opt_index) {
      googleProtobuf.Message.addToRepeatedField(this, 1, value, opt_index);
    };


    proto.EthereumSignMessage.prototype.clearAddressNList = function() {
      this.setAddressNList([]);
    };


    /**
     * required bytes message = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumSignMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * required bytes message = 2;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.EthereumSignMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * required bytes message = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.EthereumSignMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumSignMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumSignMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumSignMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumVerifyMessage = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EthereumVerifyMessage, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumVerifyMessage.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumVerifyMessage.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumVerifyMessage} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumVerifyMessage.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        signature: msg.getSignature_asB64(),
        message: msg.getMessage_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumVerifyMessage}
     */
    proto.EthereumVerifyMessage.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumVerifyMessage;
      return proto.EthereumVerifyMessage.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumVerifyMessage} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumVerifyMessage}
     */
    proto.EthereumVerifyMessage.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setMessage(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumVerifyMessage.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumVerifyMessage.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumVerifyMessage} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumVerifyMessage.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
    };


    /**
     * optional bytes address = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumVerifyMessage.prototype.getAddress = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes address = 1;
     * This is a type-conversion wrapper around `getAddress()`
     * @return {string}
     */
    proto.EthereumVerifyMessage.prototype.getAddress_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getAddress()));
    };


    /**
     * optional bytes address = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getAddress()`
     * @return {!Uint8Array}
     */
    proto.EthereumVerifyMessage.prototype.getAddress_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getAddress()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumVerifyMessage.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EthereumVerifyMessage.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumVerifyMessage.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumVerifyMessage.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.EthereumVerifyMessage.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.EthereumVerifyMessage.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumVerifyMessage.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumVerifyMessage.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumVerifyMessage.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes message = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumVerifyMessage.prototype.getMessage = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes message = 3;
     * This is a type-conversion wrapper around `getMessage()`
     * @return {string}
     */
    proto.EthereumVerifyMessage.prototype.getMessage_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getMessage()));
    };


    /**
     * optional bytes message = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getMessage()`
     * @return {!Uint8Array}
     */
    proto.EthereumVerifyMessage.prototype.getMessage_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getMessage()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumVerifyMessage.prototype.setMessage = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.EthereumVerifyMessage.prototype.clearMessage = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumVerifyMessage.prototype.hasMessage = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.EthereumMessageSignature = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.EthereumMessageSignature, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.EthereumMessageSignature.prototype.toObject = function(opt_includeInstance) {
      return proto.EthereumMessageSignature.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.EthereumMessageSignature} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumMessageSignature.toObject = function(includeInstance, msg) {
      var obj = {
        address: msg.getAddress_asB64(),
        signature: msg.getSignature_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.EthereumMessageSignature}
     */
    proto.EthereumMessageSignature.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.EthereumMessageSignature;
      return proto.EthereumMessageSignature.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.EthereumMessageSignature} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.EthereumMessageSignature}
     */
    proto.EthereumMessageSignature.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.EthereumMessageSignature.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.EthereumMessageSignature.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.EthereumMessageSignature} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.EthereumMessageSignature.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
    };


    /**
     * optional bytes address = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumMessageSignature.prototype.getAddress = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes address = 1;
     * This is a type-conversion wrapper around `getAddress()`
     * @return {string}
     */
    proto.EthereumMessageSignature.prototype.getAddress_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getAddress()));
    };


    /**
     * optional bytes address = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getAddress()`
     * @return {!Uint8Array}
     */
    proto.EthereumMessageSignature.prototype.getAddress_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getAddress()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumMessageSignature.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.EthereumMessageSignature.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumMessageSignature.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes signature = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.EthereumMessageSignature.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes signature = 2;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.EthereumMessageSignature.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.EthereumMessageSignature.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.EthereumMessageSignature.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.EthereumMessageSignature.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.EthereumMessageSignature.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SignIdentity = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.SignIdentity, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SignIdentity.prototype.toObject = function(opt_includeInstance) {
      return proto.SignIdentity.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SignIdentity} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignIdentity.toObject = function(includeInstance, msg) {
      var f, obj = {
        identity: (f = msg.getIdentity()) && types_pb.IdentityType.toObject(includeInstance, f),
        challengeHidden: msg.getChallengeHidden_asB64(),
        challengeVisual: googleProtobuf.Message.getField(msg, 3),
        ecdsaCurveName: googleProtobuf.Message.getField(msg, 4)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SignIdentity}
     */
    proto.SignIdentity.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SignIdentity;
      return proto.SignIdentity.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SignIdentity} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SignIdentity}
     */
    proto.SignIdentity.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.IdentityType;
          reader.readMessage(value,types_pb.IdentityType.deserializeBinaryFromReader);
          msg.setIdentity(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setChallengeHidden(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setChallengeVisual(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setEcdsaCurveName(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SignIdentity.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SignIdentity.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SignIdentity} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignIdentity.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getIdentity();
      if (f != null) {
        writer.writeMessage(
          1,
          f,
          types_pb.IdentityType.serializeBinaryToWriter
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
    };


    /**
     * optional IdentityType identity = 1;
     * @return {?proto.IdentityType}
     */
    proto.SignIdentity.prototype.getIdentity = function() {
      return /** @type{?proto.IdentityType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.IdentityType, 1));
    };


    /** @param {?proto.IdentityType|undefined} value */
    proto.SignIdentity.prototype.setIdentity = function(value) {
      googleProtobuf.Message.setWrapperField(this, 1, value);
    };


    proto.SignIdentity.prototype.clearIdentity = function() {
      this.setIdentity(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignIdentity.prototype.hasIdentity = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes challenge_hidden = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.SignIdentity.prototype.getChallengeHidden = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes challenge_hidden = 2;
     * This is a type-conversion wrapper around `getChallengeHidden()`
     * @return {string}
     */
    proto.SignIdentity.prototype.getChallengeHidden_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getChallengeHidden()));
    };


    /**
     * optional bytes challenge_hidden = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getChallengeHidden()`
     * @return {!Uint8Array}
     */
    proto.SignIdentity.prototype.getChallengeHidden_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getChallengeHidden()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.SignIdentity.prototype.setChallengeHidden = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.SignIdentity.prototype.clearChallengeHidden = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignIdentity.prototype.hasChallengeHidden = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string challenge_visual = 3;
     * @return {string}
     */
    proto.SignIdentity.prototype.getChallengeVisual = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.SignIdentity.prototype.setChallengeVisual = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.SignIdentity.prototype.clearChallengeVisual = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignIdentity.prototype.hasChallengeVisual = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string ecdsa_curve_name = 4;
     * @return {string}
     */
    proto.SignIdentity.prototype.getEcdsaCurveName = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /** @param {string} value */
    proto.SignIdentity.prototype.setEcdsaCurveName = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.SignIdentity.prototype.clearEcdsaCurveName = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignIdentity.prototype.hasEcdsaCurveName = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SignedIdentity = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.SignedIdentity, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SignedIdentity.prototype.toObject = function(opt_includeInstance) {
      return proto.SignedIdentity.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SignedIdentity} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignedIdentity.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        publicKey: msg.getPublicKey_asB64(),
        signature: msg.getSignature_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SignedIdentity}
     */
    proto.SignedIdentity.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SignedIdentity;
      return proto.SignedIdentity.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SignedIdentity} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SignedIdentity}
     */
    proto.SignedIdentity.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {string} */ (reader.readString());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPublicKey(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setSignature(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SignedIdentity.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SignedIdentity.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SignedIdentity} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SignedIdentity.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeString(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
    };


    /**
     * optional string address = 1;
     * @return {string}
     */
    proto.SignedIdentity.prototype.getAddress = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /** @param {string} value */
    proto.SignedIdentity.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.SignedIdentity.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedIdentity.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes public_key = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.SignedIdentity.prototype.getPublicKey = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes public_key = 2;
     * This is a type-conversion wrapper around `getPublicKey()`
     * @return {string}
     */
    proto.SignedIdentity.prototype.getPublicKey_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPublicKey()));
    };


    /**
     * optional bytes public_key = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPublicKey()`
     * @return {!Uint8Array}
     */
    proto.SignedIdentity.prototype.getPublicKey_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPublicKey()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.SignedIdentity.prototype.setPublicKey = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.SignedIdentity.prototype.clearPublicKey = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedIdentity.prototype.hasPublicKey = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes signature = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.SignedIdentity.prototype.getSignature = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes signature = 3;
     * This is a type-conversion wrapper around `getSignature()`
     * @return {string}
     */
    proto.SignedIdentity.prototype.getSignature_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getSignature()));
    };


    /**
     * optional bytes signature = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getSignature()`
     * @return {!Uint8Array}
     */
    proto.SignedIdentity.prototype.getSignature_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getSignature()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.SignedIdentity.prototype.setSignature = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.SignedIdentity.prototype.clearSignature = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.SignedIdentity.prototype.hasSignature = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.ApplyPolicies = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, proto.ApplyPolicies.repeatedFields_, null);
    };
    goog.inherits(proto.ApplyPolicies, googleProtobuf.Message);
    /**
     * List of repeated fields within this message type.
     * @private {!Array<number>}
     * @const
     */
    proto.ApplyPolicies.repeatedFields_ = [1];



    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.ApplyPolicies.prototype.toObject = function(opt_includeInstance) {
      return proto.ApplyPolicies.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.ApplyPolicies} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ApplyPolicies.toObject = function(includeInstance, msg) {
      var obj = {
        policyList: googleProtobuf.Message.toObjectList(msg.getPolicyList(),
        types_pb.PolicyType.toObject, includeInstance)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.ApplyPolicies}
     */
    proto.ApplyPolicies.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.ApplyPolicies;
      return proto.ApplyPolicies.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.ApplyPolicies} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.ApplyPolicies}
     */
    proto.ApplyPolicies.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = new types_pb.PolicyType;
          reader.readMessage(value,types_pb.PolicyType.deserializeBinaryFromReader);
          msg.addPolicy(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.ApplyPolicies.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.ApplyPolicies.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.ApplyPolicies} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.ApplyPolicies.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = message.getPolicyList();
      if (f.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f,
          types_pb.PolicyType.serializeBinaryToWriter
        );
      }
    };


    /**
     * repeated PolicyType policy = 1;
     * @return {!Array.<!proto.PolicyType>}
     */
    proto.ApplyPolicies.prototype.getPolicyList = function() {
      return /** @type{!Array.<!proto.PolicyType>} */ (
        googleProtobuf.Message.getRepeatedWrapperField(this, types_pb.PolicyType, 1));
    };


    /** @param {!Array.<!proto.PolicyType>} value */
    proto.ApplyPolicies.prototype.setPolicyList = function(value) {
      googleProtobuf.Message.setRepeatedWrapperField(this, 1, value);
    };


    /**
     * @param {!proto.PolicyType=} opt_value
     * @param {number=} opt_index
     * @return {!proto.PolicyType}
     */
    proto.ApplyPolicies.prototype.addPolicy = function(opt_value, opt_index) {
      return googleProtobuf.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.PolicyType, opt_index);
    };


    proto.ApplyPolicies.prototype.clearPolicyList = function() {
      this.setPolicyList([]);
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.FlashHash = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.FlashHash, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.FlashHash.prototype.toObject = function(opt_includeInstance) {
      return proto.FlashHash.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.FlashHash} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashHash.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        length: googleProtobuf.Message.getField(msg, 2),
        challenge: msg.getChallenge_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.FlashHash}
     */
    proto.FlashHash.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.FlashHash;
      return proto.FlashHash.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.FlashHash} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.FlashHash}
     */
    proto.FlashHash.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setLength(value);
          break;
        case 3:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setChallenge(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.FlashHash.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.FlashHash.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.FlashHash} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashHash.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBytes(
          3,
          f
        );
      }
    };


    /**
     * optional uint32 address = 1;
     * @return {number}
     */
    proto.FlashHash.prototype.getAddress = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.FlashHash.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.FlashHash.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashHash.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 length = 2;
     * @return {number}
     */
    proto.FlashHash.prototype.getLength = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.FlashHash.prototype.setLength = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.FlashHash.prototype.clearLength = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashHash.prototype.hasLength = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bytes challenge = 3;
     * @return {!(string|Uint8Array)}
     */
    proto.FlashHash.prototype.getChallenge = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /**
     * optional bytes challenge = 3;
     * This is a type-conversion wrapper around `getChallenge()`
     * @return {string}
     */
    proto.FlashHash.prototype.getChallenge_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getChallenge()));
    };


    /**
     * optional bytes challenge = 3;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getChallenge()`
     * @return {!Uint8Array}
     */
    proto.FlashHash.prototype.getChallenge_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getChallenge()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.FlashHash.prototype.setChallenge = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.FlashHash.prototype.clearChallenge = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashHash.prototype.hasChallenge = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.FlashWrite = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.FlashWrite, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.FlashWrite.prototype.toObject = function(opt_includeInstance) {
      return proto.FlashWrite.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.FlashWrite} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashWrite.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        data: msg.getData_asB64(),
        erase: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.FlashWrite}
     */
    proto.FlashWrite.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.FlashWrite;
      return proto.FlashWrite.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.FlashWrite} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.FlashWrite}
     */
    proto.FlashWrite.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setData(value);
          break;
        case 3:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setErase(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.FlashWrite.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.FlashWrite.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.FlashWrite} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashWrite.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeBool(
          3,
          f
        );
      }
    };


    /**
     * optional uint32 address = 1;
     * @return {number}
     */
    proto.FlashWrite.prototype.getAddress = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.FlashWrite.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.FlashWrite.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashWrite.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional bytes data = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.FlashWrite.prototype.getData = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * optional bytes data = 2;
     * This is a type-conversion wrapper around `getData()`
     * @return {string}
     */
    proto.FlashWrite.prototype.getData_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getData()));
    };


    /**
     * optional bytes data = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getData()`
     * @return {!Uint8Array}
     */
    proto.FlashWrite.prototype.getData_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getData()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.FlashWrite.prototype.setData = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.FlashWrite.prototype.clearData = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashWrite.prototype.hasData = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional bool erase = 3;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.FlashWrite.prototype.getErase = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, false));
    };


    /** @param {boolean} value */
    proto.FlashWrite.prototype.setErase = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.FlashWrite.prototype.clearErase = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashWrite.prototype.hasErase = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.FlashHashResponse = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.FlashHashResponse, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.FlashHashResponse.prototype.toObject = function(opt_includeInstance) {
      return proto.FlashHashResponse.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.FlashHashResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashHashResponse.toObject = function(includeInstance, msg) {
      var obj = {
        data: msg.getData_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.FlashHashResponse}
     */
    proto.FlashHashResponse.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.FlashHashResponse;
      return proto.FlashHashResponse.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.FlashHashResponse} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.FlashHashResponse}
     */
    proto.FlashHashResponse.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setData(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.FlashHashResponse.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.FlashHashResponse.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.FlashHashResponse} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FlashHashResponse.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * optional bytes data = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.FlashHashResponse.prototype.getData = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes data = 1;
     * This is a type-conversion wrapper around `getData()`
     * @return {string}
     */
    proto.FlashHashResponse.prototype.getData_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getData()));
    };


    /**
     * optional bytes data = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getData()`
     * @return {!Uint8Array}
     */
    proto.FlashHashResponse.prototype.getData_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getData()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.FlashHashResponse.prototype.setData = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.FlashHashResponse.prototype.clearData = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FlashHashResponse.prototype.hasData = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkFlashDump = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkFlashDump, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkFlashDump.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkFlashDump.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkFlashDump} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFlashDump.toObject = function(includeInstance, msg) {
      var obj = {
        address: googleProtobuf.Message.getField(msg, 1),
        length: googleProtobuf.Message.getField(msg, 2)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkFlashDump}
     */
    proto.DebugLinkFlashDump.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkFlashDump;
      return proto.DebugLinkFlashDump.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkFlashDump} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkFlashDump}
     */
    proto.DebugLinkFlashDump.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setAddress(value);
          break;
        case 2:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setLength(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkFlashDump.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkFlashDump.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkFlashDump} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFlashDump.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeUint32(
          2,
          f
        );
      }
    };


    /**
     * optional uint32 address = 1;
     * @return {number}
     */
    proto.DebugLinkFlashDump.prototype.getAddress = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.DebugLinkFlashDump.prototype.setAddress = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DebugLinkFlashDump.prototype.clearAddress = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkFlashDump.prototype.hasAddress = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional uint32 length = 2;
     * @return {number}
     */
    proto.DebugLinkFlashDump.prototype.getLength = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, 0));
    };


    /** @param {number} value */
    proto.DebugLinkFlashDump.prototype.setLength = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.DebugLinkFlashDump.prototype.clearLength = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkFlashDump.prototype.hasLength = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkFlashDumpResponse = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkFlashDumpResponse, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkFlashDumpResponse.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkFlashDumpResponse.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkFlashDumpResponse} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFlashDumpResponse.toObject = function(includeInstance, msg) {
      var obj = {
        data: msg.getData_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkFlashDumpResponse}
     */
    proto.DebugLinkFlashDumpResponse.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkFlashDumpResponse;
      return proto.DebugLinkFlashDumpResponse.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkFlashDumpResponse} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkFlashDumpResponse}
     */
    proto.DebugLinkFlashDumpResponse.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setData(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkFlashDumpResponse.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkFlashDumpResponse.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkFlashDumpResponse} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFlashDumpResponse.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
    };


    /**
     * optional bytes data = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.DebugLinkFlashDumpResponse.prototype.getData = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes data = 1;
     * This is a type-conversion wrapper around `getData()`
     * @return {string}
     */
    proto.DebugLinkFlashDumpResponse.prototype.getData_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getData()));
    };


    /**
     * optional bytes data = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getData()`
     * @return {!Uint8Array}
     */
    proto.DebugLinkFlashDumpResponse.prototype.getData_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getData()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DebugLinkFlashDumpResponse.prototype.setData = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DebugLinkFlashDumpResponse.prototype.clearData = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkFlashDumpResponse.prototype.hasData = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.SoftReset = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.SoftReset, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.SoftReset.prototype.toObject = function(opt_includeInstance) {
      return proto.SoftReset.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.SoftReset} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SoftReset.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.SoftReset}
     */
    proto.SoftReset.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.SoftReset;
      return proto.SoftReset.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.SoftReset} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.SoftReset}
     */
    proto.SoftReset.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.SoftReset.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.SoftReset.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.SoftReset} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.SoftReset.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.FirmwareErase = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.FirmwareErase, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.FirmwareErase.prototype.toObject = function(opt_includeInstance) {
      return proto.FirmwareErase.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.FirmwareErase} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FirmwareErase.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.FirmwareErase}
     */
    proto.FirmwareErase.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.FirmwareErase;
      return proto.FirmwareErase.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.FirmwareErase} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.FirmwareErase}
     */
    proto.FirmwareErase.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.FirmwareErase.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.FirmwareErase.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.FirmwareErase} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FirmwareErase.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.FirmwareUpload = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.FirmwareUpload, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.FirmwareUpload.prototype.toObject = function(opt_includeInstance) {
      return proto.FirmwareUpload.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.FirmwareUpload} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FirmwareUpload.toObject = function(includeInstance, msg) {
      var obj = {
        payloadHash: msg.getPayloadHash_asB64(),
        payload: msg.getPayload_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.FirmwareUpload}
     */
    proto.FirmwareUpload.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.FirmwareUpload;
      return proto.FirmwareUpload.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.FirmwareUpload} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.FirmwareUpload}
     */
    proto.FirmwareUpload.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPayloadHash(value);
          break;
        case 2:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setPayload(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.FirmwareUpload.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.FirmwareUpload.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.FirmwareUpload} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.FirmwareUpload.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeBytes(
          2,
          f
        );
      }
    };


    /**
     * required bytes payload_hash = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.FirmwareUpload.prototype.getPayloadHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * required bytes payload_hash = 1;
     * This is a type-conversion wrapper around `getPayloadHash()`
     * @return {string}
     */
    proto.FirmwareUpload.prototype.getPayloadHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPayloadHash()));
    };


    /**
     * required bytes payload_hash = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPayloadHash()`
     * @return {!Uint8Array}
     */
    proto.FirmwareUpload.prototype.getPayloadHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPayloadHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.FirmwareUpload.prototype.setPayloadHash = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.FirmwareUpload.prototype.clearPayloadHash = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FirmwareUpload.prototype.hasPayloadHash = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * required bytes payload = 2;
     * @return {!(string|Uint8Array)}
     */
    proto.FirmwareUpload.prototype.getPayload = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /**
     * required bytes payload = 2;
     * This is a type-conversion wrapper around `getPayload()`
     * @return {string}
     */
    proto.FirmwareUpload.prototype.getPayload_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getPayload()));
    };


    /**
     * required bytes payload = 2;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getPayload()`
     * @return {!Uint8Array}
     */
    proto.FirmwareUpload.prototype.getPayload_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getPayload()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.FirmwareUpload.prototype.setPayload = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.FirmwareUpload.prototype.clearPayload = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.FirmwareUpload.prototype.hasPayload = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkDecision = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkDecision, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkDecision.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkDecision.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkDecision} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkDecision.toObject = function(includeInstance, msg) {
      var obj = {
        yesNo: googleProtobuf.Message.getField(msg, 1)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkDecision}
     */
    proto.DebugLinkDecision.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkDecision;
      return proto.DebugLinkDecision.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkDecision} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkDecision}
     */
    proto.DebugLinkDecision.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setYesNo(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkDecision.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkDecision.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkDecision} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkDecision.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBool(
          1,
          f
        );
      }
    };


    /**
     * required bool yes_no = 1;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.DebugLinkDecision.prototype.getYesNo = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, false));
    };


    /** @param {boolean} value */
    proto.DebugLinkDecision.prototype.setYesNo = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DebugLinkDecision.prototype.clearYesNo = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkDecision.prototype.hasYesNo = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkGetState = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkGetState, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkGetState.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkGetState.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkGetState} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkGetState.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkGetState}
     */
    proto.DebugLinkGetState.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkGetState;
      return proto.DebugLinkGetState.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkGetState} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkGetState}
     */
    proto.DebugLinkGetState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkGetState.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkGetState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkGetState} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkGetState.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkState = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkState, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkState.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkState.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkState} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkState.toObject = function(includeInstance, msg) {
      var f, obj = {
        layout: msg.getLayout_asB64(),
        pin: googleProtobuf.Message.getField(msg, 2),
        matrix: googleProtobuf.Message.getField(msg, 3),
        mnemonic: googleProtobuf.Message.getField(msg, 4),
        node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
        passphraseProtection: googleProtobuf.Message.getField(msg, 6),
        resetWord: googleProtobuf.Message.getField(msg, 7),
        resetEntropy: msg.getResetEntropy_asB64(),
        recoveryFakeWord: googleProtobuf.Message.getField(msg, 9),
        recoveryWordPos: googleProtobuf.Message.getField(msg, 10),
        recoveryCipher: googleProtobuf.Message.getField(msg, 11),
        recoveryAutoCompletedWord: googleProtobuf.Message.getField(msg, 12),
        firmwareHash: msg.getFirmwareHash_asB64(),
        storageHash: msg.getStorageHash_asB64()
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkState}
     */
    proto.DebugLinkState.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkState;
      return proto.DebugLinkState.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkState} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkState}
     */
    proto.DebugLinkState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setLayout(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setPin(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setMatrix(value);
          break;
        case 4:
          var value = /** @type {string} */ (reader.readString());
          msg.setMnemonic(value);
          break;
        case 5:
          var value = new types_pb.HDNodeType;
          reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
          msg.setNode(value);
          break;
        case 6:
          var value = /** @type {boolean} */ (reader.readBool());
          msg.setPassphraseProtection(value);
          break;
        case 7:
          var value = /** @type {string} */ (reader.readString());
          msg.setResetWord(value);
          break;
        case 8:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setResetEntropy(value);
          break;
        case 9:
          var value = /** @type {string} */ (reader.readString());
          msg.setRecoveryFakeWord(value);
          break;
        case 10:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setRecoveryWordPos(value);
          break;
        case 11:
          var value = /** @type {string} */ (reader.readString());
          msg.setRecoveryCipher(value);
          break;
        case 12:
          var value = /** @type {string} */ (reader.readString());
          msg.setRecoveryAutoCompletedWord(value);
          break;
        case 13:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setFirmwareHash(value);
          break;
        case 14:
          var value = /** @type {!Uint8Array} */ (reader.readBytes());
          msg.setStorageHash(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkState.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkState} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkState.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeBytes(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 4));
      if (f != null) {
        writer.writeString(
          4,
          f
        );
      }
      f = message.getNode();
      if (f != null) {
        writer.writeMessage(
          5,
          f,
          types_pb.HDNodeType.serializeBinaryToWriter
        );
      }
      f = /** @type {boolean} */ (googleProtobuf.Message.getField(message, 6));
      if (f != null) {
        writer.writeBool(
          6,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 7));
      if (f != null) {
        writer.writeString(
          7,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 8));
      if (f != null) {
        writer.writeBytes(
          8,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 9));
      if (f != null) {
        writer.writeString(
          9,
          f
        );
      }
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 10));
      if (f != null) {
        writer.writeUint32(
          10,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 11));
      if (f != null) {
        writer.writeString(
          11,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 12));
      if (f != null) {
        writer.writeString(
          12,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 13));
      if (f != null) {
        writer.writeBytes(
          13,
          f
        );
      }
      f = /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getField(message, 14));
      if (f != null) {
        writer.writeBytes(
          14,
          f
        );
      }
    };


    /**
     * optional bytes layout = 1;
     * @return {!(string|Uint8Array)}
     */
    proto.DebugLinkState.prototype.getLayout = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, ""));
    };


    /**
     * optional bytes layout = 1;
     * This is a type-conversion wrapper around `getLayout()`
     * @return {string}
     */
    proto.DebugLinkState.prototype.getLayout_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getLayout()));
    };


    /**
     * optional bytes layout = 1;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getLayout()`
     * @return {!Uint8Array}
     */
    proto.DebugLinkState.prototype.getLayout_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getLayout()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DebugLinkState.prototype.setLayout = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DebugLinkState.prototype.clearLayout = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasLayout = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string pin = 2;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getPin = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setPin = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.DebugLinkState.prototype.clearPin = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasPin = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string matrix = 3;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getMatrix = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setMatrix = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.DebugLinkState.prototype.clearMatrix = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasMatrix = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };


    /**
     * optional string mnemonic = 4;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getMnemonic = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 4, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setMnemonic = function(value) {
      googleProtobuf.Message.setField(this, 4, value);
    };


    proto.DebugLinkState.prototype.clearMnemonic = function() {
      googleProtobuf.Message.setField(this, 4, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasMnemonic = function() {
      return googleProtobuf.Message.getField(this, 4) != null;
    };


    /**
     * optional HDNodeType node = 5;
     * @return {?proto.HDNodeType}
     */
    proto.DebugLinkState.prototype.getNode = function() {
      return /** @type{?proto.HDNodeType} */ (
        googleProtobuf.Message.getWrapperField(this, types_pb.HDNodeType, 5));
    };


    /** @param {?proto.HDNodeType|undefined} value */
    proto.DebugLinkState.prototype.setNode = function(value) {
      googleProtobuf.Message.setWrapperField(this, 5, value);
    };


    proto.DebugLinkState.prototype.clearNode = function() {
      this.setNode(undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasNode = function() {
      return googleProtobuf.Message.getField(this, 5) != null;
    };


    /**
     * optional bool passphrase_protection = 6;
     * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
     * You should avoid comparisons like {@code val === true/false} in those cases.
     * @return {boolean}
     */
    proto.DebugLinkState.prototype.getPassphraseProtection = function() {
      return /** @type {boolean} */ (googleProtobuf.Message.getFieldWithDefault(this, 6, false));
    };


    /** @param {boolean} value */
    proto.DebugLinkState.prototype.setPassphraseProtection = function(value) {
      googleProtobuf.Message.setField(this, 6, value);
    };


    proto.DebugLinkState.prototype.clearPassphraseProtection = function() {
      googleProtobuf.Message.setField(this, 6, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasPassphraseProtection = function() {
      return googleProtobuf.Message.getField(this, 6) != null;
    };


    /**
     * optional string reset_word = 7;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getResetWord = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 7, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setResetWord = function(value) {
      googleProtobuf.Message.setField(this, 7, value);
    };


    proto.DebugLinkState.prototype.clearResetWord = function() {
      googleProtobuf.Message.setField(this, 7, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasResetWord = function() {
      return googleProtobuf.Message.getField(this, 7) != null;
    };


    /**
     * optional bytes reset_entropy = 8;
     * @return {!(string|Uint8Array)}
     */
    proto.DebugLinkState.prototype.getResetEntropy = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 8, ""));
    };


    /**
     * optional bytes reset_entropy = 8;
     * This is a type-conversion wrapper around `getResetEntropy()`
     * @return {string}
     */
    proto.DebugLinkState.prototype.getResetEntropy_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getResetEntropy()));
    };


    /**
     * optional bytes reset_entropy = 8;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getResetEntropy()`
     * @return {!Uint8Array}
     */
    proto.DebugLinkState.prototype.getResetEntropy_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getResetEntropy()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DebugLinkState.prototype.setResetEntropy = function(value) {
      googleProtobuf.Message.setField(this, 8, value);
    };


    proto.DebugLinkState.prototype.clearResetEntropy = function() {
      googleProtobuf.Message.setField(this, 8, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasResetEntropy = function() {
      return googleProtobuf.Message.getField(this, 8) != null;
    };


    /**
     * optional string recovery_fake_word = 9;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getRecoveryFakeWord = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 9, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setRecoveryFakeWord = function(value) {
      googleProtobuf.Message.setField(this, 9, value);
    };


    proto.DebugLinkState.prototype.clearRecoveryFakeWord = function() {
      googleProtobuf.Message.setField(this, 9, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasRecoveryFakeWord = function() {
      return googleProtobuf.Message.getField(this, 9) != null;
    };


    /**
     * optional uint32 recovery_word_pos = 10;
     * @return {number}
     */
    proto.DebugLinkState.prototype.getRecoveryWordPos = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 10, 0));
    };


    /** @param {number} value */
    proto.DebugLinkState.prototype.setRecoveryWordPos = function(value) {
      googleProtobuf.Message.setField(this, 10, value);
    };


    proto.DebugLinkState.prototype.clearRecoveryWordPos = function() {
      googleProtobuf.Message.setField(this, 10, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasRecoveryWordPos = function() {
      return googleProtobuf.Message.getField(this, 10) != null;
    };


    /**
     * optional string recovery_cipher = 11;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getRecoveryCipher = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 11, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setRecoveryCipher = function(value) {
      googleProtobuf.Message.setField(this, 11, value);
    };


    proto.DebugLinkState.prototype.clearRecoveryCipher = function() {
      googleProtobuf.Message.setField(this, 11, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasRecoveryCipher = function() {
      return googleProtobuf.Message.getField(this, 11) != null;
    };


    /**
     * optional string recovery_auto_completed_word = 12;
     * @return {string}
     */
    proto.DebugLinkState.prototype.getRecoveryAutoCompletedWord = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 12, ""));
    };


    /** @param {string} value */
    proto.DebugLinkState.prototype.setRecoveryAutoCompletedWord = function(value) {
      googleProtobuf.Message.setField(this, 12, value);
    };


    proto.DebugLinkState.prototype.clearRecoveryAutoCompletedWord = function() {
      googleProtobuf.Message.setField(this, 12, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasRecoveryAutoCompletedWord = function() {
      return googleProtobuf.Message.getField(this, 12) != null;
    };


    /**
     * optional bytes firmware_hash = 13;
     * @return {!(string|Uint8Array)}
     */
    proto.DebugLinkState.prototype.getFirmwareHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 13, ""));
    };


    /**
     * optional bytes firmware_hash = 13;
     * This is a type-conversion wrapper around `getFirmwareHash()`
     * @return {string}
     */
    proto.DebugLinkState.prototype.getFirmwareHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getFirmwareHash()));
    };


    /**
     * optional bytes firmware_hash = 13;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getFirmwareHash()`
     * @return {!Uint8Array}
     */
    proto.DebugLinkState.prototype.getFirmwareHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getFirmwareHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DebugLinkState.prototype.setFirmwareHash = function(value) {
      googleProtobuf.Message.setField(this, 13, value);
    };


    proto.DebugLinkState.prototype.clearFirmwareHash = function() {
      googleProtobuf.Message.setField(this, 13, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasFirmwareHash = function() {
      return googleProtobuf.Message.getField(this, 13) != null;
    };


    /**
     * optional bytes storage_hash = 14;
     * @return {!(string|Uint8Array)}
     */
    proto.DebugLinkState.prototype.getStorageHash = function() {
      return /** @type {!(string|Uint8Array)} */ (googleProtobuf.Message.getFieldWithDefault(this, 14, ""));
    };


    /**
     * optional bytes storage_hash = 14;
     * This is a type-conversion wrapper around `getStorageHash()`
     * @return {string}
     */
    proto.DebugLinkState.prototype.getStorageHash_asB64 = function() {
      return /** @type {string} */ (googleProtobuf.Message.bytesAsB64(
          this.getStorageHash()));
    };


    /**
     * optional bytes storage_hash = 14;
     * Note that Uint8Array is not supported on all browsers.
     * @see http://caniuse.com/Uint8Array
     * This is a type-conversion wrapper around `getStorageHash()`
     * @return {!Uint8Array}
     */
    proto.DebugLinkState.prototype.getStorageHash_asU8 = function() {
      return /** @type {!Uint8Array} */ (googleProtobuf.Message.bytesAsU8(
          this.getStorageHash()));
    };


    /** @param {!(string|Uint8Array)} value */
    proto.DebugLinkState.prototype.setStorageHash = function(value) {
      googleProtobuf.Message.setField(this, 14, value);
    };


    proto.DebugLinkState.prototype.clearStorageHash = function() {
      googleProtobuf.Message.setField(this, 14, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkState.prototype.hasStorageHash = function() {
      return googleProtobuf.Message.getField(this, 14) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkStop = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkStop, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkStop.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkStop.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkStop} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkStop.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkStop}
     */
    proto.DebugLinkStop.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkStop;
      return proto.DebugLinkStop.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkStop} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkStop}
     */
    proto.DebugLinkStop.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkStop.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkStop.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkStop} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkStop.serializeBinaryToWriter = function(message, writer) {
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkLog = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkLog, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkLog.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkLog.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkLog} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkLog.toObject = function(includeInstance, msg) {
      var obj = {
        level: googleProtobuf.Message.getField(msg, 1),
        bucket: googleProtobuf.Message.getField(msg, 2),
        text: googleProtobuf.Message.getField(msg, 3)
      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkLog}
     */
    proto.DebugLinkLog.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkLog;
      return proto.DebugLinkLog.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkLog} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkLog}
     */
    proto.DebugLinkLog.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        case 1:
          var value = /** @type {number} */ (reader.readUint32());
          msg.setLevel(value);
          break;
        case 2:
          var value = /** @type {string} */ (reader.readString());
          msg.setBucket(value);
          break;
        case 3:
          var value = /** @type {string} */ (reader.readString());
          msg.setText(value);
          break;
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkLog.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkLog.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkLog} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkLog.serializeBinaryToWriter = function(message, writer) {
      var f = undefined;
      f = /** @type {number} */ (googleProtobuf.Message.getField(message, 1));
      if (f != null) {
        writer.writeUint32(
          1,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 2));
      if (f != null) {
        writer.writeString(
          2,
          f
        );
      }
      f = /** @type {string} */ (googleProtobuf.Message.getField(message, 3));
      if (f != null) {
        writer.writeString(
          3,
          f
        );
      }
    };


    /**
     * optional uint32 level = 1;
     * @return {number}
     */
    proto.DebugLinkLog.prototype.getLevel = function() {
      return /** @type {number} */ (googleProtobuf.Message.getFieldWithDefault(this, 1, 0));
    };


    /** @param {number} value */
    proto.DebugLinkLog.prototype.setLevel = function(value) {
      googleProtobuf.Message.setField(this, 1, value);
    };


    proto.DebugLinkLog.prototype.clearLevel = function() {
      googleProtobuf.Message.setField(this, 1, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkLog.prototype.hasLevel = function() {
      return googleProtobuf.Message.getField(this, 1) != null;
    };


    /**
     * optional string bucket = 2;
     * @return {string}
     */
    proto.DebugLinkLog.prototype.getBucket = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 2, ""));
    };


    /** @param {string} value */
    proto.DebugLinkLog.prototype.setBucket = function(value) {
      googleProtobuf.Message.setField(this, 2, value);
    };


    proto.DebugLinkLog.prototype.clearBucket = function() {
      googleProtobuf.Message.setField(this, 2, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkLog.prototype.hasBucket = function() {
      return googleProtobuf.Message.getField(this, 2) != null;
    };


    /**
     * optional string text = 3;
     * @return {string}
     */
    proto.DebugLinkLog.prototype.getText = function() {
      return /** @type {string} */ (googleProtobuf.Message.getFieldWithDefault(this, 3, ""));
    };


    /** @param {string} value */
    proto.DebugLinkLog.prototype.setText = function(value) {
      googleProtobuf.Message.setField(this, 3, value);
    };


    proto.DebugLinkLog.prototype.clearText = function() {
      googleProtobuf.Message.setField(this, 3, undefined);
    };


    /**
     * Returns whether this field is set.
     * @return {!boolean}
     */
    proto.DebugLinkLog.prototype.hasText = function() {
      return googleProtobuf.Message.getField(this, 3) != null;
    };



    /**
     * Generated by JsPbCodeGenerator.
     * @param {Array=} opt_data Optional initial data array, typically from a
     * server response, or constructed directly in Javascript. The array is used
     * in place and becomes part of the constructed object. It is not cloned.
     * If no data is provided, the constructed object will be empty, but still
     * valid.
     * @extends {jspb.Message}
     * @constructor
     */
    proto.DebugLinkFillConfig = function(opt_data) {
      googleProtobuf.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog.inherits(proto.DebugLinkFillConfig, googleProtobuf.Message);


    if (googleProtobuf.Message.GENERATE_TO_OBJECT) {
    /**
     * Creates an object representation of this proto suitable for use in Soy templates.
     * Field names that are reserved in JavaScript and will be renamed to pb_name.
     * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
     * For the list of reserved names please see:
     *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
     * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
     *     for transitional soy proto support: http://goto/soy-param-migration
     * @return {!Object}
     */
    proto.DebugLinkFillConfig.prototype.toObject = function(opt_includeInstance) {
      return proto.DebugLinkFillConfig.toObject(opt_includeInstance, this);
    };


    /**
     * Static version of the {@see toObject} method.
     * @param {boolean|undefined} includeInstance Whether to include the JSPB
     *     instance for transitional soy proto support:
     *     http://goto/soy-param-migration
     * @param {!proto.DebugLinkFillConfig} msg The msg instance to transform.
     * @return {!Object}
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFillConfig.toObject = function(includeInstance, msg) {
      var obj = {

      };

      if (includeInstance) {
        obj.$jspbMessageInstance = msg;
      }
      return obj;
    };
    }


    /**
     * Deserializes binary data (in protobuf wire format).
     * @param {jspb.ByteSource} bytes The bytes to deserialize.
     * @return {!proto.DebugLinkFillConfig}
     */
    proto.DebugLinkFillConfig.deserializeBinary = function(bytes) {
      var reader = new googleProtobuf.BinaryReader(bytes);
      var msg = new proto.DebugLinkFillConfig;
      return proto.DebugLinkFillConfig.deserializeBinaryFromReader(msg, reader);
    };


    /**
     * Deserializes binary data (in protobuf wire format) from the
     * given reader into the given message object.
     * @param {!proto.DebugLinkFillConfig} msg The message object to deserialize into.
     * @param {!jspb.BinaryReader} reader The BinaryReader to use.
     * @return {!proto.DebugLinkFillConfig}
     */
    proto.DebugLinkFillConfig.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
        default:
          reader.skipField();
          break;
        }
      }
      return msg;
    };


    /**
     * Serializes the message to binary data (in protobuf wire format).
     * @return {!Uint8Array}
     */
    proto.DebugLinkFillConfig.prototype.serializeBinary = function() {
      var writer = new googleProtobuf.BinaryWriter();
      proto.DebugLinkFillConfig.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };


    /**
     * Serializes the given message to binary data (in protobuf wire
     * format), writing to the given BinaryWriter.
     * @param {!proto.DebugLinkFillConfig} message
     * @param {!jspb.BinaryWriter} writer
     * @suppress {unusedLocalVariables} f is only used for nested messages
     */
    proto.DebugLinkFillConfig.serializeBinaryToWriter = function(message, writer) {
    };


    /**
     * @enum {number}
     */
    proto.MessageType = {
      MESSAGETYPE_INITIALIZE: 0,
      MESSAGETYPE_PING: 1,
      MESSAGETYPE_SUCCESS: 2,
      MESSAGETYPE_FAILURE: 3,
      MESSAGETYPE_CHANGEPIN: 4,
      MESSAGETYPE_WIPEDEVICE: 5,
      MESSAGETYPE_FIRMWAREERASE: 6,
      MESSAGETYPE_FIRMWAREUPLOAD: 7,
      MESSAGETYPE_GETENTROPY: 9,
      MESSAGETYPE_ENTROPY: 10,
      MESSAGETYPE_GETPUBLICKEY: 11,
      MESSAGETYPE_PUBLICKEY: 12,
      MESSAGETYPE_LOADDEVICE: 13,
      MESSAGETYPE_RESETDEVICE: 14,
      MESSAGETYPE_SIGNTX: 15,
      MESSAGETYPE_FEATURES: 17,
      MESSAGETYPE_PINMATRIXREQUEST: 18,
      MESSAGETYPE_PINMATRIXACK: 19,
      MESSAGETYPE_CANCEL: 20,
      MESSAGETYPE_TXREQUEST: 21,
      MESSAGETYPE_TXACK: 22,
      MESSAGETYPE_CIPHERKEYVALUE: 23,
      MESSAGETYPE_CLEARSESSION: 24,
      MESSAGETYPE_APPLYSETTINGS: 25,
      MESSAGETYPE_BUTTONREQUEST: 26,
      MESSAGETYPE_BUTTONACK: 27,
      MESSAGETYPE_GETADDRESS: 29,
      MESSAGETYPE_ADDRESS: 30,
      MESSAGETYPE_ENTROPYREQUEST: 35,
      MESSAGETYPE_ENTROPYACK: 36,
      MESSAGETYPE_SIGNMESSAGE: 38,
      MESSAGETYPE_VERIFYMESSAGE: 39,
      MESSAGETYPE_MESSAGESIGNATURE: 40,
      MESSAGETYPE_PASSPHRASEREQUEST: 41,
      MESSAGETYPE_PASSPHRASEACK: 42,
      MESSAGETYPE_ESTIMATETXSIZE: 43,
      MESSAGETYPE_TXSIZE: 44,
      MESSAGETYPE_RECOVERYDEVICE: 45,
      MESSAGETYPE_WORDREQUEST: 46,
      MESSAGETYPE_WORDACK: 47,
      MESSAGETYPE_CIPHEREDKEYVALUE: 48,
      MESSAGETYPE_ENCRYPTMESSAGE: 49,
      MESSAGETYPE_ENCRYPTEDMESSAGE: 50,
      MESSAGETYPE_DECRYPTMESSAGE: 51,
      MESSAGETYPE_DECRYPTEDMESSAGE: 52,
      MESSAGETYPE_SIGNIDENTITY: 53,
      MESSAGETYPE_SIGNEDIDENTITY: 54,
      MESSAGETYPE_GETFEATURES: 55,
      MESSAGETYPE_ETHEREUMGETADDRESS: 56,
      MESSAGETYPE_ETHEREUMADDRESS: 57,
      MESSAGETYPE_ETHEREUMSIGNTX: 58,
      MESSAGETYPE_ETHEREUMTXREQUEST: 59,
      MESSAGETYPE_ETHEREUMTXACK: 60,
      MESSAGETYPE_CHARACTERREQUEST: 80,
      MESSAGETYPE_CHARACTERACK: 81,
      MESSAGETYPE_RAWTXACK: 82,
      MESSAGETYPE_APPLYPOLICIES: 83,
      MESSAGETYPE_FLASHHASH: 84,
      MESSAGETYPE_FLASHWRITE: 85,
      MESSAGETYPE_FLASHHASHRESPONSE: 86,
      MESSAGETYPE_DEBUGLINKFLASHDUMP: 87,
      MESSAGETYPE_DEBUGLINKFLASHDUMPRESPONSE: 88,
      MESSAGETYPE_SOFTRESET: 89,
      MESSAGETYPE_DEBUGLINKDECISION: 100,
      MESSAGETYPE_DEBUGLINKGETSTATE: 101,
      MESSAGETYPE_DEBUGLINKSTATE: 102,
      MESSAGETYPE_DEBUGLINKSTOP: 103,
      MESSAGETYPE_DEBUGLINKLOG: 104,
      MESSAGETYPE_DEBUGLINKFILLCONFIG: 105,
      MESSAGETYPE_GETCOINTABLE: 106,
      MESSAGETYPE_COINTABLE: 107,
      MESSAGETYPE_ETHEREUMSIGNMESSAGE: 108,
      MESSAGETYPE_ETHEREUMVERIFYMESSAGE: 109,
      MESSAGETYPE_ETHEREUMMESSAGESIGNATURE: 110,
      MESSAGETYPE_EOSGETPUBLICKEY: 600,
      MESSAGETYPE_EOSPUBLICKEY: 601,
      MESSAGETYPE_EOSSIGNTX: 602,
      MESSAGETYPE_EOSTXACTIONREQUEST: 603,
      MESSAGETYPE_EOSTXACTIONACK: 604,
      MESSAGETYPE_EOSSIGNEDTX: 605
    };

    goog.object.extend(exports, proto);
    });

    // Shim until this exists for jspb https://github.com/protocolbuffers/protobuf/issues/1591
    function protoFieldToSetMethod(fieldName) {
        return "set" + (fieldName.charAt(0).toUpperCase() + fieldName.slice(1));
    }
    var isArray$1 = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };
    var leByteArrayToLong = function (byteArray) {
        var value = 0;
        for (var i = 0; i < byteArray.length; i++) {
            value = (value * 256) + byteArray[i];
        }
        return value;
    };
    // These helper functions marshal hex into and out of UInt8Arrays which are consumed by protobuf js
    var fromHexString = function (hexString) {
        var match = hexString.match(/.{1,2}/g) || [];
        return new Uint8Array(match.map(function (byte) { return parseInt(byte, 16); }));
    };
    // export const toHexString = (bytes: number[]) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')
    function toHexString(arr) {
        return Array.prototype.map.call(arr, function (x) { return ('00' + x.toString(16)).slice(-2); }).join('');
    }
    // const prevhashTx = {"txid":"6f90f3c7cbec2258b0971056ef3fe34128dbde30daa9c0639a898f9977299d54","version":1,"locktime":0,"vin":[{"txid":"ee336e79153d51f4f3e45278f1f77ab29fd5bb135dce467282e2aff22cb9c570","vout":1,"sequence":4294967295,"n":0,"scriptSig":{"hex":"483045022066c418874dbe5628296700382d727ce1734928796068c26271472df09dccf1a20221009dec59d19f9d73db381fcd35c0fff757ad73e54ef59157b0d7c57e6739a092f00121033fef08c603943dc7d25f4ce65771762143b1cd8678343d660a1a76b9d1d3ced7","asm":"3045022066c418874dbe5628296700382d727ce1734928796068c26271472df09dccf1a20221009dec59d19f9d73db381fcd35c0fff757ad73e54ef59157b0d7c57e6739a092f0[ALL] 033fef08c603943dc7d25f4ce65771762143b1cd8678343d660a1a76b9d1d3ced7"},"addr":"mnsfHtywp6AVUzgqu9P4tay6iQYY3WhCpz","valueSat":550865100,"value":5.508651,"doubleSpentTxID":null},{"txid":"2fe4d8af2b44faccc10dd5a6578c923491d2d21269a1dfe8c83f492a30fb8f9f","vout":1,"sequence":4294967295,"n":1,"scriptSig":{"hex":"47304402206fbb8e14be706b8557a2280d2a2a75c0a65c4f7936d90d510f0971c93f41f74402201b79c8c4e4ac4c944913611633c230193558296e70a36269b7fc3a80efa27d120121030cb5be79bdc36a4ff4443dbac43068cc43d638ea06ff2fa1b8dab389e39aefc7","asm":"304402206fbb8e14be706b8557a2280d2a2a75c0a65c4f7936d90d510f0971c93f41f74402201b79c8c4e4ac4c944913611633c230193558296e70a36269b7fc3a80efa27d12[ALL] 030cb5be79bdc36a4ff4443dbac43068cc43d638ea06ff2fa1b8dab389e39aefc7"},"addr":"mrDBnbEumaEiHm8pc9pj1rfUCsR4H7N5xh","valueSat":852985889,"value":8.52985889,"doubleSpentTxID":null}],"vout":[{"value":"4.03850989","n":0,"scriptPubKey":{"hex":"76a914f5a05c2664b40d3116b1c5086c9ba38ed15b742e88ac","asm":"OP_DUP OP_HASH160 f5a05c2664b40d3116b1c5086c9ba38ed15b742e OP_EQUALVERIFY OP_CHECKSIG","addresses":["n3uhx4JymCrWKX3e9i59YdJivMghF1bKZ4"],"type":"pubkeyhash"},"spentTxId":"5170fe1f25a05e1c9e125c27cd09e11f7c79c41409bc5b68f0e6f056af2d56b0","spentIndex":0,"spentHeight":203911},{"value":"10.00000000","n":1,"scriptPubKey":{"hex":"76a91424a56db43cf6f2b02e838ea493f95d8d6047423188ac","asm":"OP_DUP OP_HASH160 24a56db43cf6f2b02e838ea493f95d8d60474231 OP_EQUALVERIFY OP_CHECKSIG","addresses":["mirio8q3gtv7fhdnmb3TpZ4EuafdzSs7zL"],"type":"pubkeyhash"},"spentTxId":null,"spentIndex":null,"spentHeight":null}],"blockhash":"000000006656e1d72a211b7f469dd85209ba85c54127957a95591712a63d3848","blockheight":180573,"confirmations":1234520,"time":1391901762,"blocktime":1391901762,"valueOut":14.03850989,"size":373,"valueIn":14.03850989,"fees":0}
    // export function getPrevHashTx(prevhash){
    //   return prevhashTx
    // }
    // Copying this from ethers.js until their elliptic dep stops being circular
    function arrayify(value) {
        if (value == null) {
            throw new Error('cannot convert null value to array');
        }
        if (typeof (value) === 'string') {
            var match = value.match(/^(0x)?[0-9a-fA-F]*$/);
            if (!match) {
                throw new Error('invalid hexidecimal string');
            }
            if (match[1] !== '0x') {
                throw new Error('hex string must have 0x prefix');
            }
            value = value.substring(2);
            if (value.length % 2) {
                value = '0' + value;
            }
            var result = [];
            for (var i = 0; i < value.length; i += 2) {
                result.push(parseInt(value.substr(i, 2), 16));
            }
            return new Uint8Array(result);
        }
    }
    var HARDENED = 0x80000000;
    function bip32ToAddressNList(address) {
        if (/^m\//i.test(address)) {
            address = address.slice(2);
        }
        var path = address.split('/');
        if (path.length === 1 && path[0] === '')
            return [];
        var ret = new Array(path.length);
        for (var i = 0; i < path.length; i++) {
            var tmp = /(\d+)([hH\']?)/.exec(path[i]);
            if (tmp === null) {
                throw new Error('Invalid input');
            }
            ret[i] = parseInt(tmp[1], 10);
            if (ret[i] >= HARDENED) {
                throw new Error('Invalid child index');
            }
            if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\'') {
                ret[i] += HARDENED;
            }
            else if (tmp[2].length !== 0) {
                throw new Error('Invalid modifier');
            }
        }
        return ret;
    }
    function bip32Like(address) {
        return address.slice(0, 2) === 'm/';
    }

    var long_1 = createCommonjsModule(function (module) {
    /*
     Copyright 2013 Daniel Wirtz <dcode@dcode.io>
     Copyright 2009 The Closure Library Authors. All Rights Reserved.

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS-IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */

    /**
     * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/long.js for details
     */
    (function(global, factory) {

        /* AMD */ if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"])
            module["exports"] = factory();
        /* Global */ else
            (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

    })(commonjsGlobal, function() {

        /**
         * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
         *  See the from* functions below for more convenient ways of constructing Longs.
         * @exports Long
         * @class A Long class for representing a 64 bit two's-complement integer value.
         * @param {number} low The low (signed) 32 bits of the long
         * @param {number} high The high (signed) 32 bits of the long
         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
         * @constructor
         */
        function Long(low, high, unsigned) {

            /**
             * The low 32 bits as a signed value.
             * @type {number}
             */
            this.low = low | 0;

            /**
             * The high 32 bits as a signed value.
             * @type {number}
             */
            this.high = high | 0;

            /**
             * Whether unsigned or not.
             * @type {boolean}
             */
            this.unsigned = !!unsigned;
        }

        // The internal representation of a long is the two given signed, 32-bit values.
        // We use 32-bit pieces because these are the size of integers on which
        // Javascript performs bit-operations.  For operations like addition and
        // multiplication, we split each number into 16 bit pieces, which can easily be
        // multiplied within Javascript's floating-point representation without overflow
        // or change in sign.
        //
        // In the algorithms below, we frequently reduce the negative case to the
        // positive case by negating the input(s) and then post-processing the result.
        // Note that we must ALWAYS check specially whether those values are MIN_VALUE
        // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
        // a positive number, it overflows back into a negative).  Not handling this
        // case would often result in infinite recursion.
        //
        // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
        // methods on which they depend.

        /**
         * An indicator used to reliably determine if an object is a Long or not.
         * @type {boolean}
         * @const
         * @private
         */
        Long.prototype.__isLong__;

        Object.defineProperty(Long.prototype, "__isLong__", {
            value: true,
            enumerable: false,
            configurable: false
        });

        /**
         * @function
         * @param {*} obj Object
         * @returns {boolean}
         * @inner
         */
        function isLong(obj) {
            return (obj && obj["__isLong__"]) === true;
        }

        /**
         * Tests if the specified object is a Long.
         * @function
         * @param {*} obj Object
         * @returns {boolean}
         */
        Long.isLong = isLong;

        /**
         * A cache of the Long representations of small integer values.
         * @type {!Object}
         * @inner
         */
        var INT_CACHE = {};

        /**
         * A cache of the Long representations of small unsigned integer values.
         * @type {!Object}
         * @inner
         */
        var UINT_CACHE = {};

        /**
         * @param {number} value
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */
        function fromInt(value, unsigned) {
            var obj, cachedObj, cache;
            if (unsigned) {
                value >>>= 0;
                if (cache = (0 <= value && value < 256)) {
                    cachedObj = UINT_CACHE[value];
                    if (cachedObj)
                        return cachedObj;
                }
                obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
                if (cache)
                    UINT_CACHE[value] = obj;
                return obj;
            } else {
                value |= 0;
                if (cache = (-128 <= value && value < 128)) {
                    cachedObj = INT_CACHE[value];
                    if (cachedObj)
                        return cachedObj;
                }
                obj = fromBits(value, value < 0 ? -1 : 0, false);
                if (cache)
                    INT_CACHE[value] = obj;
                return obj;
            }
        }

        /**
         * Returns a Long representing the given 32 bit integer value.
         * @function
         * @param {number} value The 32 bit integer in question
         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
         * @returns {!Long} The corresponding Long value
         */
        Long.fromInt = fromInt;

        /**
         * @param {number} value
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */
        function fromNumber(value, unsigned) {
            if (isNaN(value) || !isFinite(value))
                return unsigned ? UZERO : ZERO;
            if (unsigned) {
                if (value < 0)
                    return UZERO;
                if (value >= TWO_PWR_64_DBL)
                    return MAX_UNSIGNED_VALUE;
            } else {
                if (value <= -TWO_PWR_63_DBL)
                    return MIN_VALUE;
                if (value + 1 >= TWO_PWR_63_DBL)
                    return MAX_VALUE;
            }
            if (value < 0)
                return fromNumber(-value, unsigned).neg();
            return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
        }

        /**
         * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
         * @function
         * @param {number} value The number in question
         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
         * @returns {!Long} The corresponding Long value
         */
        Long.fromNumber = fromNumber;

        /**
         * @param {number} lowBits
         * @param {number} highBits
         * @param {boolean=} unsigned
         * @returns {!Long}
         * @inner
         */
        function fromBits(lowBits, highBits, unsigned) {
            return new Long(lowBits, highBits, unsigned);
        }

        /**
         * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
         *  assumed to use 32 bits.
         * @function
         * @param {number} lowBits The low 32 bits
         * @param {number} highBits The high 32 bits
         * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
         * @returns {!Long} The corresponding Long value
         */
        Long.fromBits = fromBits;

        /**
         * @function
         * @param {number} base
         * @param {number} exponent
         * @returns {number}
         * @inner
         */
        var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

        /**
         * @param {string} str
         * @param {(boolean|number)=} unsigned
         * @param {number=} radix
         * @returns {!Long}
         * @inner
         */
        function fromString(str, unsigned, radix) {
            if (str.length === 0)
                throw Error('empty string');
            if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
                return ZERO;
            if (typeof unsigned === 'number') {
                // For goog.math.long compatibility
                radix = unsigned,
                unsigned = false;
            } else {
                unsigned = !! unsigned;
            }
            radix = radix || 10;
            if (radix < 2 || 36 < radix)
                throw RangeError('radix');

            var p;
            if ((p = str.indexOf('-')) > 0)
                throw Error('interior hyphen');
            else if (p === 0) {
                return fromString(str.substring(1), unsigned, radix).neg();
            }

            // Do several (8) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = fromNumber(pow_dbl(radix, 8));

            var result = ZERO;
            for (var i = 0; i < str.length; i += 8) {
                var size = Math.min(8, str.length - i),
                    value = parseInt(str.substring(i, i + size), radix);
                if (size < 8) {
                    var power = fromNumber(pow_dbl(radix, size));
                    result = result.mul(power).add(fromNumber(value));
                } else {
                    result = result.mul(radixToPower);
                    result = result.add(fromNumber(value));
                }
            }
            result.unsigned = unsigned;
            return result;
        }

        /**
         * Returns a Long representation of the given string, written using the specified radix.
         * @function
         * @param {string} str The textual representation of the Long
         * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
         * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
         * @returns {!Long} The corresponding Long value
         */
        Long.fromString = fromString;

        /**
         * @function
         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
         * @returns {!Long}
         * @inner
         */
        function fromValue(val) {
            if (val /* is compatible */ instanceof Long)
                return val;
            if (typeof val === 'number')
                return fromNumber(val);
            if (typeof val === 'string')
                return fromString(val);
            // Throws for non-objects, converts non-instanceof Long:
            return fromBits(val.low, val.high, val.unsigned);
        }

        /**
         * Converts the specified value to a Long.
         * @function
         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
         * @returns {!Long}
         */
        Long.fromValue = fromValue;

        // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
        // no runtime penalty for these.

        /**
         * @type {number}
         * @const
         * @inner
         */
        var TWO_PWR_16_DBL = 1 << 16;

        /**
         * @type {number}
         * @const
         * @inner
         */
        var TWO_PWR_24_DBL = 1 << 24;

        /**
         * @type {number}
         * @const
         * @inner
         */
        var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

        /**
         * @type {number}
         * @const
         * @inner
         */
        var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

        /**
         * @type {number}
         * @const
         * @inner
         */
        var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

        /**
         * @type {!Long}
         * @const
         * @inner
         */
        var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

        /**
         * @type {!Long}
         * @inner
         */
        var ZERO = fromInt(0);

        /**
         * Signed zero.
         * @type {!Long}
         */
        Long.ZERO = ZERO;

        /**
         * @type {!Long}
         * @inner
         */
        var UZERO = fromInt(0, true);

        /**
         * Unsigned zero.
         * @type {!Long}
         */
        Long.UZERO = UZERO;

        /**
         * @type {!Long}
         * @inner
         */
        var ONE = fromInt(1);

        /**
         * Signed one.
         * @type {!Long}
         */
        Long.ONE = ONE;

        /**
         * @type {!Long}
         * @inner
         */
        var UONE = fromInt(1, true);

        /**
         * Unsigned one.
         * @type {!Long}
         */
        Long.UONE = UONE;

        /**
         * @type {!Long}
         * @inner
         */
        var NEG_ONE = fromInt(-1);

        /**
         * Signed negative one.
         * @type {!Long}
         */
        Long.NEG_ONE = NEG_ONE;

        /**
         * @type {!Long}
         * @inner
         */
        var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

        /**
         * Maximum signed value.
         * @type {!Long}
         */
        Long.MAX_VALUE = MAX_VALUE;

        /**
         * @type {!Long}
         * @inner
         */
        var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

        /**
         * Maximum unsigned value.
         * @type {!Long}
         */
        Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

        /**
         * @type {!Long}
         * @inner
         */
        var MIN_VALUE = fromBits(0, 0x80000000|0, false);

        /**
         * Minimum signed value.
         * @type {!Long}
         */
        Long.MIN_VALUE = MIN_VALUE;

        /**
         * @alias Long.prototype
         * @inner
         */
        var LongPrototype = Long.prototype;

        /**
         * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
         * @returns {number}
         */
        LongPrototype.toInt = function toInt() {
            return this.unsigned ? this.low >>> 0 : this.low;
        };

        /**
         * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
         * @returns {number}
         */
        LongPrototype.toNumber = function toNumber() {
            if (this.unsigned)
                return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
            return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
        };

        /**
         * Converts the Long to a string written in the specified radix.
         * @param {number=} radix Radix (2-36), defaults to 10
         * @returns {string}
         * @override
         * @throws {RangeError} If `radix` is out of range
         */
        LongPrototype.toString = function toString(radix) {
            radix = radix || 10;
            if (radix < 2 || 36 < radix)
                throw RangeError('radix');
            if (this.isZero())
                return '0';
            if (this.isNegative()) { // Unsigned Longs are never negative
                if (this.eq(MIN_VALUE)) {
                    // We need to change the Long value before it can be negated, so we remove
                    // the bottom-most digit in this base and then recurse to do the rest.
                    var radixLong = fromNumber(radix),
                        div = this.div(radixLong),
                        rem1 = div.mul(radixLong).sub(this);
                    return div.toString(radix) + rem1.toInt().toString(radix);
                } else
                    return '-' + this.neg().toString(radix);
            }

            // Do several (6) digits each time through the loop, so as to
            // minimize the calls to the very expensive emulated div.
            var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
                rem = this;
            var result = '';
            while (true) {
                var remDiv = rem.div(radixToPower),
                    intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                    digits = intval.toString(radix);
                rem = remDiv;
                if (rem.isZero())
                    return digits + result;
                else {
                    while (digits.length < 6)
                        digits = '0' + digits;
                    result = '' + digits + result;
                }
            }
        };

        /**
         * Gets the high 32 bits as a signed integer.
         * @returns {number} Signed high bits
         */
        LongPrototype.getHighBits = function getHighBits() {
            return this.high;
        };

        /**
         * Gets the high 32 bits as an unsigned integer.
         * @returns {number} Unsigned high bits
         */
        LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
            return this.high >>> 0;
        };

        /**
         * Gets the low 32 bits as a signed integer.
         * @returns {number} Signed low bits
         */
        LongPrototype.getLowBits = function getLowBits() {
            return this.low;
        };

        /**
         * Gets the low 32 bits as an unsigned integer.
         * @returns {number} Unsigned low bits
         */
        LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
            return this.low >>> 0;
        };

        /**
         * Gets the number of bits needed to represent the absolute value of this Long.
         * @returns {number}
         */
        LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
            if (this.isNegative()) // Unsigned Longs are never negative
                return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
            var val = this.high != 0 ? this.high : this.low;
            for (var bit = 31; bit > 0; bit--)
                if ((val & (1 << bit)) != 0)
                    break;
            return this.high != 0 ? bit + 33 : bit + 1;
        };

        /**
         * Tests if this Long's value equals zero.
         * @returns {boolean}
         */
        LongPrototype.isZero = function isZero() {
            return this.high === 0 && this.low === 0;
        };

        /**
         * Tests if this Long's value is negative.
         * @returns {boolean}
         */
        LongPrototype.isNegative = function isNegative() {
            return !this.unsigned && this.high < 0;
        };

        /**
         * Tests if this Long's value is positive.
         * @returns {boolean}
         */
        LongPrototype.isPositive = function isPositive() {
            return this.unsigned || this.high >= 0;
        };

        /**
         * Tests if this Long's value is odd.
         * @returns {boolean}
         */
        LongPrototype.isOdd = function isOdd() {
            return (this.low & 1) === 1;
        };

        /**
         * Tests if this Long's value is even.
         * @returns {boolean}
         */
        LongPrototype.isEven = function isEven() {
            return (this.low & 1) === 0;
        };

        /**
         * Tests if this Long's value equals the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.equals = function equals(other) {
            if (!isLong(other))
                other = fromValue(other);
            if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
                return false;
            return this.high === other.high && this.low === other.low;
        };

        /**
         * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.eq = LongPrototype.equals;

        /**
         * Tests if this Long's value differs from the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.notEquals = function notEquals(other) {
            return !this.eq(/* validates */ other);
        };

        /**
         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.neq = LongPrototype.notEquals;

        /**
         * Tests if this Long's value is less than the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.lessThan = function lessThan(other) {
            return this.comp(/* validates */ other) < 0;
        };

        /**
         * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.lt = LongPrototype.lessThan;

        /**
         * Tests if this Long's value is less than or equal the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
            return this.comp(/* validates */ other) <= 0;
        };

        /**
         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.lte = LongPrototype.lessThanOrEqual;

        /**
         * Tests if this Long's value is greater than the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.greaterThan = function greaterThan(other) {
            return this.comp(/* validates */ other) > 0;
        };

        /**
         * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.gt = LongPrototype.greaterThan;

        /**
         * Tests if this Long's value is greater than or equal the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
            return this.comp(/* validates */ other) >= 0;
        };

        /**
         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {boolean}
         */
        LongPrototype.gte = LongPrototype.greaterThanOrEqual;

        /**
         * Compares this Long's value with the specified's.
         * @param {!Long|number|string} other Other value
         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
         *  if the given one is greater
         */
        LongPrototype.compare = function compare(other) {
            if (!isLong(other))
                other = fromValue(other);
            if (this.eq(other))
                return 0;
            var thisNeg = this.isNegative(),
                otherNeg = other.isNegative();
            if (thisNeg && !otherNeg)
                return -1;
            if (!thisNeg && otherNeg)
                return 1;
            // At this point the sign bits are the same
            if (!this.unsigned)
                return this.sub(other).isNegative() ? -1 : 1;
            // Both are positive if at least one is unsigned
            return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
        };

        /**
         * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
         * @function
         * @param {!Long|number|string} other Other value
         * @returns {number} 0 if they are the same, 1 if the this is greater and -1
         *  if the given one is greater
         */
        LongPrototype.comp = LongPrototype.compare;

        /**
         * Negates this Long's value.
         * @returns {!Long} Negated Long
         */
        LongPrototype.negate = function negate() {
            if (!this.unsigned && this.eq(MIN_VALUE))
                return MIN_VALUE;
            return this.not().add(ONE);
        };

        /**
         * Negates this Long's value. This is an alias of {@link Long#negate}.
         * @function
         * @returns {!Long} Negated Long
         */
        LongPrototype.neg = LongPrototype.negate;

        /**
         * Returns the sum of this and the specified Long.
         * @param {!Long|number|string} addend Addend
         * @returns {!Long} Sum
         */
        LongPrototype.add = function add(addend) {
            if (!isLong(addend))
                addend = fromValue(addend);

            // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

            var a48 = this.high >>> 16;
            var a32 = this.high & 0xFFFF;
            var a16 = this.low >>> 16;
            var a00 = this.low & 0xFFFF;

            var b48 = addend.high >>> 16;
            var b32 = addend.high & 0xFFFF;
            var b16 = addend.low >>> 16;
            var b00 = addend.low & 0xFFFF;

            var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
            c00 += a00 + b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 + b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 + b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 + b48;
            c48 &= 0xFFFF;
            return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
        };

        /**
         * Returns the difference of this and the specified Long.
         * @param {!Long|number|string} subtrahend Subtrahend
         * @returns {!Long} Difference
         */
        LongPrototype.subtract = function subtract(subtrahend) {
            if (!isLong(subtrahend))
                subtrahend = fromValue(subtrahend);
            return this.add(subtrahend.neg());
        };

        /**
         * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
         * @function
         * @param {!Long|number|string} subtrahend Subtrahend
         * @returns {!Long} Difference
         */
        LongPrototype.sub = LongPrototype.subtract;

        /**
         * Returns the product of this and the specified Long.
         * @param {!Long|number|string} multiplier Multiplier
         * @returns {!Long} Product
         */
        LongPrototype.multiply = function multiply(multiplier) {
            if (this.isZero())
                return ZERO;
            if (!isLong(multiplier))
                multiplier = fromValue(multiplier);
            if (multiplier.isZero())
                return ZERO;
            if (this.eq(MIN_VALUE))
                return multiplier.isOdd() ? MIN_VALUE : ZERO;
            if (multiplier.eq(MIN_VALUE))
                return this.isOdd() ? MIN_VALUE : ZERO;

            if (this.isNegative()) {
                if (multiplier.isNegative())
                    return this.neg().mul(multiplier.neg());
                else
                    return this.neg().mul(multiplier).neg();
            } else if (multiplier.isNegative())
                return this.mul(multiplier.neg()).neg();

            // If both longs are small, use float multiplication
            if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
                return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

            // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
            // We can skip products that would overflow.

            var a48 = this.high >>> 16;
            var a32 = this.high & 0xFFFF;
            var a16 = this.low >>> 16;
            var a00 = this.low & 0xFFFF;

            var b48 = multiplier.high >>> 16;
            var b32 = multiplier.high & 0xFFFF;
            var b16 = multiplier.low >>> 16;
            var b00 = multiplier.low & 0xFFFF;

            var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
            c00 += a00 * b00;
            c16 += c00 >>> 16;
            c00 &= 0xFFFF;
            c16 += a16 * b00;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c16 += a00 * b16;
            c32 += c16 >>> 16;
            c16 &= 0xFFFF;
            c32 += a32 * b00;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a16 * b16;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c32 += a00 * b32;
            c48 += c32 >>> 16;
            c32 &= 0xFFFF;
            c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
            c48 &= 0xFFFF;
            return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
        };

        /**
         * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
         * @function
         * @param {!Long|number|string} multiplier Multiplier
         * @returns {!Long} Product
         */
        LongPrototype.mul = LongPrototype.multiply;

        /**
         * Returns this Long divided by the specified. The result is signed if this Long is signed or
         *  unsigned if this Long is unsigned.
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Quotient
         */
        LongPrototype.divide = function divide(divisor) {
            if (!isLong(divisor))
                divisor = fromValue(divisor);
            if (divisor.isZero())
                throw Error('division by zero');
            if (this.isZero())
                return this.unsigned ? UZERO : ZERO;
            var approx, rem, res;
            if (!this.unsigned) {
                // This section is only relevant for signed longs and is derived from the
                // closure library as a whole.
                if (this.eq(MIN_VALUE)) {
                    if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                        return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                    else if (divisor.eq(MIN_VALUE))
                        return ONE;
                    else {
                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                        var halfThis = this.shr(1);
                        approx = halfThis.div(divisor).shl(1);
                        if (approx.eq(ZERO)) {
                            return divisor.isNegative() ? ONE : NEG_ONE;
                        } else {
                            rem = this.sub(divisor.mul(approx));
                            res = approx.add(rem.div(divisor));
                            return res;
                        }
                    }
                } else if (divisor.eq(MIN_VALUE))
                    return this.unsigned ? UZERO : ZERO;
                if (this.isNegative()) {
                    if (divisor.isNegative())
                        return this.neg().div(divisor.neg());
                    return this.neg().div(divisor).neg();
                } else if (divisor.isNegative())
                    return this.div(divisor.neg()).neg();
                res = ZERO;
            } else {
                // The algorithm below has not been made for unsigned longs. It's therefore
                // required to take special care of the MSB prior to running it.
                if (!divisor.unsigned)
                    divisor = divisor.toUnsigned();
                if (divisor.gt(this))
                    return UZERO;
                if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                    return UONE;
                res = UZERO;
            }

            // Repeat the following until the remainder is less than other:  find a
            // floating-point that approximates remainder / other *from below*, add this
            // into the result, and subtract it from the remainder.  It is critical that
            // the approximate value is less than or equal to the real value so that the
            // remainder never becomes negative.
            rem = this;
            while (rem.gte(divisor)) {
                // Approximate the result of division. This may be a little greater or
                // smaller than the actual value.
                approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

                // We will tweak the approximate result by changing it in the 48-th digit or
                // the smallest non-fractional digit, whichever is larger.
                var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                    delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

                // Decrease the approximation until it is smaller than the remainder.  Note
                // that if it is too large, the product overflows and is negative.
                    approxRes = fromNumber(approx),
                    approxRem = approxRes.mul(divisor);
                while (approxRem.isNegative() || approxRem.gt(rem)) {
                    approx -= delta;
                    approxRes = fromNumber(approx, this.unsigned);
                    approxRem = approxRes.mul(divisor);
                }

                // We know the answer can't be zero... and actually, zero would cause
                // infinite recursion since we would make no progress.
                if (approxRes.isZero())
                    approxRes = ONE;

                res = res.add(approxRes);
                rem = rem.sub(approxRem);
            }
            return res;
        };

        /**
         * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
         * @function
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Quotient
         */
        LongPrototype.div = LongPrototype.divide;

        /**
         * Returns this Long modulo the specified.
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Remainder
         */
        LongPrototype.modulo = function modulo(divisor) {
            if (!isLong(divisor))
                divisor = fromValue(divisor);
            return this.sub(this.div(divisor).mul(divisor));
        };

        /**
         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
         * @function
         * @param {!Long|number|string} divisor Divisor
         * @returns {!Long} Remainder
         */
        LongPrototype.mod = LongPrototype.modulo;

        /**
         * Returns the bitwise NOT of this Long.
         * @returns {!Long}
         */
        LongPrototype.not = function not() {
            return fromBits(~this.low, ~this.high, this.unsigned);
        };

        /**
         * Returns the bitwise AND of this Long and the specified.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */
        LongPrototype.and = function and(other) {
            if (!isLong(other))
                other = fromValue(other);
            return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
        };

        /**
         * Returns the bitwise OR of this Long and the specified.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */
        LongPrototype.or = function or(other) {
            if (!isLong(other))
                other = fromValue(other);
            return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
        };

        /**
         * Returns the bitwise XOR of this Long and the given one.
         * @param {!Long|number|string} other Other Long
         * @returns {!Long}
         */
        LongPrototype.xor = function xor(other) {
            if (!isLong(other))
                other = fromValue(other);
            return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };

        /**
         * Returns this Long with bits shifted to the left by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shiftLeft = function shiftLeft(numBits) {
            if (isLong(numBits))
                numBits = numBits.toInt();
            if ((numBits &= 63) === 0)
                return this;
            else if (numBits < 32)
                return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
            else
                return fromBits(0, this.low << (numBits - 32), this.unsigned);
        };

        /**
         * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shl = LongPrototype.shiftLeft;

        /**
         * Returns this Long with bits arithmetically shifted to the right by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shiftRight = function shiftRight(numBits) {
            if (isLong(numBits))
                numBits = numBits.toInt();
            if ((numBits &= 63) === 0)
                return this;
            else if (numBits < 32)
                return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
            else
                return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
        };

        /**
         * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shr = LongPrototype.shiftRight;

        /**
         * Returns this Long with bits logically shifted to the right by the given amount.
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
            if (isLong(numBits))
                numBits = numBits.toInt();
            numBits &= 63;
            if (numBits === 0)
                return this;
            else {
                var high = this.high;
                if (numBits < 32) {
                    var low = this.low;
                    return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
                } else if (numBits === 32)
                    return fromBits(high, 0, this.unsigned);
                else
                    return fromBits(high >>> (numBits - 32), 0, this.unsigned);
            }
        };

        /**
         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
         * @function
         * @param {number|!Long} numBits Number of bits
         * @returns {!Long} Shifted Long
         */
        LongPrototype.shru = LongPrototype.shiftRightUnsigned;

        /**
         * Converts this Long to signed.
         * @returns {!Long} Signed long
         */
        LongPrototype.toSigned = function toSigned() {
            if (!this.unsigned)
                return this;
            return fromBits(this.low, this.high, false);
        };

        /**
         * Converts this Long to unsigned.
         * @returns {!Long} Unsigned long
         */
        LongPrototype.toUnsigned = function toUnsigned() {
            if (this.unsigned)
                return this;
            return fromBits(this.low, this.high, true);
        };

        /**
         * Converts this Long to its byte representation.
         * @param {boolean=} le Whether little or big endian, defaults to big endian
         * @returns {!Array.<number>} Byte representation
         */
        LongPrototype.toBytes = function(le) {
            return le ? this.toBytesLE() : this.toBytesBE();
        };

        /**
         * Converts this Long to its little endian byte representation.
         * @returns {!Array.<number>} Little endian byte representation
         */
        LongPrototype.toBytesLE = function() {
            var hi = this.high,
                lo = this.low;
            return [
                 lo         & 0xff,
                (lo >>>  8) & 0xff,
                (lo >>> 16) & 0xff,
                (lo >>> 24) & 0xff,
                 hi         & 0xff,
                (hi >>>  8) & 0xff,
                (hi >>> 16) & 0xff,
                (hi >>> 24) & 0xff
            ];
        };

        /**
         * Converts this Long to its big endian byte representation.
         * @returns {!Array.<number>} Big endian byte representation
         */
        LongPrototype.toBytesBE = function() {
            var hi = this.high,
                lo = this.low;
            return [
                (hi >>> 24) & 0xff,
                (hi >>> 16) & 0xff,
                (hi >>>  8) & 0xff,
                 hi         & 0xff,
                (lo >>> 24) & 0xff,
                (lo >>> 16) & 0xff,
                (lo >>>  8) & 0xff,
                 lo         & 0xff
            ];
        };

        return Long;
    });
    });

    var bytebuffer = createCommonjsModule(function (module) {
    /*
     Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
     */

    /**
     * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
     * Backing buffer: ArrayBuffer, Accessor: Uint8Array
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/bytebuffer.js for details
     */
    (function(global, factory) {

        /* AMD */ if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"])
            module['exports'] = (function() {
                var Long; try { Long = long_1; } catch (e) {}
                return factory(Long);
            })();
        /* Global */ else
            (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

    })(commonjsGlobal, function(Long) {

        /**
         * Constructs a new ByteBuffer.
         * @class The swiss army knife for binary data in JavaScript.
         * @exports ByteBuffer
         * @constructor
         * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @expose
         */
        var ByteBuffer = function(capacity, littleEndian, noAssert) {
            if (typeof capacity === 'undefined')
                capacity = ByteBuffer.DEFAULT_CAPACITY;
            if (typeof littleEndian === 'undefined')
                littleEndian = ByteBuffer.DEFAULT_ENDIAN;
            if (typeof noAssert === 'undefined')
                noAssert = ByteBuffer.DEFAULT_NOASSERT;
            if (!noAssert) {
                capacity = capacity | 0;
                if (capacity < 0)
                    throw RangeError("Illegal capacity");
                littleEndian = !!littleEndian;
                noAssert = !!noAssert;
            }

            /**
             * Backing ArrayBuffer.
             * @type {!ArrayBuffer}
             * @expose
             */
            this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

            /**
             * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
             * @type {?Uint8Array}
             * @expose
             */
            this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

            /**
             * Absolute read/write offset.
             * @type {number}
             * @expose
             * @see ByteBuffer#flip
             * @see ByteBuffer#clear
             */
            this.offset = 0;

            /**
             * Marked offset.
             * @type {number}
             * @expose
             * @see ByteBuffer#mark
             * @see ByteBuffer#reset
             */
            this.markedOffset = -1;

            /**
             * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
             * @type {number}
             * @expose
             * @see ByteBuffer#flip
             * @see ByteBuffer#clear
             */
            this.limit = capacity;

            /**
             * Whether to use little endian byte order, defaults to `false` for big endian.
             * @type {boolean}
             * @expose
             */
            this.littleEndian = littleEndian;

            /**
             * Whether to skip assertions of offsets and values, defaults to `false`.
             * @type {boolean}
             * @expose
             */
            this.noAssert = noAssert;
        };

        /**
         * ByteBuffer version.
         * @type {string}
         * @const
         * @expose
         */
        ByteBuffer.VERSION = "5.0.1";

        /**
         * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
         * @type {boolean}
         * @const
         * @expose
         */
        ByteBuffer.LITTLE_ENDIAN = true;

        /**
         * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
         * @type {boolean}
         * @const
         * @expose
         */
        ByteBuffer.BIG_ENDIAN = false;

        /**
         * Default initial capacity of `16`.
         * @type {number}
         * @expose
         */
        ByteBuffer.DEFAULT_CAPACITY = 16;

        /**
         * Default endianess of `false` for big endian.
         * @type {boolean}
         * @expose
         */
        ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

        /**
         * Default no assertions flag of `false`.
         * @type {boolean}
         * @expose
         */
        ByteBuffer.DEFAULT_NOASSERT = false;

        /**
         * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
         *  and int64 support is not available.
         * @type {?Long}
         * @const
         * @see https://github.com/dcodeIO/long.js
         * @expose
         */
        ByteBuffer.Long = Long || null;

        /**
         * @alias ByteBuffer.prototype
         * @inner
         */
        var ByteBufferPrototype = ByteBuffer.prototype;

        /**
         * An indicator used to reliably determine if an object is a ByteBuffer or not.
         * @type {boolean}
         * @const
         * @expose
         * @private
         */
        ByteBufferPrototype.__isByteBuffer__;

        Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
            value: true,
            enumerable: false,
            configurable: false
        });

        // helpers

        /**
         * @type {!ArrayBuffer}
         * @inner
         */
        var EMPTY_BUFFER = new ArrayBuffer(0);

        /**
         * String.fromCharCode reference for compile-time renaming.
         * @type {function(...number):string}
         * @inner
         */
        var stringFromCharCode = String.fromCharCode;

        /**
         * Creates a source function for a string.
         * @param {string} s String to read from
         * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
         *  no more characters left.
         * @throws {TypeError} If the argument is invalid
         * @inner
         */
        function stringSource(s) {
            var i=0; return function() {
                return i < s.length ? s.charCodeAt(i++) : null;
            };
        }

        /**
         * Creates a destination function for a string.
         * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
         *  Returns the final string when called without arguments.
         * @inner
         */
        function stringDestination() {
            var cs = [], ps = []; return function() {
                if (arguments.length === 0)
                    return ps.join('')+stringFromCharCode.apply(String, cs);
                if (cs.length + arguments.length > 1024)
                    ps.push(stringFromCharCode.apply(String, cs)),
                        cs.length = 0;
                Array.prototype.push.apply(cs, arguments);
            };
        }

        /**
         * Gets the accessor type.
         * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
         * @expose
         */
        ByteBuffer.accessor = function() {
            return Uint8Array;
        };
        /**
         * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
         * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer}
         * @expose
         */
        ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
            return new ByteBuffer(capacity, littleEndian, noAssert);
        };

        /**
         * Concatenates multiple ByteBuffers into one.
         * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
         * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
         *  defaults to "utf8")
         * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
         *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer} Concatenated ByteBuffer
         * @expose
         */
        ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
            if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
                noAssert = littleEndian;
                littleEndian = encoding;
                encoding = undefined;
            }
            var capacity = 0;
            for (var i=0, k=buffers.length, length; i<k; ++i) {
                if (!ByteBuffer.isByteBuffer(buffers[i]))
                    buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
                length = buffers[i].limit - buffers[i].offset;
                if (length > 0) capacity += length;
            }
            if (capacity === 0)
                return new ByteBuffer(0, littleEndian, noAssert);
            var bb = new ByteBuffer(capacity, littleEndian, noAssert),
                bi;
            i=0; while (i<k) {
                bi = buffers[i++];
                length = bi.limit - bi.offset;
                if (length <= 0) continue;
                bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
                bb.offset += length;
            }
            bb.limit = bb.offset;
            bb.offset = 0;
            return bb;
        };

        /**
         * Tests if the specified type is a ByteBuffer.
         * @param {*} bb ByteBuffer to test
         * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
         * @expose
         */
        ByteBuffer.isByteBuffer = function(bb) {
            return (bb && bb["__isByteBuffer__"]) === true;
        };
        /**
         * Gets the backing buffer type.
         * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
         * @expose
         */
        ByteBuffer.type = function() {
            return ArrayBuffer;
        };
        /**
         * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
         *  {@link ByteBuffer#limit} to the length of the wrapped data.
         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
         * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
         *  "utf8")
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
         * @expose
         */
        ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
            if (typeof encoding !== 'string') {
                noAssert = littleEndian;
                littleEndian = encoding;
                encoding = undefined;
            }
            if (typeof buffer === 'string') {
                if (typeof encoding === 'undefined')
                    encoding = "utf8";
                switch (encoding) {
                    case "base64":
                        return ByteBuffer.fromBase64(buffer, littleEndian);
                    case "hex":
                        return ByteBuffer.fromHex(buffer, littleEndian);
                    case "binary":
                        return ByteBuffer.fromBinary(buffer, littleEndian);
                    case "utf8":
                        return ByteBuffer.fromUTF8(buffer, littleEndian);
                    case "debug":
                        return ByteBuffer.fromDebug(buffer, littleEndian);
                    default:
                        throw Error("Unsupported encoding: "+encoding);
                }
            }
            if (buffer === null || typeof buffer !== 'object')
                throw TypeError("Illegal buffer");
            var bb;
            if (ByteBuffer.isByteBuffer(buffer)) {
                bb = ByteBufferPrototype.clone.call(buffer);
                bb.markedOffset = -1;
                return bb;
            }
            if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
                bb = new ByteBuffer(0, littleEndian, noAssert);
                if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                    bb.buffer = buffer.buffer;
                    bb.offset = buffer.byteOffset;
                    bb.limit = buffer.byteOffset + buffer.byteLength;
                    bb.view = new Uint8Array(buffer.buffer);
                }
            } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
                bb = new ByteBuffer(0, littleEndian, noAssert);
                if (buffer.byteLength > 0) {
                    bb.buffer = buffer;
                    bb.offset = 0;
                    bb.limit = buffer.byteLength;
                    bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
                }
            } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
                bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
                bb.limit = buffer.length;
                for (var i=0; i<buffer.length; ++i)
                    bb.view[i] = buffer[i];
            } else
                throw TypeError("Illegal buffer"); // Otherwise fail
            return bb;
        };

        /**
         * Writes the array as a bitset.
         * @param {Array<boolean>} value Array of booleans to write
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
         * @returns {!ByteBuffer}
         * @expose
         */
        ByteBufferPrototype.writeBitSet = function(value, offset) {
          var relative = typeof offset === 'undefined';
          if (relative) offset = this.offset;
          if (!this.noAssert) {
            if (!(value instanceof Array))
              throw TypeError("Illegal BitSet: Not an array");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
          }

          var start = offset,
              bits = value.length,
              bytes = (bits >> 3),
              bit = 0,
              k;

          offset += this.writeVarint32(bits,offset);

          while(bytes--) {
            k = (!!value[bit++] & 1) |
                ((!!value[bit++] & 1) << 1) |
                ((!!value[bit++] & 1) << 2) |
                ((!!value[bit++] & 1) << 3) |
                ((!!value[bit++] & 1) << 4) |
                ((!!value[bit++] & 1) << 5) |
                ((!!value[bit++] & 1) << 6) |
                ((!!value[bit++] & 1) << 7);
            this.writeByte(k,offset++);
          }

          if(bit < bits) {
            var m = 0; k = 0;
            while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
            this.writeByte(k,offset++);
          }

          if (relative) {
            this.offset = offset;
            return this;
          }
          return offset - start;
        };

        /**
         * Reads a BitSet as an array of booleans.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
         * @returns {Array<boolean>
         * @expose
         */
        ByteBufferPrototype.readBitSet = function(offset) {
          var relative = typeof offset === 'undefined';
          if (relative) offset = this.offset;

          var ret = this.readVarint32(offset),
              bits = ret.value,
              bytes = (bits >> 3),
              bit = 0,
              value = [],
              k;

          offset += ret.length;

          while(bytes--) {
            k = this.readByte(offset++);
            value[bit++] = !!(k & 0x01);
            value[bit++] = !!(k & 0x02);
            value[bit++] = !!(k & 0x04);
            value[bit++] = !!(k & 0x08);
            value[bit++] = !!(k & 0x10);
            value[bit++] = !!(k & 0x20);
            value[bit++] = !!(k & 0x40);
            value[bit++] = !!(k & 0x80);
          }

          if(bit < bits) {
            var m = 0;
            k = this.readByte(offset++);
            while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
          }

          if (relative) {
            this.offset = offset;
          }
          return value;
        };
        /**
         * Reads the specified number of bytes.
         * @param {number} length Number of bytes to read
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
         * @returns {!ByteBuffer}
         * @expose
         */
        ByteBufferPrototype.readBytes = function(length, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var slice = this.slice(offset, offset + length);
            if (relative) this.offset += length;
            return slice;
        };


        // types/ints/int8

        /**
         * Writes an 8bit signed integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt8 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value |= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 1;
            var capacity0 = this.buffer.byteLength;
            if (offset > capacity0)
                this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
            offset -= 1;
            this.view[offset] = value;
            if (relative) this.offset += 1;
            return this;
        };

        /**
         * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

        /**
         * Reads an 8bit signed integer.
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readInt8 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            var value = this.view[offset];
            if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
            if (relative) this.offset += 1;
            return value;
        };

        /**
         * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
         * @function
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

        /**
         * Writes an 8bit unsigned integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint8 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value >>>= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 1;
            var capacity1 = this.buffer.byteLength;
            if (offset > capacity1)
                this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
            offset -= 1;
            this.view[offset] = value;
            if (relative) this.offset += 1;
            return this;
        };

        /**
         * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

        /**
         * Reads an 8bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readUint8 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            var value = this.view[offset];
            if (relative) this.offset += 1;
            return value;
        };

        /**
         * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
         * @function
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

        // types/ints/int16

        /**
         * Writes a 16bit signed integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @throws {TypeError} If `offset` or `value` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.writeInt16 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value |= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 2;
            var capacity2 = this.buffer.byteLength;
            if (offset > capacity2)
                this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
            offset -= 2;
            if (this.littleEndian) {
                this.view[offset+1] = (value & 0xFF00) >>> 8;
                this.view[offset  ] =  value & 0x00FF;
            } else {
                this.view[offset]   = (value & 0xFF00) >>> 8;
                this.view[offset+1] =  value & 0x00FF;
            }
            if (relative) this.offset += 2;
            return this;
        };

        /**
         * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @throws {TypeError} If `offset` or `value` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

        /**
         * Reads a 16bit signed integer.
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @returns {number} Value read
         * @throws {TypeError} If `offset` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.readInt16 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 2 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
            }
            var value = 0;
            if (this.littleEndian) {
                value  = this.view[offset  ];
                value |= this.view[offset+1] << 8;
            } else {
                value  = this.view[offset  ] << 8;
                value |= this.view[offset+1];
            }
            if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
            if (relative) this.offset += 2;
            return value;
        };

        /**
         * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
         * @function
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @returns {number} Value read
         * @throws {TypeError} If `offset` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

        /**
         * Writes a 16bit unsigned integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @throws {TypeError} If `offset` or `value` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.writeUint16 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value >>>= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 2;
            var capacity3 = this.buffer.byteLength;
            if (offset > capacity3)
                this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
            offset -= 2;
            if (this.littleEndian) {
                this.view[offset+1] = (value & 0xFF00) >>> 8;
                this.view[offset  ] =  value & 0x00FF;
            } else {
                this.view[offset]   = (value & 0xFF00) >>> 8;
                this.view[offset+1] =  value & 0x00FF;
            }
            if (relative) this.offset += 2;
            return this;
        };

        /**
         * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @throws {TypeError} If `offset` or `value` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

        /**
         * Reads a 16bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @returns {number} Value read
         * @throws {TypeError} If `offset` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.readUint16 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 2 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
            }
            var value = 0;
            if (this.littleEndian) {
                value  = this.view[offset  ];
                value |= this.view[offset+1] << 8;
            } else {
                value  = this.view[offset  ] << 8;
                value |= this.view[offset+1];
            }
            if (relative) this.offset += 2;
            return value;
        };

        /**
         * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
         * @function
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
         * @returns {number} Value read
         * @throws {TypeError} If `offset` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @expose
         */
        ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

        // types/ints/int32

        /**
         * Writes a 32bit signed integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @expose
         */
        ByteBufferPrototype.writeInt32 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value |= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 4;
            var capacity4 = this.buffer.byteLength;
            if (offset > capacity4)
                this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
            offset -= 4;
            if (this.littleEndian) {
                this.view[offset+3] = (value >>> 24) & 0xFF;
                this.view[offset+2] = (value >>> 16) & 0xFF;
                this.view[offset+1] = (value >>>  8) & 0xFF;
                this.view[offset  ] =  value         & 0xFF;
            } else {
                this.view[offset  ] = (value >>> 24) & 0xFF;
                this.view[offset+1] = (value >>> 16) & 0xFF;
                this.view[offset+2] = (value >>>  8) & 0xFF;
                this.view[offset+3] =  value         & 0xFF;
            }
            if (relative) this.offset += 4;
            return this;
        };

        /**
         * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @expose
         */
        ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

        /**
         * Reads a 32bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readInt32 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 4 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
            }
            var value = 0;
            if (this.littleEndian) {
                value  = this.view[offset+2] << 16;
                value |= this.view[offset+1] <<  8;
                value |= this.view[offset  ];
                value += this.view[offset+3] << 24 >>> 0;
            } else {
                value  = this.view[offset+1] << 16;
                value |= this.view[offset+2] <<  8;
                value |= this.view[offset+3];
                value += this.view[offset  ] << 24 >>> 0;
            }
            value |= 0; // Cast to signed
            if (relative) this.offset += 4;
            return value;
        };

        /**
         * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
         * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

        /**
         * Writes a 32bit unsigned integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @expose
         */
        ByteBufferPrototype.writeUint32 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value >>>= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 4;
            var capacity5 = this.buffer.byteLength;
            if (offset > capacity5)
                this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
            offset -= 4;
            if (this.littleEndian) {
                this.view[offset+3] = (value >>> 24) & 0xFF;
                this.view[offset+2] = (value >>> 16) & 0xFF;
                this.view[offset+1] = (value >>>  8) & 0xFF;
                this.view[offset  ] =  value         & 0xFF;
            } else {
                this.view[offset  ] = (value >>> 24) & 0xFF;
                this.view[offset+1] = (value >>> 16) & 0xFF;
                this.view[offset+2] = (value >>>  8) & 0xFF;
                this.view[offset+3] =  value         & 0xFF;
            }
            if (relative) this.offset += 4;
            return this;
        };

        /**
         * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @expose
         */
        ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

        /**
         * Reads a 32bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readUint32 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 4 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
            }
            var value = 0;
            if (this.littleEndian) {
                value  = this.view[offset+2] << 16;
                value |= this.view[offset+1] <<  8;
                value |= this.view[offset  ];
                value += this.view[offset+3] << 24 >>> 0;
            } else {
                value  = this.view[offset+1] << 16;
                value |= this.view[offset+2] <<  8;
                value |= this.view[offset+3];
                value += this.view[offset  ] << 24 >>> 0;
            }
            if (relative) this.offset += 4;
            return value;
        };

        /**
         * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number} Value read
         * @expose
         */
        ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

        // types/ints/int64

        if (Long) {

            /**
             * Writes a 64bit signed integer.
             * @param {number|!Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!ByteBuffer} this
             * @expose
             */
            ByteBufferPrototype.writeInt64 = function(value, offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof value === 'number')
                        value = Long.fromNumber(value);
                    else if (typeof value === 'string')
                        value = Long.fromString(value);
                    else if (!(value && value instanceof Long))
                        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 0 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
                }
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                offset += 8;
                var capacity6 = this.buffer.byteLength;
                if (offset > capacity6)
                    this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
                offset -= 8;
                var lo = value.low,
                    hi = value.high;
                if (this.littleEndian) {
                    this.view[offset+3] = (lo >>> 24) & 0xFF;
                    this.view[offset+2] = (lo >>> 16) & 0xFF;
                    this.view[offset+1] = (lo >>>  8) & 0xFF;
                    this.view[offset  ] =  lo         & 0xFF;
                    offset += 4;
                    this.view[offset+3] = (hi >>> 24) & 0xFF;
                    this.view[offset+2] = (hi >>> 16) & 0xFF;
                    this.view[offset+1] = (hi >>>  8) & 0xFF;
                    this.view[offset  ] =  hi         & 0xFF;
                } else {
                    this.view[offset  ] = (hi >>> 24) & 0xFF;
                    this.view[offset+1] = (hi >>> 16) & 0xFF;
                    this.view[offset+2] = (hi >>>  8) & 0xFF;
                    this.view[offset+3] =  hi         & 0xFF;
                    offset += 4;
                    this.view[offset  ] = (lo >>> 24) & 0xFF;
                    this.view[offset+1] = (lo >>> 16) & 0xFF;
                    this.view[offset+2] = (lo >>>  8) & 0xFF;
                    this.view[offset+3] =  lo         & 0xFF;
                }
                if (relative) this.offset += 8;
                return this;
            };

            /**
             * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
             * @param {number|!Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!ByteBuffer} this
             * @expose
             */
            ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

            /**
             * Reads a 64bit signed integer.
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!Long}
             * @expose
             */
            ByteBufferPrototype.readInt64 = function(offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 8 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
                }
                var lo = 0,
                    hi = 0;
                if (this.littleEndian) {
                    lo  = this.view[offset+2] << 16;
                    lo |= this.view[offset+1] <<  8;
                    lo |= this.view[offset  ];
                    lo += this.view[offset+3] << 24 >>> 0;
                    offset += 4;
                    hi  = this.view[offset+2] << 16;
                    hi |= this.view[offset+1] <<  8;
                    hi |= this.view[offset  ];
                    hi += this.view[offset+3] << 24 >>> 0;
                } else {
                    hi  = this.view[offset+1] << 16;
                    hi |= this.view[offset+2] <<  8;
                    hi |= this.view[offset+3];
                    hi += this.view[offset  ] << 24 >>> 0;
                    offset += 4;
                    lo  = this.view[offset+1] << 16;
                    lo |= this.view[offset+2] <<  8;
                    lo |= this.view[offset+3];
                    lo += this.view[offset  ] << 24 >>> 0;
                }
                var value = new Long(lo, hi, false);
                if (relative) this.offset += 8;
                return value;
            };

            /**
             * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!Long}
             * @expose
             */
            ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

            /**
             * Writes a 64bit unsigned integer.
             * @param {number|!Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!ByteBuffer} this
             * @expose
             */
            ByteBufferPrototype.writeUint64 = function(value, offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof value === 'number')
                        value = Long.fromNumber(value);
                    else if (typeof value === 'string')
                        value = Long.fromString(value);
                    else if (!(value && value instanceof Long))
                        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 0 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
                }
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                offset += 8;
                var capacity7 = this.buffer.byteLength;
                if (offset > capacity7)
                    this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
                offset -= 8;
                var lo = value.low,
                    hi = value.high;
                if (this.littleEndian) {
                    this.view[offset+3] = (lo >>> 24) & 0xFF;
                    this.view[offset+2] = (lo >>> 16) & 0xFF;
                    this.view[offset+1] = (lo >>>  8) & 0xFF;
                    this.view[offset  ] =  lo         & 0xFF;
                    offset += 4;
                    this.view[offset+3] = (hi >>> 24) & 0xFF;
                    this.view[offset+2] = (hi >>> 16) & 0xFF;
                    this.view[offset+1] = (hi >>>  8) & 0xFF;
                    this.view[offset  ] =  hi         & 0xFF;
                } else {
                    this.view[offset  ] = (hi >>> 24) & 0xFF;
                    this.view[offset+1] = (hi >>> 16) & 0xFF;
                    this.view[offset+2] = (hi >>>  8) & 0xFF;
                    this.view[offset+3] =  hi         & 0xFF;
                    offset += 4;
                    this.view[offset  ] = (lo >>> 24) & 0xFF;
                    this.view[offset+1] = (lo >>> 16) & 0xFF;
                    this.view[offset+2] = (lo >>>  8) & 0xFF;
                    this.view[offset+3] =  lo         & 0xFF;
                }
                if (relative) this.offset += 8;
                return this;
            };

            /**
             * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
             * @function
             * @param {number|!Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!ByteBuffer} this
             * @expose
             */
            ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

            /**
             * Reads a 64bit unsigned integer.
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!Long}
             * @expose
             */
            ByteBufferPrototype.readUint64 = function(offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 8 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
                }
                var lo = 0,
                    hi = 0;
                if (this.littleEndian) {
                    lo  = this.view[offset+2] << 16;
                    lo |= this.view[offset+1] <<  8;
                    lo |= this.view[offset  ];
                    lo += this.view[offset+3] << 24 >>> 0;
                    offset += 4;
                    hi  = this.view[offset+2] << 16;
                    hi |= this.view[offset+1] <<  8;
                    hi |= this.view[offset  ];
                    hi += this.view[offset+3] << 24 >>> 0;
                } else {
                    hi  = this.view[offset+1] << 16;
                    hi |= this.view[offset+2] <<  8;
                    hi |= this.view[offset+3];
                    hi += this.view[offset  ] << 24 >>> 0;
                    offset += 4;
                    lo  = this.view[offset+1] << 16;
                    lo |= this.view[offset+2] <<  8;
                    lo |= this.view[offset+3];
                    lo += this.view[offset  ] << 24 >>> 0;
                }
                var value = new Long(lo, hi, true);
                if (relative) this.offset += 8;
                return value;
            };

            /**
             * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
             * @function
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
             * @returns {!Long}
             * @expose
             */
            ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

        } // Long


        // types/floats/float32

        /*
         ieee754 - https://github.com/feross/ieee754

         The MIT License (MIT)

         Copyright (c) Feross Aboukhadijeh

         Permission is hereby granted, free of charge, to any person obtaining a copy
         of this software and associated documentation files (the "Software"), to deal
         in the Software without restriction, including without limitation the rights
         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
         copies of the Software, and to permit persons to whom the Software is
         furnished to do so, subject to the following conditions:

         The above copyright notice and this permission notice shall be included in
         all copies or substantial portions of the Software.

         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
         THE SOFTWARE.
        */

        /**
         * Reads an IEEE754 float from a byte array.
         * @param {!Array} buffer
         * @param {number} offset
         * @param {boolean} isLE
         * @param {number} mLen
         * @param {number} nBytes
         * @returns {number}
         * @inner
         */
        function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
            var e, m,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                nBits = -7,
                i = isLE ? (nBytes - 1) : 0,
                d = isLE ? -1 : 1,
                s = buffer[offset + i];

            i += d;

            e = s & ((1 << (-nBits)) - 1);
            s >>= (-nBits);
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            m = e & ((1 << (-nBits)) - 1);
            e >>= (-nBits);
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

            if (e === 0) {
                e = 1 - eBias;
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity);
            } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        }

        /**
         * Writes an IEEE754 float to a byte array.
         * @param {!Array} buffer
         * @param {number} value
         * @param {number} offset
         * @param {boolean} isLE
         * @param {number} mLen
         * @param {number} nBytes
         * @inner
         */
        function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c,
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
                i = isLE ? 0 : (nBytes - 1),
                d = isLE ? 1 : -1,
                s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
            } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--;
                    c *= 2;
                }
                if (e + eBias >= 1) {
                    value += rt / c;
                } else {
                    value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                    e++;
                    c /= 2;
                }

                if (e + eBias >= eMax) {
                    m = 0;
                    e = eMax;
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen);
                    e = e + eBias;
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                    e = 0;
                }
            }

            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

            e = (e << mLen) | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

            buffer[offset + i - d] |= s * 128;
        }

        /**
         * Writes a 32bit float.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeFloat32 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number')
                    throw TypeError("Illegal value: "+value+" (not a number)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 4;
            var capacity8 = this.buffer.byteLength;
            if (offset > capacity8)
                this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
            offset -= 4;
            ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
            if (relative) this.offset += 4;
            return this;
        };

        /**
         * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

        /**
         * Reads a 32bit float.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number}
         * @expose
         */
        ByteBufferPrototype.readFloat32 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 4 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
            }
            var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
            if (relative) this.offset += 4;
            return value;
        };

        /**
         * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
         * @returns {number}
         * @expose
         */
        ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

        // types/floats/float64

        /**
         * Writes a 64bit float.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeFloat64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number')
                    throw TypeError("Illegal value: "+value+" (not a number)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            offset += 8;
            var capacity9 = this.buffer.byteLength;
            if (offset > capacity9)
                this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
            offset -= 8;
            ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
         * @function
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

        /**
         * Reads a 64bit float.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {number}
         * @expose
         */
        ByteBufferPrototype.readFloat64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {number}
         * @expose
         */
        ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


        // types/varints/varint32

        /**
         * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT32_BYTES = 5;

        /**
         * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
         * @param {number} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint32 = function(value) {
            // ref: src/google/protobuf/io/coded_stream.cc
            value = value >>> 0;
                 if (value < 1 << 7 ) return 1;
            else if (value < 1 << 14) return 2;
            else if (value < 1 << 21) return 3;
            else if (value < 1 << 28) return 4;
            else                      return 5;
        };

        /**
         * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
         * @param {number} n Signed 32bit integer
         * @returns {number} Unsigned zigzag encoded 32bit integer
         * @expose
         */
        ByteBuffer.zigZagEncode32 = function(n) {
            return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
        };

        /**
         * Decodes a zigzag encoded signed 32bit integer.
         * @param {number} n Unsigned zigzag encoded 32bit integer
         * @returns {number} Signed 32bit integer
         * @expose
         */
        ByteBuffer.zigZagDecode32 = function(n) {
            return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
        };

        /**
         * Writes a 32bit base 128 variable-length integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
         * @expose
         */
        ByteBufferPrototype.writeVarint32 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value |= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            var size = ByteBuffer.calculateVarint32(value),
                b;
            offset += size;
            var capacity10 = this.buffer.byteLength;
            if (offset > capacity10)
                this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
            offset -= size;
            value >>>= 0;
            while (value >= 0x80) {
                b = (value & 0x7f) | 0x80;
                this.view[offset++] = b;
                value >>>= 7;
            }
            this.view[offset++] = value;
            if (relative) {
                this.offset = offset;
                return this;
            }
            return size;
        };

        /**
         * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
         * @param {number} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
         * @expose
         */
        ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
            return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
        };

        /**
         * Reads a 32bit base 128 variable-length integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
         *  and the actual number of bytes read.
         * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
         *  to fully decode the varint.
         * @expose
         */
        ByteBufferPrototype.readVarint32 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            var c = 0,
                value = 0 >>> 0,
                b;
            do {
                if (!this.noAssert && offset > this.limit) {
                    var err = Error("Truncated");
                    err['truncated'] = true;
                    throw err;
                }
                b = this.view[offset++];
                if (c < 5)
                    value |= (b & 0x7f) << (7*c);
                ++c;
            } while ((b & 0x80) !== 0);
            value |= 0;
            if (relative) {
                this.offset = offset;
                return value;
            }
            return {
                "value": value,
                "length": c
            };
        };

        /**
         * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
         *  and the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint32ZigZag = function(offset) {
            var val = this.readVarint32(offset);
            if (typeof val === 'object')
                val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
            else
                val = ByteBuffer.zigZagDecode32(val);
            return val;
        };

        // types/varints/varint64

        if (Long) {

            /**
             * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
             * @type {number}
             * @const
             * @expose
             */
            ByteBuffer.MAX_VARINT64_BYTES = 10;

            /**
             * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
             * @param {number|!Long} value Value to encode
             * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
             * @expose
             */
            ByteBuffer.calculateVarint64 = function(value) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                // ref: src/google/protobuf/io/coded_stream.cc
                var part0 = value.toInt() >>> 0,
                    part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                    part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
                if (part2 == 0) {
                    if (part1 == 0) {
                        if (part0 < 1 << 14)
                            return part0 < 1 << 7 ? 1 : 2;
                        else
                            return part0 < 1 << 21 ? 3 : 4;
                    } else {
                        if (part1 < 1 << 14)
                            return part1 < 1 << 7 ? 5 : 6;
                        else
                            return part1 < 1 << 21 ? 7 : 8;
                    }
                } else
                    return part2 < 1 << 7 ? 9 : 10;
            };

            /**
             * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
             * @param {number|!Long} value Signed long
             * @returns {!Long} Unsigned zigzag encoded long
             * @expose
             */
            ByteBuffer.zigZagEncode64 = function(value) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value, false);
                else if (typeof value === 'string')
                    value = Long.fromString(value, false);
                else if (value.unsigned !== false) value = value.toSigned();
                // ref: src/google/protobuf/wire_format_lite.h
                return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
            };

            /**
             * Decodes a zigzag encoded signed 64bit integer.
             * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
             * @returns {!Long} Signed long
             * @expose
             */
            ByteBuffer.zigZagDecode64 = function(value) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value, false);
                else if (typeof value === 'string')
                    value = Long.fromString(value, false);
                else if (value.unsigned !== false) value = value.toSigned();
                // ref: src/google/protobuf/wire_format_lite.h
                return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
            };

            /**
             * Writes a 64bit base 128 variable-length integer.
             * @param {number|Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
             *  written if omitted.
             * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
             * @expose
             */
            ByteBufferPrototype.writeVarint64 = function(value, offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof value === 'number')
                        value = Long.fromNumber(value);
                    else if (typeof value === 'string')
                        value = Long.fromString(value);
                    else if (!(value && value instanceof Long))
                        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 0 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
                }
                if (typeof value === 'number')
                    value = Long.fromNumber(value, false);
                else if (typeof value === 'string')
                    value = Long.fromString(value, false);
                else if (value.unsigned !== false) value = value.toSigned();
                var size = ByteBuffer.calculateVarint64(value),
                    part0 = value.toInt() >>> 0,
                    part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                    part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
                offset += size;
                var capacity11 = this.buffer.byteLength;
                if (offset > capacity11)
                    this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
                offset -= size;
                switch (size) {
                    case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                    case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                    case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                    case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                    case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                    case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                    case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                    case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                    case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                    case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
                }
                if (relative) {
                    this.offset += size;
                    return this;
                } else {
                    return size;
                }
            };

            /**
             * Writes a zig-zag encoded 64bit base 128 variable-length integer.
             * @param {number|Long} value Value to write
             * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
             *  written if omitted.
             * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
             * @expose
             */
            ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
                return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
            };

            /**
             * Reads a 64bit base 128 variable-length integer. Requires Long.js.
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
             *  read if omitted.
             * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
             *  the actual number of bytes read.
             * @throws {Error} If it's not a valid varint
             * @expose
             */
            ByteBufferPrototype.readVarint64 = function(offset) {
                var relative = typeof offset === 'undefined';
                if (relative) offset = this.offset;
                if (!this.noAssert) {
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + 1 > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
                }
                // ref: src/google/protobuf/io/coded_stream.cc
                var start = offset,
                    part0 = 0,
                    part1 = 0,
                    part2 = 0,
                    b  = 0;
                b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
                b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
                throw Error("Buffer overrun"); }}}}}}}}}}
                var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
                if (relative) {
                    this.offset = offset;
                    return value;
                } else {
                    return {
                        'value': value,
                        'length': offset-start
                    };
                }
            };

            /**
             * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
             * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
             *  read if omitted.
             * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
             *  the actual number of bytes read.
             * @throws {Error} If it's not a valid varint
             * @expose
             */
            ByteBufferPrototype.readVarint64ZigZag = function(offset) {
                var val = this.readVarint64(offset);
                if (val && val['value'] instanceof Long)
                    val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
                else
                    val = ByteBuffer.zigZagDecode64(val);
                return val;
            };

        } // Long


        // types/strings/cstring

        /**
         * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
         *  characters itself.
         * @param {string} str String to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  contained in `str` + 1 if omitted.
         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
         * @expose
         */
        ByteBufferPrototype.writeCString = function(str, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            var i,
                k = str.length;
            if (!this.noAssert) {
                if (typeof str !== 'string')
                    throw TypeError("Illegal str: Not a string");
                for (i=0; i<k; ++i) {
                    if (str.charCodeAt(i) === 0)
                        throw RangeError("Illegal str: Contains NULL-characters");
                }
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            // UTF8 strings do not contain zero bytes in between except for the zero character, so:
            k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
            offset += k+1;
            var capacity12 = this.buffer.byteLength;
            if (offset > capacity12)
                this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
            offset -= k+1;
            utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
                this.view[offset++] = b;
            }.bind(this));
            this.view[offset++] = 0;
            if (relative) {
                this.offset = offset;
                return this;
            }
            return k;
        };

        /**
         * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
         *  itself.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
         *  read and the actual number of bytes read.
         * @expose
         */
        ByteBufferPrototype.readCString = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            var start = offset;
            // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
            var sd, b = -1;
            utfx.decodeUTF8toUTF16(function() {
                if (b === 0) return null;
                if (offset >= this.limit)
                    throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
                b = this.view[offset++];
                return b === 0 ? null : b;
            }.bind(this), sd = stringDestination(), true);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        };

        // types/strings/istring

        /**
         * Writes a length as uint32 prefixed UTF8 encoded string.
         * @param {string} str String to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
         * @expose
         * @see ByteBuffer#writeVarint32
         */
        ByteBufferPrototype.writeIString = function(str, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof str !== 'string')
                    throw TypeError("Illegal str: Not a string");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            var start = offset,
                k;
            k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
            offset += 4+k;
            var capacity13 = this.buffer.byteLength;
            if (offset > capacity13)
                this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
            offset -= 4+k;
            if (this.littleEndian) {
                this.view[offset+3] = (k >>> 24) & 0xFF;
                this.view[offset+2] = (k >>> 16) & 0xFF;
                this.view[offset+1] = (k >>>  8) & 0xFF;
                this.view[offset  ] =  k         & 0xFF;
            } else {
                this.view[offset  ] = (k >>> 24) & 0xFF;
                this.view[offset+1] = (k >>> 16) & 0xFF;
                this.view[offset+2] = (k >>>  8) & 0xFF;
                this.view[offset+3] =  k         & 0xFF;
            }
            offset += 4;
            utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
                this.view[offset++] = b;
            }.bind(this));
            if (offset !== start + 4 + k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
            if (relative) {
                this.offset = offset;
                return this;
            }
            return offset - start;
        };

        /**
         * Reads a length as uint32 prefixed UTF8 encoded string.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
         *  read and the actual number of bytes read.
         * @expose
         * @see ByteBuffer#readVarint32
         */
        ByteBufferPrototype.readIString = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 4 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
            }
            var start = offset;
            var len = this.readUint32(offset);
            var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
            offset += str['length'];
            if (relative) {
                this.offset = offset;
                return str['string'];
            } else {
                return {
                    'string': str['string'],
                    'length': offset - start
                };
            }
        };

        // types/strings/utf8string

        /**
         * Metrics representing number of UTF8 characters. Evaluates to `c`.
         * @type {string}
         * @const
         * @expose
         */
        ByteBuffer.METRICS_CHARS = 'c';

        /**
         * Metrics representing number of bytes. Evaluates to `b`.
         * @type {string}
         * @const
         * @expose
         */
        ByteBuffer.METRICS_BYTES = 'b';

        /**
         * Writes an UTF8 encoded string.
         * @param {string} str String to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeUTF8String = function(str, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            var k;
            var start = offset;
            k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
            offset += k;
            var capacity14 = this.buffer.byteLength;
            if (offset > capacity14)
                this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
            offset -= k;
            utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
                this.view[offset++] = b;
            }.bind(this));
            if (relative) {
                this.offset = offset;
                return this;
            }
            return offset - start;
        };

        /**
         * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
         * @function
         * @param {string} str String to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
         * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

        /**
         * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
         *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
         * @param {string} str String to calculate
         * @returns {number} Number of UTF8 characters
         * @expose
         */
        ByteBuffer.calculateUTF8Chars = function(str) {
            return utfx.calculateUTF16asUTF8(stringSource(str))[0];
        };

        /**
         * Calculates the number of UTF8 bytes of a string.
         * @param {string} str String to calculate
         * @returns {number} Number of UTF8 bytes
         * @expose
         */
        ByteBuffer.calculateUTF8Bytes = function(str) {
            return utfx.calculateUTF16asUTF8(stringSource(str))[1];
        };

        /**
         * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
         * @function
         * @param {string} str String to calculate
         * @returns {number} Number of UTF8 bytes
         * @expose
         */
        ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

        /**
         * Reads an UTF8 encoded string.
         * @param {number} length Number of characters or bytes to read.
         * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
         *  {@link ByteBuffer.METRICS_CHARS}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
         *  read and the actual number of bytes read.
         * @expose
         */
        ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
            if (typeof metrics === 'number') {
                offset = metrics;
                metrics = undefined;
            }
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
            if (!this.noAssert) {
                if (typeof length !== 'number' || length % 1 !== 0)
                    throw TypeError("Illegal length: "+length+" (not an integer)");
                length |= 0;
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            var i = 0,
                start = offset,
                sd;
            if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
                sd = stringDestination();
                utfx.decodeUTF8(function() {
                    return i < length && offset < this.limit ? this.view[offset++] : null;
                }.bind(this), function(cp) {
                    ++i; utfx.UTF8toUTF16(cp, sd);
                });
                if (i !== length)
                    throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
                if (relative) {
                    this.offset = offset;
                    return sd();
                } else {
                    return {
                        "string": sd(),
                        "length": offset - start
                    };
                }
            } else if (metrics === ByteBuffer.METRICS_BYTES) {
                if (!this.noAssert) {
                    if (typeof offset !== 'number' || offset % 1 !== 0)
                        throw TypeError("Illegal offset: "+offset+" (not an integer)");
                    offset >>>= 0;
                    if (offset < 0 || offset + length > this.buffer.byteLength)
                        throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
                }
                var k = offset + length;
                utfx.decodeUTF8toUTF16(function() {
                    return offset < k ? this.view[offset++] : null;
                }.bind(this), sd = stringDestination(), this.noAssert);
                if (offset !== k)
                    throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
                if (relative) {
                    this.offset = offset;
                    return sd();
                } else {
                    return {
                        'string': sd(),
                        'length': offset - start
                    };
                }
            } else
                throw TypeError("Unsupported metrics: "+metrics);
        };

        /**
         * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
         * @function
         * @param {number} length Number of characters or bytes to read
         * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
         *  {@link ByteBuffer.METRICS_CHARS}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
         *  read and the actual number of bytes read.
         * @expose
         */
        ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

        // types/strings/vstring

        /**
         * Writes a length as varint32 prefixed UTF8 encoded string.
         * @param {string} str String to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
         * @expose
         * @see ByteBuffer#writeVarint32
         */
        ByteBufferPrototype.writeVString = function(str, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof str !== 'string')
                    throw TypeError("Illegal str: Not a string");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            var start = offset,
                k, l;
            k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
            l = ByteBuffer.calculateVarint32(k);
            offset += l+k;
            var capacity15 = this.buffer.byteLength;
            if (offset > capacity15)
                this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
            offset -= l+k;
            offset += this.writeVarint32(k, offset);
            utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
                this.view[offset++] = b;
            }.bind(this));
            if (offset !== start+k+l)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
            if (relative) {
                this.offset = offset;
                return this;
            }
            return offset - start;
        };

        /**
         * Reads a length as varint32 prefixed UTF8 encoded string.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
         *  read and the actual number of bytes read.
         * @expose
         * @see ByteBuffer#readVarint32
         */
        ByteBufferPrototype.readVString = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            var start = offset;
            var len = this.readVarint32(offset);
            var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
            offset += str['length'];
            if (relative) {
                this.offset = offset;
                return str['string'];
            } else {
                return {
                    'string': str['string'],
                    'length': offset - start
                };
            }
        };


        /**
         * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
         *  data's length.
         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
         *  will be modified according to the performed read operation.
         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
         * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
         * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
         */
        ByteBufferPrototype.append = function(source, encoding, offset) {
            if (typeof encoding === 'number' || typeof encoding !== 'string') {
                offset = encoding;
                encoding = undefined;
            }
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (!(source instanceof ByteBuffer))
                source = ByteBuffer.wrap(source, encoding);
            var length = source.limit - source.offset;
            if (length <= 0) return this; // Nothing to append
            offset += length;
            var capacity16 = this.buffer.byteLength;
            if (offset > capacity16)
                this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
            offset -= length;
            this.view.set(source.view.subarray(source.offset, source.limit), offset);
            source.offset += length;
            if (relative) this.offset += length;
            return this;
        };

        /**
         * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
            specified offset up to the length of this ByteBuffer's data.
         * @param {!ByteBuffer} target Target ByteBuffer
         * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         * @see ByteBuffer#append
         */
        ByteBufferPrototype.appendTo = function(target, offset) {
            target.append(this, offset);
            return this;
        };

        /**
         * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
         * @function
         * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
         *  will be modified according to the performed read operation.
         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;
        /**
         * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
         *  disable them if your code already makes sure that everything is valid.
         * @param {boolean} assert `true` to enable assertions, otherwise `false`
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.assert = function(assert) {
            this.noAssert = !assert;
            return this;
        };

        /**
         * Gets the capacity of this ByteBuffer's backing buffer.
         * @returns {number} Capacity of the backing buffer
         * @expose
         */
        ByteBufferPrototype.capacity = function() {
            return this.buffer.byteLength;
        };
        /**
         * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
         *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.clear = function() {
            this.offset = 0;
            this.limit = this.buffer.byteLength;
            this.markedOffset = -1;
            return this;
        };

        /**
         * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
         *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
         * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
         * @returns {!ByteBuffer} Cloned instance
         * @expose
         */
        ByteBufferPrototype.clone = function(copy) {
            var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
            if (copy) {
                bb.buffer = new ArrayBuffer(this.buffer.byteLength);
                bb.view = new Uint8Array(bb.buffer);
            } else {
                bb.buffer = this.buffer;
                bb.view = this.view;
            }
            bb.offset = this.offset;
            bb.markedOffset = this.markedOffset;
            bb.limit = this.limit;
            return bb;
        };

        /**
         * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
         *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
         *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
         * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.compact = function(begin, end) {
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            if (begin === 0 && end === this.buffer.byteLength)
                return this; // Already compacted
            var len = end - begin;
            if (len === 0) {
                this.buffer = EMPTY_BUFFER;
                this.view = null;
                if (this.markedOffset >= 0) this.markedOffset -= begin;
                this.offset = 0;
                this.limit = 0;
                return this;
            }
            var buffer = new ArrayBuffer(len);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(begin, end));
            this.buffer = buffer;
            this.view = view;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = len;
            return this;
        };

        /**
         * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
         *  {@link ByteBuffer#limit}.
         * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
         * @returns {!ByteBuffer} Copy
         * @expose
         */
        ByteBufferPrototype.copy = function(begin, end) {
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            if (begin === end)
                return new ByteBuffer(0, this.littleEndian, this.noAssert);
            var capacity = end - begin,
                bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
            bb.offset = 0;
            bb.limit = capacity;
            if (bb.markedOffset >= 0) bb.markedOffset -= begin;
            this.copyTo(bb, 0, begin, end);
            return bb;
        };

        /**
         * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
         *  {@link ByteBuffer#limit}.
         * @param {!ByteBuffer} target Target ByteBuffer
         * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
         *  by the number of bytes copied if omitted.
         * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
         *  number of bytes copied if omitted.
         * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
            var relative,
                targetRelative;
            if (!this.noAssert) {
                if (!ByteBuffer.isByteBuffer(target))
                    throw TypeError("Illegal target: Not a ByteBuffer");
            }
            targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
            sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
            sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

            if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
                throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
            if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
                throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

            var len = sourceLimit - sourceOffset;
            if (len === 0)
                return target; // Nothing to copy

            target.ensureCapacity(targetOffset + len);

            target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

            if (relative) this.offset += len;
            if (targetRelative) target.offset += len;

            return this;
        };

        /**
         * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
         *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
         *  the required capacity will be used instead.
         * @param {number} capacity Required capacity
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.ensureCapacity = function(capacity) {
            var current = this.buffer.byteLength;
            if (current < capacity)
                return this.resize((current *= 2) > capacity ? current : capacity);
            return this;
        };

        /**
         * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
         * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
         * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted. defaults to {@link ByteBuffer#offset}.
         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
         * @returns {!ByteBuffer} this
         * @expose
         * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
         */
        ByteBufferPrototype.fill = function(value, begin, end) {
            var relative = typeof begin === 'undefined';
            if (relative) begin = this.offset;
            if (typeof value === 'string' && value.length > 0)
                value = value.charCodeAt(0);
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof value !== 'number' || value % 1 !== 0)
                    throw TypeError("Illegal value: "+value+" (not an integer)");
                value |= 0;
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            if (begin >= end)
                return this; // Nothing to fill
            while (begin < end) this.view[begin++] = value;
            if (relative) this.offset = begin;
            return this;
        };

        /**
         * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
         *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.flip = function() {
            this.limit = this.offset;
            this.offset = 0;
            return this;
        };
        /**
         * Marks an offset on this ByteBuffer to be used later.
         * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
         * @returns {!ByteBuffer} this
         * @throws {TypeError} If `offset` is not a valid number
         * @throws {RangeError} If `offset` is out of bounds
         * @see ByteBuffer#reset
         * @expose
         */
        ByteBufferPrototype.mark = function(offset) {
            offset = typeof offset === 'undefined' ? this.offset : offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            this.markedOffset = offset;
            return this;
        };
        /**
         * Sets the byte order.
         * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.order = function(littleEndian) {
            if (!this.noAssert) {
                if (typeof littleEndian !== 'boolean')
                    throw TypeError("Illegal littleEndian: Not a boolean");
            }
            this.littleEndian = !!littleEndian;
            return this;
        };

        /**
         * Switches (to) little endian byte order.
         * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.LE = function(littleEndian) {
            this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
            return this;
        };

        /**
         * Switches (to) big endian byte order.
         * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.BE = function(bigEndian) {
            this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
            return this;
        };
        /**
         * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
         *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
         *  will be resized and its contents moved accordingly.
         * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
         *  modified according to the performed read operation.
         * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
         * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
         *  prepended if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
         * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
         */
        ByteBufferPrototype.prepend = function(source, encoding, offset) {
            if (typeof encoding === 'number' || typeof encoding !== 'string') {
                offset = encoding;
                encoding = undefined;
            }
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (!(source instanceof ByteBuffer))
                source = ByteBuffer.wrap(source, encoding);
            var len = source.limit - source.offset;
            if (len <= 0) return this; // Nothing to prepend
            var diff = len - offset;
            if (diff > 0) { // Not enough space before offset, so resize + move
                var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
                var view = new Uint8Array(buffer);
                view.set(this.view.subarray(offset, this.buffer.byteLength), len);
                this.buffer = buffer;
                this.view = view;
                this.offset += diff;
                if (this.markedOffset >= 0) this.markedOffset += diff;
                this.limit += diff;
                offset += diff;
            } else {
                var arrayView = new Uint8Array(this.buffer);
            }
            this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

            source.offset = source.limit;
            if (relative)
                this.offset -= len;
            return this;
        };

        /**
         * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
         *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
         *  will be resized and its contents moved accordingly.
         * @param {!ByteBuffer} target Target ByteBuffer
         * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
         *  prepended if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         * @see ByteBuffer#prepend
         */
        ByteBufferPrototype.prependTo = function(target, offset) {
            target.prepend(this, offset);
            return this;
        };
        /**
         * Prints debug information about this ByteBuffer's contents.
         * @param {function(string)=} out Output function to call, defaults to console.log
         * @expose
         */
        ByteBufferPrototype.printDebug = function(out) {
            if (typeof out !== 'function') out = console.log.bind(console);
            out(
                this.toString()+"\n"+
                "-------------------------------------------------------------------\n"+
                this.toDebug(/* columns */ true)
            );
        };

        /**
         * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
         *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
         * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
         * @expose
         */
        ByteBufferPrototype.remaining = function() {
            return this.limit - this.offset;
        };
        /**
         * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
         *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
         *  marked, sets `offset = 0`.
         * @returns {!ByteBuffer} this
         * @see ByteBuffer#mark
         * @expose
         */
        ByteBufferPrototype.reset = function() {
            if (this.markedOffset >= 0) {
                this.offset = this.markedOffset;
                this.markedOffset = -1;
            } else {
                this.offset = 0;
            }
            return this;
        };
        /**
         * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
         *  large or larger.
         * @param {number} capacity Capacity required
         * @returns {!ByteBuffer} this
         * @throws {TypeError} If `capacity` is not a number
         * @throws {RangeError} If `capacity < 0`
         * @expose
         */
        ByteBufferPrototype.resize = function(capacity) {
            if (!this.noAssert) {
                if (typeof capacity !== 'number' || capacity % 1 !== 0)
                    throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
                capacity |= 0;
                if (capacity < 0)
                    throw RangeError("Illegal capacity: 0 <= "+capacity);
            }
            if (this.buffer.byteLength < capacity) {
                var buffer = new ArrayBuffer(capacity);
                var view = new Uint8Array(buffer);
                view.set(this.view);
                this.buffer = buffer;
                this.view = view;
            }
            return this;
        };
        /**
         * Reverses this ByteBuffer's contents.
         * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.reverse = function(begin, end) {
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            if (begin === end)
                return this; // Nothing to reverse
            Array.prototype.reverse.call(this.view.subarray(begin, end));
            return this;
        };
        /**
         * Skips the next `length` bytes. This will just advance
         * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.skip = function(length) {
            if (!this.noAssert) {
                if (typeof length !== 'number' || length % 1 !== 0)
                    throw TypeError("Illegal length: "+length+" (not an integer)");
                length |= 0;
            }
            var offset = this.offset + length;
            if (!this.noAssert) {
                if (offset < 0 || offset > this.buffer.byteLength)
                    throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
            }
            this.offset = offset;
            return this;
        };

        /**
         * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
         * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
         * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
         * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
         * @expose
         */
        ByteBufferPrototype.slice = function(begin, end) {
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            var bb = this.clone();
            bb.offset = begin;
            bb.limit = end;
            return bb;
        };
        /**
         * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
         * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
         *  possible. Defaults to `false`
         * @returns {!ArrayBuffer} Contents as an ArrayBuffer
         * @expose
         */
        ByteBufferPrototype.toBuffer = function(forceCopy) {
            var offset = this.offset,
                limit = this.limit;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: Not an integer");
                offset >>>= 0;
                if (typeof limit !== 'number' || limit % 1 !== 0)
                    throw TypeError("Illegal limit: Not an integer");
                limit >>>= 0;
                if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
            }
            // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
            // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
            if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
                return this.buffer;
            if (offset === limit)
                return EMPTY_BUFFER;
            var buffer = new ArrayBuffer(limit - offset);
            new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
            return buffer;
        };

        /**
         * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
         *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
         * @function
         * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
         *  Defaults to `false`
         * @returns {!ArrayBuffer} Contents as an ArrayBuffer
         * @expose
         */
        ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

        /**
         * Converts the ByteBuffer's contents to a string.
         * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
         *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
         *  highlighted offsets.
         * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
         * @returns {string} String representation
         * @throws {Error} If `encoding` is invalid
         * @expose
         */
        ByteBufferPrototype.toString = function(encoding, begin, end) {
            if (typeof encoding === 'undefined')
                return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
            if (typeof encoding === 'number')
                encoding = "utf8",
                begin = encoding,
                end = begin;
            switch (encoding) {
                case "utf8":
                    return this.toUTF8(begin, end);
                case "base64":
                    return this.toBase64(begin, end);
                case "hex":
                    return this.toHex(begin, end);
                case "binary":
                    return this.toBinary(begin, end);
                case "debug":
                    return this.toDebug();
                case "columns":
                    return this.toColumns();
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        };

        // lxiv-embeddable

        /**
         * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
         * Released under the Apache License, Version 2.0
         * see: https://github.com/dcodeIO/lxiv for details
         */
        var lxiv = function() {

            /**
             * lxiv namespace.
             * @type {!Object.<string,*>}
             * @exports lxiv
             */
            var lxiv = {};

            /**
             * Character codes for output.
             * @type {!Array.<number>}
             * @inner
             */
            var aout = [
                65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
                81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
                103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
            ];

            /**
             * Character codes for input.
             * @type {!Array.<number>}
             * @inner
             */
            var ain = [];
            for (var i=0, k=aout.length; i<k; ++i)
                ain[aout[i]] = i;

            /**
             * Encodes bytes to base64 char codes.
             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
             *  there are no more bytes left.
             * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
             *  code.
             */
            lxiv.encode = function(src, dst) {
                var b, t;
                while ((b = src()) !== null) {
                    dst(aout[(b>>2)&0x3f]);
                    t = (b&0x3)<<4;
                    if ((b = src()) !== null) {
                        t |= (b>>4)&0xf;
                        dst(aout[(t|((b>>4)&0xf))&0x3f]);
                        t = (b&0xf)<<2;
                        if ((b = src()) !== null)
                            dst(aout[(t|((b>>6)&0x3))&0x3f]),
                            dst(aout[b&0x3f]);
                        else
                            dst(aout[t&0x3f]),
                            dst(61);
                    } else
                        dst(aout[t&0x3f]),
                        dst(61),
                        dst(61);
                }
            };

            /**
             * Decodes base64 char codes to bytes.
             * @param {!function():number|null} src Characters source as a function returning the next char code respectively
             *  `null` if there are no more characters left.
             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
             * @throws {Error} If a character code is invalid
             */
            lxiv.decode = function(src, dst) {
                var c, t1, t2;
                function fail(c) {
                    throw Error("Illegal character code: "+c);
                }
                while ((c = src()) !== null) {
                    t1 = ain[c];
                    if (typeof t1 === 'undefined') fail(c);
                    if ((c = src()) !== null) {
                        t2 = ain[c];
                        if (typeof t2 === 'undefined') fail(c);
                        dst((t1<<2)>>>0|(t2&0x30)>>4);
                        if ((c = src()) !== null) {
                            t1 = ain[c];
                            if (typeof t1 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                            if ((c = src()) !== null) {
                                t2 = ain[c];
                                if (typeof t2 === 'undefined')
                                    if (c === 61) break; else fail(c);
                                dst(((t1&0x3)<<6)>>>0|t2);
                            }
                        }
                    }
                }
            };

            /**
             * Tests if a string is valid base64.
             * @param {string} str String to test
             * @returns {boolean} `true` if valid, otherwise `false`
             */
            lxiv.test = function(str) {
                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
            };

            return lxiv;
        }();

        // encodings/base64

        /**
         * Encodes this ByteBuffer's contents to a base64 encoded string.
         * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
         * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
         * @returns {string} Base64 encoded string
         * @throws {RangeError} If `begin` or `end` is out of bounds
         * @expose
         */
        ByteBufferPrototype.toBase64 = function(begin, end) {
            if (typeof begin === 'undefined')
                begin = this.offset;
            if (typeof end === 'undefined')
                end = this.limit;
            begin = begin | 0; end = end | 0;
            if (begin < 0 || end > this.capacity || begin > end)
                throw RangeError("begin, end");
            var sd; lxiv.encode(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
            return sd();
        };

        /**
         * Decodes a base64 encoded string to a ByteBuffer.
         * @param {string} str String to decode
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @returns {!ByteBuffer} ByteBuffer
         * @expose
         */
        ByteBuffer.fromBase64 = function(str, littleEndian) {
            if (typeof str !== 'string')
                throw TypeError("str");
            var bb = new ByteBuffer(str.length/4*3, littleEndian),
                i = 0;
            lxiv.decode(stringSource(str), function(b) {
                bb.view[i++] = b;
            });
            bb.limit = i;
            return bb;
        };

        /**
         * Encodes a binary string to base64 like `window.btoa` does.
         * @param {string} str Binary string
         * @returns {string} Base64 encoded string
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
         * @expose
         */
        ByteBuffer.btoa = function(str) {
            return ByteBuffer.fromBinary(str).toBase64();
        };

        /**
         * Decodes a base64 encoded string to binary like `window.atob` does.
         * @param {string} b64 Base64 encoded string
         * @returns {string} Binary string
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
         * @expose
         */
        ByteBuffer.atob = function(b64) {
            return ByteBuffer.fromBase64(b64).toBinary();
        };

        // encodings/binary

        /**
         * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
         * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
         * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
         * @returns {string} Binary encoded string
         * @throws {RangeError} If `offset > limit`
         * @expose
         */
        ByteBufferPrototype.toBinary = function(begin, end) {
            if (typeof begin === 'undefined')
                begin = this.offset;
            if (typeof end === 'undefined')
                end = this.limit;
            begin |= 0; end |= 0;
            if (begin < 0 || end > this.capacity() || begin > end)
                throw RangeError("begin, end");
            if (begin === end)
                return "";
            var chars = [],
                parts = [];
            while (begin < end) {
                chars.push(this.view[begin++]);
                if (chars.length >= 1024)
                    parts.push(String.fromCharCode.apply(String, chars)),
                    chars = [];
            }
            return parts.join('') + String.fromCharCode.apply(String, chars);
        };

        /**
         * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
         * @param {string} str String to decode
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @returns {!ByteBuffer} ByteBuffer
         * @expose
         */
        ByteBuffer.fromBinary = function(str, littleEndian) {
            if (typeof str !== 'string')
                throw TypeError("str");
            var i = 0,
                k = str.length,
                charCode,
                bb = new ByteBuffer(k, littleEndian);
            while (i<k) {
                charCode = str.charCodeAt(i);
                if (charCode > 0xff)
                    throw RangeError("illegal char code: "+charCode);
                bb.view[i++] = charCode;
            }
            bb.limit = k;
            return bb;
        };

        // encodings/debug

        /**
         * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
         * * `<` : offset,
         * * `'` : markedOffset,
         * * `>` : limit,
         * * `|` : offset and limit,
         * * `[` : offset and markedOffset,
         * * `]` : markedOffset and limit,
         * * `!` : offset, markedOffset and limit
         * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
         * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
         * @expose
         * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
         * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
         * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
         * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
         */
        ByteBufferPrototype.toDebug = function(columns) {
            var i = -1,
                k = this.buffer.byteLength,
                b,
                hex = "",
                asc = "",
                out = "";
            while (i<k) {
                if (i !== -1) {
                    b = this.view[i];
                    if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                    else hex += b.toString(16).toUpperCase();
                    if (columns)
                        asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
                }
                ++i;
                if (columns) {
                    if (i > 0 && i % 16 === 0 && i !== k) {
                        while (hex.length < 3*16+3) hex += " ";
                        out += hex+asc+"\n";
                        hex = asc = "";
                    }
                }
                if (i === this.offset && i === this.limit)
                    hex += i === this.markedOffset ? "!" : "|";
                else if (i === this.offset)
                    hex += i === this.markedOffset ? "[" : "<";
                else if (i === this.limit)
                    hex += i === this.markedOffset ? "]" : ">";
                else
                    hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
            }
            if (columns && hex !== " ") {
                while (hex.length < 3*16+3)
                    hex += " ";
                out += hex + asc + "\n";
            }
            return columns ? out : hex;
        };

        /**
         * Decodes a hex encoded string with marked offsets to a ByteBuffer.
         * @param {string} str Debug string to decode (not be generated with `columns = true`)
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer} ByteBuffer
         * @expose
         * @see ByteBuffer#toDebug
         */
        ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
            var k = str.length,
                bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
            var i = 0, j = 0, ch, b,
                rs = false, // Require symbol next
                ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
                fail = false;
            while (i<k) {
                switch (ch = str.charAt(i++)) {
                    case '!':
                        if (!noAssert) {
                            if (ho || hm || hl) {
                                fail = true;
                                break;
                            }
                            ho = hm = hl = true;
                        }
                        bb.offset = bb.markedOffset = bb.limit = j;
                        rs = false;
                        break;
                    case '|':
                        if (!noAssert) {
                            if (ho || hl) {
                                fail = true;
                                break;
                            }
                            ho = hl = true;
                        }
                        bb.offset = bb.limit = j;
                        rs = false;
                        break;
                    case '[':
                        if (!noAssert) {
                            if (ho || hm) {
                                fail = true;
                                break;
                            }
                            ho = hm = true;
                        }
                        bb.offset = bb.markedOffset = j;
                        rs = false;
                        break;
                    case '<':
                        if (!noAssert) {
                            if (ho) {
                                fail = true;
                                break;
                            }
                            ho = true;
                        }
                        bb.offset = j;
                        rs = false;
                        break;
                    case ']':
                        if (!noAssert) {
                            if (hl || hm) {
                                fail = true;
                                break;
                            }
                            hl = hm = true;
                        }
                        bb.limit = bb.markedOffset = j;
                        rs = false;
                        break;
                    case '>':
                        if (!noAssert) {
                            if (hl) {
                                fail = true;
                                break;
                            }
                            hl = true;
                        }
                        bb.limit = j;
                        rs = false;
                        break;
                    case "'":
                        if (!noAssert) {
                            if (hm) {
                                fail = true;
                                break;
                            }
                            hm = true;
                        }
                        bb.markedOffset = j;
                        rs = false;
                        break;
                    case ' ':
                        rs = false;
                        break;
                    default:
                        if (!noAssert) {
                            if (rs) {
                                fail = true;
                                break;
                            }
                        }
                        b = parseInt(ch+str.charAt(i++), 16);
                        if (!noAssert) {
                            if (isNaN(b) || b < 0 || b > 255)
                                throw TypeError("Illegal str: Not a debug encoded string");
                        }
                        bb.view[j++] = b;
                        rs = true;
                }
                if (fail)
                    throw TypeError("Illegal str: Invalid symbol at "+i);
            }
            if (!noAssert) {
                if (!ho || !hl)
                    throw TypeError("Illegal str: Missing offset or limit");
                if (j<bb.buffer.byteLength)
                    throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
            }
            return bb;
        };

        // encodings/hex

        /**
         * Encodes this ByteBuffer's contents to a hex encoded string.
         * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
         * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
         * @returns {string} Hex encoded string
         * @expose
         */
        ByteBufferPrototype.toHex = function(begin, end) {
            begin = typeof begin === 'undefined' ? this.offset : begin;
            end = typeof end === 'undefined' ? this.limit : end;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            var out = new Array(end - begin),
                b;
            while (begin < end) {
                b = this.view[begin++];
                if (b < 0x10)
                    out.push("0", b.toString(16));
                else out.push(b.toString(16));
            }
            return out.join('');
        };

        /**
         * Decodes a hex encoded string to a ByteBuffer.
         * @param {string} str String to decode
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer} ByteBuffer
         * @expose
         */
        ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
            if (!noAssert) {
                if (typeof str !== 'string')
                    throw TypeError("Illegal str: Not a string");
                if (str.length % 2 !== 0)
                    throw TypeError("Illegal str: Length not a multiple of 2");
            }
            var k = str.length,
                bb = new ByteBuffer((k / 2) | 0, littleEndian),
                b;
            for (var i=0, j=0; i<k; i+=2) {
                b = parseInt(str.substring(i, i+2), 16);
                if (!noAssert)
                    if (!isFinite(b) || b < 0 || b > 255)
                        throw TypeError("Illegal str: Contains non-hex characters");
                bb.view[j++] = b;
            }
            bb.limit = j;
            return bb;
        };

        // utfx-embeddable

        /**
         * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
         * Released under the Apache License, Version 2.0
         * see: https://github.com/dcodeIO/utfx for details
         */
        var utfx = function() {

            /**
             * utfx namespace.
             * @inner
             * @type {!Object.<string,*>}
             */
            var utfx = {};

            /**
             * Maximum valid code point.
             * @type {number}
             * @const
             */
            utfx.MAX_CODEPOINT = 0x10FFFF;

            /**
             * Encodes UTF8 code points to UTF8 bytes.
             * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
             *  respectively `null` if there are no more code points left or a single numeric code point.
             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
             */
            utfx.encodeUTF8 = function(src, dst) {
                var cp = null;
                if (typeof src === 'number')
                    cp = src,
                    src = function() { return null; };
                while (cp !== null || (cp = src()) !== null) {
                    if (cp < 0x80)
                        dst(cp&0x7F);
                    else if (cp < 0x800)
                        dst(((cp>>6)&0x1F)|0xC0),
                        dst((cp&0x3F)|0x80);
                    else if (cp < 0x10000)
                        dst(((cp>>12)&0x0F)|0xE0),
                        dst(((cp>>6)&0x3F)|0x80),
                        dst((cp&0x3F)|0x80);
                    else
                        dst(((cp>>18)&0x07)|0xF0),
                        dst(((cp>>12)&0x3F)|0x80),
                        dst(((cp>>6)&0x3F)|0x80),
                        dst((cp&0x3F)|0x80);
                    cp = null;
                }
            };

            /**
             * Decodes UTF8 bytes to UTF8 code points.
             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
             *  are no more bytes left.
             * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
             * @throws {RangeError} If a starting byte is invalid in UTF8
             * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
             *  remaining bytes.
             */
            utfx.decodeUTF8 = function(src, dst) {
                var a, b, c, d, fail = function(b) {
                    b = b.slice(0, b.indexOf(null));
                    var err = Error(b.toString());
                    err.name = "TruncatedError";
                    err['bytes'] = b;
                    throw err;
                };
                while ((a = src()) !== null) {
                    if ((a&0x80) === 0)
                        dst(a);
                    else if ((a&0xE0) === 0xC0)
                        ((b = src()) === null) && fail([a, b]),
                        dst(((a&0x1F)<<6) | (b&0x3F));
                    else if ((a&0xF0) === 0xE0)
                        ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                        dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                    else if ((a&0xF8) === 0xF0)
                        ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                        dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                    else throw RangeError("Illegal starting byte: "+a);
                }
            };

            /**
             * Converts UTF16 characters to UTF8 code points.
             * @param {!function():number|null} src Characters source as a function returning the next char code respectively
             *  `null` if there are no more characters left.
             * @param {!function(number)} dst Code points destination as a function successively called with each converted code
             *  point.
             */
            utfx.UTF16toUTF8 = function(src, dst) {
                var c1, c2 = null;
                while (true) {
                    if ((c1 = c2 !== null ? c2 : src()) === null)
                        break;
                    if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                        if ((c2 = src()) !== null) {
                            if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                                dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                                c2 = null; continue;
                            }
                        }
                    }
                    dst(c1);
                }
                if (c2 !== null) dst(c2);
            };

            /**
             * Converts UTF8 code points to UTF16 characters.
             * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
             *  respectively `null` if there are no more code points left or a single numeric code point.
             * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
             * @throws {RangeError} If a code point is out of range
             */
            utfx.UTF8toUTF16 = function(src, dst) {
                var cp = null;
                if (typeof src === 'number')
                    cp = src, src = function() { return null; };
                while (cp !== null || (cp = src()) !== null) {
                    if (cp <= 0xFFFF)
                        dst(cp);
                    else
                        cp -= 0x10000,
                        dst((cp>>10)+0xD800),
                        dst((cp%0x400)+0xDC00);
                    cp = null;
                }
            };

            /**
             * Converts and encodes UTF16 characters to UTF8 bytes.
             * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
             *  if there are no more characters left.
             * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
             */
            utfx.encodeUTF16toUTF8 = function(src, dst) {
                utfx.UTF16toUTF8(src, function(cp) {
                    utfx.encodeUTF8(cp, dst);
                });
            };

            /**
             * Decodes and converts UTF8 bytes to UTF16 characters.
             * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
             *  are no more bytes left.
             * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
             * @throws {RangeError} If a starting byte is invalid in UTF8
             * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
             */
            utfx.decodeUTF8toUTF16 = function(src, dst) {
                utfx.decodeUTF8(src, function(cp) {
                    utfx.UTF8toUTF16(cp, dst);
                });
            };

            /**
             * Calculates the byte length of an UTF8 code point.
             * @param {number} cp UTF8 code point
             * @returns {number} Byte length
             */
            utfx.calculateCodePoint = function(cp) {
                return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            };

            /**
             * Calculates the number of UTF8 bytes required to store UTF8 code points.
             * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
             *  `null` if there are no more code points left.
             * @returns {number} The number of UTF8 bytes required
             */
            utfx.calculateUTF8 = function(src) {
                var cp, l=0;
                while ((cp = src()) !== null)
                    l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
                return l;
            };

            /**
             * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
             * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
             *  `null` if there are no more characters left.
             * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
             */
            utfx.calculateUTF16asUTF8 = function(src) {
                var n=0, l=0;
                utfx.UTF16toUTF8(src, function(cp) {
                    ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
                });
                return [n,l];
            };

            return utfx;
        }();

        // encodings/utf8

        /**
         * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
         *  string.
         * @returns {string} Hex encoded string
         * @throws {RangeError} If `offset > limit`
         * @expose
         */
        ByteBufferPrototype.toUTF8 = function(begin, end) {
            if (typeof begin === 'undefined') begin = this.offset;
            if (typeof end === 'undefined') end = this.limit;
            if (!this.noAssert) {
                if (typeof begin !== 'number' || begin % 1 !== 0)
                    throw TypeError("Illegal begin: Not an integer");
                begin >>>= 0;
                if (typeof end !== 'number' || end % 1 !== 0)
                    throw TypeError("Illegal end: Not an integer");
                end >>>= 0;
                if (begin < 0 || begin > end || end > this.buffer.byteLength)
                    throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
            }
            var sd; try {
                utfx.decodeUTF8toUTF16(function() {
                    return begin < end ? this.view[begin++] : null;
                }.bind(this), sd = stringDestination());
            } catch (e) {
                if (begin !== end)
                    throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
            }
            return sd();
        };

        /**
         * Decodes an UTF8 encoded string to a ByteBuffer.
         * @param {string} str String to decode
         * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
         *  {@link ByteBuffer.DEFAULT_ENDIAN}.
         * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
         *  {@link ByteBuffer.DEFAULT_NOASSERT}.
         * @returns {!ByteBuffer} ByteBuffer
         * @expose
         */
        ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
            if (!noAssert)
                if (typeof str !== 'string')
                    throw TypeError("Illegal str: Not a string");
            var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
                i = 0;
            utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
                bb.view[i++] = b;
            });
            bb.limit = i;
            return bb;
        };

        return ByteBuffer;
    });
    });

    // shim for using process in browser
    // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    var cachedSetTimeout = defaultSetTimout;
    var cachedClearTimeout = defaultClearTimeout;
    if (typeof global$1.setTimeout === 'function') {
        cachedSetTimeout = setTimeout;
    }
    if (typeof global$1.clearTimeout === 'function') {
        cachedClearTimeout = clearTimeout;
    }

    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    function nextTick(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    }
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    var title = 'browser';
    var platform = 'browser';
    var browser = true;
    var env = {};
    var argv = [];
    var version = ''; // empty string to avoid regexp issues
    var versions = {};
    var release = {};
    var config = {};

    function noop() {}

    var on = noop;
    var addListener = noop;
    var once = noop;
    var off = noop;
    var removeListener = noop;
    var removeAllListeners = noop;
    var emit = noop;

    function binding(name) {
        throw new Error('process.binding is not supported');
    }

    function cwd () { return '/' }
    function chdir (dir) {
        throw new Error('process.chdir is not supported');
    }function umask() { return 0; }

    // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
    var performance = global$1.performance || {};
    var performanceNow =
      performance.now        ||
      performance.mozNow     ||
      performance.msNow      ||
      performance.oNow       ||
      performance.webkitNow  ||
      function(){ return (new Date()).getTime() };

    // generate timestamp or delta
    // see http://nodejs.org/api/process.html#process_process_hrtime
    function hrtime(previousTimestamp){
      var clocktime = performanceNow.call(performance)*1e-3;
      var seconds = Math.floor(clocktime);
      var nanoseconds = Math.floor((clocktime%1)*1e9);
      if (previousTimestamp) {
        seconds = seconds - previousTimestamp[0];
        nanoseconds = nanoseconds - previousTimestamp[1];
        if (nanoseconds<0) {
          seconds--;
          nanoseconds += 1e9;
        }
      }
      return [seconds,nanoseconds]
    }

    var startTime = new Date();
    function uptime() {
      var currentTime = new Date();
      var dif = currentTime - startTime;
      return dif / 1000;
    }

    var process = {
      nextTick: nextTick,
      title: title,
      browser: browser,
      env: env,
      argv: argv,
      version: version,
      versions: versions,
      on: on,
      addListener: addListener,
      once: once,
      off: off,
      removeListener: removeListener,
      removeAllListeners: removeAllListeners,
      emit: emit,
      binding: binding,
      cwd: cwd,
      chdir: chdir,
      umask: umask,
      hrtime: hrtime,
      platform: platform,
      release: release,
      config: config,
      uptime: uptime
    };

    var eventemitter2 = createCommonjsModule(function (module, exports) {
    !function(undefined) {

      var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;

      function init() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }

      function configure(conf) {
        if (conf) {
          this._conf = conf;

          conf.delimiter && (this.delimiter = conf.delimiter);
          this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;

          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);

          if (this.wildcard) {
            this.listenerTree = {};
          }
        } else {
          this._maxListeners = defaultMaxListeners;
        }
      }

      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = '(node) warning: possible EventEmitter memory ' +
            'leak detected. ' + count + ' listeners added. ' +
            'Use emitter.setMaxListeners() to increase limit.';

        if(this.verboseMemoryLeak){
          errorMsg += ' Event name: ' + eventName + '.';
        }

        if(typeof process !== 'undefined' && process.emitWarning){
          var e = new Error(errorMsg);
          e.name = 'MaxListenersExceededWarning';
          e.emitter = this;
          e.count = count;
          process.emitWarning(e);
        } else {
          console.error(errorMsg);

          if (console.trace){
            console.trace();
          }
        }
      }

      function EventEmitter(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

      //
      // Attention, function return type now is array, always !
      // It has zero elements if no any matches found and one or more
      // elements (leafs) if there are matches
      //
      function searchListenerTree(handlers, type, tree, i) {
        if (!tree) {
          return [];
        }
        var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
            typeLength = type.length, currentType = type[i], nextType = type[i+1];
        if (i === typeLength && tree._listeners) {
          //
          // If at the end of the event(s) list and the tree has listeners
          // invoke those listeners.
          //
          if (typeof tree._listeners === 'function') {
            handlers && handlers.push(tree._listeners);
            return [tree];
          } else {
            for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
              handlers && handlers.push(tree._listeners[leaf]);
            }
            return [tree];
          }
        }

        if ((currentType === '*' || currentType === '**') || tree[currentType]) {
          //
          // If the event emitted is '*' at this part
          // or there is a concrete match at this patch
          //
          if (currentType === '*') {
            for (branch in tree) {
              if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
              }
            }
            return listeners;
          } else if(currentType === '**') {
            endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
            if(endReached && tree._listeners) {
              // The next element has a _listeners, add it to the handlers.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
            }

            for (branch in tree) {
              if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
                if(branch === '*' || branch === '**') {
                  if(tree[branch]._listeners && !endReached) {
                    listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
                  }
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                } else if(branch === nextType) {
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
                } else {
                  // No match on this one, shift into the tree but not in the type array.
                  listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
                }
              }
            }
            return listeners;
          }

          listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
        }

        xTree = tree['*'];
        if (xTree) {
          //
          // If the listener tree will allow any match for this part,
          // then recursively explore all branches of the tree
          //
          searchListenerTree(handlers, type, xTree, i+1);
        }

        xxTree = tree['**'];
        if(xxTree) {
          if(i < typeLength) {
            if(xxTree._listeners) {
              // If we have a listener on a '**', it will catch all, so add its handler.
              searchListenerTree(handlers, type, xxTree, typeLength);
            }

            // Build arrays of matching next branches and others.
            for(branch in xxTree) {
              if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
                if(branch === nextType) {
                  // We know the next element will match, so jump twice.
                  searchListenerTree(handlers, type, xxTree[branch], i+2);
                } else if(branch === currentType) {
                  // Current node matches, move into the tree.
                  searchListenerTree(handlers, type, xxTree[branch], i+1);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
                }
              }
            }
          } else if(xxTree._listeners) {
            // We have reached the end and still on a '**'
            searchListenerTree(handlers, type, xxTree, typeLength);
          } else if(xxTree['*'] && xxTree['*']._listeners) {
            searchListenerTree(handlers, type, xxTree['*'], typeLength);
          }
        }

        return listeners;
      }

      function growListenerTree(type, listener) {

        type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

        //
        // Looks for two consecutive '**', if so, don't add the event at all.
        //
        for(var i = 0, len = type.length; i+1 < len; i++) {
          if(type[i] === '**' && type[i+1] === '**') {
            return;
          }
        }

        var tree = this.listenerTree;
        var name = type.shift();

        while (name !== undefined) {

          if (!tree[name]) {
            tree[name] = {};
          }

          tree = tree[name];

          if (type.length === 0) {

            if (!tree._listeners) {
              tree._listeners = listener;
            }
            else {
              if (typeof tree._listeners === 'function') {
                tree._listeners = [tree._listeners];
              }

              tree._listeners.push(listener);

              if (
                !tree._listeners.warned &&
                this._maxListeners > 0 &&
                tree._listeners.length > this._maxListeners
              ) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
          name = type.shift();
        }
        return true;
      }

      // By default EventEmitters will print a warning if more than
      // 10 listeners are added to it. This is a useful default which
      // helps finding memory leaks.
      //
      // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.

      EventEmitter.prototype.delimiter = '.';

      EventEmitter.prototype.setMaxListeners = function(n) {
        if (n !== undefined) {
          this._maxListeners = n;
          if (!this._conf) this._conf = {};
          this._conf.maxListeners = n;
        }
      };

      EventEmitter.prototype.event = '';


      EventEmitter.prototype.once = function(event, fn) {
        return this._once(event, fn, false);
      };

      EventEmitter.prototype.prependOnceListener = function(event, fn) {
        return this._once(event, fn, true);
      };

      EventEmitter.prototype._once = function(event, fn, prepend) {
        this._many(event, 1, fn, prepend);
        return this;
      };

      EventEmitter.prototype.many = function(event, ttl, fn) {
        return this._many(event, ttl, fn, false);
      };

      EventEmitter.prototype.prependMany = function(event, ttl, fn) {
        return this._many(event, ttl, fn, true);
      };

      EventEmitter.prototype._many = function(event, ttl, fn, prepend) {
        var self = this;

        if (typeof fn !== 'function') {
          throw new Error('many only accepts instances of Function');
        }

        function listener() {
          if (--ttl === 0) {
            self.off(event, listener);
          }
          return fn.apply(this, arguments);
        }

        listener._origin = fn;

        this._on(event, listener, prepend);

        return self;
      };

      EventEmitter.prototype.emit = function() {

        this._events || init.call(this);

        var type = arguments[0];

        if (type === 'newListener' && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }

        var al = arguments.length;
        var args,l,i,j;
        var handler;

        if (this._all && this._all.length) {
          handler = this._all.slice();
          if (al > 3) {
            args = new Array(al);
            for (j = 0; j < al; j++) args[j] = arguments[j];
          }

          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
            case 1:
              handler[i].call(this, type);
              break;
            case 2:
              handler[i].call(this, type, arguments[1]);
              break;
            case 3:
              handler[i].call(this, type, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args);
            }
          }
        }

        if (this.wildcard) {
          handler = [];
          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
          if (typeof handler === 'function') {
            this.event = type;
            switch (al) {
            case 1:
              handler.call(this);
              break;
            case 2:
              handler.call(this, arguments[1]);
              break;
            case 3:
              handler.call(this, arguments[1], arguments[2]);
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++) args[j - 1] = arguments[j];
              handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            // need to make copy of handlers because list can change in the middle
            // of emit call
            handler = handler.slice();
          }
        }

        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
            case 1:
              handler[i].call(this);
              break;
            case 2:
              handler[i].call(this, arguments[1]);
              break;
            case 3:
              handler[i].call(this, arguments[1], arguments[2]);
              break;
            default:
              handler[i].apply(this, args);
            }
          }
          return true;
        } else if (!this._all && type === 'error') {
          if (arguments[1] instanceof Error) {
            throw arguments[1]; // Unhandled 'error' event
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }

        return !!this._all;
      };

      EventEmitter.prototype.emitAsync = function() {

        this._events || init.call(this);

        var type = arguments[0];

        if (type === 'newListener' && !this._newListener) {
            if (!this._events.newListener) { return Promise.resolve([false]); }
        }

        var promises= [];

        var al = arguments.length;
        var args,l,i,j;
        var handler;

        if (this._all) {
          if (al > 3) {
            args = new Array(al);
            for (j = 1; j < al; j++) args[j] = arguments[j];
          }
          for (i = 0, l = this._all.length; i < l; i++) {
            this.event = type;
            switch (al) {
            case 1:
              promises.push(this._all[i].call(this, type));
              break;
            case 2:
              promises.push(this._all[i].call(this, type, arguments[1]));
              break;
            case 3:
              promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
              break;
            default:
              promises.push(this._all[i].apply(this, args));
            }
          }
        }

        if (this.wildcard) {
          handler = [];
          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type];
        }

        if (typeof handler === 'function') {
          this.event = type;
          switch (al) {
          case 1:
            promises.push(handler.call(this));
            break;
          case 2:
            promises.push(handler.call(this, arguments[1]));
            break;
          case 3:
            promises.push(handler.call(this, arguments[1], arguments[2]));
            break;
          default:
            args = new Array(al - 1);
            for (j = 1; j < al; j++) args[j - 1] = arguments[j];
            promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++) args[j - 1] = arguments[j];
          }
          for (i = 0, l = handler.length; i < l; i++) {
            this.event = type;
            switch (al) {
            case 1:
              promises.push(handler[i].call(this));
              break;
            case 2:
              promises.push(handler[i].call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler[i].call(this, arguments[1], arguments[2]));
              break;
            default:
              promises.push(handler[i].apply(this, args));
            }
          }
        } else if (!this._all && type === 'error') {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]); // Unhandled 'error' event
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }

        return Promise.all(promises);
      };

      EventEmitter.prototype.on = function(type, listener) {
        return this._on(type, listener, false);
      };

      EventEmitter.prototype.prependListener = function(type, listener) {
        return this._on(type, listener, true);
      };

      EventEmitter.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };

      EventEmitter.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };

      EventEmitter.prototype.addListener = EventEmitter.prototype.on;

      EventEmitter.prototype._onAny = function(fn, prepend){
        if (typeof fn !== 'function') {
          throw new Error('onAny only accepts instances of Function');
        }

        if (!this._all) {
          this._all = [];
        }

        // Add the function to the event listener collection.
        if(prepend){
          this._all.unshift(fn);
        }else{
          this._all.push(fn);
        }

        return this;
      };

      EventEmitter.prototype._on = function(type, listener, prepend) {
        if (typeof type === 'function') {
          this._onAny(type, listener);
          return this;
        }

        if (typeof listener !== 'function') {
          throw new Error('on only accepts instances of Function');
        }
        this._events || init.call(this);

        // To avoid recursion in the case that type == "newListeners"! Before
        // adding it to the listeners, first emit "newListeners".
        if (this._newListener)
           this.emit('newListener', type, listener);

        if (this.wildcard) {
          growListenerTree.call(this, type, listener);
          return this;
        }

        if (!this._events[type]) {
          // Optimize the case of one listener. Don't need the extra array object.
          this._events[type] = listener;
        }
        else {
          if (typeof this._events[type] === 'function') {
            // Change to array.
            this._events[type] = [this._events[type]];
          }

          // If we've already got an array, just add
          if(prepend){
            this._events[type].unshift(listener);
          }else{
            this._events[type].push(listener);
          }

          // Check for listener leak
          if (
            !this._events[type].warned &&
            this._maxListeners > 0 &&
            this._events[type].length > this._maxListeners
          ) {
            this._events[type].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type].length, type);
          }
        }

        return this;
      };

      EventEmitter.prototype.off = function(type, listener) {
        if (typeof listener !== 'function') {
          throw new Error('removeListener only takes instances of Function');
        }

        var handlers,leafs=[];

        if(this.wildcard) {
          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        }
        else {
          // does not use listeners(), so no side effect of creating _events[type]
          if (!this._events[type]) return this;
          handlers = this._events[type];
          leafs.push({_listeners:handlers});
        }

        for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray(handlers)) {

            var position = -1;

            for (var i = 0, length = handlers.length; i < length; i++) {
              if (handlers[i] === listener ||
                (handlers[i].listener && handlers[i].listener === listener) ||
                (handlers[i]._origin && handlers[i]._origin === listener)) {
                position = i;
                break;
              }
            }

            if (position < 0) {
              continue;
            }

            if(this.wildcard) {
              leaf._listeners.splice(position, 1);
            }
            else {
              this._events[type].splice(position, 1);
            }

            if (handlers.length === 0) {
              if(this.wildcard) {
                delete leaf._listeners;
              }
              else {
                delete this._events[type];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);

            return this;
          }
          else if (handlers === listener ||
            (handlers.listener && handlers.listener === listener) ||
            (handlers._origin && handlers._origin === listener)) {
            if(this.wildcard) {
              delete leaf._listeners;
            }
            else {
              delete this._events[type];
            }
            if (this._removeListener)
              this.emit("removeListener", type, listener);
          }
        }

        function recursivelyGarbageCollect(root) {
          if (root === undefined) {
            return;
          }
          var keys = Object.keys(root);
          for (var i in keys) {
            var key = keys[i];
            var obj = root[key];
            if ((obj instanceof Function) || (typeof obj !== "object") || (obj === null))
              continue;
            if (Object.keys(obj).length > 0) {
              recursivelyGarbageCollect(root[key]);
            }
            if (Object.keys(obj).length === 0) {
              delete root[key];
            }
          }
        }
        recursivelyGarbageCollect(this.listenerTree);

        return this;
      };

      EventEmitter.prototype.offAny = function(fn) {
        var i = 0, l = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for(i = 0, l = fns.length; i < l; i++) {
            if(fn === fns[i]) {
              fns.splice(i, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for(i = 0, l = fns.length; i < l; i++)
              this.emit("removeListenerAny", fns[i]);
          }
          this._all = [];
        }
        return this;
      };

      EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

      EventEmitter.prototype.removeAllListeners = function(type) {
        if (type === undefined) {
          !this._events || init.call(this);
          return this;
        }

        if (this.wildcard) {
          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
          var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

          for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            leaf._listeners = null;
          }
        }
        else if (this._events) {
          this._events[type] = null;
        }
        return this;
      };

      EventEmitter.prototype.listeners = function(type) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers;
        }

        this._events || init.call(this);

        if (!this._events[type]) this._events[type] = [];
        if (!isArray(this._events[type])) {
          this._events[type] = [this._events[type]];
        }
        return this._events[type];
      };

      EventEmitter.prototype.eventNames = function(){
        return Object.keys(this._events);
      };

      EventEmitter.prototype.listenerCount = function(type) {
        return this.listeners(type).length;
      };

      EventEmitter.prototype.listenersAny = function() {

        if(this._all) {
          return this._all;
        }
        else {
          return [];
        }

      };

      if (typeof undefined === 'function' && undefined.amd) {
         // AMD. Register as an anonymous module.
        undefined(function() {
          return EventEmitter;
        });
      } else {
        // CommonJS
        module.exports = EventEmitter;
      }
    }();
    });

    // Port of lower_bound from http://en.cppreference.com/w/cpp/algorithm/lower_bound
    // Used to compute insertion index to keep queue sorted after insertion
    function lowerBound(array, value, comp) {
    	let first = 0;
    	let count = array.length;

    	while (count > 0) {
    		const step = (count / 2) | 0;
    		let it = first + step;

    		if (comp(array[it], value) <= 0) {
    			first = ++it;
    			count -= step + 1;
    		} else {
    			count = step;
    		}
    	}

    	return first;
    }

    class PriorityQueue {
    	constructor() {
    		this._queue = [];
    	}

    	enqueue(run, options) {
    		options = Object.assign({
    			priority: 0
    		}, options);

    		const element = {priority: options.priority, run};

    		if (this.size && this._queue[this.size - 1].priority >= options.priority) {
    			this._queue.push(element);
    			return;
    		}

    		const index = lowerBound(this._queue, element, (a, b) => b.priority - a.priority);
    		this._queue.splice(index, 0, element);
    	}

    	dequeue() {
    		return this._queue.shift().run;
    	}

    	get size() {
    		return this._queue.length;
    	}
    }

    class PQueue {
    	constructor(options) {
    		options = Object.assign({
    			carryoverConcurrencyCount: false,
    			intervalCap: Infinity,
    			interval: 0,
    			concurrency: Infinity,
    			autoStart: true,
    			queueClass: PriorityQueue
    		}, options);

    		if (!(typeof options.concurrency === 'number' && options.concurrency >= 1)) {
    			throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${options.concurrency}\` (${typeof options.concurrency})`);
    		}

    		if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
    			throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap}\` (${typeof options.intervalCap})`);
    		}

    		if (!(typeof options.interval === 'number' && Number.isFinite(options.interval) && options.interval >= 0)) {
    			throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval}\` (${typeof options.interval})`);
    		}

    		this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    		this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
    		this._intervalCount = 0;
    		this._intervalCap = options.intervalCap;
    		this._interval = options.interval;
    		this._intervalId = null;
    		this._intervalEnd = 0;
    		this._timeoutId = null;

    		this.queue = new options.queueClass(); // eslint-disable-line new-cap
    		this._queueClass = options.queueClass;
    		this._pendingCount = 0;
    		this._concurrency = options.concurrency;
    		this._isPaused = options.autoStart === false;
    		this._resolveEmpty = () => {};
    		this._resolveIdle = () => {};
    	}

    	get _doesIntervalAllowAnother() {
    		return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    	}

    	get _doesConcurrentAllowAnother() {
    		return this._pendingCount < this._concurrency;
    	}

    	_next() {
    		this._pendingCount--;
    		this._tryToStartAnother();
    	}

    	_resolvePromises() {
    		this._resolveEmpty();
    		this._resolveEmpty = () => {};

    		if (this._pendingCount === 0) {
    			this._resolveIdle();
    			this._resolveIdle = () => {};
    		}
    	}

    	_onResumeInterval() {
    		this._onInterval();
    		this._initializeIntervalIfNeeded();
    		this._timeoutId = null;
    	}

    	_intervalPaused() {
    		const now = Date.now();

    		if (this._intervalId === null) {
    			const delay = this._intervalEnd - now;
    			if (delay < 0) {
    				// Act as the interval was done
    				// We don't need to resume it here,
    				// because it'll be resumed on line 160
    				this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
    			} else {
    				// Act as the interval is pending
    				if (this._timeoutId === null) {
    					this._timeoutId = setTimeout(() => this._onResumeInterval(), delay);
    				}

    				return true;
    			}
    		}

    		return false;
    	}

    	_tryToStartAnother() {
    		if (this.queue.size === 0) {
    			// We can clear the interval ("pause")
    			// because we can redo it later ("resume")
    			clearInterval(this._intervalId);
    			this._intervalId = null;

    			this._resolvePromises();

    			return false;
    		}

    		if (!this._isPaused) {
    			const canInitializeInterval = !this._intervalPaused();
    			if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
    				this.queue.dequeue()();
    				if (canInitializeInterval) {
    					this._initializeIntervalIfNeeded();
    				}

    				return true;
    			}
    		}

    		return false;
    	}

    	_initializeIntervalIfNeeded() {
    		if (this._isIntervalIgnored || this._intervalId !== null) {
    			return;
    		}

    		this._intervalId = setInterval(() => this._onInterval(), this._interval);
    		this._intervalEnd = Date.now() + this._interval;
    	}

    	_onInterval() {
    		if (this._intervalCount === 0 && this._pendingCount === 0) {
    			clearInterval(this._intervalId);
    			this._intervalId = null;
    		}

    		this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;
    		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
    	}

    	add(fn, options) {
    		return new Promise((resolve, reject) => {
    			const run = () => {
    				this._pendingCount++;
    				this._intervalCount++;

    				try {
    					Promise.resolve(fn()).then(
    						val => {
    							resolve(val);
    							this._next();
    						},
    						err => {
    							reject(err);
    							this._next();
    						}
    					);
    				} catch (err) {
    					reject(err);
    					this._next();
    				}
    			};

    			this.queue.enqueue(run, options);
    			this._tryToStartAnother();
    		});
    	}

    	addAll(fns, options) {
    		return Promise.all(fns.map(fn => this.add(fn, options)));
    	}

    	start() {
    		if (!this._isPaused) {
    			return;
    		}

    		this._isPaused = false;
    		while (this._tryToStartAnother()) {} // eslint-disable-line no-empty
    	}

    	pause() {
    		this._isPaused = true;
    	}

    	clear() {
    		this.queue = new this._queueClass(); // eslint-disable-line new-cap
    	}

    	onEmpty() {
    		// Instantly resolve if the queue is empty
    		if (this.queue.size === 0) {
    			return Promise.resolve();
    		}

    		return new Promise(resolve => {
    			const existingResolve = this._resolveEmpty;
    			this._resolveEmpty = () => {
    				existingResolve();
    				resolve();
    			};
    		});
    	}

    	onIdle() {
    		// Instantly resolve if none pending and if nothing else is queued
    		if (this._pendingCount === 0 && this.queue.size === 0) {
    			return Promise.resolve();
    		}

    		return new Promise(resolve => {
    			const existingResolve = this._resolveIdle;
    			this._resolveIdle = () => {
    				existingResolve();
    				resolve();
    			};
    		});
    	}

    	get size() {
    		return this.queue.size;
    	}

    	get pending() {
    		return this._pendingCount;
    	}

    	get isPaused() {
    		return this._isPaused;
    	}
    }

    var pQueue = PQueue;

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isFunction(x) {
        return typeof x === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    var config$1 = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = /*@__PURE__*/ new Error();
                /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            else if (_enable_super_gross_mode_that_will_cause_bad_things) {
                /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function hostReportError(err) {
        setTimeout(function () { throw err; });
    }

    /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
    var empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config$1.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        },
        complete: function () { }
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArray$2 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isObject(x) {
        return x != null && typeof x === 'object';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var errorObject = { e: {} };

    /** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        }
        catch (e) {
            errorObject.e = e;
            return errorObject;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    var UnsubscriptionError = UnsubscriptionErrorImpl;

    /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
    var Subscription = /*@__PURE__*/ (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parent = null;
            this._parents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var hasErrors = false;
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parent = null;
            this._parents = null;
            this._subscriptions = null;
            var index = -1;
            var len = _parents ? _parents.length : 0;
            while (_parent) {
                _parent.remove(this);
                _parent = ++index < len && _parents[index] || null;
            }
            if (isFunction(_unsubscribe)) {
                var trial = tryCatch(_unsubscribe).call(this);
                if (trial === errorObject) {
                    hasErrors = true;
                    errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                        flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
                }
            }
            if (isArray$2(_subscriptions)) {
                index = -1;
                len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject(sub)) {
                        var trial = tryCatch(sub.unsubscribe).call(sub);
                        if (trial === errorObject) {
                            hasErrors = true;
                            errors = errors || [];
                            var err = errorObject.e;
                            if (err instanceof UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
            }
            if (hasErrors) {
                throw new UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            if (!teardown || (teardown === Subscription.EMPTY)) {
                return Subscription.EMPTY;
            }
            if (teardown === this) {
                return this;
            }
            var subscription = teardown;
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (typeof subscription._addParent !== 'function') {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default:
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
            var subscriptions = this._subscriptions || (this._subscriptions = []);
            subscriptions.push(subscription);
            subscription._addParent(this);
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.prototype._addParent = function (parent) {
            var _a = this, _parent = _a._parent, _parents = _a._parents;
            if (!_parent || _parent === parent) {
                this._parent = parent;
            }
            else if (!_parents) {
                this._parents = [parent];
            }
            else if (_parents.indexOf(parent) === -1) {
                _parents.push(parent);
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var rxSubscriber = typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();

    /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
    var Subscriber = /*@__PURE__*/ (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            _this._parentSubscription = null;
            switch (arguments.length) {
                case 0:
                    _this.destination = empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _a = this, _parent = _a._parent, _parents = _a._parents;
            this._parent = null;
            this._parents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parent = _parent;
            this._parents = _parents;
            this._parentSubscription = null;
            return this;
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config$1.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config$1.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config$1.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config$1.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }

    /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber]) {
                return nextOrObserver[rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber(empty);
        }
        return new Subscriber(nextOrObserver, error, complete);
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function noop$1() { }

    /** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
    function pipeFromArray(fns) {
        if (!fns) {
            return noop$1;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
    var Observable = /*@__PURE__*/ (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable$$1 = new Observable();
            observable$$1.source = this;
            observable$$1.operator = operator;
            return observable$$1;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber(observerOrNext, error, complete);
            if (operator) {
                operator.call(sink, this.source);
            }
            else {
                sink.add(this.source || (config$1.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config$1.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config$1.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor = config$1.Promise || Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var SubjectSubscription = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscription, _super);
        function SubjectSubscription(subject, subscriber) {
            var _this = _super.call(this) || this;
            _this.subject = subject;
            _this.subscriber = subscriber;
            _this.closed = false;
            return _this;
        }
        SubjectSubscription.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.closed = true;
            var subject = this.subject;
            var observers = subject.observers;
            this.subject = null;
            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
            }
            var subscriberIndex = observers.indexOf(this.subscriber);
            if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
            }
        };
        return SubjectSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
    var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SubjectSubscriber, _super);
        function SubjectSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            return _this;
        }
        return SubjectSubscriber;
    }(Subscriber));
    var Subject = /*@__PURE__*/ (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.observers = [];
            _this.closed = false;
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype[rxSubscriber] = function () {
            return new SubjectSubscriber(this);
        };
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype.next = function (value) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();
                for (var i = 0; i < len; i++) {
                    copy[i].next(value);
                }
            }
        };
        Subject.prototype.error = function (err) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.hasError = true;
            this.thrownError = err;
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].error(err);
            }
            this.observers.length = 0;
        };
        Subject.prototype.complete = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            this.isStopped = true;
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].complete();
            }
            this.observers.length = 0;
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = true;
            this.closed = true;
            this.observers = null;
        };
        Subject.prototype._trySubscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else {
                return _super.prototype._trySubscribe.call(this, subscriber);
            }
        };
        Subject.prototype._subscribe = function (subscriber) {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription.EMPTY;
            }
            else if (this.isStopped) {
                subscriber.complete();
                return Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                return new SubjectSubscription(this, subscriber);
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = /*@__PURE__*/ (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var destination = this.destination;
            if (destination && destination.next) {
                destination.next(value);
            }
        };
        AnonymousSubject.prototype.error = function (err) {
            var destination = this.destination;
            if (destination && destination.error) {
                this.destination.error(err);
            }
        };
        AnonymousSubject.prototype.complete = function () {
            var destination = this.destination;
            if (destination && destination.complete) {
                this.destination.complete();
            }
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var source = this.source;
            if (source) {
                return this.source.subscribe(subscriber);
            }
            else {
                return Subscription.EMPTY;
            }
        };
        return AnonymousSubject;
    }(Subject));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function refCount() {
        return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
        };
    }
    var RefCountOperator = /*@__PURE__*/ (function () {
        function RefCountOperator(connectable) {
            this.connectable = connectable;
        }
        RefCountOperator.prototype.call = function (subscriber, source) {
            var connectable = this.connectable;
            connectable._refCount++;
            var refCounter = new RefCountSubscriber(subscriber, connectable);
            var subscription = source.subscribe(refCounter);
            if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
            }
            return subscription;
        };
        return RefCountOperator;
    }());
    var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount = connectable._refCount;
            if (refCount <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount - 1;
            if (refCount > 1) {
                this.connection = null;
                return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
    var ConnectableObservable = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableObservable, _super);
        function ConnectableObservable(source, subjectFactory) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subjectFactory = subjectFactory;
            _this._refCount = 0;
            _this._isComplete = false;
            return _this;
        }
        ConnectableObservable.prototype._subscribe = function (subscriber) {
            return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable.prototype.getSubject = function () {
            var subject = this._subject;
            if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
            }
            return this._subject;
        };
        ConnectableObservable.prototype.connect = function () {
            var connection = this._connection;
            if (!connection) {
                this._isComplete = false;
                connection = this._connection = new Subscription();
                connection.add(this.source
                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
                if (connection.closed) {
                    this._connection = null;
                    connection = Subscription.EMPTY;
                }
                else {
                    this._connection = connection;
                }
            }
            return connection;
        };
        ConnectableObservable.prototype.refCount = function () {
            return refCount()(this);
        };
        return ConnectableObservable;
    }(Observable));
    var connectableProto = ConnectableObservable.prototype;
    var connectableObservableDescriptor = {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
    var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ConnectableSubscriber, _super);
        function ConnectableSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        ConnectableSubscriber.prototype._error = function (err) {
            this._unsubscribe();
            _super.prototype._error.call(this, err);
        };
        ConnectableSubscriber.prototype._complete = function () {
            this.connectable._isComplete = true;
            this._unsubscribe();
            _super.prototype._complete.call(this);
        };
        ConnectableSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;
                if (connection) {
                    connection.unsubscribe();
                }
            }
        };
        return ConnectableSubscriber;
    }(SubjectSubscriber));
    var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
        __extends(RefCountSubscriber, _super);
        function RefCountSubscriber(destination, connectable) {
            var _this = _super.call(this, destination) || this;
            _this.connectable = connectable;
            return _this;
        }
        RefCountSubscriber.prototype._unsubscribe = function () {
            var connectable = this.connectable;
            if (!connectable) {
                this.connection = null;
                return;
            }
            this.connectable = null;
            var refCount$$1 = connectable._refCount;
            if (refCount$$1 <= 0) {
                this.connection = null;
                return;
            }
            connectable._refCount = refCount$$1 - 1;
            if (refCount$$1 > 1) {
                this.connection = null;
                return;
            }
            var connection = this.connection;
            var sharedConnection = connectable._connection;
            this.connection = null;
            if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
            }
        };
        return RefCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
    var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(GroupBySubscriber, _super);
        function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.elementSelector = elementSelector;
            _this.durationSelector = durationSelector;
            _this.subjectSelector = subjectSelector;
            _this.groups = null;
            _this.attemptedToUnsubscribe = false;
            _this.count = 0;
            return _this;
        }
        GroupBySubscriber.prototype._next = function (value) {
            var key;
            try {
                key = this.keySelector(value);
            }
            catch (err) {
                this.error(err);
                return;
            }
            this._group(value, key);
        };
        GroupBySubscriber.prototype._group = function (value, key) {
            var groups = this.groups;
            if (!groups) {
                groups = this.groups = new Map();
            }
            var group = groups.get(key);
            var element;
            if (this.elementSelector) {
                try {
                    element = this.elementSelector(value);
                }
                catch (err) {
                    this.error(err);
                }
            }
            else {
                element = value;
            }
            if (!group) {
                group = (this.subjectSelector ? this.subjectSelector() : new Subject());
                groups.set(key, group);
                var groupedObservable = new GroupedObservable(key, group, this);
                this.destination.next(groupedObservable);
                if (this.durationSelector) {
                    var duration = void 0;
                    try {
                        duration = this.durationSelector(new GroupedObservable(key, group));
                    }
                    catch (err) {
                        this.error(err);
                        return;
                    }
                    this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
                }
            }
            if (!group.closed) {
                group.next(element);
            }
        };
        GroupBySubscriber.prototype._error = function (err) {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.error(err);
                });
                groups.clear();
            }
            this.destination.error(err);
        };
        GroupBySubscriber.prototype._complete = function () {
            var groups = this.groups;
            if (groups) {
                groups.forEach(function (group, key) {
                    group.complete();
                });
                groups.clear();
            }
            this.destination.complete();
        };
        GroupBySubscriber.prototype.removeGroup = function (key) {
            this.groups.delete(key);
        };
        GroupBySubscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.attemptedToUnsubscribe = true;
                if (this.count === 0) {
                    _super.prototype.unsubscribe.call(this);
                }
            }
        };
        return GroupBySubscriber;
    }(Subscriber));
    var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(GroupDurationSubscriber, _super);
        function GroupDurationSubscriber(key, group, parent) {
            var _this = _super.call(this, group) || this;
            _this.key = key;
            _this.group = group;
            _this.parent = parent;
            return _this;
        }
        GroupDurationSubscriber.prototype._next = function (value) {
            this.complete();
        };
        GroupDurationSubscriber.prototype._unsubscribe = function () {
            var _a = this, parent = _a.parent, key = _a.key;
            this.key = this.parent = null;
            if (parent) {
                parent.removeGroup(key);
            }
        };
        return GroupDurationSubscriber;
    }(Subscriber));
    var GroupedObservable = /*@__PURE__*/ (function (_super) {
        __extends(GroupedObservable, _super);
        function GroupedObservable(key, groupSubject, refCountSubscription) {
            var _this = _super.call(this) || this;
            _this.key = key;
            _this.groupSubject = groupSubject;
            _this.refCountSubscription = refCountSubscription;
            return _this;
        }
        GroupedObservable.prototype._subscribe = function (subscriber) {
            var subscription = new Subscription();
            var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
            if (refCountSubscription && !refCountSubscription.closed) {
                subscription.add(new InnerRefCountSubscription(refCountSubscription));
            }
            subscription.add(groupSubject.subscribe(subscriber));
            return subscription;
        };
        return GroupedObservable;
    }(Observable));
    var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
        __extends(InnerRefCountSubscription, _super);
        function InnerRefCountSubscription(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            parent.count++;
            return _this;
        }
        InnerRefCountSubscription.prototype.unsubscribe = function () {
            var parent = this.parent;
            if (!parent.closed && !this.closed) {
                _super.prototype.unsubscribe.call(this);
                parent.count -= 1;
                if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                    parent.unsubscribe();
                }
            }
        };
        return InnerRefCountSubscription;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
    var BehaviorSubject = /*@__PURE__*/ (function (_super) {
        __extends(BehaviorSubject, _super);
        function BehaviorSubject(_value) {
            var _this = _super.call(this) || this;
            _this._value = _value;
            return _this;
        }
        Object.defineProperty(BehaviorSubject.prototype, "value", {
            get: function () {
                return this.getValue();
            },
            enumerable: true,
            configurable: true
        });
        BehaviorSubject.prototype._subscribe = function (subscriber) {
            var subscription = _super.prototype._subscribe.call(this, subscriber);
            if (subscription && !subscription.closed) {
                subscriber.next(this._value);
            }
            return subscription;
        };
        BehaviorSubject.prototype.getValue = function () {
            if (this.hasError) {
                throw this.thrownError;
            }
            else if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else {
                return this._value;
            }
        };
        BehaviorSubject.prototype.next = function (value) {
            _super.prototype.next.call(this, this._value = value);
        };
        return BehaviorSubject;
    }(Subject));

    /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
    var Action = /*@__PURE__*/ (function (_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            return this;
        };
        return Action;
    }(Subscription));

    /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
    var AsyncAction = /*@__PURE__*/ (function (_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            return setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && this.delay === delay && this.pending === false) {
                return id;
            }
            clearInterval(id);
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, delay) {
            var errored = false;
            var errorValue = undefined;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = !!e && e || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype._unsubscribe = function () {
            var id = this.id;
            var scheduler = this.scheduler;
            var actions = scheduler.actions;
            var index = actions.indexOf(this);
            this.work = null;
            this.state = null;
            this.pending = false;
            this.scheduler = null;
            if (index !== -1) {
                actions.splice(index, 1);
            }
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
        };
        return AsyncAction;
    }(Action));

    /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
    var QueueAction = /*@__PURE__*/ (function (_super) {
        __extends(QueueAction, _super);
        function QueueAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        QueueAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.delay = delay;
            this.state = state;
            this.scheduler.flush(this);
            return this;
        };
        QueueAction.prototype.execute = function (state, delay) {
            return (delay > 0 || this.closed) ?
                _super.prototype.execute.call(this, state, delay) :
                this._execute(state, delay);
        };
        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            return scheduler.flush(this);
        };
        return QueueAction;
    }(AsyncAction));

    var Scheduler = /*@__PURE__*/ (function () {
        function Scheduler(SchedulerAction, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            this.SchedulerAction = SchedulerAction;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
                delay = 0;
            }
            return new this.SchedulerAction(this, work).schedule(state, delay);
        };
        Scheduler.now = function () { return Date.now(); };
        return Scheduler;
    }());

    /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
    var AsyncScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) {
                now = Scheduler.now;
            }
            var _this = _super.call(this, SchedulerAction, function () {
                if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                    return AsyncScheduler.delegate.now();
                }
                else {
                    return now();
                }
            }) || this;
            _this.actions = [];
            _this.active = false;
            _this.scheduled = undefined;
            return _this;
        }
        AsyncScheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) {
                delay = 0;
            }
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
                return AsyncScheduler.delegate.schedule(work, delay, state);
            }
            else {
                return _super.prototype.schedule.call(this, work, delay, state);
            }
        };
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this.active) {
                actions.push(action);
                return;
            }
            var error;
            this.active = true;
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (action = actions.shift());
            this.active = false;
            if (error) {
                while (action = actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
    var QueueScheduler = /*@__PURE__*/ (function (_super) {
        __extends(QueueScheduler, _super);
        function QueueScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler;
    }(AsyncScheduler));

    /** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
    var queue$1 = /*@__PURE__*/ new QueueScheduler(QueueAction);

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
    var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
    function empty$1(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }
    function emptyScheduled(scheduler) {
        return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isScheduler(value) {
        return value && typeof value.schedule === 'function';
    }

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var subscribeToArray = function (array) {
        return function (subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            if (!subscriber.closed) {
                subscriber.complete();
            }
        };
    };

    /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
    function fromArray(input, scheduler) {
        if (!scheduler) {
            return new Observable(subscribeToArray(input));
        }
        else {
            return new Observable(function (subscriber) {
                var sub = new Subscription();
                var i = 0;
                sub.add(scheduler.schedule(function () {
                    if (i === input.length) {
                        subscriber.complete();
                        return;
                    }
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        sub.add(this.schedule());
                    }
                }));
                return sub;
            });
        }
    }

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
    function scalar(value) {
        var result = new Observable(function (subscriber) {
            subscriber.next(value);
            subscriber.complete();
        });
        result._isScalar = true;
        result.value = value;
        return result;
    }

    /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = args[args.length - 1];
        if (isScheduler(scheduler)) {
            args.pop();
        }
        else {
            scheduler = undefined;
        }
        switch (args.length) {
            case 0:
                return empty$1(scheduler);
            case 1:
                return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
            default:
                return fromArray(args, scheduler);
        }
    }

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
    function throwError(error, scheduler) {
        if (!scheduler) {
            return new Observable(function (subscriber) { return subscriber.error(error); });
        }
        else {
            return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
        }
    }
    function dispatch(_a) {
        var error = _a.error, subscriber = _a.subscriber;
        subscriber.error(error);
    }

    /** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
    var Notification = /*@__PURE__*/ (function () {
        function Notification(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        Notification.prototype.observe = function (observer) {
            switch (this.kind) {
                case 'N':
                    return observer.next && observer.next(this.value);
                case 'E':
                    return observer.error && observer.error(this.error);
                case 'C':
                    return observer.complete && observer.complete();
            }
        };
        Notification.prototype.do = function (next, error, complete) {
            var kind = this.kind;
            switch (kind) {
                case 'N':
                    return next && next(this.value);
                case 'E':
                    return error && error(this.error);
                case 'C':
                    return complete && complete();
            }
        };
        Notification.prototype.accept = function (nextOrObserver, error, complete) {
            if (nextOrObserver && typeof nextOrObserver.next === 'function') {
                return this.observe(nextOrObserver);
            }
            else {
                return this.do(nextOrObserver, error, complete);
            }
        };
        Notification.prototype.toObservable = function () {
            var kind = this.kind;
            switch (kind) {
                case 'N':
                    return of(this.value);
                case 'E':
                    return throwError(this.error);
                case 'C':
                    return empty$1();
            }
            throw new Error('unexpected notification kind value');
        };
        Notification.createNext = function (value) {
            if (typeof value !== 'undefined') {
                return new Notification('N', value);
            }
            return Notification.undefinedValueNotification;
        };
        Notification.createError = function (err) {
            return new Notification('E', undefined, err);
        };
        Notification.createComplete = function () {
            return Notification.completeNotification;
        };
        Notification.completeNotification = new Notification('C');
        Notification.undefinedValueNotification = new Notification('N', undefined);
        return Notification;
    }());

    /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
    var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ObserveOnSubscriber, _super);
        function ObserveOnSubscriber(destination, scheduler, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            var _this = _super.call(this, destination) || this;
            _this.scheduler = scheduler;
            _this.delay = delay;
            return _this;
        }
        ObserveOnSubscriber.dispatch = function (arg) {
            var notification = arg.notification, destination = arg.destination;
            notification.observe(destination);
            this.unsubscribe();
        };
        ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
            var destination = this.destination;
            destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
        };
        ObserveOnSubscriber.prototype._next = function (value) {
            this.scheduleMessage(Notification.createNext(value));
        };
        ObserveOnSubscriber.prototype._error = function (err) {
            this.scheduleMessage(Notification.createError(err));
            this.unsubscribe();
        };
        ObserveOnSubscriber.prototype._complete = function () {
            this.scheduleMessage(Notification.createComplete());
            this.unsubscribe();
        };
        return ObserveOnSubscriber;
    }(Subscriber));
    var ObserveOnMessage = /*@__PURE__*/ (function () {
        function ObserveOnMessage(notification, destination) {
            this.notification = notification;
            this.destination = destination;
        }
        return ObserveOnMessage;
    }());

    /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
    var ReplaySubject = /*@__PURE__*/ (function (_super) {
        __extends(ReplaySubject, _super);
        function ReplaySubject(bufferSize, windowTime, scheduler) {
            if (bufferSize === void 0) {
                bufferSize = Number.POSITIVE_INFINITY;
            }
            if (windowTime === void 0) {
                windowTime = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this) || this;
            _this.scheduler = scheduler;
            _this._events = [];
            _this._infiniteTimeWindow = false;
            _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
            _this._windowTime = windowTime < 1 ? 1 : windowTime;
            if (windowTime === Number.POSITIVE_INFINITY) {
                _this._infiniteTimeWindow = true;
                _this.next = _this.nextInfiniteTimeWindow;
            }
            else {
                _this.next = _this.nextTimeWindow;
            }
            return _this;
        }
        ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
            _super.prototype.next.call(this, value);
        };
        ReplaySubject.prototype.nextTimeWindow = function (value) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
            _super.prototype.next.call(this, value);
        };
        ReplaySubject.prototype._subscribe = function (subscriber) {
            var _infiniteTimeWindow = this._infiniteTimeWindow;
            var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
            var scheduler = this.scheduler;
            var len = _events.length;
            var subscription;
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
            else if (this.isStopped || this.hasError) {
                subscription = Subscription.EMPTY;
            }
            else {
                this.observers.push(subscriber);
                subscription = new SubjectSubscription(this, subscriber);
            }
            if (scheduler) {
                subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
            }
            if (_infiniteTimeWindow) {
                for (var i = 0; i < len && !subscriber.closed; i++) {
                    subscriber.next(_events[i]);
                }
            }
            else {
                for (var i = 0; i < len && !subscriber.closed; i++) {
                    subscriber.next(_events[i].value);
                }
            }
            if (this.hasError) {
                subscriber.error(this.thrownError);
            }
            else if (this.isStopped) {
                subscriber.complete();
            }
            return subscription;
        };
        ReplaySubject.prototype._getNow = function () {
            return (this.scheduler || queue$1).now();
        };
        ReplaySubject.prototype._trimBufferThenGetEvents = function () {
            var now = this._getNow();
            var _bufferSize = this._bufferSize;
            var _windowTime = this._windowTime;
            var _events = this._events;
            var eventsCount = _events.length;
            var spliceCount = 0;
            while (spliceCount < eventsCount) {
                if ((now - _events[spliceCount].time) < _windowTime) {
                    break;
                }
                spliceCount++;
            }
            if (eventsCount > _bufferSize) {
                spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
            }
            if (spliceCount > 0) {
                _events.splice(0, spliceCount);
            }
            return _events;
        };
        return ReplaySubject;
    }(Subject));
    var ReplayEvent = /*@__PURE__*/ (function () {
        function ReplayEvent(time, value) {
            this.time = time;
            this.value = value;
        }
        return ReplayEvent;
    }());

    /** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
    var AsyncSubject = /*@__PURE__*/ (function (_super) {
        __extends(AsyncSubject, _super);
        function AsyncSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.value = null;
            _this.hasNext = false;
            _this.hasCompleted = false;
            return _this;
        }
        AsyncSubject.prototype._subscribe = function (subscriber) {
            if (this.hasError) {
                subscriber.error(this.thrownError);
                return Subscription.EMPTY;
            }
            else if (this.hasCompleted && this.hasNext) {
                subscriber.next(this.value);
                subscriber.complete();
                return Subscription.EMPTY;
            }
            return _super.prototype._subscribe.call(this, subscriber);
        };
        AsyncSubject.prototype.next = function (value) {
            if (!this.hasCompleted) {
                this.value = value;
                this.hasNext = true;
            }
        };
        AsyncSubject.prototype.error = function (error) {
            if (!this.hasCompleted) {
                _super.prototype.error.call(this, error);
            }
        };
        AsyncSubject.prototype.complete = function () {
            this.hasCompleted = true;
            if (this.hasNext) {
                _super.prototype.next.call(this, this.value);
            }
            _super.prototype.complete.call(this);
        };
        return AsyncSubject;
    }(Subject));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var nextHandle = 1;
    var tasksByHandle = {};
    function runIfPresent(handle) {
        var cb = tasksByHandle[handle];
        if (cb) {
            cb();
        }
    }
    var Immediate = {
        setImmediate: function (cb) {
            var handle = nextHandle++;
            tasksByHandle[handle] = cb;
            Promise.resolve().then(function () { return runIfPresent(handle); });
            return handle;
        },
        clearImmediate: function (handle) {
            delete tasksByHandle[handle];
        },
    };

    /** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
    var AsapAction = /*@__PURE__*/ (function (_super) {
        __extends(AsapAction, _super);
        function AsapAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
        };
        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                Immediate.clearImmediate(id);
                scheduler.scheduled = undefined;
            }
            return undefined;
        };
        return AsapAction;
    }(AsyncAction));

    /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
    var AsapScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AsapScheduler, _super);
        function AsapScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsapScheduler;
    }(AsyncScheduler));

    /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
    var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

    /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
    var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

    /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
    var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
        __extends(AnimationFrameAction, _super);
        function AnimationFrameAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            return _this;
        }
        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
            }
            scheduler.actions.push(this);
            return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
        };
        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
            }
            if (scheduler.actions.length === 0) {
                cancelAnimationFrame(id);
                scheduler.scheduled = undefined;
            }
            return undefined;
        };
        return AnimationFrameAction;
    }(AsyncAction));

    /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
    var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
        __extends(AnimationFrameScheduler, _super);
        function AnimationFrameScheduler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler.prototype.flush = function (action) {
            this.active = true;
            this.scheduled = undefined;
            var actions = this.actions;
            var error;
            var index = -1;
            var count = actions.length;
            action = action || actions.shift();
            do {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            } while (++index < count && (action = actions.shift()));
            this.active = false;
            if (error) {
                while (++index < count && (action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AnimationFrameScheduler;
    }(AsyncScheduler));

    /** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
    var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

    /** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
    var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
        __extends(VirtualTimeScheduler, _super);
        function VirtualTimeScheduler(SchedulerAction, maxFrames) {
            if (SchedulerAction === void 0) {
                SchedulerAction = VirtualAction;
            }
            if (maxFrames === void 0) {
                maxFrames = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
            _this.maxFrames = maxFrames;
            _this.frame = 0;
            _this.index = -1;
            return _this;
        }
        VirtualTimeScheduler.prototype.flush = function () {
            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
            var error, action;
            while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
                if (error = action.execute(action.state, action.delay)) {
                    break;
                }
            }
            if (error) {
                while (action = actions.shift()) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        VirtualTimeScheduler.frameTimeFactor = 10;
        return VirtualTimeScheduler;
    }(AsyncScheduler));
    var VirtualAction = /*@__PURE__*/ (function (_super) {
        __extends(VirtualAction, _super);
        function VirtualAction(scheduler, work, index) {
            if (index === void 0) {
                index = scheduler.index += 1;
            }
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.index = index;
            _this.active = true;
            _this.index = scheduler.index = index;
            return _this;
        }
        VirtualAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            if (!this.id) {
                return _super.prototype.schedule.call(this, state, delay);
            }
            this.active = false;
            var action = new VirtualAction(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
        };
        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            this.delay = scheduler.frame + delay;
            var actions = scheduler.actions;
            actions.push(this);
            actions.sort(VirtualAction.sortActions);
            return true;
        };
        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
            if (delay === void 0) {
                delay = 0;
            }
            return undefined;
        };
        VirtualAction.prototype._execute = function (state, delay) {
            if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
            }
        };
        VirtualAction.sortActions = function (a, b) {
            if (a.delay === b.delay) {
                if (a.index === b.index) {
                    return 0;
                }
                else if (a.index > b.index) {
                    return 1;
                }
                else {
                    return -1;
                }
            }
            else if (a.delay > b.delay) {
                return 1;
            }
            else {
                return -1;
            }
        };
        return VirtualAction;
    }(AsyncAction));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    var EmptyError = EmptyErrorImpl;

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    var MapOperator = /*@__PURE__*/ (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    var MapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var OuterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(OuterSubscriber, _super);
        function OuterSubscriber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        OuterSubscriber.prototype.notifyError = function (error, innerSub) {
            this.destination.error(error);
        };
        OuterSubscriber.prototype.notifyComplete = function (innerSub) {
            this.destination.complete();
        };
        return OuterSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var InnerSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(InnerSubscriber, _super);
        function InnerSubscriber(parent, outerValue, outerIndex) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this.outerValue = outerValue;
            _this.outerIndex = outerIndex;
            _this.index = 0;
            return _this;
        }
        InnerSubscriber.prototype._next = function (value) {
            this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
        };
        InnerSubscriber.prototype._error = function (error) {
            this.parent.notifyError(error, this);
            this.unsubscribe();
        };
        InnerSubscriber.prototype._complete = function () {
            this.parent.notifyComplete(this);
            this.unsubscribe();
        };
        return InnerSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
    var subscribeToPromise = function (promise) {
        return function (subscriber) {
            promise.then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, hostReportError);
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = /*@__PURE__*/ getSymbolIterator();

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
    var subscribeToIterable = function (iterable) {
        return function (subscriber) {
            var iterator$$1 = iterable[iterator]();
            do {
                var item = iterator$$1.next();
                if (item.done) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(item.value);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
            if (typeof iterator$$1.return === 'function') {
                subscriber.add(function () {
                    if (iterator$$1.return) {
                        iterator$$1.return();
                    }
                });
            }
            return subscriber;
        };
    };

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
    var subscribeToObservable = function (obj) {
        return function (subscriber) {
            var obs = obj[observable]();
            if (typeof obs.subscribe !== 'function') {
                throw new TypeError('Provided object does not correctly implement Symbol.observable');
            }
            else {
                return obs.subscribe(subscriber);
            }
        };
    };

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */
    function isPromise(value) {
        return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    }

    /** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
    var subscribeTo = function (result) {
        if (result instanceof Observable) {
            return function (subscriber) {
                if (result._isScalar) {
                    subscriber.next(result.value);
                    subscriber.complete();
                    return undefined;
                }
                else {
                    return result.subscribe(subscriber);
                }
            };
        }
        else if (result && typeof result[observable] === 'function') {
            return subscribeToObservable(result);
        }
        else if (isArrayLike(result)) {
            return subscribeToArray(result);
        }
        else if (isPromise(result)) {
            return subscribeToPromise(result);
        }
        else if (result && typeof result[iterator] === 'function') {
            return subscribeToIterable(result);
        }
        else {
            var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
            var msg = "You provided " + value + " where a stream was expected."
                + ' You can provide an Observable, Promise, Array, or Iterable.';
            throw new TypeError(msg);
        }
    };

    /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
        if (destination === void 0) {
            destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
        }
        if (destination.closed) {
            return;
        }
        return subscribeTo(result)(destination);
    }

    /** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
    var NONE = {};
    var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(CombineLatestSubscriber, _super);
        function CombineLatestSubscriber(destination, resultSelector) {
            var _this = _super.call(this, destination) || this;
            _this.resultSelector = resultSelector;
            _this.active = 0;
            _this.values = [];
            _this.observables = [];
            return _this;
        }
        CombineLatestSubscriber.prototype._next = function (observable) {
            this.values.push(NONE);
            this.observables.push(observable);
        };
        CombineLatestSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
                this.destination.complete();
            }
            else {
                this.active = len;
                this.toRespond = len;
                for (var i = 0; i < len; i++) {
                    var observable = observables[i];
                    this.add(subscribeToResult(this, observable, observable, i));
                }
            }
        };
        CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
            if ((this.active -= 1) === 0) {
                this.destination.complete();
            }
        };
        CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var values = this.values;
            var oldVal = values[outerIndex];
            var toRespond = !this.toRespond
                ? 0
                : oldVal === NONE ? --this.toRespond : this.toRespond;
            values[outerIndex] = innerValue;
            if (toRespond === 0) {
                if (this.resultSelector) {
                    this._tryResultSelector(values);
                }
                else {
                    this.destination.next(values.slice());
                }
            }
        };
        CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
            var result;
            try {
                result = this.resultSelector.apply(this, values);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return CombineLatestSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
    var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MergeMapSubscriber, _super);
        function MergeMapSubscriber(destination, project, concurrent) {
            if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
            }
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
        }
        MergeMapSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                this._tryNext(value);
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeMapSubscriber.prototype._tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.active++;
            this._innerSub(result, value, index);
        };
        MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, ish, value, index, innerSubscriber);
        };
        MergeMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            this.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
            }
        };
        return MergeMapSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */
    var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ForkJoinSubscriber, _super);
        function ForkJoinSubscriber(destination, sources) {
            var _this = _super.call(this, destination) || this;
            _this.sources = sources;
            _this.completed = 0;
            _this.haveValues = 0;
            var len = sources.length;
            _this.values = new Array(len);
            for (var i = 0; i < len; i++) {
                var source = sources[i];
                var innerSubscription = subscribeToResult(_this, source, null, i);
                if (innerSubscription) {
                    _this.add(innerSubscription);
                }
            }
            return _this;
        }
        ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values[outerIndex] = innerValue;
            if (!innerSub._hasValue) {
                innerSub._hasValue = true;
                this.haveValues++;
            }
        };
        ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
            var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
            var len = values.length;
            if (!innerSub._hasValue) {
                destination.complete();
                return;
            }
            this.completed++;
            if (this.completed !== len) {
                return;
            }
            if (haveValues === len) {
                destination.next(values);
            }
            destination.complete();
        };
        return ForkJoinSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray$2(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
        }
        return new Observable(function (subscriber) {
            function handler(e) {
                if (arguments.length > 1) {
                    subscriber.next(Array.prototype.slice.call(arguments));
                }
                else {
                    subscriber.next(e);
                }
            }
            setupSubscription(target, eventName, handler, subscriber, options);
        });
    }
    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
        }
        else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () { return source_2.off(eventName, handler); };
        }
        else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
        }
        else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        }
        else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(unsubscribe);
    }
    function isNodeStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }
    function isJQueryStyleEventEmitter(sourceObj) {
        return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }
    function isEventTarget(sourceObj) {
        return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    }

    /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
    function isNumeric(val) {
        return !isArray$2(val) && (val - parseFloat(val) + 1) >= 0;
    }

    /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
    var NEVER = /*@__PURE__*/ new Observable(noop$1);

    /** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var RaceSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RaceSubscriber, _super);
        function RaceSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasFirst = false;
            _this.observables = [];
            _this.subscriptions = [];
            return _this;
        }
        RaceSubscriber.prototype._next = function (observable) {
            this.observables.push(observable);
        };
        RaceSubscriber.prototype._complete = function () {
            var observables = this.observables;
            var len = observables.length;
            if (len === 0) {
                this.destination.complete();
            }
            else {
                for (var i = 0; i < len && !this.hasFirst; i++) {
                    var observable = observables[i];
                    var subscription = subscribeToResult(this, observable, observable, i);
                    if (this.subscriptions) {
                        this.subscriptions.push(subscription);
                    }
                    this.add(subscription);
                }
                this.observables = null;
            }
        };
        RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (!this.hasFirst) {
                this.hasFirst = true;
                for (var i = 0; i < this.subscriptions.length; i++) {
                    if (i !== outerIndex) {
                        var subscription = this.subscriptions[i];
                        subscription.unsubscribe();
                        this.remove(subscription);
                    }
                }
                this.subscriptions = null;
            }
            this.destination.next(innerValue);
        };
        return RaceSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
    var ZipSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ZipSubscriber, _super);
        function ZipSubscriber(destination, resultSelector, values) {
            if (values === void 0) {
                values = Object.create(null);
            }
            var _this = _super.call(this, destination) || this;
            _this.iterators = [];
            _this.active = 0;
            _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
            _this.values = values;
            return _this;
        }
        ZipSubscriber.prototype._next = function (value) {
            var iterators = this.iterators;
            if (isArray$2(value)) {
                iterators.push(new StaticArrayIterator(value));
            }
            else if (typeof value[iterator] === 'function') {
                iterators.push(new StaticIterator(value[iterator]()));
            }
            else {
                iterators.push(new ZipBufferIterator(this.destination, this, value));
            }
        };
        ZipSubscriber.prototype._complete = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            this.unsubscribe();
            if (len === 0) {
                this.destination.complete();
                return;
            }
            this.active = len;
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                if (iterator$$1.stillUnsubscribed) {
                    var destination = this.destination;
                    destination.add(iterator$$1.subscribe(iterator$$1, i));
                }
                else {
                    this.active--;
                }
            }
        };
        ZipSubscriber.prototype.notifyInactive = function () {
            this.active--;
            if (this.active === 0) {
                this.destination.complete();
            }
        };
        ZipSubscriber.prototype.checkIterators = function () {
            var iterators = this.iterators;
            var len = iterators.length;
            var destination = this.destination;
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                    return;
                }
            }
            var shouldComplete = false;
            var args = [];
            for (var i = 0; i < len; i++) {
                var iterator$$1 = iterators[i];
                var result = iterator$$1.next();
                if (iterator$$1.hasCompleted()) {
                    shouldComplete = true;
                }
                if (result.done) {
                    destination.complete();
                    return;
                }
                args.push(result.value);
            }
            if (this.resultSelector) {
                this._tryresultSelector(args);
            }
            else {
                destination.next(args);
            }
            if (shouldComplete) {
                destination.complete();
            }
        };
        ZipSubscriber.prototype._tryresultSelector = function (args) {
            var result;
            try {
                result = this.resultSelector.apply(this, args);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return ZipSubscriber;
    }(Subscriber));
    var StaticIterator = /*@__PURE__*/ (function () {
        function StaticIterator(iterator$$1) {
            this.iterator = iterator$$1;
            this.nextResult = iterator$$1.next();
        }
        StaticIterator.prototype.hasValue = function () {
            return true;
        };
        StaticIterator.prototype.next = function () {
            var result = this.nextResult;
            this.nextResult = this.iterator.next();
            return result;
        };
        StaticIterator.prototype.hasCompleted = function () {
            var nextResult = this.nextResult;
            return nextResult && nextResult.done;
        };
        return StaticIterator;
    }());
    var StaticArrayIterator = /*@__PURE__*/ (function () {
        function StaticArrayIterator(array) {
            this.array = array;
            this.index = 0;
            this.length = 0;
            this.length = array.length;
        }
        StaticArrayIterator.prototype[iterator] = function () {
            return this;
        };
        StaticArrayIterator.prototype.next = function (value) {
            var i = this.index++;
            var array = this.array;
            return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
        };
        StaticArrayIterator.prototype.hasValue = function () {
            return this.array.length > this.index;
        };
        StaticArrayIterator.prototype.hasCompleted = function () {
            return this.array.length === this.index;
        };
        return StaticArrayIterator;
    }());
    var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
        __extends(ZipBufferIterator, _super);
        function ZipBufferIterator(destination, parent, observable) {
            var _this = _super.call(this, destination) || this;
            _this.parent = parent;
            _this.observable = observable;
            _this.stillUnsubscribed = true;
            _this.buffer = [];
            _this.isComplete = false;
            return _this;
        }
        ZipBufferIterator.prototype[iterator] = function () {
            return this;
        };
        ZipBufferIterator.prototype.next = function () {
            var buffer = this.buffer;
            if (buffer.length === 0 && this.isComplete) {
                return { value: null, done: true };
            }
            else {
                return { value: buffer.shift(), done: false };
            }
        };
        ZipBufferIterator.prototype.hasValue = function () {
            return this.buffer.length > 0;
        };
        ZipBufferIterator.prototype.hasCompleted = function () {
            return this.buffer.length === 0 && this.isComplete;
        };
        ZipBufferIterator.prototype.notifyComplete = function () {
            if (this.buffer.length > 0) {
                this.isComplete = true;
                this.parent.notifyInactive();
            }
            else {
                this.destination.complete();
            }
        };
        ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.buffer.push(innerValue);
            this.parent.checkIterators();
        };
        ZipBufferIterator.prototype.subscribe = function (value, index) {
            return subscribeToResult(this, this.observable, this, index);
        };
        return ZipBufferIterator;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var AuditSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(AuditSubscriber, _super);
        function AuditSubscriber(destination, durationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.durationSelector = durationSelector;
            _this.hasValue = false;
            return _this;
        }
        AuditSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
            if (!this.throttled) {
                var duration = tryCatch(this.durationSelector)(value);
                if (duration === errorObject) {
                    this.destination.error(errorObject.e);
                }
                else {
                    var innerSubscription = subscribeToResult(this, duration);
                    if (!innerSubscription || innerSubscription.closed) {
                        this.clearThrottle();
                    }
                    else {
                        this.add(this.throttled = innerSubscription);
                    }
                }
            }
        };
        AuditSubscriber.prototype.clearThrottle = function () {
            var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
            if (throttled) {
                this.remove(throttled);
                this.throttled = null;
                throttled.unsubscribe();
            }
            if (hasValue) {
                this.value = null;
                this.hasValue = false;
                this.destination.next(value);
            }
        };
        AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
            this.clearThrottle();
        };
        AuditSubscriber.prototype.notifyComplete = function () {
            this.clearThrottle();
        };
        return AuditSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var BufferSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferSubscriber, _super);
        function BufferSubscriber(destination, closingNotifier) {
            var _this = _super.call(this, destination) || this;
            _this.buffer = [];
            _this.add(subscribeToResult(_this, closingNotifier));
            return _this;
        }
        BufferSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
        };
        BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var buffer = this.buffer;
            this.buffer = [];
            this.destination.next(buffer);
        };
        return BufferSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferCountSubscriber, _super);
        function BufferCountSubscriber(destination, bufferSize) {
            var _this = _super.call(this, destination) || this;
            _this.bufferSize = bufferSize;
            _this.buffer = [];
            return _this;
        }
        BufferCountSubscriber.prototype._next = function (value) {
            var buffer = this.buffer;
            buffer.push(value);
            if (buffer.length == this.bufferSize) {
                this.destination.next(buffer);
                this.buffer = [];
            }
        };
        BufferCountSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer.length > 0) {
                this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
        };
        return BufferCountSubscriber;
    }(Subscriber));
    var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferSkipCountSubscriber, _super);
        function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
            var _this = _super.call(this, destination) || this;
            _this.bufferSize = bufferSize;
            _this.startBufferEvery = startBufferEvery;
            _this.buffers = [];
            _this.count = 0;
            return _this;
        }
        BufferSkipCountSubscriber.prototype._next = function (value) {
            var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
            this.count++;
            if (count % startBufferEvery === 0) {
                buffers.push([]);
            }
            for (var i = buffers.length; i--;) {
                var buffer = buffers[i];
                buffer.push(value);
                if (buffer.length === bufferSize) {
                    buffers.splice(i, 1);
                    this.destination.next(buffer);
                }
            }
        };
        BufferSkipCountSubscriber.prototype._complete = function () {
            var _a = this, buffers = _a.buffers, destination = _a.destination;
            while (buffers.length > 0) {
                var buffer = buffers.shift();
                if (buffer.length > 0) {
                    destination.next(buffer);
                }
            }
            _super.prototype._complete.call(this);
        };
        return BufferSkipCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
    var Context = /*@__PURE__*/ (function () {
        function Context() {
            this.buffer = [];
        }
        return Context;
    }());
    var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferTimeSubscriber, _super);
        function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.bufferTimeSpan = bufferTimeSpan;
            _this.bufferCreationInterval = bufferCreationInterval;
            _this.maxBufferSize = maxBufferSize;
            _this.scheduler = scheduler;
            _this.contexts = [];
            var context = _this.openContext();
            _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
            if (_this.timespanOnly) {
                var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
                _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
            }
            else {
                var closeState = { subscriber: _this, context: context };
                var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
                _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
                _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
            }
            return _this;
        }
        BufferTimeSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            var filledBufferContext;
            for (var i = 0; i < len; i++) {
                var context_1 = contexts[i];
                var buffer = context_1.buffer;
                buffer.push(value);
                if (buffer.length == this.maxBufferSize) {
                    filledBufferContext = context_1;
                }
            }
            if (filledBufferContext) {
                this.onBufferFull(filledBufferContext);
            }
        };
        BufferTimeSubscriber.prototype._error = function (err) {
            this.contexts.length = 0;
            _super.prototype._error.call(this, err);
        };
        BufferTimeSubscriber.prototype._complete = function () {
            var _a = this, contexts = _a.contexts, destination = _a.destination;
            while (contexts.length > 0) {
                var context_2 = contexts.shift();
                destination.next(context_2.buffer);
            }
            _super.prototype._complete.call(this);
        };
        BufferTimeSubscriber.prototype._unsubscribe = function () {
            this.contexts = null;
        };
        BufferTimeSubscriber.prototype.onBufferFull = function (context) {
            this.closeContext(context);
            var closeAction = context.closeAction;
            closeAction.unsubscribe();
            this.remove(closeAction);
            if (!this.closed && this.timespanOnly) {
                context = this.openContext();
                var bufferTimeSpan = this.bufferTimeSpan;
                var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
                this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
            }
        };
        BufferTimeSubscriber.prototype.openContext = function () {
            var context = new Context();
            this.contexts.push(context);
            return context;
        };
        BufferTimeSubscriber.prototype.closeContext = function (context) {
            this.destination.next(context.buffer);
            var contexts = this.contexts;
            var spliceIndex = contexts ? contexts.indexOf(context) : -1;
            if (spliceIndex >= 0) {
                contexts.splice(contexts.indexOf(context), 1);
            }
        };
        return BufferTimeSubscriber;
    }(Subscriber));
    function dispatchBufferTimeSpanOnly(state) {
        var subscriber = state.subscriber;
        var prevContext = state.context;
        if (prevContext) {
            subscriber.closeContext(prevContext);
        }
        if (!subscriber.closed) {
            state.context = subscriber.openContext();
            state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
        }
    }
    function dispatchBufferCreation(state) {
        var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
        var context = subscriber.openContext();
        var action = this;
        if (!subscriber.closed) {
            subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
            action.schedule(state, bufferCreationInterval);
        }
    }
    function dispatchBufferClose(arg) {
        var subscriber = arg.subscriber, context = arg.context;
        subscriber.closeContext(context);
    }

    /** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
    var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferToggleSubscriber, _super);
        function BufferToggleSubscriber(destination, openings, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.openings = openings;
            _this.closingSelector = closingSelector;
            _this.contexts = [];
            _this.add(subscribeToResult(_this, openings));
            return _this;
        }
        BufferToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].buffer.push(value);
            }
        };
        BufferToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            while (contexts.length > 0) {
                var context_1 = contexts.shift();
                context_1.subscription.unsubscribe();
                context_1.buffer = null;
                context_1.subscription = null;
            }
            this.contexts = null;
            _super.prototype._error.call(this, err);
        };
        BufferToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            while (contexts.length > 0) {
                var context_2 = contexts.shift();
                this.destination.next(context_2.buffer);
                context_2.subscription.unsubscribe();
                context_2.buffer = null;
                context_2.subscription = null;
            }
            this.contexts = null;
            _super.prototype._complete.call(this);
        };
        BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
        };
        BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
            this.closeBuffer(innerSub.context);
        };
        BufferToggleSubscriber.prototype.openBuffer = function (value) {
            try {
                var closingSelector = this.closingSelector;
                var closingNotifier = closingSelector.call(this, value);
                if (closingNotifier) {
                    this.trySubscribe(closingNotifier);
                }
            }
            catch (err) {
                this._error(err);
            }
        };
        BufferToggleSubscriber.prototype.closeBuffer = function (context) {
            var contexts = this.contexts;
            if (contexts && context) {
                var buffer = context.buffer, subscription = context.subscription;
                this.destination.next(buffer);
                contexts.splice(contexts.indexOf(context), 1);
                this.remove(subscription);
                subscription.unsubscribe();
            }
        };
        BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
            var contexts = this.contexts;
            var buffer = [];
            var subscription = new Subscription();
            var context = { buffer: buffer, subscription: subscription };
            contexts.push(context);
            var innerSubscription = subscribeToResult(this, closingNotifier, context);
            if (!innerSubscription || innerSubscription.closed) {
                this.closeBuffer(context);
            }
            else {
                innerSubscription.context = context;
                this.add(innerSubscription);
                subscription.add(innerSubscription);
            }
        };
        return BufferToggleSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(BufferWhenSubscriber, _super);
        function BufferWhenSubscriber(destination, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.closingSelector = closingSelector;
            _this.subscribing = false;
            _this.openBuffer();
            return _this;
        }
        BufferWhenSubscriber.prototype._next = function (value) {
            this.buffer.push(value);
        };
        BufferWhenSubscriber.prototype._complete = function () {
            var buffer = this.buffer;
            if (buffer) {
                this.destination.next(buffer);
            }
            _super.prototype._complete.call(this);
        };
        BufferWhenSubscriber.prototype._unsubscribe = function () {
            this.buffer = null;
            this.subscribing = false;
        };
        BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openBuffer();
        };
        BufferWhenSubscriber.prototype.notifyComplete = function () {
            if (this.subscribing) {
                this.complete();
            }
            else {
                this.openBuffer();
            }
        };
        BufferWhenSubscriber.prototype.openBuffer = function () {
            var closingSubscription = this.closingSubscription;
            if (closingSubscription) {
                this.remove(closingSubscription);
                closingSubscription.unsubscribe();
            }
            var buffer = this.buffer;
            if (this.buffer) {
                this.destination.next(buffer);
            }
            this.buffer = [];
            var closingNotifier = tryCatch(this.closingSelector)();
            if (closingNotifier === errorObject) {
                this.error(errorObject.e);
            }
            else {
                closingSubscription = new Subscription();
                this.closingSubscription = closingSubscription;
                this.add(closingSubscription);
                this.subscribing = true;
                closingSubscription.add(subscribeToResult(this, closingNotifier));
                this.subscribing = false;
            }
        };
        return BufferWhenSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var CatchSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(CatchSubscriber, _super);
        function CatchSubscriber(destination, selector, caught) {
            var _this = _super.call(this, destination) || this;
            _this.selector = selector;
            _this.caught = caught;
            return _this;
        }
        CatchSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var result = void 0;
                try {
                    result = this.selector(err, this.caught);
                }
                catch (err2) {
                    _super.prototype.error.call(this, err2);
                    return;
                }
                this._unsubscribeAndRecycle();
                var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
                this.add(innerSubscriber);
                subscribeToResult(this, result, undefined, undefined, innerSubscriber);
            }
        };
        return CatchSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var CountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(CountSubscriber, _super);
        function CountSubscriber(destination, predicate, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.count = 0;
            _this.index = 0;
            return _this;
        }
        CountSubscriber.prototype._next = function (value) {
            if (this.predicate) {
                this._tryPredicate(value);
            }
            else {
                this.count++;
            }
        };
        CountSubscriber.prototype._tryPredicate = function (value) {
            var result;
            try {
                result = this.predicate(value, this.index++, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.count++;
            }
        };
        CountSubscriber.prototype._complete = function () {
            this.destination.next(this.count);
            this.destination.complete();
        };
        return CountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DebounceSubscriber, _super);
        function DebounceSubscriber(destination, durationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.durationSelector = durationSelector;
            _this.hasValue = false;
            _this.durationSubscription = null;
            return _this;
        }
        DebounceSubscriber.prototype._next = function (value) {
            try {
                var result = this.durationSelector.call(this, value);
                if (result) {
                    this._tryNext(value, result);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        DebounceSubscriber.prototype._complete = function () {
            this.emitValue();
            this.destination.complete();
        };
        DebounceSubscriber.prototype._tryNext = function (value, duration) {
            var subscription = this.durationSubscription;
            this.value = value;
            this.hasValue = true;
            if (subscription) {
                subscription.unsubscribe();
                this.remove(subscription);
            }
            subscription = subscribeToResult(this, duration);
            if (subscription && !subscription.closed) {
                this.add(this.durationSubscription = subscription);
            }
        };
        DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.emitValue();
        };
        DebounceSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
        };
        DebounceSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
                var value = this.value;
                var subscription = this.durationSubscription;
                if (subscription) {
                    this.durationSubscription = null;
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
                this.value = null;
                this.hasValue = false;
                _super.prototype._next.call(this, value);
            }
        };
        return DebounceSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
    var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DebounceTimeSubscriber, _super);
        function DebounceTimeSubscriber(destination, dueTime, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.dueTime = dueTime;
            _this.scheduler = scheduler;
            _this.debouncedSubscription = null;
            _this.lastValue = null;
            _this.hasValue = false;
            return _this;
        }
        DebounceTimeSubscriber.prototype._next = function (value) {
            this.clearDebounce();
            this.lastValue = value;
            this.hasValue = true;
            this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
        };
        DebounceTimeSubscriber.prototype._complete = function () {
            this.debouncedNext();
            this.destination.complete();
        };
        DebounceTimeSubscriber.prototype.debouncedNext = function () {
            this.clearDebounce();
            if (this.hasValue) {
                var lastValue = this.lastValue;
                this.lastValue = null;
                this.hasValue = false;
                this.destination.next(lastValue);
            }
        };
        DebounceTimeSubscriber.prototype.clearDebounce = function () {
            var debouncedSubscription = this.debouncedSubscription;
            if (debouncedSubscription !== null) {
                this.remove(debouncedSubscription);
                debouncedSubscription.unsubscribe();
                this.debouncedSubscription = null;
            }
        };
        return DebounceTimeSubscriber;
    }(Subscriber));
    function dispatchNext$2(subscriber) {
        subscriber.debouncedNext();
    }

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DefaultIfEmptySubscriber, _super);
        function DefaultIfEmptySubscriber(destination, defaultValue) {
            var _this = _super.call(this, destination) || this;
            _this.defaultValue = defaultValue;
            _this.isEmpty = true;
            return _this;
        }
        DefaultIfEmptySubscriber.prototype._next = function (value) {
            this.isEmpty = false;
            this.destination.next(value);
        };
        DefaultIfEmptySubscriber.prototype._complete = function () {
            if (this.isEmpty) {
                this.destination.next(this.defaultValue);
            }
            this.destination.complete();
        };
        return DefaultIfEmptySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
    var DelaySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DelaySubscriber, _super);
        function DelaySubscriber(destination, delay, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.delay = delay;
            _this.scheduler = scheduler;
            _this.queue = [];
            _this.active = false;
            _this.errored = false;
            return _this;
        }
        DelaySubscriber.dispatch = function (state) {
            var source = state.source;
            var queue = source.queue;
            var scheduler = state.scheduler;
            var destination = state.destination;
            while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
                queue.shift().notification.observe(destination);
            }
            if (queue.length > 0) {
                var delay_1 = Math.max(0, queue[0].time - scheduler.now());
                this.schedule(state, delay_1);
            }
            else {
                this.unsubscribe();
                source.active = false;
            }
        };
        DelaySubscriber.prototype._schedule = function (scheduler) {
            this.active = true;
            var destination = this.destination;
            destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
                source: this, destination: this.destination, scheduler: scheduler
            }));
        };
        DelaySubscriber.prototype.scheduleNotification = function (notification) {
            if (this.errored === true) {
                return;
            }
            var scheduler = this.scheduler;
            var message = new DelayMessage(scheduler.now() + this.delay, notification);
            this.queue.push(message);
            if (this.active === false) {
                this._schedule(scheduler);
            }
        };
        DelaySubscriber.prototype._next = function (value) {
            this.scheduleNotification(Notification.createNext(value));
        };
        DelaySubscriber.prototype._error = function (err) {
            this.errored = true;
            this.queue = [];
            this.destination.error(err);
            this.unsubscribe();
        };
        DelaySubscriber.prototype._complete = function () {
            this.scheduleNotification(Notification.createComplete());
            this.unsubscribe();
        };
        return DelaySubscriber;
    }(Subscriber));
    var DelayMessage = /*@__PURE__*/ (function () {
        function DelayMessage(time, notification) {
            this.time = time;
            this.notification = notification;
        }
        return DelayMessage;
    }());

    /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DelayWhenSubscriber, _super);
        function DelayWhenSubscriber(destination, delayDurationSelector) {
            var _this = _super.call(this, destination) || this;
            _this.delayDurationSelector = delayDurationSelector;
            _this.completed = false;
            _this.delayNotifierSubscriptions = [];
            _this.index = 0;
            return _this;
        }
        DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(outerValue);
            this.removeSubscription(innerSub);
            this.tryComplete();
        };
        DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            var value = this.removeSubscription(innerSub);
            if (value) {
                this.destination.next(value);
            }
            this.tryComplete();
        };
        DelayWhenSubscriber.prototype._next = function (value) {
            var index = this.index++;
            try {
                var delayNotifier = this.delayDurationSelector(value, index);
                if (delayNotifier) {
                    this.tryDelay(delayNotifier, value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        DelayWhenSubscriber.prototype._complete = function () {
            this.completed = true;
            this.tryComplete();
            this.unsubscribe();
        };
        DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
            subscription.unsubscribe();
            var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
            if (subscriptionIdx !== -1) {
                this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            }
            return subscription.outerValue;
        };
        DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
            var notifierSubscription = subscribeToResult(this, delayNotifier, value);
            if (notifierSubscription && !notifierSubscription.closed) {
                var destination = this.destination;
                destination.add(notifierSubscription);
                this.delayNotifierSubscriptions.push(notifierSubscription);
            }
        };
        DelayWhenSubscriber.prototype.tryComplete = function () {
            if (this.completed && this.delayNotifierSubscriptions.length === 0) {
                this.destination.complete();
            }
        };
        return DelayWhenSubscriber;
    }(OuterSubscriber));
    var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
        __extends(SubscriptionDelayObservable, _super);
        function SubscriptionDelayObservable(source, subscriptionDelay) {
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.subscriptionDelay = subscriptionDelay;
            return _this;
        }
        SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
            this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
        };
        return SubscriptionDelayObservable;
    }(Observable));
    var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SubscriptionDelaySubscriber, _super);
        function SubscriptionDelaySubscriber(parent, source) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this.source = source;
            _this.sourceSubscribed = false;
            return _this;
        }
        SubscriptionDelaySubscriber.prototype._next = function (unused) {
            this.subscribeToSource();
        };
        SubscriptionDelaySubscriber.prototype._error = function (err) {
            this.unsubscribe();
            this.parent.error(err);
        };
        SubscriptionDelaySubscriber.prototype._complete = function () {
            this.unsubscribe();
            this.subscribeToSource();
        };
        SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
            if (!this.sourceSubscribed) {
                this.sourceSubscribed = true;
                this.unsubscribe();
                this.source.subscribe(this.parent);
            }
        };
        return SubscriptionDelaySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DeMaterializeSubscriber, _super);
        function DeMaterializeSubscriber(destination) {
            return _super.call(this, destination) || this;
        }
        DeMaterializeSubscriber.prototype._next = function (value) {
            value.observe(this.destination);
        };
        return DeMaterializeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DistinctSubscriber, _super);
        function DistinctSubscriber(destination, keySelector, flushes) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.values = new Set();
            if (flushes) {
                _this.add(subscribeToResult(_this, flushes));
            }
            return _this;
        }
        DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values.clear();
        };
        DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        DistinctSubscriber.prototype._next = function (value) {
            if (this.keySelector) {
                this._useKeySelector(value);
            }
            else {
                this._finalizeNext(value, value);
            }
        };
        DistinctSubscriber.prototype._useKeySelector = function (value) {
            var key;
            var destination = this.destination;
            try {
                key = this.keySelector(value);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            this._finalizeNext(key, value);
        };
        DistinctSubscriber.prototype._finalizeNext = function (key, value) {
            var values = this.values;
            if (!values.has(key)) {
                values.add(key);
                this.destination.next(value);
            }
        };
        return DistinctSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
    var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(DistinctUntilChangedSubscriber, _super);
        function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
            var _this = _super.call(this, destination) || this;
            _this.keySelector = keySelector;
            _this.hasKey = false;
            if (typeof compare === 'function') {
                _this.compare = compare;
            }
            return _this;
        }
        DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
            return x === y;
        };
        DistinctUntilChangedSubscriber.prototype._next = function (value) {
            var keySelector = this.keySelector;
            var key = value;
            if (keySelector) {
                key = tryCatch(this.keySelector)(value);
                if (key === errorObject) {
                    return this.destination.error(errorObject.e);
                }
            }
            var result = false;
            if (this.hasKey) {
                result = tryCatch(this.compare)(this.key, key);
                if (result === errorObject) {
                    return this.destination.error(errorObject.e);
                }
            }
            else {
                this.hasKey = true;
            }
            if (Boolean(result) === false) {
                this.key = key;
                this.destination.next(value);
            }
        };
        return DistinctUntilChangedSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var FilterSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
        }
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
    var TapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TapSubscriber, _super);
        function TapSubscriber(destination, observerOrNext, error, complete) {
            var _this = _super.call(this, destination) || this;
            _this._tapNext = noop$1;
            _this._tapError = noop$1;
            _this._tapComplete = noop$1;
            _this._tapError = error || noop$1;
            _this._tapComplete = complete || noop$1;
            if (isFunction(observerOrNext)) {
                _this._context = _this;
                _this._tapNext = observerOrNext;
            }
            else if (observerOrNext) {
                _this._context = observerOrNext;
                _this._tapNext = observerOrNext.next || noop$1;
                _this._tapError = observerOrNext.error || noop$1;
                _this._tapComplete = observerOrNext.complete || noop$1;
            }
            return _this;
        }
        TapSubscriber.prototype._next = function (value) {
            try {
                this._tapNext.call(this._context, value);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(value);
        };
        TapSubscriber.prototype._error = function (err) {
            try {
                this._tapError.call(this._context, err);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.error(err);
        };
        TapSubscriber.prototype._complete = function () {
            try {
                this._tapComplete.call(this._context);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            return this.destination.complete();
        };
        return TapSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
    function take(count) {
        return function (source) {
            if (count === 0) {
                return empty$1();
            }
            else {
                return source.lift(new TakeOperator(count));
            }
        };
    }
    var TakeOperator = /*@__PURE__*/ (function () {
        function TakeOperator(total) {
            this.total = total;
            if (this.total < 0) {
                throw new ArgumentOutOfRangeError;
            }
        }
        TakeOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeSubscriber(subscriber, this.total));
        };
        return TakeOperator;
    }());
    var TakeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeSubscriber, _super);
        function TakeSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.count = 0;
            return _this;
        }
        TakeSubscriber.prototype._next = function (value) {
            var total = this.total;
            var count = ++this.count;
            if (count <= total) {
                this.destination.next(value);
                if (count === total) {
                    this.destination.complete();
                    this.unsubscribe();
                }
            }
        };
        return TakeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var EverySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(EverySubscriber, _super);
        function EverySubscriber(destination, predicate, thisArg, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.source = source;
            _this.index = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
            this.destination.next(everyValueMatch);
            this.destination.complete();
        };
        EverySubscriber.prototype._next = function (value) {
            var result = false;
            try {
                result = this.predicate.call(this.thisArg, value, this.index++, this.source);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (!result) {
                this.notifyComplete(false);
            }
        };
        EverySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
        };
        return EverySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SwitchFirstSubscriber, _super);
        function SwitchFirstSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasCompleted = false;
            _this.hasSubscription = false;
            return _this;
        }
        SwitchFirstSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
                this.hasSubscription = true;
                this.add(subscribeToResult(this, value));
            }
        };
        SwitchFirstSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
                this.destination.complete();
            }
        };
        SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
            this.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
                this.destination.complete();
            }
        };
        return SwitchFirstSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
    var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ExhaustMapSubscriber, _super);
        function ExhaustMapSubscriber(destination, project) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.hasSubscription = false;
            _this.hasCompleted = false;
            _this.index = 0;
            return _this;
        }
        ExhaustMapSubscriber.prototype._next = function (value) {
            if (!this.hasSubscription) {
                this.tryNext(value);
            }
        };
        ExhaustMapSubscriber.prototype.tryNext = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.hasSubscription = true;
            this._innerSub(result, value, index);
        };
        ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, result, value, index, innerSubscriber);
        };
        ExhaustMapSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (!this.hasSubscription) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        ExhaustMapSubscriber.prototype.notifyError = function (err) {
            this.destination.error(err);
        };
        ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var destination = this.destination;
            destination.remove(innerSub);
            this.hasSubscription = false;
            if (this.hasCompleted) {
                this.destination.complete();
            }
        };
        return ExhaustMapSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ExpandSubscriber, _super);
        function ExpandSubscriber(destination, project, concurrent, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.concurrent = concurrent;
            _this.scheduler = scheduler;
            _this.index = 0;
            _this.active = 0;
            _this.hasCompleted = false;
            if (concurrent < Number.POSITIVE_INFINITY) {
                _this.buffer = [];
            }
            return _this;
        }
        ExpandSubscriber.dispatch = function (arg) {
            var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
            subscriber.subscribeToProjection(result, value, index);
        };
        ExpandSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (destination.closed) {
                this._complete();
                return;
            }
            var index = this.index++;
            if (this.active < this.concurrent) {
                destination.next(value);
                var result = tryCatch(this.project)(value, index);
                if (result === errorObject) {
                    destination.error(errorObject.e);
                }
                else if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            else {
                this.buffer.push(value);
            }
        };
        ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
            this.active++;
            var destination = this.destination;
            destination.add(subscribeToResult(this, result, value, index));
        };
        ExpandSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
            }
            this.unsubscribe();
        };
        ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this._next(innerValue);
        };
        ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            var destination = this.destination;
            destination.remove(innerSub);
            this.active--;
            if (buffer && buffer.length > 0) {
                this._next(buffer.shift());
            }
            if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
            }
        };
        return ExpandSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
    var FinallySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(FinallySubscriber, _super);
        function FinallySubscriber(destination, callback) {
            var _this = _super.call(this, destination) || this;
            _this.add(new Subscription(callback));
            return _this;
        }
        return FinallySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(FindValueSubscriber, _super);
        function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.yieldIndex = yieldIndex;
            _this.thisArg = thisArg;
            _this.index = 0;
            return _this;
        }
        FindValueSubscriber.prototype.notifyComplete = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
            this.unsubscribe();
        };
        FindValueSubscriber.prototype._next = function (value) {
            var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
            var index = this.index++;
            try {
                var result = predicate.call(thisArg || this, value, index, this.source);
                if (result) {
                    this.notifyComplete(this.yieldIndex ? index : value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        FindValueSubscriber.prototype._complete = function () {
            this.notifyComplete(this.yieldIndex ? -1 : undefined);
        };
        return FindValueSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(IgnoreElementsSubscriber, _super);
        function IgnoreElementsSubscriber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgnoreElementsSubscriber.prototype._next = function (unused) {
        };
        return IgnoreElementsSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(IsEmptySubscriber, _super);
        function IsEmptySubscriber(destination) {
            return _super.call(this, destination) || this;
        }
        IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
            var destination = this.destination;
            destination.next(isEmpty);
            destination.complete();
        };
        IsEmptySubscriber.prototype._next = function (value) {
            this.notifyComplete(false);
        };
        IsEmptySubscriber.prototype._complete = function () {
            this.notifyComplete(true);
        };
        return IsEmptySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
    var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeLastSubscriber, _super);
        function TakeLastSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.ring = new Array();
            _this.count = 0;
            return _this;
        }
        TakeLastSubscriber.prototype._next = function (value) {
            var ring = this.ring;
            var total = this.total;
            var count = this.count++;
            if (ring.length < total) {
                ring.push(value);
            }
            else {
                var index = count % total;
                ring[index] = value;
            }
        };
        TakeLastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            var count = this.count;
            if (count > 0) {
                var total = this.count >= this.total ? this.total : this.count;
                var ring = this.ring;
                for (var i = 0; i < total; i++) {
                    var idx = (count++) % total;
                    destination.next(ring[idx]);
                }
            }
            destination.complete();
        };
        return TakeLastSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var MapToSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MapToSubscriber, _super);
        function MapToSubscriber(destination, value) {
            var _this = _super.call(this, destination) || this;
            _this.value = value;
            return _this;
        }
        MapToSubscriber.prototype._next = function (x) {
            this.destination.next(this.value);
        };
        return MapToSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
    var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MaterializeSubscriber, _super);
        function MaterializeSubscriber(destination) {
            return _super.call(this, destination) || this;
        }
        MaterializeSubscriber.prototype._next = function (value) {
            this.destination.next(Notification.createNext(value));
        };
        MaterializeSubscriber.prototype._error = function (err) {
            var destination = this.destination;
            destination.next(Notification.createError(err));
            destination.complete();
        };
        MaterializeSubscriber.prototype._complete = function () {
            var destination = this.destination;
            destination.next(Notification.createComplete());
            destination.complete();
        };
        return MaterializeSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var ScanSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ScanSubscriber, _super);
        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this._seed = _seed;
            _this.hasSeed = hasSeed;
            _this.index = 0;
            return _this;
        }
        Object.defineProperty(ScanSubscriber.prototype, "seed", {
            get: function () {
                return this._seed;
            },
            set: function (value) {
                this.hasSeed = true;
                this._seed = value;
            },
            enumerable: true,
            configurable: true
        });
        ScanSubscriber.prototype._next = function (value) {
            if (!this.hasSeed) {
                this.seed = value;
                this.destination.next(value);
            }
            else {
                return this._tryNext(value);
            }
        };
        ScanSubscriber.prototype._tryNext = function (value) {
            var index = this.index++;
            var result;
            try {
                result = this.accumulator(this.seed, value, index);
            }
            catch (err) {
                this.destination.error(err);
            }
            this.seed = result;
            this.destination.next(result);
        };
        return ScanSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
    var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(MergeScanSubscriber, _super);
        function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this.acc = acc;
            _this.concurrent = concurrent;
            _this.hasValue = false;
            _this.hasCompleted = false;
            _this.buffer = [];
            _this.active = 0;
            _this.index = 0;
            return _this;
        }
        MergeScanSubscriber.prototype._next = function (value) {
            if (this.active < this.concurrent) {
                var index = this.index++;
                var ish = tryCatch(this.accumulator)(this.acc, value);
                var destination = this.destination;
                if (ish === errorObject) {
                    destination.error(errorObject.e);
                }
                else {
                    this.active++;
                    this._innerSub(ish, value, index);
                }
            }
            else {
                this.buffer.push(value);
            }
        };
        MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            subscribeToResult(this, ish, value, index, innerSubscriber);
        };
        MergeScanSubscriber.prototype._complete = function () {
            this.hasCompleted = true;
            if (this.active === 0 && this.buffer.length === 0) {
                if (this.hasValue === false) {
                    this.destination.next(this.acc);
                }
                this.destination.complete();
            }
            this.unsubscribe();
        };
        MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var destination = this.destination;
            this.acc = innerValue;
            this.hasValue = true;
            destination.next(innerValue);
        };
        MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
            var buffer = this.buffer;
            var destination = this.destination;
            destination.remove(innerSub);
            this.active--;
            if (buffer.length > 0) {
                this._next(buffer.shift());
            }
            else if (this.active === 0 && this.hasCompleted) {
                if (this.hasValue === false) {
                    this.destination.next(this.acc);
                }
                this.destination.complete();
            }
        };
        return MergeScanSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(OnErrorResumeNextSubscriber, _super);
        function OnErrorResumeNextSubscriber(destination, nextSources) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.nextSources = nextSources;
            return _this;
        }
        OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
            this.subscribeToNextSource();
        };
        OnErrorResumeNextSubscriber.prototype._error = function (err) {
            this.subscribeToNextSource();
            this.unsubscribe();
        };
        OnErrorResumeNextSubscriber.prototype._complete = function () {
            this.subscribeToNextSource();
            this.unsubscribe();
        };
        OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
            var next = this.nextSources.shift();
            if (next) {
                var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
                var destination = this.destination;
                destination.add(innerSubscriber);
                subscribeToResult(this, next, undefined, undefined, innerSubscriber);
            }
            else {
                this.destination.complete();
            }
        };
        return OnErrorResumeNextSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(PairwiseSubscriber, _super);
        function PairwiseSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.hasPrev = false;
            return _this;
        }
        PairwiseSubscriber.prototype._next = function (value) {
            if (this.hasPrev) {
                this.destination.next([this.prev, value]);
            }
            else {
                this.hasPrev = true;
            }
            this.prev = value;
        };
        return PairwiseSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _map PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
    var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RepeatSubscriber, _super);
        function RepeatSubscriber(destination, count, source) {
            var _this = _super.call(this, destination) || this;
            _this.count = count;
            _this.source = source;
            return _this;
        }
        RepeatSubscriber.prototype.complete = function () {
            if (!this.isStopped) {
                var _a = this, source = _a.source, count = _a.count;
                if (count === 0) {
                    return _super.prototype.complete.call(this);
                }
                else if (count > -1) {
                    this.count = count - 1;
                }
                source.subscribe(this._unsubscribeAndRecycle());
            }
        };
        return RepeatSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RepeatWhenSubscriber, _super);
        function RepeatWhenSubscriber(destination, notifier, source) {
            var _this = _super.call(this, destination) || this;
            _this.notifier = notifier;
            _this.source = source;
            _this.sourceIsBeingSubscribedTo = true;
            return _this;
        }
        RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.sourceIsBeingSubscribedTo = true;
            this.source.subscribe(this);
        };
        RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
            if (this.sourceIsBeingSubscribedTo === false) {
                return _super.prototype.complete.call(this);
            }
        };
        RepeatWhenSubscriber.prototype.complete = function () {
            this.sourceIsBeingSubscribedTo = false;
            if (!this.isStopped) {
                if (!this.retries) {
                    this.subscribeToRetries();
                }
                if (!this.retriesSubscription || this.retriesSubscription.closed) {
                    return _super.prototype.complete.call(this);
                }
                this._unsubscribeAndRecycle();
                this.notifications.next();
            }
        };
        RepeatWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
            if (notifications) {
                notifications.unsubscribe();
                this.notifications = null;
            }
            if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
            }
            this.retries = null;
        };
        RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
            var _unsubscribe = this._unsubscribe;
            this._unsubscribe = null;
            _super.prototype._unsubscribeAndRecycle.call(this);
            this._unsubscribe = _unsubscribe;
            return this;
        };
        RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
            this.notifications = new Subject();
            var retries = tryCatch(this.notifier)(this.notifications);
            if (retries === errorObject) {
                return _super.prototype.complete.call(this);
            }
            this.retries = retries;
            this.retriesSubscription = subscribeToResult(this, retries);
        };
        return RepeatWhenSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var RetrySubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RetrySubscriber, _super);
        function RetrySubscriber(destination, count, source) {
            var _this = _super.call(this, destination) || this;
            _this.count = count;
            _this.source = source;
            return _this;
        }
        RetrySubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _a = this, source = _a.source, count = _a.count;
                if (count === 0) {
                    return _super.prototype.error.call(this, err);
                }
                else if (count > -1) {
                    this.count = count - 1;
                }
                source.subscribe(this._unsubscribeAndRecycle());
            }
        };
        return RetrySubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(RetryWhenSubscriber, _super);
        function RetryWhenSubscriber(destination, notifier, source) {
            var _this = _super.call(this, destination) || this;
            _this.notifier = notifier;
            _this.source = source;
            return _this;
        }
        RetryWhenSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var errors = this.errors;
                var retries = this.retries;
                var retriesSubscription = this.retriesSubscription;
                if (!retries) {
                    errors = new Subject();
                    retries = tryCatch(this.notifier)(errors);
                    if (retries === errorObject) {
                        return _super.prototype.error.call(this, errorObject.e);
                    }
                    retriesSubscription = subscribeToResult(this, retries);
                }
                else {
                    this.errors = null;
                    this.retriesSubscription = null;
                }
                this._unsubscribeAndRecycle();
                this.errors = errors;
                this.retries = retries;
                this.retriesSubscription = retriesSubscription;
                errors.next(err);
            }
        };
        RetryWhenSubscriber.prototype._unsubscribe = function () {
            var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
            if (errors) {
                errors.unsubscribe();
                this.errors = null;
            }
            if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
            }
            this.retries = null;
        };
        RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            var _unsubscribe = this._unsubscribe;
            this._unsubscribe = null;
            this._unsubscribeAndRecycle();
            this._unsubscribe = _unsubscribe;
            this.source.subscribe(this);
        };
        return RetryWhenSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var SampleSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SampleSubscriber, _super);
        function SampleSubscriber() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.hasValue = false;
            return _this;
        }
        SampleSubscriber.prototype._next = function (value) {
            this.value = value;
            this.hasValue = true;
        };
        SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.emitValue();
        };
        SampleSubscriber.prototype.notifyComplete = function () {
            this.emitValue();
        };
        SampleSubscriber.prototype.emitValue = function () {
            if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.value);
            }
        };
        return SampleSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
    var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SampleTimeSubscriber, _super);
        function SampleTimeSubscriber(destination, period, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.period = period;
            _this.scheduler = scheduler;
            _this.hasValue = false;
            _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
            return _this;
        }
        SampleTimeSubscriber.prototype._next = function (value) {
            this.lastValue = value;
            this.hasValue = true;
        };
        SampleTimeSubscriber.prototype.notifyNext = function () {
            if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.lastValue);
            }
        };
        return SampleTimeSubscriber;
    }(Subscriber));
    function dispatchNotification(state) {
        var subscriber = state.subscriber, period = state.period;
        subscriber.notifyNext();
        this.schedule(state, period);
    }

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
    var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SequenceEqualSubscriber, _super);
        function SequenceEqualSubscriber(destination, compareTo, comparor) {
            var _this = _super.call(this, destination) || this;
            _this.compareTo = compareTo;
            _this.comparor = comparor;
            _this._a = [];
            _this._b = [];
            _this._oneComplete = false;
            _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
            return _this;
        }
        SequenceEqualSubscriber.prototype._next = function (value) {
            if (this._oneComplete && this._b.length === 0) {
                this.emit(false);
            }
            else {
                this._a.push(value);
                this.checkValues();
            }
        };
        SequenceEqualSubscriber.prototype._complete = function () {
            if (this._oneComplete) {
                this.emit(this._a.length === 0 && this._b.length === 0);
            }
            else {
                this._oneComplete = true;
            }
            this.unsubscribe();
        };
        SequenceEqualSubscriber.prototype.checkValues = function () {
            var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
            while (_a.length > 0 && _b.length > 0) {
                var a = _a.shift();
                var b = _b.shift();
                var areEqual = false;
                if (comparor) {
                    areEqual = tryCatch(comparor)(a, b);
                    if (areEqual === errorObject) {
                        this.destination.error(errorObject.e);
                    }
                }
                else {
                    areEqual = a === b;
                }
                if (!areEqual) {
                    this.emit(false);
                }
            }
        };
        SequenceEqualSubscriber.prototype.emit = function (value) {
            var destination = this.destination;
            destination.next(value);
            destination.complete();
        };
        SequenceEqualSubscriber.prototype.nextB = function (value) {
            if (this._oneComplete && this._a.length === 0) {
                this.emit(false);
            }
            else {
                this._b.push(value);
                this.checkValues();
            }
        };
        SequenceEqualSubscriber.prototype.completeB = function () {
            if (this._oneComplete) {
                this.emit(this._a.length === 0 && this._b.length === 0);
            }
            else {
                this._oneComplete = true;
            }
        };
        return SequenceEqualSubscriber;
    }(Subscriber));
    var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SequenceEqualCompareToSubscriber, _super);
        function SequenceEqualCompareToSubscriber(destination, parent) {
            var _this = _super.call(this, destination) || this;
            _this.parent = parent;
            return _this;
        }
        SequenceEqualCompareToSubscriber.prototype._next = function (value) {
            this.parent.nextB(value);
        };
        SequenceEqualCompareToSubscriber.prototype._error = function (err) {
            this.parent.error(err);
            this.unsubscribe();
        };
        SequenceEqualCompareToSubscriber.prototype._complete = function () {
            this.parent.completeB();
            this.unsubscribe();
        };
        return SequenceEqualCompareToSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
    var SingleSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SingleSubscriber, _super);
        function SingleSubscriber(destination, predicate, source) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.source = source;
            _this.seenValue = false;
            _this.index = 0;
            return _this;
        }
        SingleSubscriber.prototype.applySingleValue = function (value) {
            if (this.seenValue) {
                this.destination.error('Sequence contains more than one element');
            }
            else {
                this.seenValue = true;
                this.singleValue = value;
            }
        };
        SingleSubscriber.prototype._next = function (value) {
            var index = this.index++;
            if (this.predicate) {
                this.tryNext(value, index);
            }
            else {
                this.applySingleValue(value);
            }
        };
        SingleSubscriber.prototype.tryNext = function (value, index) {
            try {
                if (this.predicate(value, index, this.source)) {
                    this.applySingleValue(value);
                }
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        SingleSubscriber.prototype._complete = function () {
            var destination = this.destination;
            if (this.index > 0) {
                destination.next(this.seenValue ? this.singleValue : undefined);
                destination.complete();
            }
            else {
                destination.error(new EmptyError);
            }
        };
        return SingleSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var SkipSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SkipSubscriber, _super);
        function SkipSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.count = 0;
            return _this;
        }
        SkipSubscriber.prototype._next = function (x) {
            if (++this.count > this.total) {
                this.destination.next(x);
            }
        };
        return SkipSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
    var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SkipLastSubscriber, _super);
        function SkipLastSubscriber(destination, _skipCount) {
            var _this = _super.call(this, destination) || this;
            _this._skipCount = _skipCount;
            _this._count = 0;
            _this._ring = new Array(_skipCount);
            return _this;
        }
        SkipLastSubscriber.prototype._next = function (value) {
            var skipCount = this._skipCount;
            var count = this._count++;
            if (count < skipCount) {
                this._ring[count] = value;
            }
            else {
                var currentIndex = count % skipCount;
                var ring = this._ring;
                var oldValue = ring[currentIndex];
                ring[currentIndex] = value;
                this.destination.next(oldValue);
            }
        };
        return SkipLastSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SkipUntilSubscriber, _super);
        function SkipUntilSubscriber(destination, notifier) {
            var _this = _super.call(this, destination) || this;
            _this.hasValue = false;
            var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
            _this.add(innerSubscriber);
            _this.innerSubscription = innerSubscriber;
            subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
            return _this;
        }
        SkipUntilSubscriber.prototype._next = function (value) {
            if (this.hasValue) {
                _super.prototype._next.call(this, value);
            }
        };
        SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.hasValue = true;
            if (this.innerSubscription) {
                this.innerSubscription.unsubscribe();
            }
        };
        SkipUntilSubscriber.prototype.notifyComplete = function () {
        };
        return SkipUntilSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SkipWhileSubscriber, _super);
        function SkipWhileSubscriber(destination, predicate) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.skipping = true;
            _this.index = 0;
            return _this;
        }
        SkipWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            if (this.skipping) {
                this.tryCallPredicate(value);
            }
            if (!this.skipping) {
                destination.next(value);
            }
        };
        SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
            try {
                var result = this.predicate(value, this.index++);
                this.skipping = Boolean(result);
            }
            catch (err) {
                this.destination.error(err);
            }
        };
        return SkipWhileSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
    var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
        __extends(SubscribeOnObservable, _super);
        function SubscribeOnObservable(source, delayTime, scheduler) {
            if (delayTime === void 0) {
                delayTime = 0;
            }
            if (scheduler === void 0) {
                scheduler = asap;
            }
            var _this = _super.call(this) || this;
            _this.source = source;
            _this.delayTime = delayTime;
            _this.scheduler = scheduler;
            if (!isNumeric(delayTime) || delayTime < 0) {
                _this.delayTime = 0;
            }
            if (!scheduler || typeof scheduler.schedule !== 'function') {
                _this.scheduler = asap;
            }
            return _this;
        }
        SubscribeOnObservable.create = function (source, delay, scheduler) {
            if (delay === void 0) {
                delay = 0;
            }
            if (scheduler === void 0) {
                scheduler = asap;
            }
            return new SubscribeOnObservable(source, delay, scheduler);
        };
        SubscribeOnObservable.dispatch = function (arg) {
            var source = arg.source, subscriber = arg.subscriber;
            return this.add(source.subscribe(subscriber));
        };
        SubscribeOnObservable.prototype._subscribe = function (subscriber) {
            var delay = this.delayTime;
            var source = this.source;
            var scheduler = this.scheduler;
            return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
                source: source, subscriber: subscriber
            });
        };
        return SubscribeOnObservable;
    }(Observable));

    /** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
    var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(SwitchMapSubscriber, _super);
        function SwitchMapSubscriber(destination, project) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.index = 0;
            return _this;
        }
        SwitchMapSubscriber.prototype._next = function (value) {
            var result;
            var index = this.index++;
            try {
                result = this.project(value, index);
            }
            catch (error) {
                this.destination.error(error);
                return;
            }
            this._innerSub(result, value, index);
        };
        SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
            var innerSubscription = this.innerSubscription;
            if (innerSubscription) {
                innerSubscription.unsubscribe();
            }
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            this.innerSubscription = subscribeToResult(this, result, value, index, innerSubscriber);
        };
        SwitchMapSubscriber.prototype._complete = function () {
            var innerSubscription = this.innerSubscription;
            if (!innerSubscription || innerSubscription.closed) {
                _super.prototype._complete.call(this);
            }
            this.unsubscribe();
        };
        SwitchMapSubscriber.prototype._unsubscribe = function () {
            this.innerSubscription = null;
        };
        SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
            var destination = this.destination;
            destination.remove(innerSub);
            this.innerSubscription = null;
            if (this.isStopped) {
                _super.prototype._complete.call(this);
            }
        };
        SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.destination.next(innerValue);
        };
        return SwitchMapSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeUntilSubscriber, _super);
        function TakeUntilSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.seenValue = false;
            return _this;
        }
        TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.seenValue = true;
            this.complete();
        };
        TakeUntilSubscriber.prototype.notifyComplete = function () {
        };
        return TakeUntilSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
    var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TakeWhileSubscriber, _super);
        function TakeWhileSubscriber(destination, predicate) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.index = 0;
            return _this;
        }
        TakeWhileSubscriber.prototype._next = function (value) {
            var destination = this.destination;
            var result;
            try {
                result = this.predicate(value, this.index++);
            }
            catch (err) {
                destination.error(err);
                return;
            }
            this.nextOrComplete(value, result);
        };
        TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
            var destination = this.destination;
            if (Boolean(predicateResult)) {
                destination.next(value);
            }
            else {
                destination.complete();
            }
        };
        return TakeWhileSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ThrottleSubscriber, _super);
        function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.durationSelector = durationSelector;
            _this._leading = _leading;
            _this._trailing = _trailing;
            _this._hasValue = false;
            return _this;
        }
        ThrottleSubscriber.prototype._next = function (value) {
            this._hasValue = true;
            this._sendValue = value;
            if (!this._throttled) {
                if (this._leading) {
                    this.send();
                }
                else {
                    this.throttle(value);
                }
            }
        };
        ThrottleSubscriber.prototype.send = function () {
            var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
            if (_hasValue) {
                this.destination.next(_sendValue);
                this.throttle(_sendValue);
            }
            this._hasValue = false;
            this._sendValue = null;
        };
        ThrottleSubscriber.prototype.throttle = function (value) {
            var duration = this.tryDurationSelector(value);
            if (duration) {
                this.add(this._throttled = subscribeToResult(this, duration));
            }
        };
        ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
            try {
                return this.durationSelector(value);
            }
            catch (err) {
                this.destination.error(err);
                return null;
            }
        };
        ThrottleSubscriber.prototype.throttlingDone = function () {
            var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
            if (_throttled) {
                _throttled.unsubscribe();
            }
            this._throttled = null;
            if (_trailing) {
                this.send();
            }
        };
        ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.throttlingDone();
        };
        ThrottleSubscriber.prototype.notifyComplete = function () {
            this.throttlingDone();
        };
        return ThrottleSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
    var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(ThrottleTimeSubscriber, _super);
        function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
            var _this = _super.call(this, destination) || this;
            _this.duration = duration;
            _this.scheduler = scheduler;
            _this.leading = leading;
            _this.trailing = trailing;
            _this._hasTrailingValue = false;
            _this._trailingValue = null;
            return _this;
        }
        ThrottleTimeSubscriber.prototype._next = function (value) {
            if (this.throttled) {
                if (this.trailing) {
                    this._trailingValue = value;
                    this._hasTrailingValue = true;
                }
            }
            else {
                this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
                if (this.leading) {
                    this.destination.next(value);
                }
            }
        };
        ThrottleTimeSubscriber.prototype._complete = function () {
            if (this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this.destination.complete();
            }
            else {
                this.destination.complete();
            }
        };
        ThrottleTimeSubscriber.prototype.clearThrottle = function () {
            var throttled = this.throttled;
            if (throttled) {
                if (this.trailing && this._hasTrailingValue) {
                    this.destination.next(this._trailingValue);
                    this._trailingValue = null;
                    this._hasTrailingValue = false;
                }
                throttled.unsubscribe();
                this.remove(throttled);
                this.throttled = null;
            }
        };
        return ThrottleTimeSubscriber;
    }(Subscriber));
    function dispatchNext$3(arg) {
        var subscriber = arg.subscriber;
        subscriber.clearThrottle();
    }

    /** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(TimeoutWithSubscriber, _super);
        function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.absoluteTimeout = absoluteTimeout;
            _this.waitFor = waitFor;
            _this.withObservable = withObservable;
            _this.scheduler = scheduler;
            _this.action = null;
            _this.scheduleTimeout();
            return _this;
        }
        TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
            var withObservable = subscriber.withObservable;
            subscriber._unsubscribeAndRecycle();
            subscriber.add(subscribeToResult(subscriber, withObservable));
        };
        TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
            var action = this.action;
            if (action) {
                this.action = action.schedule(this, this.waitFor);
            }
            else {
                this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
            }
        };
        TimeoutWithSubscriber.prototype._next = function (value) {
            if (!this.absoluteTimeout) {
                this.scheduleTimeout();
            }
            _super.prototype._next.call(this, value);
        };
        TimeoutWithSubscriber.prototype._unsubscribe = function () {
            this.action = null;
            this.scheduler = null;
            this.withObservable = null;
        };
        return TimeoutWithSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

    /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var WindowSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(WindowSubscriber, _super);
        function WindowSubscriber(destination) {
            var _this = _super.call(this, destination) || this;
            _this.window = new Subject();
            destination.next(_this.window);
            return _this;
        }
        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openWindow();
        };
        WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this._complete();
        };
        WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
        };
        WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
        };
        WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
        };
        WindowSubscriber.prototype._unsubscribe = function () {
            this.window = null;
        };
        WindowSubscriber.prototype.openWindow = function () {
            var prevWindow = this.window;
            if (prevWindow) {
                prevWindow.complete();
            }
            var destination = this.destination;
            var newWindow = this.window = new Subject();
            destination.next(newWindow);
        };
        return WindowSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
    var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(WindowCountSubscriber, _super);
        function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.windowSize = windowSize;
            _this.startWindowEvery = startWindowEvery;
            _this.windows = [new Subject()];
            _this.count = 0;
            destination.next(_this.windows[0]);
            return _this;
        }
        WindowCountSubscriber.prototype._next = function (value) {
            var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
            var destination = this.destination;
            var windowSize = this.windowSize;
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len && !this.closed; i++) {
                windows[i].next(value);
            }
            var c = this.count - windowSize + 1;
            if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
                windows.shift().complete();
            }
            if (++this.count % startWindowEvery === 0 && !this.closed) {
                var window_1 = new Subject();
                windows.push(window_1);
                destination.next(window_1);
            }
        };
        WindowCountSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            if (windows) {
                while (windows.length > 0 && !this.closed) {
                    windows.shift().error(err);
                }
            }
            this.destination.error(err);
        };
        WindowCountSubscriber.prototype._complete = function () {
            var windows = this.windows;
            if (windows) {
                while (windows.length > 0 && !this.closed) {
                    windows.shift().complete();
                }
            }
            this.destination.complete();
        };
        WindowCountSubscriber.prototype._unsubscribe = function () {
            this.count = 0;
            this.windows = null;
        };
        return WindowCountSubscriber;
    }(Subscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
    var CountedSubject = /*@__PURE__*/ (function (_super) {
        __extends(CountedSubject, _super);
        function CountedSubject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._numberOfNextedValues = 0;
            return _this;
        }
        CountedSubject.prototype.next = function (value) {
            this._numberOfNextedValues++;
            _super.prototype.next.call(this, value);
        };
        Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
            get: function () {
                return this._numberOfNextedValues;
            },
            enumerable: true,
            configurable: true
        });
        return CountedSubject;
    }(Subject));
    var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(WindowTimeSubscriber, _super);
        function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.windowTimeSpan = windowTimeSpan;
            _this.windowCreationInterval = windowCreationInterval;
            _this.maxWindowSize = maxWindowSize;
            _this.scheduler = scheduler;
            _this.windows = [];
            var window = _this.openWindow();
            if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                var closeState = { subscriber: _this, window: window, context: null };
                var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
                _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
                _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
            }
            else {
                var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
                _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
            }
            return _this;
        }
        WindowTimeSubscriber.prototype._next = function (value) {
            var windows = this.windows;
            var len = windows.length;
            for (var i = 0; i < len; i++) {
                var window_1 = windows[i];
                if (!window_1.closed) {
                    window_1.next(value);
                    if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                        this.closeWindow(window_1);
                    }
                }
            }
        };
        WindowTimeSubscriber.prototype._error = function (err) {
            var windows = this.windows;
            while (windows.length > 0) {
                windows.shift().error(err);
            }
            this.destination.error(err);
        };
        WindowTimeSubscriber.prototype._complete = function () {
            var windows = this.windows;
            while (windows.length > 0) {
                var window_2 = windows.shift();
                if (!window_2.closed) {
                    window_2.complete();
                }
            }
            this.destination.complete();
        };
        WindowTimeSubscriber.prototype.openWindow = function () {
            var window = new CountedSubject();
            this.windows.push(window);
            var destination = this.destination;
            destination.next(window);
            return window;
        };
        WindowTimeSubscriber.prototype.closeWindow = function (window) {
            window.complete();
            var windows = this.windows;
            windows.splice(windows.indexOf(window), 1);
        };
        return WindowTimeSubscriber;
    }(Subscriber));
    function dispatchWindowTimeSpanOnly(state) {
        var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
        if (window) {
            subscriber.closeWindow(window);
        }
        state.window = subscriber.openWindow();
        this.schedule(state, windowTimeSpan);
    }
    function dispatchWindowCreation(state) {
        var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
        var window = subscriber.openWindow();
        var action = this;
        var context = { action: action, subscription: null };
        var timeSpanState = { subscriber: subscriber, window: window, context: context };
        context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
        action.add(context.subscription);
        action.schedule(state, windowCreationInterval);
    }
    function dispatchWindowClose(state) {
        var subscriber = state.subscriber, window = state.window, context = state.context;
        if (context && context.action && context.subscription) {
            context.action.remove(context.subscription);
        }
        subscriber.closeWindow(window);
    }

    /** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(WindowToggleSubscriber, _super);
        function WindowToggleSubscriber(destination, openings, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.openings = openings;
            _this.closingSelector = closingSelector;
            _this.contexts = [];
            _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
            return _this;
        }
        WindowToggleSubscriber.prototype._next = function (value) {
            var contexts = this.contexts;
            if (contexts) {
                var len = contexts.length;
                for (var i = 0; i < len; i++) {
                    contexts[i].window.next(value);
                }
            }
        };
        WindowToggleSubscriber.prototype._error = function (err) {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context_1 = contexts[index];
                    context_1.window.error(err);
                    context_1.subscription.unsubscribe();
                }
            }
            _super.prototype._error.call(this, err);
        };
        WindowToggleSubscriber.prototype._complete = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context_2 = contexts[index];
                    context_2.window.complete();
                    context_2.subscription.unsubscribe();
                }
            }
            _super.prototype._complete.call(this);
        };
        WindowToggleSubscriber.prototype._unsubscribe = function () {
            var contexts = this.contexts;
            this.contexts = null;
            if (contexts) {
                var len = contexts.length;
                var index = -1;
                while (++index < len) {
                    var context_3 = contexts[index];
                    context_3.window.unsubscribe();
                    context_3.subscription.unsubscribe();
                }
            }
        };
        WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            if (outerValue === this.openings) {
                var closingSelector = this.closingSelector;
                var closingNotifier = tryCatch(closingSelector)(innerValue);
                if (closingNotifier === errorObject) {
                    return this.error(errorObject.e);
                }
                else {
                    var window_1 = new Subject();
                    var subscription = new Subscription();
                    var context_4 = { window: window_1, subscription: subscription };
                    this.contexts.push(context_4);
                    var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
                    if (innerSubscription.closed) {
                        this.closeWindow(this.contexts.length - 1);
                    }
                    else {
                        innerSubscription.context = context_4;
                        subscription.add(innerSubscription);
                    }
                    this.destination.next(window_1);
                }
            }
            else {
                this.closeWindow(this.contexts.indexOf(outerValue));
            }
        };
        WindowToggleSubscriber.prototype.notifyError = function (err) {
            this.error(err);
        };
        WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
            if (inner !== this.openSubscription) {
                this.closeWindow(this.contexts.indexOf(inner.context));
            }
        };
        WindowToggleSubscriber.prototype.closeWindow = function (index) {
            if (index === -1) {
                return;
            }
            var contexts = this.contexts;
            var context = contexts[index];
            var window = context.window, subscription = context.subscription;
            contexts.splice(index, 1);
            window.complete();
            subscription.unsubscribe();
        };
        return WindowToggleSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
        __extends(WindowSubscriber, _super);
        function WindowSubscriber(destination, closingSelector) {
            var _this = _super.call(this, destination) || this;
            _this.destination = destination;
            _this.closingSelector = closingSelector;
            _this.openWindow();
            return _this;
        }
        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.openWindow(innerSub);
        };
        WindowSubscriber.prototype.notifyError = function (error, innerSub) {
            this._error(error);
        };
        WindowSubscriber.prototype.notifyComplete = function (innerSub) {
            this.openWindow(innerSub);
        };
        WindowSubscriber.prototype._next = function (value) {
            this.window.next(value);
        };
        WindowSubscriber.prototype._error = function (err) {
            this.window.error(err);
            this.destination.error(err);
            this.unsubscribeClosingNotification();
        };
        WindowSubscriber.prototype._complete = function () {
            this.window.complete();
            this.destination.complete();
            this.unsubscribeClosingNotification();
        };
        WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
            if (this.closingNotification) {
                this.closingNotification.unsubscribe();
            }
        };
        WindowSubscriber.prototype.openWindow = function (innerSub) {
            if (innerSub === void 0) {
                innerSub = null;
            }
            if (innerSub) {
                this.remove(innerSub);
                innerSub.unsubscribe();
            }
            var prevWindow = this.window;
            if (prevWindow) {
                prevWindow.complete();
            }
            var window = this.window = new Subject();
            this.destination.next(window);
            var closingNotifier = tryCatch(this.closingSelector)();
            if (closingNotifier === errorObject) {
                var err = errorObject.e;
                this.destination.error(err);
                this.window.error(err);
            }
            else {
                this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
            }
        };
        return WindowSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
    var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
        __extends(WithLatestFromSubscriber, _super);
        function WithLatestFromSubscriber(destination, observables, project) {
            var _this = _super.call(this, destination) || this;
            _this.observables = observables;
            _this.project = project;
            _this.toRespond = [];
            var len = observables.length;
            _this.values = new Array(len);
            for (var i = 0; i < len; i++) {
                _this.toRespond.push(i);
            }
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                _this.add(subscribeToResult(_this, observable, observable, i));
            }
            return _this;
        }
        WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
            this.values[outerIndex] = innerValue;
            var toRespond = this.toRespond;
            if (toRespond.length > 0) {
                var found = toRespond.indexOf(outerIndex);
                if (found !== -1) {
                    toRespond.splice(found, 1);
                }
            }
        };
        WithLatestFromSubscriber.prototype.notifyComplete = function () {
        };
        WithLatestFromSubscriber.prototype._next = function (value) {
            if (this.toRespond.length === 0) {
                var args = [value].concat(this.values);
                if (this.project) {
                    this._tryProject(args);
                }
                else {
                    this.destination.next(args);
                }
            }
        };
        WithLatestFromSubscriber.prototype._tryProject = function (args) {
            var result;
            try {
                result = this.project.apply(this, args);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return WithLatestFromSubscriber;
    }(OuterSubscriber));

    /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

    /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

    /** PURE_IMPORTS_START  PURE_IMPORTS_END */

    var options = {
    	java_package: "com.keepkey.deviceprotocol",
    	java_outer_classname: "KeepKeyMessage"
    };
    var nested = {
    	wire_in: {
    		type: "bool",
    		id: 50002,
    		extend: "google.protobuf.EnumValueOptions"
    	},
    	wire_out: {
    		type: "bool",
    		id: 50003,
    		extend: "google.protobuf.EnumValueOptions"
    	},
    	wire_debug_in: {
    		type: "bool",
    		id: 50004,
    		extend: "google.protobuf.EnumValueOptions"
    	},
    	wire_debug_out: {
    		type: "bool",
    		id: 50005,
    		extend: "google.protobuf.EnumValueOptions"
    	},
    	FailureType: {
    		values: {
    			Failure_UnexpectedMessage: 1,
    			Failure_ButtonExpected: 2,
    			Failure_SyntaxError: 3,
    			Failure_ActionCancelled: 4,
    			Failure_PinExpected: 5,
    			Failure_PinCancelled: 6,
    			Failure_PinInvalid: 7,
    			Failure_InvalidSignature: 8,
    			Failure_Other: 9,
    			Failure_NotEnoughFunds: 10,
    			Failure_NotInitialized: 11,
    			Failure_PinMismatch: 12,
    			Failure_FirmwareError: 99
    		}
    	},
    	OutputScriptType: {
    		values: {
    			PAYTOADDRESS: 0,
    			PAYTOSCRIPTHASH: 1,
    			PAYTOMULTISIG: 2,
    			PAYTOOPRETURN: 3,
    			PAYTOWITNESS: 4,
    			PAYTOP2SHWITNESS: 5
    		}
    	},
    	InputScriptType: {
    		values: {
    			SPENDADDRESS: 0,
    			SPENDMULTISIG: 1,
    			EXTERNAL: 2,
    			SPENDWITNESS: 3,
    			SPENDP2SHWITNESS: 4
    		}
    	},
    	RequestType: {
    		values: {
    			TXINPUT: 0,
    			TXOUTPUT: 1,
    			TXMETA: 2,
    			TXFINISHED: 3,
    			TXEXTRADATA: 4
    		}
    	},
    	OutputAddressType: {
    		values: {
    			SPEND: 0,
    			TRANSFER: 1,
    			CHANGE: 2,
    			EXCHANGE: 3
    		}
    	},
    	ButtonRequestType: {
    		values: {
    			ButtonRequest_Other: 1,
    			ButtonRequest_FeeOverThreshold: 2,
    			ButtonRequest_ConfirmOutput: 3,
    			ButtonRequest_ResetDevice: 4,
    			ButtonRequest_ConfirmWord: 5,
    			ButtonRequest_WipeDevice: 6,
    			ButtonRequest_ProtectCall: 7,
    			ButtonRequest_SignTx: 8,
    			ButtonRequest_FirmwareCheck: 9,
    			ButtonRequest_Address: 10,
    			ButtonRequest_FirmwareErase: 11,
    			ButtonRequest_ConfirmTransferToAccount: 12,
    			ButtonRequest_ConfirmTransferToNodePath: 13,
    			ButtonRequest_ChangeLabel: 14,
    			ButtonRequest_ChangeLanguage: 15,
    			ButtonRequest_EnablePassphrase: 16,
    			ButtonRequest_DisablePassphrase: 17,
    			ButtonRequest_EncryptAndSignMessage: 18,
    			ButtonRequest_EncryptMessage: 19,
    			ButtonRequest_ImportPrivateKey: 20,
    			ButtonRequest_ImportRecoverySentence: 21,
    			ButtonRequest_SignIdentity: 22,
    			ButtonRequest_Ping: 23,
    			ButtonRequest_RemovePin: 24,
    			ButtonRequest_ChangePin: 25,
    			ButtonRequest_CreatePin: 26,
    			ButtonRequest_GetEntropy: 27,
    			ButtonRequest_SignMessage: 28,
    			ButtonRequest_ApplyPolicies: 29,
    			ButtonRequest_SignExchange: 30,
    			ButtonRequest_AutoLockDelayMs: 31,
    			ButtonRequest_U2FCounter: 32
    		}
    	},
    	PinMatrixRequestType: {
    		values: {
    			PinMatrixRequestType_Current: 1,
    			PinMatrixRequestType_NewFirst: 2,
    			PinMatrixRequestType_NewSecond: 3
    		}
    	},
    	HDNodeType: {
    		fields: {
    			depth: {
    				rule: "required",
    				type: "uint32",
    				id: 1
    			},
    			fingerprint: {
    				rule: "required",
    				type: "uint32",
    				id: 2
    			},
    			child_num: {
    				rule: "required",
    				type: "uint32",
    				id: 3
    			},
    			chain_code: {
    				rule: "required",
    				type: "bytes",
    				id: 4
    			},
    			private_key: {
    				type: "bytes",
    				id: 5
    			},
    			public_key: {
    				type: "bytes",
    				id: 6
    			}
    		}
    	},
    	HDNodePathType: {
    		fields: {
    			node: {
    				rule: "required",
    				type: "HDNodeType",
    				id: 1
    			},
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 2,
    				options: {
    					packed: false
    				}
    			}
    		}
    	},
    	CoinType: {
    		fields: {
    			coin_name: {
    				type: "string",
    				id: 1
    			},
    			coin_shortcut: {
    				type: "string",
    				id: 2
    			},
    			address_type: {
    				type: "uint32",
    				id: 3,
    				options: {
    					"default": 0
    				}
    			},
    			maxfee_kb: {
    				type: "uint64",
    				id: 4
    			},
    			address_type_p2sh: {
    				type: "uint32",
    				id: 5,
    				options: {
    					"default": 5
    				}
    			},
    			address_type_p2wpkh: {
    				type: "uint32",
    				id: 6,
    				options: {
    					"default": 6
    				}
    			},
    			address_type_p2wsh: {
    				type: "uint32",
    				id: 7,
    				options: {
    					"default": 10
    				}
    			},
    			signed_message_header: {
    				type: "string",
    				id: 8
    			},
    			bip44_account_path: {
    				type: "uint32",
    				id: 9
    			},
    			forkid: {
    				type: "uint32",
    				id: 12
    			},
    			decimals: {
    				type: "uint32",
    				id: 13
    			},
    			contract_address: {
    				type: "bytes",
    				id: 14
    			},
    			gas_limit: {
    				type: "bytes",
    				id: 15
    			},
    			xpub_magic: {
    				type: "uint32",
    				id: 16,
    				options: {
    					"default": 76067358
    				}
    			},
    			xprv_magic: {
    				type: "uint32",
    				id: 17,
    				options: {
    					"default": 76066276
    				}
    			},
    			segwit: {
    				type: "bool",
    				id: 18
    			},
    			force_bip143: {
    				type: "bool",
    				id: 19
    			},
    			curve_name: {
    				type: "string",
    				id: 20
    			},
    			cashaddr_prefix: {
    				type: "string",
    				id: 21
    			},
    			bech32_prefix: {
    				type: "string",
    				id: 22
    			},
    			decred: {
    				type: "bool",
    				id: 23
    			},
    			version_group_id: {
    				type: "uint32",
    				id: 24
    			},
    			xpub_magic_segwit_p2sh: {
    				type: "uint32",
    				id: 25
    			},
    			xpub_magic_segwit_native: {
    				type: "uint32",
    				id: 26
    			}
    		}
    	},
    	MultisigRedeemScriptType: {
    		fields: {
    			pubkeys: {
    				rule: "repeated",
    				type: "HDNodePathType",
    				id: 1
    			},
    			signatures: {
    				rule: "repeated",
    				type: "bytes",
    				id: 2
    			},
    			m: {
    				type: "uint32",
    				id: 3
    			}
    		}
    	},
    	TxInputType: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			prev_hash: {
    				rule: "required",
    				type: "bytes",
    				id: 2
    			},
    			prev_index: {
    				rule: "required",
    				type: "uint32",
    				id: 3
    			},
    			script_sig: {
    				type: "bytes",
    				id: 4
    			},
    			sequence: {
    				type: "uint32",
    				id: 5,
    				options: {
    					"default": 4294967295
    				}
    			},
    			script_type: {
    				type: "InputScriptType",
    				id: 6,
    				options: {
    					"default": "SPENDADDRESS"
    				}
    			},
    			multisig: {
    				type: "MultisigRedeemScriptType",
    				id: 7
    			},
    			amount: {
    				type: "uint64",
    				id: 8
    			},
    			decred_tree: {
    				type: "uint32",
    				id: 9
    			},
    			decred_script_version: {
    				type: "uint32",
    				id: 10
    			}
    		}
    	},
    	TxOutputType: {
    		fields: {
    			address: {
    				type: "string",
    				id: 1
    			},
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 2,
    				options: {
    					packed: false
    				}
    			},
    			amount: {
    				rule: "required",
    				type: "uint64",
    				id: 3
    			},
    			script_type: {
    				rule: "required",
    				type: "OutputScriptType",
    				id: 4
    			},
    			multisig: {
    				type: "MultisigRedeemScriptType",
    				id: 5
    			},
    			op_return_data: {
    				type: "bytes",
    				id: 6
    			},
    			address_type: {
    				type: "OutputAddressType",
    				id: 7
    			},
    			exchange_type: {
    				type: "ExchangeType",
    				id: 8
    			},
    			decred_script_version: {
    				type: "uint32",
    				id: 9
    			}
    		}
    	},
    	TxOutputBinType: {
    		fields: {
    			amount: {
    				rule: "required",
    				type: "uint64",
    				id: 1
    			},
    			script_pubkey: {
    				rule: "required",
    				type: "bytes",
    				id: 2
    			},
    			decred_script_version: {
    				type: "uint32",
    				id: 3
    			}
    		}
    	},
    	TransactionType: {
    		fields: {
    			version: {
    				type: "uint32",
    				id: 1
    			},
    			inputs: {
    				rule: "repeated",
    				type: "TxInputType",
    				id: 2
    			},
    			bin_outputs: {
    				rule: "repeated",
    				type: "TxOutputBinType",
    				id: 3
    			},
    			outputs: {
    				rule: "repeated",
    				type: "TxOutputType",
    				id: 5
    			},
    			lock_time: {
    				type: "uint32",
    				id: 4
    			},
    			inputs_cnt: {
    				type: "uint32",
    				id: 6
    			},
    			outputs_cnt: {
    				type: "uint32",
    				id: 7
    			},
    			extra_data: {
    				type: "bytes",
    				id: 8
    			},
    			extra_data_len: {
    				type: "uint32",
    				id: 9
    			},
    			expiry: {
    				type: "uint32",
    				id: 10
    			},
    			overwintered: {
    				type: "bool",
    				id: 11
    			}
    		}
    	},
    	RawTransactionType: {
    		fields: {
    			payload: {
    				rule: "required",
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	TxRequestDetailsType: {
    		fields: {
    			request_index: {
    				type: "uint32",
    				id: 1
    			},
    			tx_hash: {
    				type: "bytes",
    				id: 2
    			},
    			extra_data_len: {
    				type: "uint32",
    				id: 3
    			},
    			extra_data_offset: {
    				type: "uint32",
    				id: 4
    			}
    		}
    	},
    	TxRequestSerializedType: {
    		fields: {
    			signature_index: {
    				type: "uint32",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			},
    			serialized_tx: {
    				type: "bytes",
    				id: 3
    			}
    		}
    	},
    	IdentityType: {
    		fields: {
    			proto: {
    				type: "string",
    				id: 1
    			},
    			user: {
    				type: "string",
    				id: 2
    			},
    			host: {
    				type: "string",
    				id: 3
    			},
    			port: {
    				type: "string",
    				id: 4
    			},
    			path: {
    				type: "string",
    				id: 5
    			},
    			index: {
    				type: "uint32",
    				id: 6,
    				options: {
    					"default": 0
    				}
    			}
    		}
    	},
    	PolicyType: {
    		fields: {
    			policy_name: {
    				type: "string",
    				id: 1
    			},
    			enabled: {
    				type: "bool",
    				id: 2
    			}
    		}
    	},
    	ExchangeType: {
    		fields: {
    			signed_exchange_response: {
    				type: "SignedExchangeResponse",
    				id: 1
    			},
    			withdrawal_coin_name: {
    				type: "string",
    				id: 2,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			withdrawal_address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 3,
    				options: {
    					packed: false
    				}
    			},
    			return_address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 4,
    				options: {
    					packed: false
    				}
    			}
    		}
    	},
    	google: {
    		nested: {
    			protobuf: {
    				options: {
    					java_package: "com.google.protobuf",
    					java_outer_classname: "DescriptorProtos",
    					optimize_for: "SPEED"
    				},
    				nested: {
    					FileDescriptorSet: {
    						fields: {
    							file: {
    								rule: "repeated",
    								type: "FileDescriptorProto",
    								id: 1
    							}
    						}
    					},
    					FileDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							"package": {
    								type: "string",
    								id: 2
    							},
    							dependency: {
    								rule: "repeated",
    								type: "string",
    								id: 3
    							},
    							public_dependency: {
    								rule: "repeated",
    								type: "int32",
    								id: 10,
    								options: {
    									packed: false
    								}
    							},
    							weak_dependency: {
    								rule: "repeated",
    								type: "int32",
    								id: 11,
    								options: {
    									packed: false
    								}
    							},
    							message_type: {
    								rule: "repeated",
    								type: "DescriptorProto",
    								id: 4
    							},
    							enum_type: {
    								rule: "repeated",
    								type: "EnumDescriptorProto",
    								id: 5
    							},
    							service: {
    								rule: "repeated",
    								type: "ServiceDescriptorProto",
    								id: 6
    							},
    							extension: {
    								rule: "repeated",
    								type: "FieldDescriptorProto",
    								id: 7
    							},
    							options: {
    								type: "FileOptions",
    								id: 8
    							},
    							source_code_info: {
    								type: "SourceCodeInfo",
    								id: 9
    							}
    						}
    					},
    					DescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							field: {
    								rule: "repeated",
    								type: "FieldDescriptorProto",
    								id: 2
    							},
    							extension: {
    								rule: "repeated",
    								type: "FieldDescriptorProto",
    								id: 6
    							},
    							nested_type: {
    								rule: "repeated",
    								type: "DescriptorProto",
    								id: 3
    							},
    							enum_type: {
    								rule: "repeated",
    								type: "EnumDescriptorProto",
    								id: 4
    							},
    							extension_range: {
    								rule: "repeated",
    								type: "ExtensionRange",
    								id: 5
    							},
    							options: {
    								type: "MessageOptions",
    								id: 7
    							}
    						},
    						nested: {
    							ExtensionRange: {
    								fields: {
    									start: {
    										type: "int32",
    										id: 1
    									},
    									end: {
    										type: "int32",
    										id: 2
    									}
    								}
    							}
    						}
    					},
    					FieldDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							number: {
    								type: "int32",
    								id: 3
    							},
    							label: {
    								type: "Label",
    								id: 4
    							},
    							type: {
    								type: "Type",
    								id: 5
    							},
    							type_name: {
    								type: "string",
    								id: 6
    							},
    							extendee: {
    								type: "string",
    								id: 2
    							},
    							default_value: {
    								type: "string",
    								id: 7
    							},
    							options: {
    								type: "FieldOptions",
    								id: 8
    							}
    						},
    						nested: {
    							Type: {
    								values: {
    									TYPE_DOUBLE: 1,
    									TYPE_FLOAT: 2,
    									TYPE_INT64: 3,
    									TYPE_UINT64: 4,
    									TYPE_INT32: 5,
    									TYPE_FIXED64: 6,
    									TYPE_FIXED32: 7,
    									TYPE_BOOL: 8,
    									TYPE_STRING: 9,
    									TYPE_GROUP: 10,
    									TYPE_MESSAGE: 11,
    									TYPE_BYTES: 12,
    									TYPE_UINT32: 13,
    									TYPE_ENUM: 14,
    									TYPE_SFIXED32: 15,
    									TYPE_SFIXED64: 16,
    									TYPE_SINT32: 17,
    									TYPE_SINT64: 18
    								}
    							},
    							Label: {
    								values: {
    									LABEL_OPTIONAL: 1,
    									LABEL_REQUIRED: 2,
    									LABEL_REPEATED: 3
    								}
    							}
    						}
    					},
    					EnumDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							value: {
    								rule: "repeated",
    								type: "EnumValueDescriptorProto",
    								id: 2
    							},
    							options: {
    								type: "EnumOptions",
    								id: 3
    							}
    						}
    					},
    					EnumValueDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							number: {
    								type: "int32",
    								id: 2
    							},
    							options: {
    								type: "EnumValueOptions",
    								id: 3
    							}
    						}
    					},
    					ServiceDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							method: {
    								rule: "repeated",
    								type: "MethodDescriptorProto",
    								id: 2
    							},
    							options: {
    								type: "ServiceOptions",
    								id: 3
    							}
    						}
    					},
    					MethodDescriptorProto: {
    						fields: {
    							name: {
    								type: "string",
    								id: 1
    							},
    							input_type: {
    								type: "string",
    								id: 2
    							},
    							output_type: {
    								type: "string",
    								id: 3
    							},
    							options: {
    								type: "MethodOptions",
    								id: 4
    							}
    						}
    					},
    					FileOptions: {
    						fields: {
    							java_package: {
    								type: "string",
    								id: 1
    							},
    							java_outer_classname: {
    								type: "string",
    								id: 8
    							},
    							java_multiple_files: {
    								type: "bool",
    								id: 10,
    								options: {
    									"default": false
    								}
    							},
    							java_generate_equals_and_hash: {
    								type: "bool",
    								id: 20,
    								options: {
    									"default": false
    								}
    							},
    							optimize_for: {
    								type: "OptimizeMode",
    								id: 9,
    								options: {
    									"default": "SPEED"
    								}
    							},
    							go_package: {
    								type: "string",
    								id: 11
    							},
    							cc_generic_services: {
    								type: "bool",
    								id: 16,
    								options: {
    									"default": false
    								}
    							},
    							java_generic_services: {
    								type: "bool",
    								id: 17,
    								options: {
    									"default": false
    								}
    							},
    							py_generic_services: {
    								type: "bool",
    								id: 18,
    								options: {
    									"default": false
    								}
    							},
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						],
    						nested: {
    							OptimizeMode: {
    								values: {
    									SPEED: 1,
    									CODE_SIZE: 2,
    									LITE_RUNTIME: 3
    								}
    							}
    						}
    					},
    					MessageOptions: {
    						fields: {
    							message_set_wire_format: {
    								type: "bool",
    								id: 1,
    								options: {
    									"default": false
    								}
    							},
    							no_standard_descriptor_accessor: {
    								type: "bool",
    								id: 2,
    								options: {
    									"default": false
    								}
    							},
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						]
    					},
    					FieldOptions: {
    						fields: {
    							ctype: {
    								type: "CType",
    								id: 1,
    								options: {
    									"default": "STRING"
    								}
    							},
    							packed: {
    								type: "bool",
    								id: 2
    							},
    							lazy: {
    								type: "bool",
    								id: 5,
    								options: {
    									"default": false
    								}
    							},
    							deprecated: {
    								type: "bool",
    								id: 3,
    								options: {
    									"default": false
    								}
    							},
    							experimental_map_key: {
    								type: "string",
    								id: 9
    							},
    							weak: {
    								type: "bool",
    								id: 10,
    								options: {
    									"default": false
    								}
    							},
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						],
    						nested: {
    							CType: {
    								values: {
    									STRING: 0,
    									CORD: 1,
    									STRING_PIECE: 2
    								}
    							}
    						}
    					},
    					EnumOptions: {
    						fields: {
    							allow_alias: {
    								type: "bool",
    								id: 2,
    								options: {
    									"default": true
    								}
    							},
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						]
    					},
    					EnumValueOptions: {
    						fields: {
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						]
    					},
    					ServiceOptions: {
    						fields: {
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						]
    					},
    					MethodOptions: {
    						fields: {
    							uninterpreted_option: {
    								rule: "repeated",
    								type: "UninterpretedOption",
    								id: 999
    							}
    						},
    						extensions: [
    							[
    								1000,
    								536870911
    							]
    						]
    					},
    					UninterpretedOption: {
    						fields: {
    							name: {
    								rule: "repeated",
    								type: "NamePart",
    								id: 2
    							},
    							identifier_value: {
    								type: "string",
    								id: 3
    							},
    							positive_int_value: {
    								type: "uint64",
    								id: 4
    							},
    							negative_int_value: {
    								type: "int64",
    								id: 5
    							},
    							double_value: {
    								type: "double",
    								id: 6
    							},
    							string_value: {
    								type: "bytes",
    								id: 7
    							},
    							aggregate_value: {
    								type: "string",
    								id: 8
    							}
    						},
    						nested: {
    							NamePart: {
    								fields: {
    									name_part: {
    										rule: "required",
    										type: "string",
    										id: 1
    									},
    									is_extension: {
    										rule: "required",
    										type: "bool",
    										id: 2
    									}
    								}
    							}
    						}
    					},
    					SourceCodeInfo: {
    						fields: {
    							location: {
    								rule: "repeated",
    								type: "Location",
    								id: 1
    							}
    						},
    						nested: {
    							Location: {
    								fields: {
    									path: {
    										rule: "repeated",
    										type: "int32",
    										id: 1
    									},
    									span: {
    										rule: "repeated",
    										type: "int32",
    										id: 2
    									},
    									leading_comments: {
    										type: "string",
    										id: 3
    									},
    									trailing_comments: {
    										type: "string",
    										id: 4
    									}
    								}
    							}
    						}
    					}
    				}
    			}
    		}
    	},
    	ExchangeAddress: {
    		fields: {
    			coin_type: {
    				type: "string",
    				id: 1
    			},
    			address: {
    				type: "string",
    				id: 2
    			},
    			dest_tag: {
    				type: "string",
    				id: 3
    			},
    			rs_address: {
    				type: "string",
    				id: 4
    			}
    		}
    	},
    	ExchangeResponseV2: {
    		fields: {
    			deposit_address: {
    				type: "ExchangeAddress",
    				id: 1
    			},
    			deposit_amount: {
    				type: "bytes",
    				id: 2
    			},
    			expiration: {
    				type: "int64",
    				id: 3
    			},
    			quoted_rate: {
    				type: "bytes",
    				id: 4
    			},
    			withdrawal_address: {
    				type: "ExchangeAddress",
    				id: 5
    			},
    			withdrawal_amount: {
    				type: "bytes",
    				id: 6
    			},
    			return_address: {
    				type: "ExchangeAddress",
    				id: 7
    			},
    			api_key: {
    				type: "bytes",
    				id: 8
    			},
    			miner_fee: {
    				type: "bytes",
    				id: 9
    			},
    			order_id: {
    				type: "bytes",
    				id: 10
    			}
    		}
    	},
    	SignedExchangeResponse: {
    		fields: {
    			response: {
    				type: "ExchangeResponse",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			},
    			responseV2: {
    				type: "ExchangeResponseV2",
    				id: 3
    			}
    		}
    	},
    	ExchangeResponse: {
    		fields: {
    			deposit_address: {
    				type: "ExchangeAddress",
    				id: 1
    			},
    			deposit_amount: {
    				type: "uint64",
    				id: 2
    			},
    			expiration: {
    				type: "int64",
    				id: 3
    			},
    			quoted_rate: {
    				type: "uint64",
    				id: 4
    			},
    			withdrawal_address: {
    				type: "ExchangeAddress",
    				id: 5
    			},
    			withdrawal_amount: {
    				type: "uint64",
    				id: 6
    			},
    			return_address: {
    				type: "ExchangeAddress",
    				id: 7
    			},
    			api_key: {
    				type: "bytes",
    				id: 8
    			},
    			miner_fee: {
    				type: "uint64",
    				id: 9
    			},
    			order_id: {
    				type: "bytes",
    				id: 10
    			}
    		}
    	},
    	MessageType: {
    		values: {
    			MessageType_Initialize: 0,
    			MessageType_Ping: 1,
    			MessageType_Success: 2,
    			MessageType_Failure: 3,
    			MessageType_ChangePin: 4,
    			MessageType_WipeDevice: 5,
    			MessageType_FirmwareErase: 6,
    			MessageType_FirmwareUpload: 7,
    			MessageType_GetEntropy: 9,
    			MessageType_Entropy: 10,
    			MessageType_GetPublicKey: 11,
    			MessageType_PublicKey: 12,
    			MessageType_LoadDevice: 13,
    			MessageType_ResetDevice: 14,
    			MessageType_SignTx: 15,
    			MessageType_SimpleSignTx: 16,
    			MessageType_Features: 17,
    			MessageType_PinMatrixRequest: 18,
    			MessageType_PinMatrixAck: 19,
    			MessageType_Cancel: 20,
    			MessageType_TxRequest: 21,
    			MessageType_TxAck: 22,
    			MessageType_CipherKeyValue: 23,
    			MessageType_ClearSession: 24,
    			MessageType_ApplySettings: 25,
    			MessageType_ButtonRequest: 26,
    			MessageType_ButtonAck: 27,
    			MessageType_GetAddress: 29,
    			MessageType_Address: 30,
    			MessageType_EntropyRequest: 35,
    			MessageType_EntropyAck: 36,
    			MessageType_SignMessage: 38,
    			MessageType_VerifyMessage: 39,
    			MessageType_MessageSignature: 40,
    			MessageType_PassphraseRequest: 41,
    			MessageType_PassphraseAck: 42,
    			MessageType_EstimateTxSize: 43,
    			MessageType_TxSize: 44,
    			MessageType_RecoveryDevice: 45,
    			MessageType_WordRequest: 46,
    			MessageType_WordAck: 47,
    			MessageType_CipheredKeyValue: 48,
    			MessageType_EncryptMessage: 49,
    			MessageType_EncryptedMessage: 50,
    			MessageType_DecryptMessage: 51,
    			MessageType_DecryptedMessage: 52,
    			MessageType_SignIdentity: 53,
    			MessageType_SignedIdentity: 54,
    			MessageType_GetFeatures: 55,
    			MessageType_EthereumGetAddress: 56,
    			MessageType_EthereumAddress: 57,
    			MessageType_EthereumSignTx: 58,
    			MessageType_EthereumTxRequest: 59,
    			MessageType_EthereumTxAck: 60,
    			MessageType_CharacterRequest: 80,
    			MessageType_CharacterAck: 81,
    			MessageType_RawTxAck: 82,
    			MessageType_ApplyPolicies: 83,
    			MessageType_FlashHash: 84,
    			MessageType_FlashWrite: 85,
    			MessageType_FlashHashResponse: 86,
    			MessageType_DebugLinkFlashDump: 87,
    			MessageType_DebugLinkFlashDumpResponse: 88,
    			MessageType_SoftReset: 89,
    			MessageType_DebugLinkDecision: 100,
    			MessageType_DebugLinkGetState: 101,
    			MessageType_DebugLinkState: 102,
    			MessageType_DebugLinkStop: 103,
    			MessageType_DebugLinkLog: 104,
    			MessageType_DebugLinkFillConfig: 105,
    			MessageType_GetCoinTable: 106,
    			MessageType_CoinTable: 107,
    			MessageType_EthereumSignMessage: 108,
    			MessageType_EthereumVerifyMessage: 109,
    			MessageType_EthereumMessageSignature: 110
    		}
    	},
    	Initialize: {
    		fields: {
    		}
    	},
    	GetFeatures: {
    		fields: {
    		}
    	},
    	Features: {
    		fields: {
    			vendor: {
    				type: "string",
    				id: 1
    			},
    			major_version: {
    				type: "uint32",
    				id: 2
    			},
    			minor_version: {
    				type: "uint32",
    				id: 3
    			},
    			patch_version: {
    				type: "uint32",
    				id: 4
    			},
    			bootloader_mode: {
    				type: "bool",
    				id: 5
    			},
    			device_id: {
    				type: "string",
    				id: 6
    			},
    			pin_protection: {
    				type: "bool",
    				id: 7
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 8
    			},
    			language: {
    				type: "string",
    				id: 9
    			},
    			label: {
    				type: "string",
    				id: 10
    			},
    			coins: {
    				rule: "repeated",
    				type: "CoinType",
    				id: 11
    			},
    			initialized: {
    				type: "bool",
    				id: 12
    			},
    			revision: {
    				type: "bytes",
    				id: 13
    			},
    			bootloader_hash: {
    				type: "bytes",
    				id: 14
    			},
    			imported: {
    				type: "bool",
    				id: 15
    			},
    			pin_cached: {
    				type: "bool",
    				id: 16
    			},
    			passphrase_cached: {
    				type: "bool",
    				id: 17
    			},
    			policies: {
    				rule: "repeated",
    				type: "PolicyType",
    				id: 18
    			},
    			model: {
    				type: "string",
    				id: 21
    			},
    			firmware_variant: {
    				type: "string",
    				id: 22
    			},
    			firmware_hash: {
    				type: "bytes",
    				id: 23
    			},
    			no_backup: {
    				type: "bool",
    				id: 24
    			}
    		}
    	},
    	GetCoinTable: {
    		fields: {
    			start: {
    				type: "uint32",
    				id: 1
    			},
    			end: {
    				type: "uint32",
    				id: 2
    			}
    		}
    	},
    	CoinTable: {
    		fields: {
    			table: {
    				rule: "repeated",
    				type: "CoinType",
    				id: 1
    			},
    			num_coins: {
    				type: "uint32",
    				id: 2
    			},
    			chunk_size: {
    				type: "uint32",
    				id: 3
    			}
    		}
    	},
    	ClearSession: {
    		fields: {
    		}
    	},
    	ApplySettings: {
    		fields: {
    			language: {
    				type: "string",
    				id: 1
    			},
    			label: {
    				type: "string",
    				id: 2
    			},
    			use_passphrase: {
    				type: "bool",
    				id: 3
    			},
    			auto_lock_delay_ms: {
    				type: "uint32",
    				id: 4
    			},
    			u2f_counter: {
    				type: "uint32",
    				id: 5
    			}
    		}
    	},
    	ChangePin: {
    		fields: {
    			remove: {
    				type: "bool",
    				id: 1
    			}
    		}
    	},
    	Ping: {
    		fields: {
    			message: {
    				type: "string",
    				id: 1
    			},
    			button_protection: {
    				type: "bool",
    				id: 2
    			},
    			pin_protection: {
    				type: "bool",
    				id: 3
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 4
    			}
    		}
    	},
    	Success: {
    		fields: {
    			message: {
    				type: "string",
    				id: 1
    			}
    		}
    	},
    	Failure: {
    		fields: {
    			code: {
    				type: "FailureType",
    				id: 1
    			},
    			message: {
    				type: "string",
    				id: 2
    			}
    		}
    	},
    	ButtonRequest: {
    		fields: {
    			code: {
    				type: "ButtonRequestType",
    				id: 1
    			},
    			data: {
    				type: "string",
    				id: 2
    			}
    		}
    	},
    	ButtonAck: {
    		fields: {
    		}
    	},
    	PinMatrixRequest: {
    		fields: {
    			type: {
    				type: "PinMatrixRequestType",
    				id: 1
    			}
    		}
    	},
    	PinMatrixAck: {
    		fields: {
    			pin: {
    				rule: "required",
    				type: "string",
    				id: 1
    			}
    		}
    	},
    	Cancel: {
    		fields: {
    		}
    	},
    	PassphraseRequest: {
    		fields: {
    		}
    	},
    	PassphraseAck: {
    		fields: {
    			passphrase: {
    				rule: "required",
    				type: "string",
    				id: 1
    			}
    		}
    	},
    	GetEntropy: {
    		fields: {
    			size: {
    				rule: "required",
    				type: "uint32",
    				id: 1
    			}
    		}
    	},
    	Entropy: {
    		fields: {
    			entropy: {
    				rule: "required",
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	GetPublicKey: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			ecdsa_curve_name: {
    				type: "string",
    				id: 2
    			},
    			show_display: {
    				type: "bool",
    				id: 3
    			},
    			coin_name: {
    				type: "string",
    				id: 4,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			script_type: {
    				type: "InputScriptType",
    				id: 5,
    				options: {
    					"default": "SPENDADDRESS"
    				}
    			}
    		}
    	},
    	PublicKey: {
    		fields: {
    			node: {
    				rule: "required",
    				type: "HDNodeType",
    				id: 1
    			},
    			xpub: {
    				type: "string",
    				id: 2
    			}
    		}
    	},
    	GetAddress: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			coin_name: {
    				type: "string",
    				id: 2,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			show_display: {
    				type: "bool",
    				id: 3
    			},
    			multisig: {
    				type: "MultisigRedeemScriptType",
    				id: 4
    			},
    			script_type: {
    				type: "InputScriptType",
    				id: 5,
    				options: {
    					"default": "SPENDADDRESS"
    				}
    			}
    		}
    	},
    	EthereumGetAddress: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			show_display: {
    				type: "bool",
    				id: 2
    			}
    		}
    	},
    	Address: {
    		fields: {
    			address: {
    				rule: "required",
    				type: "string",
    				id: 1
    			}
    		}
    	},
    	EthereumAddress: {
    		fields: {
    			address: {
    				rule: "required",
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	WipeDevice: {
    		fields: {
    		}
    	},
    	LoadDevice: {
    		fields: {
    			mnemonic: {
    				type: "string",
    				id: 1
    			},
    			node: {
    				type: "HDNodeType",
    				id: 2
    			},
    			pin: {
    				type: "string",
    				id: 3
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 4
    			},
    			language: {
    				type: "string",
    				id: 5,
    				options: {
    					"default": "english"
    				}
    			},
    			label: {
    				type: "string",
    				id: 6
    			},
    			skip_checksum: {
    				type: "bool",
    				id: 7
    			},
    			u2f_counter: {
    				type: "uint32",
    				id: 8
    			}
    		}
    	},
    	ResetDevice: {
    		fields: {
    			display_random: {
    				type: "bool",
    				id: 1
    			},
    			strength: {
    				type: "uint32",
    				id: 2,
    				options: {
    					"default": 256
    				}
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 3
    			},
    			pin_protection: {
    				type: "bool",
    				id: 4
    			},
    			language: {
    				type: "string",
    				id: 5,
    				options: {
    					"default": "english"
    				}
    			},
    			label: {
    				type: "string",
    				id: 6
    			},
    			no_backup: {
    				type: "bool",
    				id: 7
    			},
    			auto_lock_delay_ms: {
    				type: "uint32",
    				id: 8
    			}
    		}
    	},
    	EntropyRequest: {
    		fields: {
    		}
    	},
    	EntropyAck: {
    		fields: {
    			entropy: {
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	RecoveryDevice: {
    		fields: {
    			word_count: {
    				type: "uint32",
    				id: 1
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 2
    			},
    			pin_protection: {
    				type: "bool",
    				id: 3
    			},
    			language: {
    				type: "string",
    				id: 4,
    				options: {
    					"default": "english"
    				}
    			},
    			label: {
    				type: "string",
    				id: 5
    			},
    			enforce_wordlist: {
    				type: "bool",
    				id: 6
    			},
    			use_character_cipher: {
    				type: "bool",
    				id: 7
    			},
    			auto_lock_delay_ms: {
    				type: "uint32",
    				id: 8
    			}
    		}
    	},
    	WordRequest: {
    		fields: {
    		}
    	},
    	WordAck: {
    		fields: {
    			word: {
    				rule: "required",
    				type: "string",
    				id: 1
    			}
    		}
    	},
    	CharacterRequest: {
    		fields: {
    			word_pos: {
    				rule: "required",
    				type: "uint32",
    				id: 1
    			},
    			character_pos: {
    				rule: "required",
    				type: "uint32",
    				id: 2
    			}
    		}
    	},
    	CharacterAck: {
    		fields: {
    			character: {
    				type: "string",
    				id: 1
    			},
    			"delete": {
    				type: "bool",
    				id: 2
    			},
    			done: {
    				type: "bool",
    				id: 3
    			}
    		}
    	},
    	SignMessage: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			message: {
    				rule: "required",
    				type: "bytes",
    				id: 2
    			},
    			coin_name: {
    				type: "string",
    				id: 3,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			script_type: {
    				type: "InputScriptType",
    				id: 4,
    				options: {
    					"default": "SPENDADDRESS"
    				}
    			}
    		}
    	},
    	VerifyMessage: {
    		fields: {
    			address: {
    				type: "string",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			},
    			message: {
    				type: "bytes",
    				id: 3
    			},
    			coin_name: {
    				type: "string",
    				id: 4,
    				options: {
    					"default": "Bitcoin"
    				}
    			}
    		}
    	},
    	MessageSignature: {
    		fields: {
    			address: {
    				type: "string",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			}
    		}
    	},
    	EncryptMessage: {
    		fields: {
    			pubkey: {
    				type: "bytes",
    				id: 1
    			},
    			message: {
    				type: "bytes",
    				id: 2
    			},
    			display_only: {
    				type: "bool",
    				id: 3
    			},
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 4,
    				options: {
    					packed: false
    				}
    			},
    			coin_name: {
    				type: "string",
    				id: 5,
    				options: {
    					"default": "Bitcoin"
    				}
    			}
    		}
    	},
    	EncryptedMessage: {
    		fields: {
    			nonce: {
    				type: "bytes",
    				id: 1
    			},
    			message: {
    				type: "bytes",
    				id: 2
    			},
    			hmac: {
    				type: "bytes",
    				id: 3
    			}
    		}
    	},
    	DecryptMessage: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			nonce: {
    				type: "bytes",
    				id: 2
    			},
    			message: {
    				type: "bytes",
    				id: 3
    			},
    			hmac: {
    				type: "bytes",
    				id: 4
    			}
    		}
    	},
    	DecryptedMessage: {
    		fields: {
    			message: {
    				type: "bytes",
    				id: 1
    			},
    			address: {
    				type: "string",
    				id: 2
    			}
    		}
    	},
    	CipherKeyValue: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			key: {
    				type: "string",
    				id: 2
    			},
    			value: {
    				type: "bytes",
    				id: 3
    			},
    			encrypt: {
    				type: "bool",
    				id: 4
    			},
    			ask_on_encrypt: {
    				type: "bool",
    				id: 5
    			},
    			ask_on_decrypt: {
    				type: "bool",
    				id: 6
    			},
    			iv: {
    				type: "bytes",
    				id: 7
    			}
    		}
    	},
    	CipheredKeyValue: {
    		fields: {
    			value: {
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	EstimateTxSize: {
    		fields: {
    			outputs_count: {
    				rule: "required",
    				type: "uint32",
    				id: 1
    			},
    			inputs_count: {
    				rule: "required",
    				type: "uint32",
    				id: 2
    			},
    			coin_name: {
    				type: "string",
    				id: 3,
    				options: {
    					"default": "Bitcoin"
    				}
    			}
    		}
    	},
    	TxSize: {
    		fields: {
    			tx_size: {
    				type: "uint32",
    				id: 1
    			}
    		}
    	},
    	SignTx: {
    		fields: {
    			outputs_count: {
    				rule: "required",
    				type: "uint32",
    				id: 1
    			},
    			inputs_count: {
    				rule: "required",
    				type: "uint32",
    				id: 2
    			},
    			coin_name: {
    				type: "string",
    				id: 3,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			version: {
    				type: "uint32",
    				id: 4,
    				options: {
    					"default": 1
    				}
    			},
    			lock_time: {
    				type: "uint32",
    				id: 5,
    				options: {
    					"default": 0
    				}
    			},
    			expiry: {
    				type: "uint32",
    				id: 6
    			},
    			overwintered: {
    				type: "bool",
    				id: 7
    			},
    			version_group_id: {
    				type: "uint32",
    				id: 8
    			}
    		}
    	},
    	SimpleSignTx: {
    		fields: {
    			inputs: {
    				rule: "repeated",
    				type: "TxInputType",
    				id: 1
    			},
    			outputs: {
    				rule: "repeated",
    				type: "TxOutputType",
    				id: 2
    			},
    			transactions: {
    				rule: "repeated",
    				type: "TransactionType",
    				id: 3
    			},
    			coin_name: {
    				type: "string",
    				id: 4,
    				options: {
    					"default": "Bitcoin"
    				}
    			},
    			version: {
    				type: "uint32",
    				id: 5,
    				options: {
    					"default": 1
    				}
    			},
    			lock_time: {
    				type: "uint32",
    				id: 6,
    				options: {
    					"default": 0
    				}
    			},
    			expiry: {
    				type: "uint32",
    				id: 7
    			},
    			overwintered: {
    				type: "bool",
    				id: 8
    			}
    		}
    	},
    	TxRequest: {
    		fields: {
    			request_type: {
    				type: "RequestType",
    				id: 1
    			},
    			details: {
    				type: "TxRequestDetailsType",
    				id: 2
    			},
    			serialized: {
    				type: "TxRequestSerializedType",
    				id: 3
    			}
    		}
    	},
    	TxAck: {
    		fields: {
    			tx: {
    				type: "TransactionType",
    				id: 1
    			}
    		}
    	},
    	RawTxAck: {
    		fields: {
    			tx: {
    				type: "RawTransactionType",
    				id: 1
    			}
    		}
    	},
    	EthereumSignTx: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			nonce: {
    				type: "bytes",
    				id: 2
    			},
    			gas_price: {
    				type: "bytes",
    				id: 3
    			},
    			gas_limit: {
    				type: "bytes",
    				id: 4
    			},
    			to: {
    				type: "bytes",
    				id: 5
    			},
    			value: {
    				type: "bytes",
    				id: 6
    			},
    			data_initial_chunk: {
    				type: "bytes",
    				id: 7
    			},
    			data_length: {
    				type: "uint32",
    				id: 8
    			},
    			to_address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 9,
    				options: {
    					packed: false
    				}
    			},
    			address_type: {
    				type: "OutputAddressType",
    				id: 10
    			},
    			exchange_type: {
    				type: "ExchangeType",
    				id: 11
    			},
    			chain_id: {
    				type: "uint32",
    				id: 12
    			},
    			token_value: {
    				type: "bytes",
    				id: 100
    			},
    			token_to: {
    				type: "bytes",
    				id: 101
    			},
    			token_shortcut: {
    				type: "string",
    				id: 102
    			},
    			tx_type: {
    				type: "uint32",
    				id: 103
    			}
    		}
    	},
    	EthereumTxRequest: {
    		fields: {
    			data_length: {
    				type: "uint32",
    				id: 1
    			},
    			signature_v: {
    				type: "uint32",
    				id: 2
    			},
    			signature_r: {
    				type: "bytes",
    				id: 3
    			},
    			signature_s: {
    				type: "bytes",
    				id: 4
    			},
    			hash: {
    				type: "bytes",
    				id: 5
    			},
    			signature_der: {
    				type: "bytes",
    				id: 6
    			}
    		}
    	},
    	EthereumTxAck: {
    		fields: {
    			data_chunk: {
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	EthereumSignMessage: {
    		fields: {
    			address_n: {
    				rule: "repeated",
    				type: "uint32",
    				id: 1,
    				options: {
    					packed: false
    				}
    			},
    			message: {
    				rule: "required",
    				type: "bytes",
    				id: 2
    			}
    		}
    	},
    	EthereumVerifyMessage: {
    		fields: {
    			address: {
    				type: "bytes",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			},
    			message: {
    				type: "bytes",
    				id: 3
    			}
    		}
    	},
    	EthereumMessageSignature: {
    		fields: {
    			address: {
    				type: "bytes",
    				id: 1
    			},
    			signature: {
    				type: "bytes",
    				id: 2
    			}
    		}
    	},
    	SignIdentity: {
    		fields: {
    			identity: {
    				type: "IdentityType",
    				id: 1
    			},
    			challenge_hidden: {
    				type: "bytes",
    				id: 2
    			},
    			challenge_visual: {
    				type: "string",
    				id: 3
    			},
    			ecdsa_curve_name: {
    				type: "string",
    				id: 4
    			}
    		}
    	},
    	SignedIdentity: {
    		fields: {
    			address: {
    				type: "string",
    				id: 1
    			},
    			public_key: {
    				type: "bytes",
    				id: 2
    			},
    			signature: {
    				type: "bytes",
    				id: 3
    			}
    		}
    	},
    	ApplyPolicies: {
    		fields: {
    			policy: {
    				rule: "repeated",
    				type: "PolicyType",
    				id: 1
    			}
    		}
    	},
    	FlashHash: {
    		fields: {
    			address: {
    				type: "uint32",
    				id: 1
    			},
    			length: {
    				type: "uint32",
    				id: 2
    			},
    			challenge: {
    				type: "bytes",
    				id: 3
    			}
    		}
    	},
    	FlashWrite: {
    		fields: {
    			address: {
    				type: "uint32",
    				id: 1
    			},
    			data: {
    				type: "bytes",
    				id: 2
    			},
    			erase: {
    				type: "bool",
    				id: 3
    			}
    		}
    	},
    	FlashHashResponse: {
    		fields: {
    			data: {
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	DebugLinkFlashDump: {
    		fields: {
    			address: {
    				type: "uint32",
    				id: 1
    			},
    			length: {
    				type: "uint32",
    				id: 2
    			}
    		}
    	},
    	DebugLinkFlashDumpResponse: {
    		fields: {
    			data: {
    				type: "bytes",
    				id: 1
    			}
    		}
    	},
    	SoftReset: {
    		fields: {
    		}
    	},
    	FirmwareErase: {
    		fields: {
    		}
    	},
    	FirmwareUpload: {
    		fields: {
    			payload_hash: {
    				rule: "required",
    				type: "bytes",
    				id: 1
    			},
    			payload: {
    				rule: "required",
    				type: "bytes",
    				id: 2
    			}
    		}
    	},
    	DebugLinkDecision: {
    		fields: {
    			yes_no: {
    				rule: "required",
    				type: "bool",
    				id: 1
    			}
    		}
    	},
    	DebugLinkGetState: {
    		fields: {
    		}
    	},
    	DebugLinkState: {
    		fields: {
    			layout: {
    				type: "bytes",
    				id: 1
    			},
    			pin: {
    				type: "string",
    				id: 2
    			},
    			matrix: {
    				type: "string",
    				id: 3
    			},
    			mnemonic: {
    				type: "string",
    				id: 4
    			},
    			node: {
    				type: "HDNodeType",
    				id: 5
    			},
    			passphrase_protection: {
    				type: "bool",
    				id: 6
    			},
    			reset_word: {
    				type: "string",
    				id: 7
    			},
    			reset_entropy: {
    				type: "bytes",
    				id: 8
    			},
    			recovery_fake_word: {
    				type: "string",
    				id: 9
    			},
    			recovery_word_pos: {
    				type: "uint32",
    				id: 10
    			},
    			recovery_cipher: {
    				type: "string",
    				id: 11
    			},
    			recovery_auto_completed_word: {
    				type: "string",
    				id: 12
    			},
    			firmware_hash: {
    				type: "bytes",
    				id: 13
    			},
    			storage_hash: {
    				type: "bytes",
    				id: 14
    			}
    		}
    	},
    	DebugLinkStop: {
    		fields: {
    		}
    	},
    	DebugLinkLog: {
    		fields: {
    			level: {
    				type: "uint32",
    				id: 1
    			},
    			bucket: {
    				type: "string",
    				id: 2
    			},
    			text: {
    				type: "string",
    				id: 3
    			}
    		}
    	},
    	DebugLinkFillConfig: {
    		fields: {
    		}
    	}
    };
    var proto$1 = {
    	options: options,
    	nested: nested
    };

    var values = proto$1.nested.MessageType.values;
    var messageTypeRegistry = Object.entries(values).reduce(function (registry, entry) {
        registry[entry[1]] = messages_pb[entry[0].split('_')[1]];
        return registry;
    }, {});

    var values$1 = proto$1.nested.MessageType.values;
    // Map of message type enums to human readable message name
    var messageNameRegistry = Object.entries(values$1).reduce(function (registry, entry) {
        registry[entry[1]] = entry[0].split('_')[1];
        return registry;
    }, {});

    function makeEvent(e) {
        return __assign({ message_type: messageNameRegistry[e.message_enum], date: Date.now() }, e);
    }

    var NO_THROW_CODES = [
        types_pb.FailureType.FAILURE_ACTIONCANCELLED,
        types_pb.FailureType.FAILURE_PINCANCELLED
    ];
    var Device = /** @class */ (function () {
        function Device() {
        }
        // exchange sends a request to the device and streams back the results
        // the MessageType enum numer will be returned in addition to the google-protobuf message
        // based on trezorExchange()
        // in https://github.com/go-ethereum/accounts/usbwallet/trezor.go
        // and https://github.com/solipsis/go-keepkey/blob/master/pkg/keepkey/transport.go#L277
        Device.prototype.exchange = function (msgTypeEnum, msg) {
            return __awaiter(this, void 0, void 0, function () {
                var msgBuffer, responseBuffer, _a, responseTypeEnum, responseMsg, errorResponse, ack, interruptedResponse, interruptedResponse, interruptedResponse;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            msgBuffer = this.toMessageBuffer(msgTypeEnum, msg);
                            return [4 /*yield*/, this.sendRaw(msgBuffer)];
                        case 1:
                            responseBuffer = _b.sent();
                            this.events.emit(String(msgTypeEnum), makeEvent({
                                message_enum: msgTypeEnum,
                                message: msg.toObject(),
                                from_device: false,
                                interface: this.interface
                            }));
                            _a = this.fromMessageBuffer(responseBuffer), responseTypeEnum = _a[0], responseMsg = _a[1];
                            this.events.emit(String(responseTypeEnum), makeEvent({
                                message_enum: responseTypeEnum,
                                message: responseMsg.toObject(),
                                from_device: true,
                                interface: this.interface
                            }));
                            // If error, throw with response message
                            if (responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_FAILURE) {
                                errorResponse = responseMsg;
                                if (!NO_THROW_CODES.includes(errorResponse.getCode()))
                                    throw new Error(errorResponse.getMessage()); // We don't want to throw if cancel actions are user initiated
                            }
                            if (responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_BUTTONREQUEST) {
                                return [2 /*return*/, this.exchange(messages_pb.MessageType.MESSAGETYPE_BUTTONACK, new messages_pb.ButtonAck())];
                            }
                            if (responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_ENTROPYREQUEST) {
                                ack = new messages_pb.EntropyAck();
                                ack.setEntropy(this.getEntropy(32));
                                return [2 /*return*/, this.exchange(messages_pb.MessageType.MESSAGETYPE_ENTROPYACK, ack)];
                            }
                            if (!(responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_PINMATRIXREQUEST)) return [3 /*break*/, 3];
                            return [4 /*yield*/, fromEvent(this.events, 'PINMATRIXACK_INTERRUPT_RESULT').pipe(take(1)).toPromise()];
                        case 2:
                            interruptedResponse = _b.sent();
                            return [2 /*return*/, interruptedResponse];
                        case 3:
                            if (!(responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_PASSPHRASEREQUEST)) return [3 /*break*/, 5];
                            return [4 /*yield*/, fromEvent(this.events, 'PASSPHRASEACK_INTERRUPT_RESULT').pipe(take(1)).toPromise()];
                        case 4:
                            interruptedResponse = _b.sent();
                            return [2 /*return*/, interruptedResponse];
                        case 5:
                            if (!(responseTypeEnum === messages_pb.MessageType.MESSAGETYPE_CHARACTERREQUEST)) return [3 /*break*/, 7];
                            return [4 /*yield*/, fromEvent(this.events, 'CHARACTERACK_INTERRUPT_RESULT').pipe(take(1)).toPromise()];
                        case 6:
                            interruptedResponse = _b.sent();
                            return [2 /*return*/, interruptedResponse];
                        case 7: return [2 /*return*/, [responseTypeEnum, responseMsg]];
                    }
                });
            });
        };
        Device.prototype.toMessageBuffer = function (msgTypeEnum, msg) {
            var messageBuffer = msg.serializeBinary();
            var headerBuffer = new ArrayBuffer(8);
            var headerView = new DataView(headerBuffer);
            headerView.setUint8(0, 0x23);
            headerView.setUint8(1, 0x23);
            headerView.setUint16(2, msgTypeEnum);
            headerView.setUint32(4, messageBuffer.byteLength);
            return bytebuffer.concat([headerView.buffer, messageBuffer]);
        };
        Device.prototype.fromMessageBuffer = function (buff) {
            var dataView = buff.view;
            var typeID = leByteArrayToLong(dataView.slice(3, 5));
            var MessageType = messageTypeRegistry[typeID];
            if (!MessageType) {
                var msg_1 = new messages_pb.Failure();
                msg_1.setCode(types_pb.FailureType.FAILURE_UNEXPECTEDMESSAGE);
                msg_1.setMessage('Unknown message type received');
                return [messages_pb.MessageType.MESSAGETYPE_FAILURE, msg_1];
            }
            var msg = new MessageType();
            var reader = new googleProtobuf.BinaryReader(dataView.slice(9), 0, buff.limit - (9 + 2));
            return [typeID, MessageType.deserializeBinaryFromReader(msg, reader)];
        };
        Device.failureMessageFactory = function (e) {
            var msg = new messages_pb.Failure();
            msg.setCode(types_pb.FailureType.FAILURE_UNEXPECTEDMESSAGE);
            if (typeof e === 'string') {
                msg.setMessage(e);
            }
            else {
                msg.setMessage(String(e));
            }
            return bytebuffer.wrap(msg.serializeBinary());
        };
        return Device;
    }());

    var SEGMENT_SIZE = 63;
    var WebUSBDevice = /** @class */ (function (_super) {
        __extends(WebUSBDevice, _super);
        function WebUSBDevice(config) {
            var _this = _super.call(this) || this;
            _this.interface = 'StandardWebUSB';
            _this.usbDevice = config.usbDevice;
            _this.events = config.events || new eventemitter2.EventEmitter2();
            _this.queue = new pQueue({ concurrency: 1 });
            return _this;
        }
        WebUSBDevice.requestPair = function () {
            return __awaiter(this, void 0, void 0, function () {
                var device;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!window.navigator.usb) {
                                throw new Error('WebUSB is not available in this browser. We recommend trying Chrome.');
                            }
                            return [4 /*yield*/, window.navigator.usb.requestDevice({
                                    filters: [{
                                            vendorId: 0x2b24, productId: 0x0002 // WebUSB
                                        }, {
                                            vendorId: 0x2b24, productId: 0x0001 // HID
                                        }]
                                })];
                        case 1:
                            device = _a.sent();
                            if (device.productId === 1)
                                throw new Error("Firmware v6.1.0 or later is required to use your keepkey with this client. Please update your device.");
                            return [2 /*return*/, device];
                    }
                });
            });
        };
        Object.defineProperty(WebUSBDevice.prototype, "isInitialized", {
            get: function () {
                return this.usbDevice.opened;
            },
            enumerable: true,
            configurable: true
        });
        WebUSBDevice.prototype.initialize = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.usbDevice.open()];
                        case 1:
                            _a.sent();
                            if (!(this.usbDevice.configuration === null)) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.usbDevice.selectConfiguration(1)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [4 /*yield*/, this.usbDevice.claimInterface(0)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        WebUSBDevice.prototype.cancelPending = function () {
            return __awaiter(this, void 0, void 0, function () {
                var cancelMsg, buffer, e_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            console.log('pending', this.queue.pending);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            // If there are no pending commands, we should wait for a read back from the cancel command
                            // Otherwise the pending promise will read the error
                            if (this.queue.pending === 0) {
                                this.queue.add(function () { return _this.read(); }, { priority: 1000 })
                                    .then(function () { return console.log('cancenPending read done'); })
                                    .catch(function (e) { return console.log('cancenPending read failed', e); });
                            }
                            cancelMsg = new messages_pb.Cancel();
                            buffer = this.toMessageBuffer(messages_pb.MessageType.MESSAGETYPE_CANCEL, cancelMsg);
                            return [4 /*yield*/, this.write(buffer)];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            console.error('Cancel Pending Error', e_1);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        WebUSBDevice.prototype.disconnect = function () {
            return __awaiter(this, void 0, void 0, function () {
                var e_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            // If the device is disconnected, this will fail and throw, which is fine.
                            return [4 /*yield*/, this.usbDevice.close()];
                        case 1:
                            // If the device is disconnected, this will fail and throw, which is fine.
                            _a.sent();
                            return [3 /*break*/, 3];
                        case 2:
                            e_2 = _a.sent();
                            console.log('Disconnect Error (Ignored):', e_2);
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        WebUSBDevice.prototype.getEntropy = function (length) {
            if (length === void 0) { length = 64; }
            return window.crypto.getRandomValues(new Uint8Array(length));
        };
        // This must return a tuple of [returnedBuffer, entireBufferThatWasSent], concatenating if
        // buffers were sent in chunks
        WebUSBDevice.prototype.sendRaw = function (buffer) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // Temporarily removing queue to debug overflow error potentially caused by concurrent sends
                    return [2 /*return*/, this.queue.add(function () { return __awaiter(_this, void 0, void 0, function () {
                            var e_3;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 3, , 4]);
                                        return [4 /*yield*/, this.write(buffer)];
                                    case 1:
                                        _a.sent();
                                        return [4 /*yield*/, this.read()];
                                    case 2: return [2 /*return*/, _a.sent()];
                                    case 3:
                                        e_3 = _a.sent();
                                        return [2 /*return*/, Device.failureMessageFactory(e_3)];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); })];
                });
            });
        };
        WebUSBDevice.prototype.write = function (buff) {
            return __awaiter(this, void 0, void 0, function () {
                var i, segment, padding, fragments, fragmentBuffer;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // break frame into segments
                            this.events.emit('write', buff);
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < buff.limit)) return [3 /*break*/, 4];
                            segment = buff.toArrayBuffer().slice(i, i + SEGMENT_SIZE);
                            padding = new Array(SEGMENT_SIZE - segment.byteLength + 1).join('\0');
                            fragments = [];
                            fragments.push([63]);
                            fragments.push(segment);
                            fragments.push(padding);
                            fragmentBuffer = bytebuffer.concat(fragments);
                            return [4 /*yield*/, this.writeChunk(fragmentBuffer)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            i += SEGMENT_SIZE;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        WebUSBDevice.prototype.read = function () {
            return __awaiter(this, void 0, void 0, function () {
                var first, valid, msgLength, buffer, k, offset, next, k, res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.events.emit('reading');
                            return [4 /*yield*/, this.readChunk()
                                // Check that buffer starts with: "?##" [ 0x3f, 0x23, 0x23 ]
                                // "?" = USB marker, "##" = KeepKey magic bytes
                                // Message ID is bytes 4-5. Message length starts at byte 6.
                            ];
                        case 1:
                            first = _a.sent();
                            valid = (first.getUint32(0) & 0xffffff00) === 0x3f232300;
                            msgLength = first.getUint32(5);
                            if (!(valid && msgLength >= 0 && msgLength < 131072)) return [3 /*break*/, 5];
                            buffer = new Uint8Array(9 + 2 + msgLength);
                            for (k = 0; k < first.byteLength; k++) {
                                buffer[k] = first.getUint8(k);
                            }
                            offset = first.byteLength;
                            _a.label = 2;
                        case 2:
                            if (!(offset < buffer.length)) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.readChunk()
                                // Drop USB "?" packet identifier in the first byte
                            ];
                        case 3:
                            next = _a.sent();
                            // Drop USB "?" packet identifier in the first byte
                            for (k = 1; (k < next.byteLength && offset < buffer.length); k++) {
                                buffer[offset] = next.getUint8(k);
                                offset++;
                            }
                            return [3 /*break*/, 2];
                        case 4:
                            res = bytebuffer.wrap(buffer);
                            this.events.emit('read', res);
                            return [2 /*return*/, res];
                        case 5:
                            console.error('Invalid message', { msgLength: msgLength, valid: valid, first: first });
                            throw new Error('Invalid message');
                    }
                });
            });
        };
        WebUSBDevice.prototype.writeChunk = function (buffer) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.usbDevice.transferOut(1, buffer.toArrayBuffer())];
                });
            });
        };
        WebUSBDevice.prototype.readChunk = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.usbDevice.transferIn(1, SEGMENT_SIZE + 1)];
                        case 1:
                            result = _a.sent();
                            if (!(result.status === 'stall')) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.usbDevice.clearHalt('out', 1)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [2 /*return*/, Promise.resolve(result.data)];
                    }
                });
            });
        };
        return WebUSBDevice;
    }(Device));

    var initialKeepKeyArgs = {
        autoButton: false,
        device: null
    };
    var KeepKey = /** @class */ (function () {
        function KeepKey(config) {
            this.autoButton = false;
            var mergedConfig = __assign({}, initialKeepKeyArgs, config);
            this.autoButton = mergedConfig.autoButton;
            this.device = mergedConfig.device;
        }
        KeepKey.withWebUSB = function (webUSBDeviceConfig) {
            return new KeepKey({ autoButton: false, device: new WebUSBDevice(webUSBDeviceConfig) });
        };
        KeepKey.prototype.acknowledgeWithCharacter = function (character) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.acknowledgeWithCharacterProto(character, false, false)];
                });
            });
        };
        KeepKey.prototype.acknowledgeWithCharacterDelete = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.acknowledgeWithCharacterProto('', true, false)];
                });
            });
        };
        KeepKey.prototype.acknowledgeWithCharacterDone = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.acknowledgeWithCharacterProto('', false, true)];
                });
            });
        };
        KeepKey.prototype.acknowledgeWithCharacterProto = function (character, _delete, _done) {
            return __awaiter(this, void 0, void 0, function () {
                var characterAck, _a, typeEnum, response, responseObj;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            characterAck = new messages_pb.CharacterAck();
                            if (character !== '') {
                                characterAck.setCharacter(character);
                            }
                            else if (_delete) {
                                characterAck.setDelete(_delete);
                            }
                            else if (_done) {
                                characterAck.setDone(_done);
                            }
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_CHARACTERACK, characterAck)];
                        case 1:
                            _a = _b.sent(), typeEnum = _a[0], response = _a[1];
                            responseObj = response.toObject();
                            // Emit event to notify clients that a character has been exchanged
                            this.device.events.emit('CHARACTERACK_INTERRUPT_RESULT', typeEnum, response);
                            return [2 /*return*/, [typeEnum, responseObj]];
                    }
                });
            });
        };
        // Send passphrase to the device, this will typically be called in response to a MESSAGETYPE_PASSPHRASEREQUEST event
        KeepKey.prototype.acknowledgeWithPassphrase = function (passphrase) {
            return __awaiter(this, void 0, void 0, function () {
                var passphraseAck, _a, typeEnum, response, responseObj;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            passphraseAck = new messages_pb.PassphraseAck();
                            passphraseAck.setPassphrase(passphrase);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_PASSPHRASEACK, passphraseAck)];
                        case 1:
                            _a = _b.sent(), typeEnum = _a[0], response = _a[1];
                            responseObj = response.toObject();
                            // Emit event to notify clients that passphrase has been exchanged
                            this.device.events.emit('PASSPHRASEACK_INTERRUPT_RESULT', typeEnum, response);
                            return [2 /*return*/, [typeEnum, responseObj]];
                    }
                });
            });
        };
        // Send pin to the device, this will typically be called in response to a MESSAGETYPE_PINMATRIXREQUEST event
        KeepKey.prototype.acknowledgeWithPin = function (pin) {
            return __awaiter(this, void 0, void 0, function () {
                var matrixAck, _a, typeEnum, response, responseObj;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            matrixAck = new messages_pb.PinMatrixAck();
                            matrixAck.setPin(pin);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_PINMATRIXACK, matrixAck)];
                        case 1:
                            _a = _b.sent(), typeEnum = _a[0], response = _a[1];
                            responseObj = response.toObject();
                            // Emit event to notify clients that pin has been exchanged
                            this.device.events.emit('PINMATRIXACK_INTERRUPT_RESULT', typeEnum, response);
                            return [2 /*return*/, [typeEnum, responseObj]];
                    }
                });
            });
        };
        // ApplyPolicy enables or disables a named policy such as "ShapeShift" on the device
        KeepKey.prototype.applyPolicy = function (p) {
            return __awaiter(this, void 0, void 0, function () {
                var policy, applyPolicies;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            policy = new types_pb.PolicyType();
                            policy.setPolicyName(p.policyName);
                            policy.setEnabled(p.enabled);
                            applyPolicies = new messages_pb.ApplyPolicies();
                            applyPolicies.setPolicyList([policy]);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_APPLYPOLICIES, applyPolicies)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // ApplySettings changes the label, language, and enabling/disabling the passphrase
        // The default language is english
        KeepKey.prototype.applySettings = function (s) {
            return __awaiter(this, void 0, void 0, function () {
                var applySettings;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            applySettings = new messages_pb.ApplySettings();
                            if (s.label) {
                                applySettings.setLabel(s.label);
                            }
                            if (s.language) {
                                applySettings.setLanguage(s.language);
                            }
                            if (s.usePassphrase !== undefined) {
                                applySettings.setUsePassphrase(s.usePassphrase);
                            }
                            if (s.autoLockDelayMs) {
                                applySettings.setAutoLockDelayMs(s.autoLockDelayMs);
                            }
                            if (s.u2fCounter) {
                                applySettings.setU2fCounter(s.u2fCounter);
                            }
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_APPLYSETTINGS, applySettings)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // Cancel aborts the last device action that required user interaction
        // It can follow a button request, passphrase request, or pin request
        KeepKey.prototype.cancel = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.device.cancelPending()];
                        case 1:
                            _a.sent();
                            this.device.events.emit('CANCEL_ACTION');
                            return [2 /*return*/];
                    }
                });
            });
        };
        // ChangePin requests setting/changing the pin
        KeepKey.prototype.changePin = function () {
            return __awaiter(this, void 0, void 0, function () {
                var changePin;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            changePin = new messages_pb.ChangePin();
                            // User may be propmpted for button press up to 2 times
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_CHANGEPIN, changePin)];
                        case 1:
                            // User may be propmpted for button press up to 2 times
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // CipherKeyValue encrypts or decrypts a value with a given key, nodepath, and initializationVector
        // This method encrypts if encrypt is true and decrypts if false, the confirm paramater determines wether
        // the user is prompted on the device. See EncryptKeyValue() and DecryptKeyValue() for convenience methods
        // NOTE: If the length of the value in bytes is not divisible by 16 it will be zero padded
        KeepKey.prototype.cipherKeyValue = function (v) {
            return __awaiter(this, void 0, void 0, function () {
                var cipherKeyValue, _a, _, response, value;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            cipherKeyValue = new messages_pb.CipherKeyValue();
                            cipherKeyValue.setAddressNList(v.addressNList);
                            cipherKeyValue.setKey(v.key);
                            cipherKeyValue.setValue(v.value);
                            cipherKeyValue.setEncrypt(v.encrypt);
                            cipherKeyValue.setAskOnEncrypt(v.askOnEncrypt || false);
                            cipherKeyValue.setAskOnDecrypt(v.askOnDecrypt || false);
                            cipherKeyValue.setIv(v.iv || '');
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_CIPHERKEYVALUE, cipherKeyValue)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            value = response.toObject().value;
                            return [2 /*return*/, value];
                    }
                });
            });
        };
        // ClearSession clears cached session values such as the pin and passphrase
        KeepKey.prototype.clearSession = function () {
            return __awaiter(this, void 0, void 0, function () {
                var clearSession;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            clearSession = new messages_pb.ClearSession();
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_CLEARSESSION, clearSession)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // DecryptKeyValue is a convenience method around decrypting with CipherKeyValue().
        // For more granular control of the process use CipherKeyValue()
        KeepKey.prototype.decryptKeyValue = function (v) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.cipherKeyValue(v)];
                });
            });
        };
        // EthereumGetAddress returns the ethereum address associated with the given node path
        // Optionally you can display  the address on the screen
        KeepKey.prototype.ethereumGetAddress = function (a) {
            return __awaiter(this, void 0, void 0, function () {
                var getAddr, _a, _, response, ethAddress;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            getAddr = new messages_pb.EthereumGetAddress();
                            getAddr.setAddressNList(a.addressNList);
                            getAddr.setShowDisplay(a.showDisplay !== false);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_ETHEREUMGETADDRESS, getAddr)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            ethAddress = response;
                            if (ethAddress.hasAddressStr()) {
                                return [2 /*return*/, ethAddress.getAddressStr()];
                            }
                            else if (ethAddress.hasAddress()) {
                                return [2 /*return*/, '0x' + toHexString(ethAddress.getAddress_asU8())];
                            }
                            throw new Error('unable to obtain eth address from device');
                    }
                });
            });
        };
        // Sign an ethereum transaction using a given node path
        // The user may be prompted for a pin and/or passphrase if they are enabled
        KeepKey.prototype.ethereumSignTx = function (tx, addressType, exchangeType, data, chainId) {
            return __awaiter(this, void 0, void 0, function () {
                var est, dataChunk, dataRemaining, response, nextResponse, dataLength;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            est = new messages_pb.EthereumSignTx();
                            if (addressType === types_pb.OutputAddressType.TRANSFER) {
                                throw Error('Not implemented yet.');
                            }
                            else if (addressType === types_pb.OutputAddressType.EXCHANGE) {
                                est.setAddressNList(tx.addressNList);
                                est.setNonce(typeof tx.nonce === 'string' ? arrayify(tx.nonce) : tx.nonce);
                                est.setGasPrice(typeof tx.gasPrice === 'string' ? arrayify(tx.gasPrice) : tx.gasPrice);
                                est.setGasLimit(typeof tx.gasLimit === 'string' ? arrayify(tx.gasLimit) : tx.gasLimit);
                                est.setValue(typeof tx.value === 'string' ? arrayify(tx.value) : tx.value);
                                est.setAddressType(types_pb.OutputAddressType.EXCHANGE);
                                est.setExchangeType(exchangeType);
                            }
                            else {
                                est.setAddressNList(tx.addressNList);
                                est.setNonce(typeof tx.nonce === 'string' ? arrayify(tx.nonce) : tx.nonce);
                                est.setGasPrice(typeof tx.gasPrice === 'string' ? arrayify(tx.gasPrice) : tx.gasPrice);
                                est.setGasLimit(typeof tx.gasLimit === 'string' ? arrayify(tx.gasLimit) : tx.gasLimit);
                                est.setValue(typeof tx.value === 'string' ? arrayify(tx.value) : tx.value);
                                est.setAddressType(types_pb.OutputAddressType.SPEND);
                            }
                            if (tx.to) {
                                if (typeof tx.to === 'string')
                                    est.setTo(arrayify(tx.to));
                                else
                                    est.setTo(tx.to);
                            }
                            dataChunk = null;
                            dataRemaining = typeof data === 'string' ? arrayify(data) : data;
                            if (dataRemaining) {
                                est.setDataLength(dataRemaining.length);
                                dataChunk = dataRemaining.slice(0, 1024);
                                dataRemaining = dataRemaining.slice(dataChunk.length);
                                est.setDataInitialChunk(dataChunk);
                            }
                            if (chainId != null) {
                                est.setChainId(chainId);
                            }
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_ETHEREUMSIGNTX, est)];
                        case 1:
                            nextResponse = _a.sent();
                            response = nextResponse[1];
                            _a.label = 2;
                        case 2:
                            if (!response.hasDataLength()) return [3 /*break*/, 4];
                            dataLength = response.getDataLength();
                            dataChunk = dataRemaining.slice(0, dataLength);
                            dataRemaining = dataRemaining.slice(dataLength, dataRemaining.length);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_ETHEREUMSIGNTX, est)];
                        case 3:
                            nextResponse = _a.sent();
                            response = nextResponse[1];
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/, {
                                r: '0x' + toHexString(response.getSignatureR_asU8()),
                                s: '0x' + toHexString(response.getSignatureS_asU8()),
                                v: '0x' + response.getSignatureV().toString(16)
                            }];
                    }
                });
            });
        };
        KeepKey.prototype.ethereumSignMessage = function (m) {
            return __awaiter(this, void 0, void 0, function () {
                var msg, _a, _, response, sig;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            msg = new messages_pb.EthereumSignMessage();
                            msg.setAddressNList(m.addressNList || bip32ToAddressNList("m/44'/60'/0'/0/0"));
                            msg.setMessage(m.message);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, msg)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            sig = response.toObject();
                            return [2 /*return*/, {
                                    address: sig.address,
                                    signature: sig.signature
                                }];
                    }
                });
            });
        };
        KeepKey.prototype.ethereumVerifyMessage = function (m) {
            return __awaiter(this, void 0, void 0, function () {
                var msg, _a, _, response;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            msg = new messages_pb.EthereumVerifyMessage();
                            msg.setAddress(m.address);
                            msg.setSignature(m.signature);
                            msg.setMessage(m.message);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_ETHEREUMVERIFYMESSAGE, msg)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            return [2 /*return*/, typeof response === typeof messages_pb.Success];
                    }
                });
            });
        };
        // FirmwareErase askes the device to erase its firmware
        KeepKey.prototype.firmwareErase = function () {
            return __awaiter(this, void 0, void 0, function () {
                var firmwareErase;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            firmwareErase = new messages_pb.FirmwareErase();
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_FIRMWAREERASE, firmwareErase)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // Initialize assigns a hid connection to this KeepKey and send initialize message to device
        KeepKey.prototype.initialize = function () {
            return __awaiter(this, void 0, void 0, function () {
                var initialize, _a, _, response, features;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.device.initialize()
                            // send initialize
                        ];
                        case 1:
                            _b.sent();
                            initialize = new messages_pb.Initialize();
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_INITIALIZE, initialize)];
                        case 2:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            features = response.toObject();
                            this.features = features;
                            return [2 /*return*/, features];
                    }
                });
            });
        };
        // GetAddress returns an address string given a node path and a coin type.
        // Optionally you can display the address on the device screen
        // If passphrase is enabled this may request the passphrase.
        KeepKey.prototype.getAddress = function (g) {
            return __awaiter(this, void 0, void 0, function () {
                var address, _a, _, response, msg;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            address = new messages_pb.GetAddress();
                            address.setAddressNList(g.addressNList);
                            address.setCoinName(g.coinName);
                            address.setShowDisplay(g.showDisplay !== false);
                            address.setScriptType(g.scriptType || types_pb.InputScriptType.SPENDADDRESS);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETADDRESS, address)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            msg = response.toObject();
                            return [2 /*return*/, msg.address];
                    }
                });
            });
        };
        // GetFeatures returns the features and other device information such as the version, label, and supported coins
        KeepKey.prototype.getFeatures = function () {
            return __awaiter(this, void 0, void 0, function () {
                var features, _a, _, response;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            features = new messages_pb.GetFeatures();
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETFEATURES, features)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            return [2 /*return*/, response.toObject()];
                    }
                });
            });
        };
        // GetEntropy requests sample data from the hardware RNG
        KeepKey.prototype.getEntropy = function (size) {
            return __awaiter(this, void 0, void 0, function () {
                var getEntropy, _a, _, response, entropy;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            getEntropy = new messages_pb.GetEntropy();
                            getEntropy.setSize(size);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETENTROPY, getEntropy)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            entropy = response.toObject().entropy;
                            return [2 /*return*/, entropy];
                    }
                });
            });
        };
        // GetPublicKey asks the device for a public key corresponding to a nodePath and curve name.
        // Returns the hdnode, the XPUB as a string and a possidble error
        // This may prompt the user for a passphrase
        KeepKey.prototype.getPublicKey = function (g) {
            return __awaiter(this, void 0, void 0, function () {
                var getPublicKey, _a, _, response, publicKey;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            getPublicKey = new messages_pb.GetPublicKey();
                            getPublicKey.setAddressNList(g.addressNList);
                            getPublicKey.setEcdsaCurveName(g.ecdsaCurveName || 'secp256k1');
                            getPublicKey.setShowDisplay(g.showDisplay || false);
                            getPublicKey.setScriptType(g.scriptType || types_pb.InputScriptType.SPENDADDRESS);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETPUBLICKEY, getPublicKey)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            publicKey = response.toObject();
                            return [2 /*return*/, [publicKey.node, publicKey.xpub]];
                    }
                });
            });
        };
        // GetNumCoins returns the number of coins supported by the device regardless of if the hanve funds.
        KeepKey.prototype.getNumCoins = function () {
            return __awaiter(this, void 0, void 0, function () {
                var getCoinTable, _a, _, response;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            getCoinTable = new messages_pb.GetCoinTable();
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETCOINTABLE, getCoinTable)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            return [2 /*return*/, response.getNumCoins()];
                    }
                });
            });
        };
        KeepKey.prototype.getAllCoinsAsMap = function () {
            return __awaiter(this, void 0, void 0, function () {
                var numCoins, coinTable, i, pagedTable;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.getNumCoins()];
                        case 1:
                            numCoins = _a.sent();
                            coinTable = {};
                            i = 0;
                            _a.label = 2;
                        case 2:
                            if (!(i < numCoins)) return [3 /*break*/, 5];
                            return [4 /*yield*/, this.getCoinTable(i, i + Math.min(numCoins - i, 10))];
                        case 3:
                            pagedTable = _a.sent();
                            pagedTable.filter(function (coin) { return !coin.coinShortcut.startsWith(' '); }).forEach(function (coinType) {
                                var symbol = coinType.coinShortcut;
                                coinTable[symbol] = {
                                    coinShortcut: symbol,
                                    bip44AccountPath: coinType.bip44AccountPath,
                                    curveName: coinType.curveName,
                                    coinName: coinType.coinName
                                };
                            });
                            _a.label = 4;
                        case 4:
                            i += 10;
                            return [3 /*break*/, 2];
                        case 5: return [2 /*return*/, coinTable];
                    }
                });
            });
        };
        // GetCoinTable returns an array of Types.CoinTypes, with start and end arguments for paging.
        // You cannot request more than 10 at a time.
        KeepKey.prototype.getCoinTable = function (start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = start + 10; }
            return __awaiter(this, void 0, void 0, function () {
                var getCoinTable, _a, _, response, coinTable;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            getCoinTable = new messages_pb.GetCoinTable();
                            getCoinTable.setStart(start);
                            getCoinTable.setEnd(end);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_GETCOINTABLE, getCoinTable)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            coinTable = response.toObject();
                            return [2 /*return*/, coinTable.tableList];
                    }
                });
            });
        };
        // getCoinShortcutXPubPairs returns an array of [coinShortcut, xPub] pairs
        KeepKey.prototype.getCoinShortcutXPubPairs = function (coinTable) {
            return __awaiter(this, void 0, void 0, function () {
                var publicKeys, pairs;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Promise.all(coinTable.map(function (coinType) { return _this.getPublicKey({
                                addressNList: [2147483648 + 44, coinType.bip44AccountPath, 2147483648]
                            }); }))];
                        case 1:
                            publicKeys = _a.sent();
                            pairs = [];
                            publicKeys.forEach(function (_a, i) {
                                var xPub = _a[1];
                                pairs.push([coinTable[i].coinShortcut, xPub]);
                            });
                            return [2 /*return*/, pairs];
                    }
                });
            });
        };
        // LoadDevice loads a provided seed onto the device and applies the provided settings
        // including setting a pin/device label, enabling/disabling the passphrase, and whether to
        // check the checksum of the provided mnemonic
        KeepKey.prototype.loadDevice = function (l) {
            return __awaiter(this, void 0, void 0, function () {
                var loadDevice;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            loadDevice = new messages_pb.LoadDevice();
                            loadDevice.setMnemonic(l.mnemonic);
                            loadDevice.setPassphraseProtection(l.passphraseProtection || false);
                            loadDevice.setSkipChecksum(l.skipChecksum || true);
                            if (l.pin)
                                loadDevice.setPin(l.pin);
                            if (l.label)
                                loadDevice.setLabel(l.label);
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_LOADDEVICE, loadDevice)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        KeepKey.prototype.recoveryDevice = function (r) {
            return __awaiter(this, void 0, void 0, function () {
                var msg, epoch;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (r.wordCount !== 12 && r.wordCount !== 18 && r.wordCount !== 24) {
                                throw new Error('Invalid word count. Use 12/18/24');
                            }
                            msg = new messages_pb.RecoveryDevice();
                            msg.setWordCount(r.wordCount);
                            msg.setPassphraseProtection(r.passphraseProtection);
                            msg.setPinProtection(r.pinProtection);
                            msg.setLabel(r.label);
                            msg.setLanguage(r.language || 'english');
                            msg.setEnforceWordlist(true);
                            msg.setUseCharacterCipher(true);
                            if (r.autoLockDelayMs) {
                                msg.setAutoLockDelayMs(r.autoLockDelayMs);
                            }
                            epoch = Math.floor(+new Date() / 1000);
                            msg.setU2fCounter(r.u2fCounter || epoch);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_RECOVERYDEVICE, msg)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // Ping the device. If a message is provided it will be shown on the device screen and returned
        // in the success message. Optionally require a button press, pin, or passphrase to continue
        KeepKey.prototype.ping = function (p) {
            return __awaiter(this, void 0, void 0, function () {
                var ping, _a, _, response, message;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            ping = new messages_pb.Ping();
                            ping.setMessage(p.message);
                            ping.setButtonProtection(p.buttonProtection || false);
                            ping.setPinProtection(p.pinProtection || false);
                            ping.setPassphraseProtection(p.passphraseProtection || false);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_PING, ping)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            message = response.toObject().message;
                            return [2 /*return*/, message];
                    }
                });
            });
        };
        KeepKey.prototype.prepareSignTx = function (coinName, inputs, outputs, exchangeOutputs) {
            return __awaiter(this, void 0, void 0, function () {
                var txmap, unsignedTx;
                return __generator(this, function (_a) {
                    txmap = {} // Create a map of transactions by txid needed for the KeepKey signing flow.
                    ;
                    unsignedTx = new types_pb.TransactionType();
                    unsignedTx.setVersion(2);
                    unsignedTx.setInputsCnt(inputs.length);
                    unsignedTx.setOutputsCnt(outputs.length);
                    unsignedTx.setLockTime(0); // TODO: remove?
                    inputs.forEach(function (input, i) {
                        var utxo = new types_pb.TxInputType();
                        utxo.setPrevHash(fromHexString(input.txid));
                        utxo.setPrevIndex(input.vout);
                        // utxo.setSequence(4294967295)  // TODO: check this
                        // utxo.setScriptType(Types.InputScriptType.SPENDADDRESS)  // TODO: handle multisig & segwit
                        utxo.setAddressNList(input.address_n); // bip-32 path to the master key.  TODO: check this
                        utxo.setAmount(input.amount); // Only required by KeepKey for segwit inputs
                        unsignedTx.addInputs(utxo, i);
                    });
                    outputs.forEach(function (output, k) {
                        var newOutput = new types_pb.TxOutputType();
                        newOutput.setAmount(output.amount);
                        newOutput.setScriptType(types_pb.OutputScriptType.PAYTOADDRESS); // TODO: Support all script types. NOTE: Older firmware may require PAYTOSCRIPTHASH.
                        if (exchangeOutputs && exchangeOutputs[k]) {
                            var exchangeOutput = exchangeOutputs[k];
                            // convert the base64 encoded signedExchangeResponse message into the correct object
                            var signedExchange = exchange_pb.SignedExchangeResponse.deserializeBinary(exchangeOutput.signed_exchange_response);
                            // decode the deposit amount from a little-endian Uint8Array into an unsigned uint64
                            var depAmt = signedExchange.getResponsev2().getDepositAmount_asU8();
                            var val = 0;
                            for (var jj = depAmt.length - 1; jj >= 0; jj--) {
                                val += depAmt[jj] * Math.pow(2, (8 * (depAmt.length - jj - 1)));
                                // TODO validate is uint64
                            }
                            var outExchangeType = new types_pb.ExchangeType();
                            outExchangeType.setSignedExchangeResponse(signedExchange);
                            outExchangeType.setWithdrawalCoinName(exchangeOutput.withdrawal_coin_name);
                            outExchangeType.setWithdrawalAddressNList(exchangeOutput.withdrawal_address_n);
                            outExchangeType.setReturnAddressNList(exchangeOutput.return_address_n);
                            newOutput.setAmount(val);
                            newOutput.setAddress(signedExchange.toObject().responsev2.depositAddress.address);
                            newOutput.setScriptType(types_pb.OutputScriptType.PAYTOADDRESS);
                            newOutput.setAddressType(3);
                            newOutput.setExchangeType(outExchangeType);
                        }
                        else if (output.isChange) {
                            newOutput.setAddressNList(output.address_n);
                            newOutput.setAddressType(types_pb.OutputAddressType.CHANGE);
                        }
                        else {
                            newOutput.setAddress(output.address);
                            newOutput.setAddressType(types_pb.OutputAddressType.SPEND);
                        }
                        unsignedTx.addOutputs(newOutput, k);
                    });
                    txmap['unsigned'] = unsignedTx;
                    inputs.forEach(function (inputTx) {
                        var tx = new types_pb.TransactionType();
                        tx.setVersion(inputTx.tx.version);
                        tx.setLockTime(inputTx.tx.locktime); // TODO: remove?
                        tx.setInputsCnt(inputTx.tx.vin.length);
                        tx.setOutputsCnt(inputTx.tx.vout.length);
                        inputTx.tx.vin.forEach(function (vin, i) {
                            var txInput = new types_pb.TxInputType();
                            txInput.setPrevHash(fromHexString(vin.txid));
                            txInput.setPrevIndex(vin.vout);
                            txInput.setSequence(vin.sequence);
                            txInput.setScriptSig(fromHexString(vin.scriptSig.hex));
                            txInput.setScriptType(types_pb.InputScriptType.SPENDADDRESS);
                            txInput.setAmount(vin.valueSat);
                            tx.addInputs(txInput, i);
                        });
                        inputTx.tx.vout.forEach(function (vout, i) {
                            var txOutput = new types_pb.TxOutputBinType();
                            txOutput.setAmount(Number((vout.value * (Math.pow(10, 8))).toFixed(0)));
                            txOutput.setScriptPubkey(fromHexString(vout.scriptPubKey.hex));
                            tx.addBinOutputs(txOutput, i);
                        });
                        txmap[inputTx.txid] = tx;
                    });
                    return [2 /*return*/, txmap];
                });
            });
        };
        // RemovePin disables pin protection for the device. If a pin is currently enabled
        // it will prompt the user to enter the current pin
        KeepKey.prototype.removePin = function () {
            return __awaiter(this, void 0, void 0, function () {
                var changePin;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            changePin = new messages_pb.ChangePin();
                            changePin.setRemove(true);
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_CHANGEPIN, changePin)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // ResetDevice generates a new seed using device RNG for entropy and applies the provided settings
        // The device must be uninitialized  before calling this method. This can be achieved by calling WipeDevice()
        // The device entropy strength must be 128, 192, or 256
        KeepKey.prototype.resetDevice = function (r) {
            return __awaiter(this, void 0, void 0, function () {
                var resetDevice, epoch;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            resetDevice = new messages_pb.ResetDevice();
                            resetDevice.setStrength(r.strength || 128);
                            resetDevice.setDisplayRandom(r.displayRandom || false);
                            resetDevice.setPassphraseProtection(r.passphraseProtection || false);
                            resetDevice.setPinProtection(r.pinProtection || false);
                            resetDevice.setLabel(r.label);
                            if (r.autoLockDelayMs) {
                                resetDevice.setAutoLockDelayMs(r.autoLockDelayMs);
                            }
                            epoch = Math.floor(+new Date() / 1000);
                            resetDevice.setU2fCounter(r.u2fCounter || epoch);
                            // resetDevice.setWordsPerGape(wordsPerScreen) // Re-enable when patch gets in
                            // Send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_RESETDEVICE, resetDevice)];
                        case 1:
                            // resetDevice.setWordsPerGape(wordsPerScreen) // Re-enable when patch gets in
                            // Send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        KeepKey.prototype.send = function (events) {
            return __awaiter(this, void 0, void 0, function () {
                var _loop_1, this_1, _i, events_1, event_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _loop_1 = function (event_1) {
                                var MessageType, msg;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            MessageType = messageTypeRegistry[event_1.message_enum];
                                            msg = new MessageType();
                                            Object.entries(event_1.message).forEach(function (_a) {
                                                var key = _a[0], value = _a[1];
                                                var setterMethod = protoFieldToSetMethod(key);
                                                if (msg[setterMethod]) {
                                                    // Assume setter methods are always of the format: strength -> setStrength
                                                    // until this exists https://github.com/protocolbuffers/protobuf/issues/1591
                                                    msg[setterMethod](value);
                                                }
                                            });
                                            return [4 /*yield*/, this_1.device.exchange(event_1.message_enum, msg)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _i = 0, events_1 = events;
                            _a.label = 1;
                        case 1:
                            if (!(_i < events_1.length)) return [3 /*break*/, 4];
                            event_1 = events_1[_i];
                            return [5 /*yield**/, _loop_1(event_1)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        // Sign UTXO Transaction
        KeepKey.prototype.signTransaction = function (coinName, inputs, outputs, exchangeOutputs, version, lockTime) {
            if (exchangeOutputs === void 0) { exchangeOutputs = []; }
            return __awaiter(this, void 0, void 0, function () {
                var _a, txmap, tx, responseType, response, signatures, serializedTx, errorResponse, txRequest, currentTx, msg, txAck, nextResponse, nextResponse, nextResponse, offset, length_1, nextResponse;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.prepareSignTx(coinName, inputs, outputs, exchangeOutputs)
                            // Prepare and send initial message
                        ];
                        case 1:
                            txmap = _b.sent();
                            tx = new messages_pb.SignTx();
                            tx.setInputsCount(inputs.length);
                            tx.setOutputsCount(outputs.length);
                            tx.setCoinName(coinName);
                            if (version != null)
                                tx.setVersion(version);
                            if (lockTime != null)
                                tx.setLockTime(lockTime);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_SIGNTX, tx)
                                // Prepare structure for signatures
                            ];
                        case 2:
                            _a = _b.sent(), responseType = _a[0], response = _a[1];
                            signatures = new Array(inputs.length).fill(null);
                            serializedTx = '';
                            _b.label = 3;
                        case 3:
                            if (responseType === messages_pb.MessageType.MESSAGETYPE_FAILURE) {
                                errorResponse = response;
                                throw new Error("Signing failed: " + errorResponse.getMessage());
                            }
                            if (responseType !== messages_pb.MessageType.MESSAGETYPE_TXREQUEST) {
                                throw new Error("Unexpected message type: " + responseType);
                            }
                            txRequest = response;
                            // If there's some part of signed transaction, add it
                            if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {
                                serializedTx += toHexString(txRequest.getSerialized().getSerializedTx_asU8());
                            }
                            if (txRequest.hasSerialized() && txRequest.getSerialized().hasSignatureIndex()) {
                                if (signatures[txRequest.getSerialized().getSignatureIndex()] !== null) {
                                    throw new Error("Signature for index " + txRequest.getSerialized().getSignatureIndex() + " already filled");
                                }
                                signatures[txRequest.getSerialized().getSignatureIndex()] = txRequest.getSerialized().getSignature_asB64();
                            }
                            if (txRequest.getRequestType() === types_pb.RequestType.TXFINISHED) {
                                // Device didn't ask for more information, finish workflow
                                return [3 /*break*/, 12];
                            }
                            currentTx = null;
                            msg = null;
                            txAck = null;
                            // Device asked for one more information, let's process it.
                            if (txRequest.hasDetails() && !txRequest.getDetails().hasTxHash()) {
                                currentTx = txmap['unsigned'];
                            }
                            else {
                                currentTx = txmap[toHexString(txRequest.getDetails().getTxHash_asU8())];
                            }
                            if (!(txRequest.getRequestType() === types_pb.RequestType.TXMETA)) return [3 /*break*/, 5];
                            msg = new types_pb.TransactionType();
                            msg.setVersion(currentTx.getVersion());
                            msg.setLockTime(currentTx.getLockTime());
                            msg.setInputsCnt(currentTx.getInputsCnt());
                            if (txRequest.getDetails().hasTxHash()) {
                                msg.setOutputsCnt(currentTx.getBinOutputsList().length);
                            }
                            else {
                                msg.setOutputsCnt(currentTx.getOutputsList().length);
                            }
                            if (currentTx.hasExtraData()) {
                                msg.setExtraDataLen(currentTx.getExtraData_asU8().length);
                            }
                            else {
                                msg.setExtraDataLen(0);
                            }
                            txAck = new messages_pb.TxAck();
                            txAck.setTx(msg);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_TXACK, txAck)];
                        case 4:
                            nextResponse = _b.sent();
                            responseType = nextResponse[0];
                            response = nextResponse[1];
                            return [3 /*break*/, 11];
                        case 5:
                            if (!(txRequest.getRequestType() === types_pb.RequestType.TXINPUT)) return [3 /*break*/, 7];
                            msg = new types_pb.TransactionType();
                            msg.setInputsList([currentTx.getInputsList()[txRequest.getDetails().getRequestIndex()]]);
                            txAck = new messages_pb.TxAck();
                            txAck.setTx(msg);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_TXACK, txAck)];
                        case 6:
                            nextResponse = _b.sent();
                            responseType = nextResponse[0];
                            response = nextResponse[1];
                            return [3 /*break*/, 11];
                        case 7:
                            if (!(txRequest.getRequestType() === types_pb.RequestType.TXOUTPUT)) return [3 /*break*/, 9];
                            msg = new types_pb.TransactionType();
                            if (txRequest.getDetails().hasTxHash()) {
                                msg.setBinOutputsList([currentTx.getBinOutputsList()[txRequest.getDetails().getRequestIndex()]]);
                            }
                            else {
                                msg.setOutputsList([currentTx.getOutputsList()[txRequest.getDetails().getRequestIndex()]]);
                                msg.setOutputsCnt(1);
                            }
                            txAck = new messages_pb.TxAck();
                            txAck.setTx(msg);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_TXACK, txAck)];
                        case 8:
                            nextResponse = _b.sent();
                            responseType = nextResponse[0];
                            response = nextResponse[1];
                            return [3 /*break*/, 11];
                        case 9:
                            if (!(txRequest.getRequestType() === types_pb.RequestType.TXEXTRADATA)) return [3 /*break*/, 11];
                            offset = txRequest.getDetails().getExtraDataOffset();
                            length_1 = txRequest.getDetails().getExtraDataLen();
                            msg = new types_pb.TransactionType();
                            msg.setExtraData(currentTx.getExtraData_asU8().slice(offset, offset + length_1));
                            txAck = new messages_pb.TxAck();
                            txAck.setTx(msg);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_TXACK, txAck)];
                        case 10:
                            nextResponse = _b.sent();
                            responseType = nextResponse[0];
                            response = nextResponse[1];
                            _b.label = 11;
                        case 11: return [3 /*break*/, 3];
                        case 12:
                            if (signatures.includes(null)) {
                                throw new Error('Some signatures are missing!');
                            }
                            return [2 /*return*/, [signatures, serializedTx]];
                    }
                });
            });
        };
        // SignMessage signs a message using the given nodepath and Coin
        KeepKey.prototype.signMessage = function (s) {
            return __awaiter(this, void 0, void 0, function () {
                var sign, _a, _, response, messageSignature;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            sign = new messages_pb.SignMessage();
                            sign.setAddressNList(s.addressNList);
                            sign.setMessage(s.message);
                            sign.setCoinName(s.coinName);
                            sign.setScriptType(s.scriptType || types_pb.InputScriptType.SPENDADDRESS);
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_SIGNMESSAGE, sign)];
                        case 1:
                            _a = _b.sent(), _ = _a[0], response = _a[1];
                            messageSignature = response.toObject();
                            return [2 /*return*/, [messageSignature.signature, messageSignature.address]];
                    }
                });
            });
        };
        // SoftReset power cycles the device. The device only responds to
        // this message while in manufacturer mode
        KeepKey.prototype.softReset = function () {
            return __awaiter(this, void 0, void 0, function () {
                var softReset;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            softReset = new messages_pb.SoftReset();
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_SOFTRESET, softReset)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // VerifyMessage verifies a signed message
        KeepKey.prototype.verifyMessage = function (addr, coinName, msg, sig) {
            return __awaiter(this, void 0, void 0, function () {
                var verify;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            verify = new messages_pb.VerifyMessage();
                            verify.setAddress(addr);
                            verify.setSignature(sig);
                            verify.setMessage(msg);
                            verify.setCoinName(coinName);
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_VERIFYMESSAGE, verify)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        // WipeDevice wipes all sensitive data and settings
        KeepKey.prototype.wipeDevice = function () {
            return __awaiter(this, void 0, void 0, function () {
                var wipeDevice;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            wipeDevice = new messages_pb.WipeDevice();
                            // send
                            return [4 /*yield*/, this.device.exchange(messages_pb.MessageType.MESSAGETYPE_WIPEDEVICE, wipeDevice)];
                        case 1:
                            // send
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return KeepKey;
    }());

    var defaultUSBDeviceCallback = function () { }; // tslint:disable-line:no-empty
    var KeepKeyManager = /** @class */ (function () {
        function KeepKeyManager(config) {
            if (config === void 0) { config = {}; }
            this.deviceEvents = new eventemitter2.EventEmitter2({ wildcard: true });
            this.keepkeys = {};
            this.onConnectCallback = defaultUSBDeviceCallback;
            this.onDisconnectCallback = defaultUSBDeviceCallback;
            this.onConnectCallback = config.onConnectCallback || defaultUSBDeviceCallback;
            this.onDisconnectCallback = config.onDisconnectCallback || defaultUSBDeviceCallback;
            // If we have access to WebUSB, register callbacks
            if (window.navigator.usb) {
                window.navigator.usb.onconnect = this.handleConnectKeepKey.bind(this);
                window.navigator.usb.ondisconnect = this.handleDisconnectKeepKey.bind(this);
            }
        }
        Object.defineProperty(KeepKeyManager.prototype, "initializedCount", {
            get: function () {
                return Object.keys(this.keepkeys).length;
            },
            enumerable: true,
            configurable: true
        });
        KeepKeyManager.prototype.initializeWebUSBDevices = function (webusbConfig, devices) {
            return __awaiter(this, void 0, void 0, function () {
                var devicesToInitialize, _a, _i, devicesToInitialize_1, usbDevice, k, features;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!window.navigator.usb)
                                throw new Error('WebUSB not supported in your browser!');
                            _a = devices;
                            if (_a) return [3 /*break*/, 2];
                            return [4 /*yield*/, window.navigator.usb.getDevices()];
                        case 1:
                            _a = (_b.sent());
                            _b.label = 2;
                        case 2:
                            devicesToInitialize = _a;
                            _i = 0, devicesToInitialize_1 = devicesToInitialize;
                            _b.label = 3;
                        case 3:
                            if (!(_i < devicesToInitialize_1.length)) return [3 /*break*/, 8];
                            usbDevice = devicesToInitialize_1[_i];
                            if (!this.keepkeys[usbDevice.serialNumber]) return [3 /*break*/, 5];
                            return [4 /*yield*/, this.get(usbDevice.serialNumber).initialize()];
                        case 4:
                            _b.sent();
                            return [3 /*break*/, 7];
                        case 5:
                            k = KeepKey.withWebUSB(__assign({ usbDevice: usbDevice }, webusbConfig));
                            return [4 /*yield*/, k.initialize()];
                        case 6:
                            features = _b.sent();
                            if (features)
                                this.add(k, usbDevice.serialNumber);
                            _b.label = 7;
                        case 7:
                            _i++;
                            return [3 /*break*/, 3];
                        case 8: return [2 /*return*/, this.initializedCount];
                    }
                });
            });
        };
        KeepKeyManager.prototype.add = function (keepkey, deviceID) {
            var id = deviceID || keepkey.features.deviceId;
            if (!(this.keepkeys[id])) {
                this.keepkeys[id] = keepkey;
                this.decorateEvents(deviceID, keepkey.device.events);
                return true;
            }
            return false;
        };
        KeepKeyManager.prototype.exec = function (method) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, Promise.all(Object.values(this.keepkeys)
                            .map(function (k) { return k[method].apply(k, args); })).then(function (values) { return values.reduce(function (final, response, i) {
                            final[Object.keys(_this.keepkeys)[i]] = response;
                            return final;
                        }, {}); })];
                });
            });
        };
        KeepKeyManager.prototype.get = function (deviceID) {
            if (this.keepkeys[deviceID])
                return this.keepkeys[deviceID];
            if (this.initializedCount)
                return Object.values(this.keepkeys)[0];
            return null;
        };
        KeepKeyManager.prototype.remove = function (deviceID) {
            return __awaiter(this, void 0, void 0, function () {
                var keepkey, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.keepkeys[deviceID])
                                return [2 /*return*/];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 4, , 5]);
                            keepkey = this.get(deviceID);
                            return [4 /*yield*/, keepkey.clearSession()];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, keepkey.device.disconnect()];
                        case 3:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            e_1 = _a.sent();
                            console.error(e_1);
                            return [3 /*break*/, 5];
                        case 5:
                            delete this.keepkeys[deviceID];
                            return [2 /*return*/];
                    }
                });
            });
        };
        KeepKeyManager.prototype.removeAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Promise.all(Object.keys(this.keepkeys).map(this.remove))];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        KeepKeyManager.prototype.disconnectAll = function () {
            Object.values(this.keepkeys).forEach(function (k) {
                if (k.device.queue)
                    k.device.queue.clear();
                k.device.disconnect().catch(console.log);
            });
        };
        KeepKeyManager.prototype.decorateEvents = function (deviceID, events) {
            var _this = this;
            events.onAny(function (e) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    values[_i - 1] = arguments[_i];
                }
                return _this.deviceEvents.emit([e, deviceID], [deviceID].concat(values));
            });
        };
        KeepKeyManager.prototype.handleConnectKeepKey = function (e) {
            var _this = this;
            var deviceID = e.device.serialNumber;
            this.initializeWebUSBDevices(null, [e.device])
                .then(function () { return _this.onConnectCallback(deviceID); })
                .catch(console.error);
        };
        KeepKeyManager.prototype.handleDisconnectKeepKey = function (e) {
            var _this = this;
            var deviceID = e.device.serialNumber;
            this.remove(deviceID)
                .then(function () { return _this.onDisconnectCallback(deviceID); })
                .catch(function (e) {
                console.error(e);
                _this.onDisconnectCallback(deviceID);
            });
        };
        return KeepKeyManager;
    }());

    function ethTxAsProto(tx, nodePath) {
        var est = new messages_pb.EthereumSignTx();
        est.setAddressNList(nodePath);
        // For proper rlp encoding when the value of the  parameter is zero,
        // the device expects an empty byte array instead of
        // a byte array with a value of zero
        if (tx.value) {
            est.setValue(emptyOrVal(tx.value));
        }
        if (tx.gasLimit) {
            est.setValue(emptyOrVal(tx.gasLimit));
        }
        if (tx.gasPrice) {
            est.setValue(emptyOrVal(tx.gasPrice));
        }
        return est;
    }
    function emptyOrVal(val) {
        if (!val)
            return new Uint8Array();
        else
            return arrayify(val);
    }
    function newTokenTransaction(tx, tShortCut, tRecipient, tValue) {
        return {
            ethereumTx: tx,
            tokenShortcut: tShortCut,
            tokenTo: tRecipient,
            tokenValue: tValue
        };
    }

    exports.KeepKeyManager = KeepKeyManager;
    exports.KeepKey = KeepKey;
    exports.WebUSBDevice = WebUSBDevice;
    exports.Messages = messages_pb;
    exports.Types = types_pb;
    exports.Exchange = exchange_pb;
    exports.messageTypeRegistry = messageTypeRegistry;
    exports.ethTxAsProto = ethTxAsProto;
    exports.newTokenTransaction = newTokenTransaction;
    exports.protoFieldToSetMethod = protoFieldToSetMethod;
    exports.isArray = isArray$1;
    exports.leByteArrayToLong = leByteArrayToLong;
    exports.fromHexString = fromHexString;
    exports.toHexString = toHexString;
    exports.arrayify = arrayify;
    exports.bip32ToAddressNList = bip32ToAddressNList;
    exports.bip32Like = bip32Like;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=keepkey.browser.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/lib/hid-framing.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib/hid-framing.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _errors = __webpack_require__(/*! @ledgerhq/errors */ "./node_modules/@ledgerhq/errors/lib/index.js");

var Tag = 0x05;

function asUInt16BE(value) {
  var b = Buffer.alloc(2);
  b.writeUInt16BE(value, 0);
  return b;
}

var initialAcc = {
  data: Buffer.alloc(0),
  dataLength: 0,
  sequence: 0
};

/**
 *
 */
var createHIDframing = function createHIDframing(channel, packetSize) {
  return {
    makeBlocks: function makeBlocks(apdu) {
      var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);
      var blockSize = packetSize - 5;
      var nbBlocks = Math.ceil(data.length / blockSize);
      data = Buffer.concat([data, // fill data with padding
      Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);

      var blocks = [];
      for (var i = 0; i < nbBlocks; i++) {
        var head = Buffer.alloc(5);
        head.writeUInt16BE(channel, 0);
        head.writeUInt8(Tag, 2);
        head.writeUInt16BE(i, 3);
        var chunk = data.slice(i * blockSize, (i + 1) * blockSize);
        blocks.push(Buffer.concat([head, chunk]));
      }
      return blocks;
    },
    reduceResponse: function reduceResponse(acc, chunk) {
      var _ref = acc || initialAcc,
          data = _ref.data,
          dataLength = _ref.dataLength,
          sequence = _ref.sequence;

      if (chunk.readUInt16BE(0) !== channel) {
        throw new _errors.TransportError("Invalid channel", "InvalidChannel");
      }
      if (chunk.readUInt8(2) !== Tag) {
        throw new _errors.TransportError("Invalid tag", "InvalidTag");
      }
      if (chunk.readUInt16BE(3) !== sequence) {
        throw new _errors.TransportError("Invalid sequence", "InvalidSequence");
      }

      if (!acc) {
        dataLength = chunk.readUInt16BE(5);
      }
      sequence++;
      var chunkData = chunk.slice(acc ? 5 : 7);
      data = Buffer.concat([data, chunkData]);
      if (data.length > dataLength) {
        data = data.slice(0, dataLength);
      }

      return {
        data: data,
        dataLength: dataLength,
        sequence: sequence
      };
    },
    getReducedResult: function getReducedResult(acc) {
      if (acc && acc.dataLength === acc.data.length) {
        return acc.data;
      }
    }
  };
};

exports.default = createHIDframing;
//# sourceMappingURL=hid-framing.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)
 *
 ** Model
 * Ledger Nano S : 0x10
 * Ledger Blue : 0x00
 * Ledger Nano X : 0x40
 *
 ** Interface support bitfield
 * Generic HID : 0x01
 * Keyboard HID : 0x02
 * U2F : 0x04
 * CCID : 0x08
 * WebUSB : 0x10
 */

var IIGenericHID = exports.IIGenericHID = 0x01;
var IIKeyboardHID = exports.IIKeyboardHID = 0x02;
var IIU2F = exports.IIU2F = 0x04;
var IICCID = exports.IICCID = 0x08;
var IIWebUSB = exports.IIWebUSB = 0x10;

var devices = {
  blue: {
    id: "blue",
    productName: "Ledger Blue",
    productIdMM: 0,
    legacyUsbProductId: 0x0000,
    usbOnly: true
  },
  nanoS: {
    id: "nanoS",
    productName: "Ledger Nano S",
    productIdMM: 1,
    legacyUsbProductId: 0x0001,
    usbOnly: true
  },
  nanoX: {
    id: "nanoX",
    productName: "Ledger Nano X",
    productIdMM: 4,
    legacyUsbProductId: 0x0004,
    usbOnly: false,
    bluetoothSpec: [{
      // this is the legacy one (prototype version). we will eventually drop it.
      serviceUuid: "d973f2e0-b19e-11e2-9e96-0800200c9a66",
      notifyUuid: "d973f2e1-b19e-11e2-9e96-0800200c9a66",
      writeUuid: "d973f2e2-b19e-11e2-9e96-0800200c9a66"
    }, {
      serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
      notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
      writeUuid: "13d63400-2c97-0004-0002-4c6564676572"
    }]
  }
};

var productMap = {
  Blue: "blue",
  "Nano S": "nanoS",
  "Nano X": "nanoX"
};

// $FlowFixMe
var devicesList = Object.values(devices);

/**
 *
 */
var ledgerUSBVendorId = exports.ledgerUSBVendorId = 0x2c97;

/**
 *
 */
var getDeviceModel = exports.getDeviceModel = function getDeviceModel(id) {
  var info = devices[id];
  if (!info) throw new Error("device '" + id + "' does not exist");
  return info;
};

/**
 *
 */
var identifyUSBProductId = exports.identifyUSBProductId = function identifyUSBProductId(usbProductId) {
  var legacy = devicesList.find(function (d) {
    return d.legacyUsbProductId === usbProductId;
  });
  if (legacy) return legacy;

  var mm = usbProductId >> 8;
  var deviceModel = devicesList.find(function (d) {
    return d.productIdMM === mm;
  });
  return deviceModel;
};

var identifyProductName = exports.identifyProductName = function identifyProductName(productName) {
  var productId = productMap[productName];
  var deviceModel = devicesList.find(function (d) {
    return d.id === productId;
  });

  return deviceModel;
};

var bluetoothServices = [];
var serviceUuidToInfos = {};

for (var _id in devices) {
  var _deviceModel = devices[_id];
  var _bluetoothSpec = _deviceModel.bluetoothSpec;

  if (_bluetoothSpec) {
    for (var i = 0; i < _bluetoothSpec.length; i++) {
      var spec = _bluetoothSpec[i];
      bluetoothServices.push(spec.serviceUuid);
      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, "")] = _extends({ deviceModel: _deviceModel }, spec);
    }
  }
}

/**
 *
 */
var getBluetoothServiceUuids = exports.getBluetoothServiceUuids = function getBluetoothServiceUuids() {
  return bluetoothServices;
};

/**
 *
 */
var getInfosForServiceUuid = exports.getInfosForServiceUuid = function getInfosForServiceUuid(uuid) {
  return serviceUuidToInfos[uuid.toLowerCase()];
};

/**
 *
 */


/**
 *
 */


/**
 *
 */
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/errors/lib/helpers.js":
/*!******************************************************!*\
  !*** ./node_modules/@ledgerhq/errors/lib/helpers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* eslint-disable no-continue */
/* eslint-disable no-param-reassign */
/* eslint-disable no-prototype-builtins */

var errorClasses = {};
var deserializers = {};

var addCustomErrorDeserializer = exports.addCustomErrorDeserializer = function addCustomErrorDeserializer(name, deserializer) {
  deserializers[name] = deserializer;
};

var createCustomErrorClass = exports.createCustomErrorClass = function createCustomErrorClass(name) {
  var C = function CustomError(message, fields) {
    Object.assign(this, fields);
    this.name = name;
    this.message = message || name;
    this.stack = new Error().stack;
  };
  // $FlowFixMe
  C.prototype = new Error();

  errorClasses[name] = C;
  // $FlowFixMe we can't easily type a subset of Error for now...
  return C;
};

// inspired from https://github.com/programble/errio/blob/master/index.js
var deserializeError = exports.deserializeError = function deserializeError(object) {
  if ((typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && object) {
    try {
      // $FlowFixMe FIXME HACK
      var msg = JSON.parse(object.message);
      if (msg.message && msg.name) {
        object = msg;
      }
    } catch (e) {
      // nothing
    }

    var error = void 0;
    if (typeof object.name === "string") {
      var _object = object,
          name = _object.name;

      var des = deserializers[name];
      if (des) {
        error = des(object);
      } else {
        var _constructor = name === "Error" ? Error : errorClasses[name];

        if (!_constructor) {
          console.warn("deserializing an unknown class '" + name + "'");
          _constructor = createCustomErrorClass(name);
        }

        error = Object.create(_constructor.prototype);
        try {
          for (var prop in object) {
            if (object.hasOwnProperty(prop)) {
              error[prop] = object[prop];
            }
          }
        } catch (e) {
          // sometimes setting a property can fail (e.g. .name)
        }
      }
    } else {
      error = new Error(object.message);
    }

    if (!error.stack && Error.captureStackTrace) {
      Error.captureStackTrace(error, deserializeError);
    }
    return error;
  }
  return new Error(String(object));
};

// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js
var serializeError = exports.serializeError = function serializeError(value) {
  if (!value) return value;
  if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
    return destroyCircular(value, []);
  }
  if (typeof value === "function") {
    return "[Function: " + (value.name || "anonymous") + "]";
  }
  return value;
};

// https://www.npmjs.com/package/destroy-circular
function destroyCircular(from, seen) {
  var to = {};
  seen.push(from);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      var value = from[key];
      if (typeof value === "function") {
        continue;
      }
      if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object") {
        to[key] = value;
        continue;
      }
      if (seen.indexOf(from[key]) === -1) {
        to[key] = destroyCircular(from[key], seen.slice(0));
        continue;
      }
      to[key] = "[Circular]";
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (typeof from.name === "string") {
    to.name = from.name;
  }
  if (typeof from.message === "string") {
    to.message = from.message;
  }
  if (typeof from.stack === "string") {
    to.stack = from.stack;
  }
  return to;
}
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/errors/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@ledgerhq/errors/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusCodes = exports.DBNotReset = exports.DBWrongPassword = exports.NoDBPathGiven = exports.FirmwareOrAppUpdateRequired = exports.LedgerAPI5xx = exports.LedgerAPI4xx = exports.GenuineCheckFailed = exports.PairingFailed = exports.SyncError = exports.FeeTooHigh = exports.FeeRequired = exports.FeeNotLoaded = exports.CantScanQRCode = exports.ETHAddressNonEIP = exports.WrongAppForCurrency = exports.WrongDeviceForAccount = exports.WebsocketConnectionFailed = exports.WebsocketConnectionError = exports.DeviceShouldStayInApp = exports.TransportWebUSBGestureRequired = exports.TransportInterfaceNotAvailable = exports.TransportOpenUserCancelled = exports.UserRefusedOnDevice = exports.UserRefusedAllowManager = exports.UserRefusedFirmwareUpdate = exports.UserRefusedAddress = exports.UserRefusedDeviceNameChange = exports.UpdateYourApp = exports.MCUNotGenuineToDashboard = exports.UnexpectedBootloader = exports.TimeoutTagged = exports.PasswordIncorrectError = exports.PasswordsDontMatchError = exports.GasLessThanEstimate = exports.NotEnoughGas = exports.NoAccessToCamera = exports.NotEnoughBalanceBecauseDestinationNotCreated = exports.NotEnoughBalance = exports.NoAddressesFound = exports.NetworkDown = exports.ManagerUninstallBTCDep = exports.ManagerNotEnoughSpaceError = exports.ManagerFirmwareNotEnoughSpaceError = exports.ManagerDeviceLockedError = exports.ManagerAppDepUninstallRequired = exports.ManagerAppDepInstallRequired = exports.ManagerAppRelyOnBTCError = exports.ManagerAppAlreadyInstalledError = exports.LedgerAPINotAvailable = exports.LedgerAPIErrorWithMessage = exports.LedgerAPIError = exports.UnknownMCU = exports.LatestMCUInstalledError = exports.InvalidAddressBecauseDestinationIsAlsoSource = exports.InvalidAddress = exports.HardResetFail = exports.FeeEstimationFailed = exports.EthAppPleaseEnableContractData = exports.EnpointConfigError = exports.DisconnectedDeviceDuringOperation = exports.DisconnectedDevice = exports.DeviceSocketNoBulkStatus = exports.DeviceSocketFail = exports.DeviceNameInvalid = exports.DeviceHalted = exports.DeviceInOSUExpected = exports.DeviceOnDashboardUnexpected = exports.DeviceOnDashboardExpected = exports.DeviceNotGenuineError = exports.DeviceGenuineSocketEarlyClose = exports.DeviceAppVerifyNotSupported = exports.CurrencyNotSupported = exports.CashAddrNotSupported = exports.CantOpenDevice = exports.BtcUnmatchedApp = exports.BluetoothRequired = exports.AccountNotSupported = exports.AccountNameRequiredError = exports.addCustomErrorDeserializer = exports.createCustomErrorClass = exports.deserializeError = exports.serializeError = undefined;
exports.TransportError = TransportError;
exports.getAltStatusMessage = getAltStatusMessage;
exports.TransportStatusError = TransportStatusError;

var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/@ledgerhq/errors/lib/helpers.js");

exports.serializeError = _helpers.serializeError;
exports.deserializeError = _helpers.deserializeError;
exports.createCustomErrorClass = _helpers.createCustomErrorClass;
exports.addCustomErrorDeserializer = _helpers.addCustomErrorDeserializer;
var AccountNameRequiredError = exports.AccountNameRequiredError = (0, _helpers.createCustomErrorClass)("AccountNameRequired");
var AccountNotSupported = exports.AccountNotSupported = (0, _helpers.createCustomErrorClass)("AccountNotSupported");
var BluetoothRequired = exports.BluetoothRequired = (0, _helpers.createCustomErrorClass)("BluetoothRequired");
var BtcUnmatchedApp = exports.BtcUnmatchedApp = (0, _helpers.createCustomErrorClass)("BtcUnmatchedApp");
var CantOpenDevice = exports.CantOpenDevice = (0, _helpers.createCustomErrorClass)("CantOpenDevice");
var CashAddrNotSupported = exports.CashAddrNotSupported = (0, _helpers.createCustomErrorClass)("CashAddrNotSupported");
var CurrencyNotSupported = exports.CurrencyNotSupported = (0, _helpers.createCustomErrorClass)("CurrencyNotSupported");
var DeviceAppVerifyNotSupported = exports.DeviceAppVerifyNotSupported = (0, _helpers.createCustomErrorClass)("DeviceAppVerifyNotSupported");
var DeviceGenuineSocketEarlyClose = exports.DeviceGenuineSocketEarlyClose = (0, _helpers.createCustomErrorClass)("DeviceGenuineSocketEarlyClose");
var DeviceNotGenuineError = exports.DeviceNotGenuineError = (0, _helpers.createCustomErrorClass)("DeviceNotGenuine");
var DeviceOnDashboardExpected = exports.DeviceOnDashboardExpected = (0, _helpers.createCustomErrorClass)("DeviceOnDashboardExpected");
var DeviceOnDashboardUnexpected = exports.DeviceOnDashboardUnexpected = (0, _helpers.createCustomErrorClass)("DeviceOnDashboardUnexpected");
var DeviceInOSUExpected = exports.DeviceInOSUExpected = (0, _helpers.createCustomErrorClass)("DeviceInOSUExpected");
var DeviceHalted = exports.DeviceHalted = (0, _helpers.createCustomErrorClass)("DeviceHalted");
var DeviceNameInvalid = exports.DeviceNameInvalid = (0, _helpers.createCustomErrorClass)("DeviceNameInvalid");
var DeviceSocketFail = exports.DeviceSocketFail = (0, _helpers.createCustomErrorClass)("DeviceSocketFail");
var DeviceSocketNoBulkStatus = exports.DeviceSocketNoBulkStatus = (0, _helpers.createCustomErrorClass)("DeviceSocketNoBulkStatus");
var DisconnectedDevice = exports.DisconnectedDevice = (0, _helpers.createCustomErrorClass)("DisconnectedDevice");
var DisconnectedDeviceDuringOperation = exports.DisconnectedDeviceDuringOperation = (0, _helpers.createCustomErrorClass)("DisconnectedDeviceDuringOperation");
var EnpointConfigError = exports.EnpointConfigError = (0, _helpers.createCustomErrorClass)("EnpointConfig");
var EthAppPleaseEnableContractData = exports.EthAppPleaseEnableContractData = (0, _helpers.createCustomErrorClass)("EthAppPleaseEnableContractData");
var FeeEstimationFailed = exports.FeeEstimationFailed = (0, _helpers.createCustomErrorClass)("FeeEstimationFailed");
var HardResetFail = exports.HardResetFail = (0, _helpers.createCustomErrorClass)("HardResetFail");
var InvalidAddress = exports.InvalidAddress = (0, _helpers.createCustomErrorClass)("InvalidAddress");
var InvalidAddressBecauseDestinationIsAlsoSource = exports.InvalidAddressBecauseDestinationIsAlsoSource = (0, _helpers.createCustomErrorClass)("InvalidAddressBecauseDestinationIsAlsoSource");
var LatestMCUInstalledError = exports.LatestMCUInstalledError = (0, _helpers.createCustomErrorClass)("LatestMCUInstalledError");
var UnknownMCU = exports.UnknownMCU = (0, _helpers.createCustomErrorClass)("UnknownMCU");
var LedgerAPIError = exports.LedgerAPIError = (0, _helpers.createCustomErrorClass)("LedgerAPIError");
var LedgerAPIErrorWithMessage = exports.LedgerAPIErrorWithMessage = (0, _helpers.createCustomErrorClass)("LedgerAPIErrorWithMessage");
var LedgerAPINotAvailable = exports.LedgerAPINotAvailable = (0, _helpers.createCustomErrorClass)("LedgerAPINotAvailable");
var ManagerAppAlreadyInstalledError = exports.ManagerAppAlreadyInstalledError = (0, _helpers.createCustomErrorClass)("ManagerAppAlreadyInstalled");
var ManagerAppRelyOnBTCError = exports.ManagerAppRelyOnBTCError = (0, _helpers.createCustomErrorClass)("ManagerAppRelyOnBTC");
var ManagerAppDepInstallRequired = exports.ManagerAppDepInstallRequired = (0, _helpers.createCustomErrorClass)("ManagerAppDepInstallRequired");
var ManagerAppDepUninstallRequired = exports.ManagerAppDepUninstallRequired = (0, _helpers.createCustomErrorClass)("ManagerAppDepUninstallRequired");
var ManagerDeviceLockedError = exports.ManagerDeviceLockedError = (0, _helpers.createCustomErrorClass)("ManagerDeviceLocked");
var ManagerFirmwareNotEnoughSpaceError = exports.ManagerFirmwareNotEnoughSpaceError = (0, _helpers.createCustomErrorClass)("ManagerFirmwareNotEnoughSpace");
var ManagerNotEnoughSpaceError = exports.ManagerNotEnoughSpaceError = (0, _helpers.createCustomErrorClass)("ManagerNotEnoughSpace");
var ManagerUninstallBTCDep = exports.ManagerUninstallBTCDep = (0, _helpers.createCustomErrorClass)("ManagerUninstallBTCDep");
var NetworkDown = exports.NetworkDown = (0, _helpers.createCustomErrorClass)("NetworkDown");
var NoAddressesFound = exports.NoAddressesFound = (0, _helpers.createCustomErrorClass)("NoAddressesFound");
var NotEnoughBalance = exports.NotEnoughBalance = (0, _helpers.createCustomErrorClass)("NotEnoughBalance");
var NotEnoughBalanceBecauseDestinationNotCreated = exports.NotEnoughBalanceBecauseDestinationNotCreated = (0, _helpers.createCustomErrorClass)("NotEnoughBalanceBecauseDestinationNotCreated");
var NoAccessToCamera = exports.NoAccessToCamera = (0, _helpers.createCustomErrorClass)("NoAccessToCamera");
var NotEnoughGas = exports.NotEnoughGas = (0, _helpers.createCustomErrorClass)("NotEnoughGas");
var GasLessThanEstimate = exports.GasLessThanEstimate = (0, _helpers.createCustomErrorClass)("GasLessThanEstimate");
var PasswordsDontMatchError = exports.PasswordsDontMatchError = (0, _helpers.createCustomErrorClass)("PasswordsDontMatch");
var PasswordIncorrectError = exports.PasswordIncorrectError = (0, _helpers.createCustomErrorClass)("PasswordIncorrect");
var TimeoutTagged = exports.TimeoutTagged = (0, _helpers.createCustomErrorClass)("TimeoutTagged");
var UnexpectedBootloader = exports.UnexpectedBootloader = (0, _helpers.createCustomErrorClass)("UnexpectedBootloader");
var MCUNotGenuineToDashboard = exports.MCUNotGenuineToDashboard = (0, _helpers.createCustomErrorClass)("MCUNotGenuineToDashboard");
var UpdateYourApp = exports.UpdateYourApp = (0, _helpers.createCustomErrorClass)("UpdateYourApp");
var UserRefusedDeviceNameChange = exports.UserRefusedDeviceNameChange = (0, _helpers.createCustomErrorClass)("UserRefusedDeviceNameChange");
var UserRefusedAddress = exports.UserRefusedAddress = (0, _helpers.createCustomErrorClass)("UserRefusedAddress");
var UserRefusedFirmwareUpdate = exports.UserRefusedFirmwareUpdate = (0, _helpers.createCustomErrorClass)("UserRefusedFirmwareUpdate");
var UserRefusedAllowManager = exports.UserRefusedAllowManager = (0, _helpers.createCustomErrorClass)("UserRefusedAllowManager");
var UserRefusedOnDevice = exports.UserRefusedOnDevice = (0, _helpers.createCustomErrorClass)("UserRefusedOnDevice"); // TODO rename because it's just for transaction refusal
var TransportOpenUserCancelled = exports.TransportOpenUserCancelled = (0, _helpers.createCustomErrorClass)("TransportOpenUserCancelled");
var TransportInterfaceNotAvailable = exports.TransportInterfaceNotAvailable = (0, _helpers.createCustomErrorClass)("TransportInterfaceNotAvailable");
var TransportWebUSBGestureRequired = exports.TransportWebUSBGestureRequired = (0, _helpers.createCustomErrorClass)("TransportWebUSBGestureRequired");
var DeviceShouldStayInApp = exports.DeviceShouldStayInApp = (0, _helpers.createCustomErrorClass)("DeviceShouldStayInApp");
var WebsocketConnectionError = exports.WebsocketConnectionError = (0, _helpers.createCustomErrorClass)("WebsocketConnectionError");
var WebsocketConnectionFailed = exports.WebsocketConnectionFailed = (0, _helpers.createCustomErrorClass)("WebsocketConnectionFailed");
var WrongDeviceForAccount = exports.WrongDeviceForAccount = (0, _helpers.createCustomErrorClass)("WrongDeviceForAccount");
var WrongAppForCurrency = exports.WrongAppForCurrency = (0, _helpers.createCustomErrorClass)("WrongAppForCurrency");
var ETHAddressNonEIP = exports.ETHAddressNonEIP = (0, _helpers.createCustomErrorClass)("ETHAddressNonEIP");
var CantScanQRCode = exports.CantScanQRCode = (0, _helpers.createCustomErrorClass)("CantScanQRCode");
var FeeNotLoaded = exports.FeeNotLoaded = (0, _helpers.createCustomErrorClass)("FeeNotLoaded");
var FeeRequired = exports.FeeRequired = (0, _helpers.createCustomErrorClass)("FeeRequired");
var FeeTooHigh = exports.FeeTooHigh = (0, _helpers.createCustomErrorClass)("FeeTooHigh");
var SyncError = exports.SyncError = (0, _helpers.createCustomErrorClass)("SyncError");
var PairingFailed = exports.PairingFailed = (0, _helpers.createCustomErrorClass)("PairingFailed");
var GenuineCheckFailed = exports.GenuineCheckFailed = (0, _helpers.createCustomErrorClass)("GenuineCheckFailed");
var LedgerAPI4xx = exports.LedgerAPI4xx = (0, _helpers.createCustomErrorClass)("LedgerAPI4xx");
var LedgerAPI5xx = exports.LedgerAPI5xx = (0, _helpers.createCustomErrorClass)("LedgerAPI5xx");
var FirmwareOrAppUpdateRequired = exports.FirmwareOrAppUpdateRequired = (0, _helpers.createCustomErrorClass)("FirmwareOrAppUpdateRequired");

// db stuff, no need to translate
var NoDBPathGiven = exports.NoDBPathGiven = (0, _helpers.createCustomErrorClass)("NoDBPathGiven");
var DBWrongPassword = exports.DBWrongPassword = (0, _helpers.createCustomErrorClass)("DBWrongPassword");
var DBNotReset = exports.DBNotReset = (0, _helpers.createCustomErrorClass)("DBNotReset");

/**
 * TransportError is used for any generic transport errors.
 * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
 */
function TransportError(message, id) {
  this.name = "TransportError";
  this.message = message;
  this.stack = new Error().stack;
  this.id = id;
}
//$FlowFixMe
TransportError.prototype = new Error();

(0, _helpers.addCustomErrorDeserializer)("TransportError", function (e) {
  return new TransportError(e.message, e.id);
});

var StatusCodes = exports.StatusCodes = {
  PIN_REMAINING_ATTEMPTS: 0x63c0,
  INCORRECT_LENGTH: 0x6700,
  COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,
  SECURITY_STATUS_NOT_SATISFIED: 0x6982,
  CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,
  INCORRECT_DATA: 0x6a80,
  NOT_ENOUGH_MEMORY_SPACE: 0x6a84,
  REFERENCED_DATA_NOT_FOUND: 0x6a88,
  FILE_ALREADY_EXISTS: 0x6a89,
  INCORRECT_P1_P2: 0x6b00,
  INS_NOT_SUPPORTED: 0x6d00,
  CLA_NOT_SUPPORTED: 0x6e00,
  TECHNICAL_PROBLEM: 0x6f00,
  OK: 0x9000,
  MEMORY_PROBLEM: 0x9240,
  NO_EF_SELECTED: 0x9400,
  INVALID_OFFSET: 0x9402,
  FILE_NOT_FOUND: 0x9404,
  INCONSISTENT_FILE: 0x9408,
  ALGORITHM_NOT_SUPPORTED: 0x9484,
  INVALID_KCV: 0x9485,
  CODE_NOT_INITIALIZED: 0x9802,
  ACCESS_CONDITION_NOT_FULFILLED: 0x9804,
  CONTRADICTION_SECRET_CODE_STATUS: 0x9808,
  CONTRADICTION_INVALIDATION: 0x9810,
  CODE_BLOCKED: 0x9840,
  MAX_VALUE_REACHED: 0x9850,
  GP_AUTH_FAILED: 0x6300,
  LICENSING: 0x6f42,
  HALTED: 0x6faa
};

function getAltStatusMessage(code) {
  switch (code) {
    // improve text of most common errors
    case 0x6700:
      return "Incorrect length";
    case 0x6982:
      return "Security not satisfied (dongle locked or have invalid access rights)";
    case 0x6985:
      return "Condition of use not satisfied (denied by the user?)";
    case 0x6a80:
      return "Invalid data received";
    case 0x6b00:
      return "Invalid parameter received";
  }
  if (0x6f00 <= code && code <= 0x6fff) {
    return "Internal error, please report";
  }
}

/**
 * Error thrown when a device returned a non success status.
 * the error.statusCode is one of the `StatusCodes` exported by this library.
 */
function TransportStatusError(statusCode) {
  this.name = "TransportStatusError";
  var statusText = Object.keys(StatusCodes).find(function (k) {
    return StatusCodes[k] === statusCode;
  }) || "UNKNOWN_ERROR";
  var smsg = getAltStatusMessage(statusCode) || statusText;
  var statusCodeStr = statusCode.toString(16);
  this.message = "Ledger device: " + smsg + " (0x" + statusCodeStr + ")";
  this.stack = new Error().stack;
  this.statusCode = statusCode;
  this.statusText = statusText;
}
//$FlowFixMe
TransportStatusError.prototype = new Error();

(0, _helpers.addCustomErrorDeserializer)("TransportStatusError", function (e) {
  return new TransportStatusError(e.statusCode);
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-app-eth/data/erc20.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-app-eth/data/erc20.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "AAAAZgNaQ06573cLal4S5FmDxdgFRSWKo487eAAAAAoAAAABMEQCIFl3BvBR/N8N5OrjZULRDq0P6r/gQuOBd9XTGfg5dFdLAiAraImuYXl9inTiqNH6oD1yDjTNaKeNotkI4LC6ImxhRAAAAGYDWlJY5B0kiVcdMiGJJG2vpeveH0aZ9JgAAAASAAAAATBEAiAK6GNMInYqi6QdKsseBo3M6UczfG3ZhPE7gg05YXaVIwIgMwaknYpsNbEaYQiOFXCzkoyjoNtr029Xe174dihWH/cAAABpBTB4QlRDtu12RMaUFtZ7Ui4gvClKmptAWzEAAAAIAAAAATBFAiEA2UkiC1HMK5i877Abmr1Om/aEvUXiIsqXuGX0jcrPP1MCIFsphKwcLDXOxifN6kqIujazD3wJLDxZc4wEwuv3ZTi8AAAAZgNaWEOD4r6NEU+WYSIThLOlDSS5alZT9QAAABIAAAABMEQCIBHDMvdW35oBmEhJgeC/oxIKIyrjeH2/P1rLsym0fuW0AiBMQNqeERmBGiLny0WuCXdTJaV/1qUG/xUujycGRyDgUAAAAGcDMVNHD3JxSzWjZihd+FiGou4XRgEpKhcAAAASAAAAATBFAiEAxe+sAi/MF7js9B6LOiQ4kfoz9pVF86uv9LzzKiOvaQYCIFmbP2rFN7pQ81etOY3PYfPoyIVc7SG9+VP+UXuevrOWAAAAZgMxV0/9vBrcJvD4+GBqXWO306PNIcIrIwAAAAgAAAABMEQCIBvK3jRJAMX9G0/LInMeaiO/AZM6MTJ6uswabJ/jgME/AiAEvw84OA/ESMgBSQx2rCZqizVsWe9/2XJ2ie85XiuPtgAAAGYDMjJ4AHPl5S4rT+IY112ZTuKzyC+ch+oAAAAIAAAAATBEAiBmrYYpvOQ7Wq0yxgpab/lPzfA6p75odd9mVuZVUhPZngIgacpf+Ii6oZtIg7Nj4kn9IvNamnwTztUcagv22fTS73UAAABmAzMwMK7JinCIEEFIeMO830aq0x3tSkVXAAAAEgAAAAEwRAIgIz6/suxqUcK755gI1TPY5z7Y0m2sagGcZ+IVMz7k8a8CIEqmiu1mrJl5sQntBvgQrHt4p0IH72YOswYS1EUIrCxvAAAAaQVLV0FUVCQbpnJXSnijpgTN0KlEKac6hKMkAAAAEgAAAAEwRQIhAL4eNwizGjCAZNFwyCh1UR8xBHNvF9f7tuapsTaXzr7LAiBz16Q01VRfF2L9IrGlaGWmpFoQts/qfENfLnmmNI/TmAAAAGcEJEZYWaAk6AV+7EdKmyNWgzcH3QV54m7zAAAAEgAAAAEwRAIgDbhWuZmnFENPH0CSSD97dDIFkvV7OosSALSJ/FOeZNwCIA+o55Nyv4PmbmP0OHO2lmDKY/jXcgHXaTqZ+we3pu2dAAAAZwQkRkZDToTp5fsKlyYoz0VoxAMWfvHUBDEAAAASAAAAATBEAiAcz+4ADikWl0oOLPVlqRP52aFLda4k8ipZModp/eL1LwIgahi8xWDiFhbnyXkYHvzOS6KXXqjIh5BmHGxF+9K8kjAAAABoBCRIVVLNt+z9NAPu84gsZbdh75tQVIkKRwAAABIAAAABMEUCIQDMZCRGFvlDTfXdgsMiqBBp7UzSGL535DNaf/a5DRK8GQIgHebrutIn/rkf4nlSD5AroKcnVRCkoxqqI2S+853WEwgAAABnBCRJUU4NuNi3a8Nhusu3LixJHgYIWperMQAAABIAAAABMEQCIBObDYp1J9fESDvjo9pm2p6j9yDEW46BJ7/72oZriLVUAiBdYUR8avsHBkGvZBOIEqJHSEYsxWKryPOXxMjfr10xJAAAAGoHKlBMQVNNQZXXMh7c5RlBm6HbxgqJuvv1XqwNAAAABgAAAAMwRAIgN5Xd2f66jd/vUGosTglpZxl5NSd572FuGK4Z5Lt7D+MCIG3RBSUl1GyZaVFcRA8BZ1+ZHCtWRP6E0V2qfRw2dm93AAAAaAUkVEVBS33X9W1pfMDytSvVXAV/N48f5qtLAAAAEgAAAAEwRAIgHp662zGWoOmi9SktstFz9ZNW3rlbKCg1XOeaYCPGbjYCIDM9x0LeKjuiBLynEvgMQ5fxXAXQMVkKBDgZPSXQrgc0AAAAZgNSVELsSRwQiOrpkreiFO+womatCSenKgAAABIAAAABMEQCIGgHg27eIRLrHrBtQZWOEmqRDFPeDC4Dh50To+oAqiNsAiADrubG5USV1XWLEmxriTmbFfMh+j7Zs20dDTm5v4exHgAAAGcEQUJDSMx9JtjqYoG7NjyESFFfLGH3vBnwAAAAEgAAAAEwRAIgQTjdUk/0LQc8l0hY2MszdxV33XXR1QtXrLM1z6zwFiUCIAJc+6IA6MGdXmybmEamCM7SdOunC8BuBcIWApDvRYPSAAAAaQVBQllTUw6Na0ceMy8UDn2du5nl44Ivco2mAAAAEgAAAAEwRQIhAMI8Va+589yI2fYNFsSoLUKg2/5Y5xx+9jr+TJ5LdNwqAiBIVRh7EGiqy12j5dsfLdYsF8Cazvnewg5ep6hiSVKmygAAAGYDQUNDE/G3/fvh/GZnbVZIPiGx7LQLWOIAAAASAAAAATBEAiByngRNEpt/c/Y56v5ALdbODJrAcoHimfaciQ7DXxaIVAIgblbMIau6G2N8cwlvu9UyGNpuD+yt7pvH9NAEJM9LTF0AAABnA0FSRHWqew0CUy84M7ZsfwrTU3bTc934AAAAEgAAAAEwRQIhAP4cnIeOfzK94eKUZ+ZC9hpiD9zlqdG38BStkuimNL0BAiAs8ds3yQE4ommbQPBMqeHmnhXgwD7AbrlopftHJ0a0IAAAAGYDQUNFBhRxEAIrdouo+ZqPOF3xGhUanMgAAAAAAAAAATBEAiAllvjQDdTaJlG4hX3iIDj1MjCPTJqZXadCFGiECFU9QQIgUGvPTJSSPGtoCCFaAE8YTeeQPYKFZCLzlXQfjMyJsFYAAABmA0FEQiuqyTMM+axHnYGRlXlNea0MdhbjAAAAEgAAAAEwRAIgPHA/gU81tis/P7GqF0a2bxedrIeCfVPC+LFJ2iRIW1UCIBBZcwkQ/XsHD2iypSXdqPaAq1olLewbIGsFEamZ5b8mAAAAZwNBRExmDnFIN4X2YTNUixD2km3DMrBuYQAAABIAAAABMEUCIQDDFklij+P37mG4JBr+zq7LDMrtfvjidPwxU4UbIZ94agIgKfPhJRCLUd2ZIq7Kn8HxwCtosp182cd5IRWi7jdnSP0AAABmA0FEWERwu4fXe5Y6AT25Ob4zL5J/K5kuAAAABAAAAAEwRAIgFNTGBz7vhdlwPRhx5w+yAT5sdAJNlKZ/z7LAbsr+3PsCIEgiSuNRMCuSIYC3GGqPI1Y6FcaPROPUerg47o95x/X2AAAAZwNBREjmmjU7MVLde3Bv991A/h0Yt4AtMQAAABIAAAABMEUCIQC78FA5/IRKa6aHf2VPu63YKZH249JdmyuBkj7iVnVm1QIgeIp/dLaVs4x0JQnH1+B0GKJyV1suQKXBpVBVUYTpqKMAAABnA0FESYgQxjRw04Y5lUxrQarFRYSMRkhKAAAAEgAAAAEwRQIhAMfExmBMf1rp1Q64bW9w6rqrF8yZ5BkW/dwiw9Al8n6wAiBJTDZQDMwnV2tfLZTvtsJ6AZ2HUYEu7vdyQGAFHWRiSQAAAGcEQURTVEIoZqjwsDLFzx373vMaIPRQlWKwAAAAAAAAAAEwRAIgVOgJxOPSiTTnb7GXDTd4E7OuCTQmRSnIKjG82eWvfSUCIEWx9BKDOhNacl12fX4yGA9N80dfcCiVfl8U7k31mzPHAAAAZgNBRFTQ1tbF/kpnfTQ8xDNTa7cXuuFn3QAAAAkAAAABMEQCIHcMEcBunMTCwJQvlpaVna8KcNZSllXyteXNBzBquYAZAiAMZvlCMJlH/C7hY76rJGVz6XRUm8AWA7ugs6cqsE43nQAAAGkFQUVSR0+uMbhb/mJ0fQg2uCYItIMDYaPTegAAABIAAAABMEUCIQDcFL86alLYyWbYFPNWSkctOSZH94mCBAC5ymUhDWsIywIgPSwK4KdoWJNmq6O9tIxpIt21A+0pa4D2Z3v+fhxr6/sAAABmA0FSTrpfEbFrFVeSzzsuaIDocGhZqK62AAAACAAAAAEwRAIgO17bMzmwos30UEjz8JeMkUYObnQtt37WR8e0Caqc0OUCIHBtdG5AjF5litee9XGNoBELlUKIm7c0epQqqtu1YkV4AAAAZgJBRVyppxsdAYScCpVJDMAFWXF/zw0dAAAAEgAAAAEwRQIhAJdtVjRHe3lXHs3K4LGjsO9FpdW2SckZ4wFtsm+8JoEBAiB8/DiVdu2E04nhllAzqKLYKFxrg1mGIWiLKxUtkZXfEgAAAGYDRExUB+PHBlNUiwTwp1lwwfgbTLv7YG8AAAASAAAAATBEAiA2b/r25130tzVjJ8D2Nx9x5Ff1QWQxxZnBroTqGpM5bgIgIP2auGLvIliWrrY2ET9cPbvfQMrqsU4KwajL0ea6u1wAAABnA0FJRDfoeJu5mWyskVbNX1/TJZnmuRKJAAAAEgAAAAEwRQIhAOaLWbiTXgxt0e0ma3XL9z+6attxCWeOHh6Av+BEc9swAiBwNNeXPyx/mDiwhWDkDkqBkp2AsuAhRNEyl/Ujma91lAAAAGcDQUlE0XiyDGAHVyvR/QHSBcwg0ytKYBUAAAAIAAAAATBFAiEAsqJ8vmnHjG54LA0+BlNvnRJSjCMkAaO7MX72N5Lcws4CIBRpEPsN0EO27BbvjP/JewC8cHXlOCYWY1TUpvZhelhgAAAAZwNBSVgQY85SQmXVo6Yk9JFKzVc92JzpiAAAABIAAAABMEUCIQCbXzXGlXSYR633ZT8gOVs/oJBgKlVy78EFO+Pp8Z1IeAIgfFd0Bs2XrvPmy8vKuHvZPTTdRBUQc+uEa2SFRMyE+/sAAABnA0FQVCOuPFs5sS8Gk+BUNe6qHlHYxhUwAAAAEgAAAAEwRQIhAIQNaLxdbh9jbmo8XUpeh65NpHsEqSLeCn3vbf0PzRs+AiBQ6d/eaX/dBHHtett0oOuwUy9B5Lsmu+mZpgJvnW8smQAAAGcDQVRIFUPQ+DSJ6CoTRN9oJ7I9VB8jWlAAAAASAAAAATBFAiEAtWcrg98Lvr2w59NubF07N4sHgGe1hzjthJNFjtBwrG4CIAsadJUKTvT6rh/FHumQzRghiMNj205Z9POhlw2Dndt1AAAAZgNBTElCicBDoSOS8QJzB/tYJy2OvYU5EgAAABIAAAABMEQCIEvduqbrD6X4AIK7Gl0i5iBqpvChP7rxZQuwPGv9o3nEAiAvQEEMyHVSyK1IFg4ctux/bLJOBu3xOAO8x3xrMAQaqgAAAGcEQUlPTkztp5BqXtIXl4XNOkCmnui8mcRmAAAACAAAAAEwRAIgfoRvaEqYDd56qSss6GGSPgcMMsN0W3+Q7W/QzLGNl+4CICBgMrynwO+NxdjWiAZG7cmNHv3mJYcInlo7w2kYu50QAAAAZwNBU1QnBUsTsbeYs0W1kaTSLmVi1H6nWgAAAAQAAAABMEUCIQDdr6XN6a9KTzhBCBvt8ueY74bDPUTp2S3odzZ4Y8z/dQIgRjWJJha+Y3xxnsLK4tYeRj5bvXOoqo75bJ2kdv6tp2YAAABnA0FJUifc4exNP3LD5FfMUDVPH5dd3vSIAAAACAAAAAEwRQIhAPSzz/KHptBaeDtIf25D1c9I6TmS0wFjTyTGiBazw5msAiAq0eixCnqP4nWfCwsxhS5Xp0/lSW+XQLCvwcifaRseTAAAAGgEQUxDTxgaY3RtOtzzVsvHOs4igy/7se5aAAAACAAAAAEwRQIhAK5xZ+A0KhorZO63NJhibUTT6tokH/jnPFcd4K2TdCL0AiAUSi8muIIw/eoZrLwBSuXBOcMwhCcKX5LG4lJaH7DiagAAAGgEQUxJU+phCxFTR3cgdI3BPtN4ADlB2E+rAAAAEgAAAAEwRQIhAPS0Y6e1Q+p4Vn3NQGMZQWP2azjgejEwlmHiH55mHmwlAiBaH0o52KwDXTwt63err1xnY9TYGYPD3v708Az9SvRwsAAAAGYDU09DLQ6VvUeV16zg2jwP97cGpZcOudMAAAASAAAAATBEAiAbVx6oQwz+KKMhS+2YWRa8NVVw2MnMVcJ81LqwNLe25gIgWCjyEP6fE1Ki4lm8mMC7jhQldF8GF8KPEN0DwVxilrAAAABmA0FMVnRMnDbRzDJopLmy4oxgsXUshel9AAAAEgAAAAEwRAIgaAwtw5gJ1eNx08+2VcmQIpYlMQQpOAYGf/alScxakLgCIGK3QJ1/kfoQeyIsLLQAne5CuUQrJgChyEP0X4mr9ivTAAAAZwNBTFBFS58km8FJLumVeTu8Ple4MPGl6QAAABIAAAABMEUCIQCSeSg/wXWLkGtpPCdkjHnM3Gh/IKwGK4x+YZGaFlIYngIgKaYvRwzhMrZDAUZCzqpeBczDodffWX3GeHa4zOBqta8AAABnBEFMVFNjisFJ6o75oShsQbl3AXqnNZ5s+gAAABIAAAABMEQCID5x9g1JbpGhmO1f/hGQY+m8a3pX7FXFL9hK68vlaZIfAiAalmEtouvLFSEeJLq6ub1GPqE+QFvdOWXzkMlWN71QuAAAAGcDQUxW/BeYbuwHtJNI0kI4dV/zun9/0oIAAAAIAAAAATBFAiEA7b0TpVjTAQfPaXhdoAF3PldvynvpPXWC0Gv+8xmKpQ4CIGO+kWawbNyZGIRiQZ/UB3PZWqMNqQhhwIlXN5OxumfvAAAAZgNBTFhJsSe8M85+FYbsKM7GplsRJZbIIgAAABIAAAABMEQCIGpLNoiyOjK419E3AB0dVjRM8CZSERAtIX0WGmCWqLj4AiAmtFKR+hjv7ff7xpy5vWWRQAA0nTXyt0snBuVg1r1fPQAAAGcDQU1CTcNkPbxkK3LBWOfz0v8jLfYcts4AAAASAAAAATBFAiEAgmimO4fvf9upErEbV6wSOD03Pl+FxUdrsV5DXHsTxGECIGCRnXqQEmJxsEDgxwRVvDPyzXw9gNBDLo1ev86SWgduAAAAZwRBTVRDhJNs92MKo+J92a/5aLFA1a7kn1oAAAAIAAAAATBEAiB9Prqg5PQ2MRUAS66ysUpYHw+wLyAt7lUCi67VUrogVgIgDLKf9BIxVw/c5KNuZXOAf90SLj0X6izjMCLOu57DuRwAAABnBEFNSVOUm+2IbHOfGjJzYpszINsMUCTHGQAAAAkAAAABMEQCIBAa4hsijsLeLixww6wHHovKGqmlYJoWNYrcU79FUrt6AiALj/GtmaHVrbRwfPioD3Rx4qDGGie1tsSHxXVWKhwU6AAAAGcEQU1MVMoOcmlgDTU/cLFK0RiklXVFXA8vAAAAEgAAAAEwRAIgNKphg1dMIxERuqJcRzE0It4FnvYoPBksMYZdw2I3GQECIBBiwaV0/V8RVB7jq/kMKaBe23ArlwW2rhDvv8hEY1AOAAAAZwNBTU84yHqomyuM2blbc24fp7YS6pchaQAAABIAAAABMEUCIQD/eM8mwgUWppsy7DXeMUkkQD7P7vbmjhAxSev1yeCwCAIgVMnuQmfr72eg7zEzMAfzeVMUoGTa85lwkmw/h70QQg4AAABnA0FNTnN/mKyMpZ8saK1ljjw9jIlj5ApMAAAAEgAAAAEwRQIhAJ3M0DMYBJ4Djtu3GxJViDUhW7LCsG4qyY40H1801pntAiBEw9xrbWRlj6ZvV2CrOziw76MiPqimK2HdMBqH5LtTYAAAAGcEQU1QTNRrptlCBQ1Inb2TiiyQml1QOaFhAAAACQAAAAEwRAIgaCviIeVUb+xM+BI7w818aQqhtiByFrWK1/fmofosT5ECIDeSBrzMu4A3Bceh0YzhDJ8qYQYtqUrgg00X0Md9fhgkAAAAZwRBUElTTA++G7RmEpFeeWfSwyE81NhyV60AAAASAAAAATBEAiB6lrk0uRN8xIDeBybIK0mwupBYN8+dfi2XNUjZNO6oXgIgcee4FRSitEMhnBUtKJ0WesCxupxk9SGDtkuhrjTe6kgAAABnA0ExOLp9y6Kt4xm8dy2033Wna6AN+zGwAAAAEgAAAAEwRQIhALKh8Kz5CKeZNNJqKGa89JQmbZCCFis8YDfds67a7SOHAiAILrd24cJqwkp5VyZtVIAWw/ZUZFk46OLNFkVBEjEC2AAAAGcEQVBPVBbB5bryG5+kvJ8sN05NwZ+rWsXcAAAAEgAAAAEwRAIgclLd4qBeN/dCK4Ev/ejHyHD0SHITTudiptWvUl7Oo/8CIEYoT8wfieJJDCnYr1tUIigE1b2E2QD/O6TJPzWwP+9EAAAAaARBUFBDGnqL2RBvK42XfghYLcfSTHI6sNsAAAASAAAAATBFAiEA2d+qWS9YPBhW2Mqf04ybSqP6QvOnKIWHbmVJ4YDUtGYCIBPczKAAA4YDbylh2qVmyZOKlA/Cid1hxWni4IMnuklaAAAAZgNBTlSWCyNqB88SJmPEMDNQYJpmp7KIwAAAABIAAAABMEQCICHAGG4Q7MMl3rSUHm7b5dNmOM+WzaSwhGnepXtQihJvAiAPA109BJ/4f7w7CdzLiXZ1tvScF+hWutCSQY94SEv9WwAAAGcEQVJCSVv/xF10DCE+GbaLQOntiXBfSV5EAAAAEgAAAAEwRAIgQIFLMW3tjWx1MwH0iEJO9JY5NuzwcXSXd7jo9P3ve98CIBQdwKywzczcRGl3aO0aqRq2iSvozbopkHsvu4v+WUxjAAAAZgNBUkKvvsTWW8exFthRB/0F2RJJECm/RgAAABIAAAABMEQCIHH27Nj1QlgYgcVkJDbKMJs28t4njQHHDmb41SucxMfOAiAYIB5cQ4f7ejYqxE8GcEEJgqhM/VfAzdlM5kO/J/tQwgAAAGcEQVJDVBJF74D02eAu2UJTdej2SbkiGzHYAAAACAAAAAEwRAIgASDRlYcAyb8mJXEvGWBGb2BNwqLhHTMwr8sTqscwZ90CIBUQnCQINA0+RtMYlbUFZBYKjPuPzE0Vktsm/ynW7WuwAAAAZwNBUkOscJ/LRKQ8NfDaTjFjsRehfzdw9QAAABIAAAABMEUCIQDNUggBbHXwK6MN6bSG6c+m5EodSUkJ/xYSUWgIIoL40wIgDhwoPxFVPAgKmLHWLfPSrkCS2vunm2Iu9M2v/6wniWYAAABnA0FCVLmNTJdCXZkI5m5Tpv32c6zKC+mGAAAAEgAAAAEwRQIhALBpMSiv9gWeJxEExT2QVpfiFwl4MAmEHChBePvQl1NlAiBzSRV71oj6E1HRT1TkdUiH8hhJDpxY/ecDvn/qTkSFvgAAAGYDQVJU/sDPf+B4pQCr8V8ShJWPIgScLH4AAAASAAAAATBEAiBAnU7pWVNGf0i6wMXNTJScqFNKXvm+5yyck/nKrHpMLwIgMHwz73U+MPYN4wTpcPa/Qpy/GNlgOpJheh1RXYr6NXUAAABoBEFSVFPwE+DqJss4azAheDoyAb8mUnePkwAAABIAAAABMEUCIQDp/ukKm4m4PB5dKZLLLoLRJh9zAxNrqJtQtlaHty4vTQIgIx79vOH260uW1a1ZLRreh+iuTW8loSHC7ckaGy7RE8wAAABnA0FLQxykOhcLrWGTIub1TUa1flBNtmOqAAAAEgAAAAEwRQIhAO6WAWUby5InQ3Jw6kSRyK2bv7NsuXJDw9rJSR8qDh/KAiB4M6em66wO2mUF5MoS04WeK2Y8aF4mETP+JtQWOGj9nwAAAGcDQVJYdwX6o0sW621338eBK+I2e6awJI4AAAAIAAAAATBFAiEAhGk1RZOwkV9UEttDBTruZ7bVsPC6U67QrpAicmy3eW4CIC11/BgYKv0BTHyogPZVC2D83K5pZVScn9Z2DV+Py1+oAAAAZwRBUlhUsNkmwbw9eAZPPhB11b2aJPNa5sUAAAASAAAAATBEAiBg2yyazs3mTEiB3acIb0KLlh0Tuy6ehP0HU4DNcQBkIQIgcMyR1lx1gc81Qg/rG/TF6coptM0/qdbRNolx+h6jhN0AAABmA0FUWBoPKrRuxjD5/WOAKQJ7VSr6ZLlMAAAAEgAAAAEwRAIgbJfhOX5Gppb09WSB7GX79a7bup/5Z26+LXPpO1FHw0wCIEsjwFeQQiSJ22uYJOPm/mGSBGO07q0/A7/t8QA6MLH5AAAAaAVBU1RST3sik4yoQao5LJPbt/TEIXjj1l6IAAAABAAAAAEwRAIgG9OVFYU9ipJnA5wRZ4cEpaMFgx+gCa2hLI9vO5761GoCIHSQ4OEgC/aQSkE6UAlKKYS3opAJxOYDjohjdSflhz9KAAAAZgNBVEgXBS1R6VRZLBBGMgwjcaurbHPvEAAAABIAAAABMEQCIHkbA4qWGewg2lb5+9wMveY74tCek9d7IEPHNk4PEI0uAiAjtj1rco/rc/i+whdVOQmBaWkppur/XlDmKJc5gXD4jgAAAGYDQVRMeLf62lWmTdiV2MjDV3ndi2f6igUAAAASAAAAATBEAiBdScdg4NeSli87mxlI8m7a1ijMCKmWwS2DEyxnADWBJgIgQXV0TtevcXs/26TfDPO0/qXf6Bz4g8dWzb5HoIXKTV0AAABnA0FUVIh4NNO41FC2urEJwlLfPaKG1zzkAAAAEgAAAAEwRQIhAOf5N/I/kilnXeBNKF4cPC0KQP3w2coRDCPMU4cuQlffAiB+w21t848M0FOdKfq8PPe0UforiqOWq/drbAaadwZc0wAAAGYDQVRNmxHvyqoYkPbuUsa7fPgVOsXXQTkAAAAIAAAAATBEAiACUa2MZ4/HgR530j1aYrXTodoHcbOAB156NVZ2Y2OFLQIgIRGJfZt+MfLrGpWVeNheyOgq2RkVvzEm8m3Qgab35I0AAABoBEFUTUmXrrUGbhpZDoaLURRXvrb+mdMp9QAAABIAAAABMEUCIQDDNKBOs6JmWvXY2LdQSyk9M1W/BQfhd7FmS2Vbg5o+PAIgIxFg0nB6NtX967Vj7dq68eUAlup7u/SUclOKVvilS9AAAABoBEFUVE5jOXhNlHjaQxBqQpGWdyoCnC8XfQAAABIAAAABMEUCIQDpbuqrOD32q5Z5Qn4daYCNTa1KuQxl5MmgumlSEmwVlgIgVASCRhtjVUVHle/ObkpxahbGw+21rl3ynLOmEPkzpU4AAABnA0FVQ8EtCZvjFWet1OTk0NRWkcP1j1ZjAAAAEgAAAAEwRQIhAO/SSLTPdHXvAUIWbC98+Cbng7snVXavWq311Tklqw+XAiAJt2GTVxOAxoWl9slZO/BiBqHsCCq/PiLNakyJJL/vNwAAAGcDUkVQGYU2Xp94NZqbatdg4yQS9KRF6GIAAAASAAAAATBFAiEAro/i8OnysrpVEneAGuqcpS0GSjfghuT3ECD2lO+Xsz8CIDGl1spVRSUqNK8B6D24PBupWRjmHaDKctdGSq1Mj9nxAAAAZwRBVVJBzc/A9mxSL9CGobcl6jwO65+eiBQAAAASAAAAATBEAiAX/bg10BKER6uGS/piNQy9nQE2MHq2Uykbg+Z90x83VgIgS2u8VcYjn7Uy1AracRWeC40C+rPn115vx1HXmL+UrpkAAABmA0FPQZqxZdeVAZttiz6XHdqRBxQhMF5aAAAAEgAAAAEwRAIgfVxyFRKFIsq9m4xblz20hYRBr6MQthy/BkDbAmb8NeECIGKOrzgj+cEJu87m2fCQ/lJIOWzfzAAqJd1gYeJqELc9AAAAZgNBVFMtruGqYdYKJS3IBWRJmmmAKFNYOgAAAAQAAAABMEQCIB35TV4FaXI4qiXpj/u23K7m3jTVvpMmKUShzdlzB3NNAiB5U9cqssigX+b4eE7NX/0v9sY/aM/Tafbfg1vV598F1gAAAGYDTklPVVTgTnZTPh0UxS8Fvu9snTKeHjAAAAAAAAAAATBEAiEAx59v7FVy3Y/8ZfYFO5Z5EOfrJT+NO6emIU/i5LhdOYMCH2aqiiYMKWGlCTzuk7mkPP19gjgZzQIaUdMOpRRDvigAAABnA0FWQe0keYA5axAWm7HTb24njtFnAKYPAAAABAAAAAEwRQIhAIRpyoLHJH6dgvRNcenttU4WfexNNCkVaxmrp3ZjD0sKAiAGsxujZR+H7Kg7ztD1ZJdrpt9BvC1QFUDuEiOHs6eGAQAAAGYDQVZUDYjtbnS7/Za4MSMWOLZsBVcegk8AAAASAAAAATBEAiAuaZPHXidJxYI6xZ5I90At7TFX6xLFxN3OFnDMP7yemgIgIIfz2W0lC0LmGHLwkluuLfui26RCSm2I3kU8hCclFoQAAABoBFdPUkumhlFPr31UKJJm9IPR5IUsmeE+xwAAAAgAAAABMEUCIQDz93BIxF5o2Js91yXbUWBbodQgQ8wetnG2eBDHBUWllgIgZmtdipahgYEsIxhcUCZjZjow9RmZVfrHBOYxJqqu4B8AAABmA0FYMc1LSw8yhKM6xJxnlh7G4RFwgxjPAAAABQAAAAEwRAIgDk10+LOiRqsIr+04tEFavpdBSjUS3pdhv9AqOHp82pMCIC/zSead3tpy8NuMT4PsnrNslBK9AI9j11ojmEIZtg9QAAAAZwRBWFBSw55iagTFlx13DjGXYNeSZQKXXkcAAAASAAAAATBEAiA5EqlDY0S2W8wUvsS42TGQC8KfFaoEqTDnUXgJsYX5/QIgLSlgMKvBZ6iLBaAZS43PTO7gb6YMrpozAl4/KPxcF18AAABnA0JCQ+fT5EE+Ka41sIkxQPRQCWXHQ2XlAAAAEgAAAAEwRQIhAJgHl9S+/gOOa6LNNnsMsCpXR/IYAV1LY1eL09QDsekOAiAmKKbNVEKxu21os6Ir4igxONgU2ZSK59N4ulEc26slrQAAAGgEQjJCWF1R/M7TEUqLtekM3Q+daCvLzFOTAAAAEgAAAAEwRQIhAP0lJYeBhWGVjthfu4yBRgX+wWZzRXAT3emMWkwqeuDIAiA8jjBIEzmP5d4vQa8FiY4aWLRXS+QfeFivY54Ybfo/hAAAAGgFQkFOQ0GZizuCvJ26FzmQvnr7dyeItay4vQAAABIAAAABMEQCIHchm/jm8Ws4e6o62K+3Hd47kRel3mm9JgE1yJSNVr4UAiAll4IrEbv8sM8YuziViWtBA2LyBvtiSlWxAWZWEiEWpwAAAGYDQk5UH1c9b7PxPWif+ES0zjd5TXmn/xwAAAASAAAAATBEAiBQLvpUPb6hraIImEW8XgKMnGtc+b16ZNz62SJf3cHrywIgPeo52XLFupIyNrCYxvNxzeSPayYN2YEKbL42j9gVNoQAAABpBUJDQVNItbtIVnv9C/6eSwjvi3+RVWzCoRIAAAASAAAAATBFAiEA+dVA+S4VzXeho9ohKT8Jm6j4iu9lq9Q3XBUYbVXLLwoCIGc+5cfeLPtNlTRbV6e8AcSGG4VRjfrF10R1duHFY0B2AAAAZgNCS0PIi+BMgJhWt149/hnrTc8KOxUxegAAAAgAAAABMEQCIGr88waEq/4cOucHDm4HqTLfTph5+yxZCU7DwRyX6bbeAiAuNDN2XTDPJaJZ2Th9RnSO5u7fq9W/GoUxODt09z0L/gAAAGYDQktYRSRbxZIZ7qr2zT84LgeKRh/53nsAAAASAAAAATBEAiBWN+e2Z7jvh64phpta6qpWgMzQtxPKlc2LuH92trDGWgIgQN1AmUO5m5x+e1cQjAZmaHVGI6J7PCWio3Bp7yResmkAAABnBEJBTlj4fw2RU/6lSccorWHLgBWVpotz3gAAABIAAAABMEQCIHViD6CL6NFiNoHxExcgULkjCQ9PbW4Hn2REDDVFyUE6AiADwmYp24bPMC4GND1ofdwA+0lRWUk6tisVRvF6SqjKlwAAAGYDQkFUDYd19khDBnmnCemNKwy2JQ0oh+8AAAASAAAAATBEAiA56IPUnLsQ6GgFJ2wzLUxNISVfHc6BbLVP7+VIQSYxYQIgAJVZbnRmJmHJO38xwOkoLjOlcVE0wOfTqYz1pGN+1fEAAABnA0JBWJoCQrejPay+QO25J4NPlus5+PvLAAAAEgAAAAEwRQIhAJfHv696k5niwjsyEvGSRXv4GV8+A9G7Ixd1yjgc0JLlAiAfGvP/kDHcuSlsdBSJA/RdOt6B1cBVKbbHnvV1V42S5QAAAGcDQkJONaaWQoVwg7ovML+rc12sx/C6yWkAAAASAAAAATBFAiEAoPOeqnVUJwi/aKzObQjwGHaGgOf5LULFTsMhheymjvQCIG0Z/fekLzH8Gl/JfCD2ZdFHzeU0ic+jwpomvkbX8UFNAAAAaARCQ0FQH0HkLQqePA3TuhW1JzQng7QyAKkAAAAAAAAAATBFAiEAkZ8Xb56B0Y3ztUYq+Ptd2rjL/AHt/8+OK+U4hJcuUrECIDnDpducDSu6GCIsJF5CDo8tG2wPqGib/e0tLZOUeQKTAAAAaARCQ0ROHnl86YbDz/RHL3041cSrpV3+/kAAAAAPAAAAATBFAiEAgqwdiJ0EcvgQGm79pZbOzqLEj2lgmFsfA3TZA4nHcEcCICD0pObJeKmxKBYUGmvS2z0jAVwCy+jxrHGjgjPSg5bEAAAAZgNCQ0y8EjRVLr6jK1EhGQNWu6bTuyJbtQAAABIAAAABMEQCIBTaE+0XzuIbhfdy14SOK4LmANBJnnDt2vZXoJGSvU8zAiArFHEnw4ndHRUEwkjvKxWsvkDIOfHMPFig60sUavtBcgAAAGgEQkNQVBxEgXUNql/1IaKnSQ2Zge1GRl29AAAAEgAAAAEwRQIhAP4dxSL5yT7PkywgZspmxwqAkTwfKJxXCB3zC7sdFT4rAiA0dpQj2zdItnBwMwk8FWPHNCvYdaa7RpHWKCUr4wRhZQAAAGgEQkVBVC+xK8z29d0zi3a+eEqTreByQlaQAAAAEgAAAAEwRQIhALm93h8ckS9BRs/3NDWh0FeqkZa3oYYoq8iMyaEo4AHkAiAP/BzfoR9Swbld6g3ZY4myKcLZB3shrEvNRoGr9fMDngAAAGYDQkVFTY/BRToPNZ6ZyWdZVOZW2A2Zb78AAAASAAAAATBEAiBh5eL/ZM4pFqB1eE4cvyL7tJZreepGJtVU6i6eONwnjAIgcJCr5OhbuOToP9dIvt1ll26XGI5tozQMhuaagz6u590AAABnBEJDQkNzZ6aAOdRwTzC/v22UgCDDsH38WQAAABIAAAABMEQCIGv9j+SlYV4tgryZzRYdsBR3TbcvInyziJIQU/2+64/VAiBF3h+ohFlAzaQKlHcZ9vxeE/amm7SHistluL5jW3rQEQAAAGsIQmVlckNvaW50weS4yuWSaewdhdPU8yQ5YEj0rAAAAAAAAAABMEQCIHvWrxvshVhBPLwwKtA/ZN9QtH8WF5HytHy5VZqUnFmOAiAMas5+IsI7eDk+mD18bxVhZ1/BQSwhHutJMH1/4AhWqgAAAGcDQlVDyjwYpluALsJn+PSAJUXn9T0kx14AAAASAAAAATBFAiEA7CdCqfvPENhsNCVq1VWQ4OzJHsSWLyxIV4TrkjD7hxYCICeGx43pJn1UchHzEjy47MUiwYzcjz6EO/61BHNUUxp5AAAAZwNCQkk31AUQovW8mKp6D3v0s0U7z7kKwQAAABIAAAABMEUCIQDxJ78RBbny2flsbfgPiMqFOUUSzw3gFOzWiVr+2Ik4YQIgai8zwUhyNsX8CmWP9WGFMt7kBQt3yTDczfihx5T/8V8AAABoBEJORlTaLEJPyYx0HC1O8vQol87+2JfKdQAAAAkAAAABMEUCIQDkRmuQvAam6kN2YLLCvPJxth5p8fRrDID2tzpMhfgSTAIgR7/sst/MCX0L7R5uG+VSUXEeDQPkoAHvTeztePwNZmcAAABoBUJFUlJZauuV8GzahMo0XC3g87f5aSOkT0wAAAAOAAAAATBEAiBxu35HR/LTkKw4WwE/cxdPEom/yj3KnGAZMb//CI4vQAIgR/ex63c1+1odoVYhBtqaw78OEvcMFI2Sgua4sSX76fUAAABnA0JQQ+hloE+w1WUQfq+QSe8iwn3QxLvvAAAAEgAAAAEwRQIhAMGVwdacA3W5I90zPu5ejC9gSYt6XTymUfYnEQPfOq9CAiB/uQIxpu3FO28H8cCaSibsho1ZrDXFqpo4RThsMZfRXAAAAGcDQkVUiqM6eJn8yOpfvmpgihCcOJOhuLIAAAASAAAAATBFAiEA2g21Yw8996q+iVO+PVRpC4L35CyaXCHABH/sPXnejW0CIGgQGfdNcHRCKoDTXiVIp8iaFg0KvGsjhZuhhzCZE0uaAAAAZgNCSFL+XZCMmthfZRGF2qakdwcm4rJ9CQAAABIAAAABMEQCIDVuEeMdDdR4hDjOE5SrhRWShB/fljTfmkW0CweL09SVAiAnFWP7SDtEvbIeqayhMmEMB6GiLoQsleCdR6Vj7MN5AwAAAGoGQkVUSEVSFMkm8ikARLZH4b8gcuZ7SV7/GQUAAAASAAAAATBFAiEAj85dBUszpAWRdAkICSVUt3Ldqp3tiR9ITTRcYbnXk+kCICYeFpcPZrHEOCOjqaAC5siJkv9NHzoQMrGlmTSb36udAAAAZwNCS0Kyv+twuQPxuqx/K6LGKTTH5bl0xAAAAAgAAAABMEUCIQCenuYpDAyw3zOlgZj5HjxAL909mRtwbZEWTk0EUn7mQQIgBWapVtH7gEhA8gSQN7Ai6JvKgCi7wNqdeBqLz+3+UBMAAABnBEJFVFJ2MYbrjUhW1TbtRHgwKXEhT+vGqQAAABIAAAABMEQCIA8mrjttkGU+tgxxTHboZDlE6yVXkFiIxYPWehCOB7ByAiBVLSChE4ThLo589CgQUcMn9CJm2qtmF2cUeqm1v5vJWwAAAGgEQlpOVOGu6YSVNl/BeWmcG7PnYfpxa+5iAAAAEgAAAAEwRQIhAN/6YyWhPHRy/fCl+0cnp6T/3gcMwtaTr/g5VTguDQHFAiAorDDZBV4iun/J5DJqISUqzwwNWnZpKCGj3n2p5elQxwAAAGcDQmV6ODnYujEnUaoCSP7WqLrLhDCOIO0AAAASAAAAATBFAiEAvjqh3t3CeOuyWcs453rWgsIgYx4q2ttqJOEXFz1CJdYCIErpiONagCEEbuGYwh0Z9QXMPqnNUb7wrqpVNToIRI4sAAAAaARCSFBD7nQRD7WhAHsGKC4N5dc6Yb9B2c0AAAASAAAAATBFAiEAuiG54Vzy5XLZh8HbbuadBdraEY326YfLS9TagvNBhHYCIAMsKPW7V4jneBsjHUKVcy0g063gYTU8UC1hOCJWx3ERAAAAZwNCQk+E98RLb+0QgPZH41TVUllb4sxgLwAAABIAAAABMEUCIQCtohdpZdPkRx4llGgl6q0s1HrSrDF5RaQqtKZPmnVb+AIgfwxQr9hzlufddm74umEbn7R6fbBDuFo/MvsZtdbrFawAAABmA0tFWUzZiK+603KJuq9TwT6Y4r1GquqMAAAAEgAAAAEwRAIgBt/NCeHIKVMO7fBq3WOy4M+bSQaOXRIzW6dZywadOhsCIFUnTYEYxskmsr7rxhcs5clB0RxbWBBUC37mQ8EVGLNfAAAAZwNCQVLHPyR0ABrR1q7WFa9TYxFIz5jeawAAABIAAAABMEUCIQDJb0F6FAZVg9wsueOCD1M4NwSUZFktQNhpWzGnp47J3AIgZh+I2O/nPlB9d1xOcu6zuUtIegh70ieFnjh0piZhc3UAAABnA1hCTEmuwHUuaNAoLbVExnf2ukB7oX7XAAAAEgAAAAEwRQIhAJ2ea1NaN7Mzk6pfI4GE6p9BsV/ptEoX2oF5jw7gTmQDAiA0f0lPs5BI50K2DybN30SvWt3jMsCVLjpfcofSU6YGGgAAAGYDQk5D71HJN3/rKYVuYWJcr5OQvQtn6hgAAAAIAAAAATBEAiAtm8BfF+CwnK47vugFs5zhqULaKafXhbhnmg9lXINDGQIgDgl0oLSFhriysasxWZdBHLqQpw0z3LttZh0UE1fHaFYAAABnBEJUQ0ECclg26/Ps2xzfHHsC/Lv6onNq+AAAAAgAAAABMEQCIHKzMI1vxVikbu4it02Tz7xqk/UA6cgM3iw8TEHKhfE7AiA1stLdgcJHQARcC3ghETrFZnuIaAv1v39MFM9flyRp3QAAAGcDQkFTKgXSLbB5vEDC93odH/cDpW5jHMEAAAAIAAAAATBFAiEAzkM0ovFg6Q6ZncAzkOe5n3NNyYzragKgnYH3xtNNek0CIG38oYxrnS9FwwRNdanLTUeGSJsSbyhjVgIeaO+s0wZLAAAAZgNCQ1YQFGE+Kzy8TVdQVNSYLlgNm5nXsQAAAAgAAAABMEQCIBYVH8UK8siRZynRM2rzNk5B3ii1iiywpMcBnYRT2QOAAiApQPtCfGHvH5koQp84nW/xDrl3DdBNJcOGasIBW4us8AAAAGoGQklUQ0FSCLTIZq6dG+VqBuDDAgVLT/4Ge0MAAAAIAAAAATBFAiEA6Wks51KkYoFrk5hlZFjTcV0rDwugo/lHii6MD1WUeywCIHKQbFBchWXNLeooNHqo+DAzmr9Y2YaLZiDEpVcbu7tdAAAAZgNCVFEWsOYqwTovrtNtGLziNW0lqzz60wAAABIAAAABMEQCIEBo2hc1ReVXJQd3nDcL0/MoIELUAoVVe4iUzuRQydr+AiAVybKeD2BtW+zBwckW8E1D+849fVsReGW3QetTEWpfBgAAAGUCVkSam7m0sRv47M/4S1imzMzUBYp/DQAAAAgAAAABMEQCIBhtehp9iTGKUC9MlM/SBSMSj5rXQCBgRUCdt/FSOdttAiA2NxZaoDYqXfZ/PLKTsC6YLBHrgcIz0nSHq61u2pbTTwAAAGkGQlRDT05Fh/Xow0JSGIN/PLZ9uUGvDAEyPlYAAAASAAAAATBEAiAklBDpxtiZMfwNkoaILWaWnn1dTl2lARL29JwriLnXUAIgS3VbkSZspccSz2a+xgPry2lEQ4lsmPOM0XKPz2Jr/zAAAABoBEJUQ1JqrIy5hh5Cv4JZ9avcauOuiZCeEQAAAAgAAAABMEUCIQC3iBv8Q85DV1EgMtEc6qlVMDrWsgv2Hr0hQZGkAknsSAIgJ2x3rQN7lQd+v8RRT5t7ubEKAJzWednSrHH/tWSWM6YAAABnA0JUS9uGRvW0h7Xdl5+sYYNQ6FAY9VfUAAAAEgAAAAEwRQIhAIrq5hsI1OBEBUjceXqk5yAKudsraKBSVV8lq+zrTtMcAiBACUWMsOTHGjt+cOPF4iGkrZBKMdiermbwq8yJMhtkTAAAAGcDQkRHGWGzMxlp7VJ3B1H8cY71MIOLbe4AAAASAAAAATBFAiEAtdqUKCGV4C8kbdRYQv92DHfYrXcvTbl0qAB5nGvPvtcCIAIoWXHd5Iz7a8uafhvB2zcGR5o57uHllcHP4v01HKd2AAAAZwRDU05PKddSd6x/AzWyFl0IlehyXL9ljXMAAAAIAAAAATBEAiA5Eysjdbg2R9Vn20OSlppR7iZr/v/cCw9BJq3DB3c0MAIgAiwTln8HiX6O6IFNQ9t5nUQYjqJ9YqpKr33haUzldsMAAABnA0JUVAgKoH4scYUVDX5NqYg4qNL+rD38AAAAAAAAAAEwRQIhALIeFd1GfBHh/tACcn/e4McDrbwyvqAvPDPjZ2OVfWSqAiAjrDC/dcCghfFZRFWrilFCKwzui9SgqzJE3dfWubfSaQAAAGcDQlRSSZprd7wlwmvPgmXiECsbPdFhcCQAAAASAAAAATBFAiEA6bjb202T80ouER4w+TknYuNQOMvxvMQ6FAnYqi1YobYCIFoDrFwzekohUTPwM9ePBybLBkdWzK8dRad947kjQk4bAAAAZwNGTFhwsUfgHpKF585oubpDf+OpGQ51agAAABIAAAABMEUCIQC56qGHQrUZDoHLjJSpuxYCclM3Tz9O/vqKjpSZ9CtKTwIgQe2IBgcg0Qs+OVuIlOIE4zyMNzw8DpAL46ABrtyZYiwAAABmA0JUUsvxX7gkb2efnfATWIHLKaN0b3NLAAAAEgAAAAEwRAIgJOxWROD56t7SfAY9GfQd1sAnCsQChF0L1SCHnmP42YcCIH52ryzjl6LaPoOSN2y85m/Ef35jeY9lxTmCrXkqO+ERAAAAZQNCS0JcObxo5YokKmJOT8lr53o4PFIALQAAABIAAAABMEMCIEssVE4PntV1YvxYDMkuXG+hk86HiCjdga/LAyY58DKOAh9IYRlJhX/dG2PPJr0M1SoWo61J29LJpQhgFjSl74TmAAAAZwNCVEySaF6TlWU3wlu3XV1H/KQmbdYouAAAAAQAAAABMEUCIQDdhonYaBOgKrZOlBUMX6tMq+wmv4A4WZXoRUvStjOwzwIgKl3FLJFn2phdF3NBjW+9eacx253Md9+2u0xXG+3ZKpsAAABmA0JNWJhu4rlExC0Bf1KvIcTGm4Tb6jXYAAAAEgAAAAEwRAIgMlyz7pI3j3rcbo2Ndladrc9Hwqxa0CpSTlEbRVdhIMMCIEBR1eyHuW/xpJyFsM8pu6EtJkc5jAXJs8KSkQHBcJCDAAAAawdCSVRQQVJL89KfuY0txeeMhxmN7vmTdzRf1vEAAAAIAAAAATBFAiEA2iqrjhGo3f1enb7SWtFd/zwImlOvuiTKnNwS+rGuiUICIFgTKbaAKPVYnVtVsNBzboPDf0mpaqpwZvHSo1RctIY2AAAAZwNCSVizEEtLnaggJei5+Psos1U84vZwaQAAABIAAAABMEUCIQDCJ7EX0Zqxt8O/jGpvdh8IGByP95PPxM8JluNTGXW0xAIgbhRohbzpglGjJDGUzlEH3HkWCIPizva1Fi++i7nJLP4AAABnA0JNQ99u80M1B4C/jDQQvwYuDAFbHdZxAAAACAAAAAEwRQIhAKSvE5D02G8bpdwM3m0cRKKL19e+bYub8vMs7XU/mlTqAiA6XHh3mPi5t9lQ+w6ncnvC7pZ6KzcQ5KpqhkNoS/+ddAAAAGkFQkxJTktCvt1kfjh9q+xlp9w6O6vMaLtmTQAAABIAAAABMEUCIQDX+6uWqHWmKof7+C+u5v79avx92X7YLxcVSOA0LnJD2gIgfMAfrgO22Wh5VpjGuUaYU0mjWXoJqoRIav8jShLhr6sAAABmA1hCUCje4B1T/tDt9fbjEL+O+TEVE65AAAAAEgAAAAEwRAIgT0f3ghLGvkBMd8EcKsd8P3D7JDsuT4CGCzzKlJgtiaMCIG0n/9gg+bXgSRjMYFjKBdU71SI1vXT36Glbdm2sNAXGAAAAZwNBUlml+PwJIYgMtzQjaL0SjrgFBEKxoQAAABIAAAABMEUCIQCN5zL6ZJatPf7IRilhQwictbZQp/Dxtm5baQHF3qFpGwIgUrS0F7glvt7LwOE2rHLHohaAeG9K2KCJy8V7r0UVi9oAAABlAkJDLssTqMRYw3nE2aclniAt4DyPPRkAAAASAAAAATBEAiBv4JJHJDNXidRtPr7AFcVUi/L3DBbXI2pMm/4Brh5VgwIga/XIF2Sa6It/r74LCKWk7YClutPzAoJRPAv0KrRohNgAAABnBEJDRFSs+iCftzvz3Vu/sRAbm8mZxJBipQAAABIAAAABMEQCICxBZ2DBxsNJ8Vfjtc/xJLiRi64htm3KbVrHvTKckNgaAiB9bfo/U7cGy5jANH8Lhn+6sQEidIAy/65D0kfoEbYwkQAAAGcDQklUCJuF+hX3LBCIy77yOknbgLkd1SEAAAAIAAAAATBFAiEAloF5D+fIb9M1tKQ/pQR0YuG69sghzc78JZ/WzNfCFPgCIFvbRtGLrUUG9KrI7q9IM5gDXyea4SgMs4zuBDseuqT1AAAAZwRNRVNI8DBFpMgHfjjzuOLtM7iu5p7fhp8AAAASAAAAATBEAiBlWIOVAd5exBLNToHHxrcyKBl0bTCoHtvT0tU+/qx0+AIgCbw1BM6XBebvTcxDgfRbCzqEAcZLMIX/Wtao7H8IKuEAAABmA0JPUH8eLH1qab80gk1yxTtFUOiVwNjCAAAACAAAAAEwRAIgYBYi6BbpT9OGIklko5aP4Tfpe/uOw1mz34E87wAaesUCIDZeGYGuekuTWxb05j6gUVYBm3zBD3N5i3HBiNiketidAAAAZgNCUFQydoJ3m6sr9NEzfol0q53oJ1p8qAAAABIAAAABMEQCIF32NneLlR4hP1vwfM+uI+tmajVxlrPZFZSnOZ7dcnirAiADmKXP2p8PqQ/1mVB6CWOGlWIZxojmooO1HQOPTKrlaQAAAGcEQktSeDz54MOFpavsn9KnF5CqNExOjjVwAAAAEgAAAAEwRAIgcDKL9TKn7svsvbQ9ZOsqiZvD0uMSa/oBTNbLX29qtV4CIEQKb+yvR8onWvXL6ilCa9NLG0YQNV9poFKwQs3GznRIAAAAZwNCU1RQmji3ocwNzYOqnQYhRmPZ7Hx/SgAAABIAAAABMEUCIQDQ/tLjYIanwnQOJtfZclRCG90/VN0n96LxbSycQoDaEAIgA4yTQN1NWQ4wi2fm+bEQlSdJCHEKCodErkZO4yvzJesAAABnA1RJWOofNG+vAj+XTrWtrwiLvN8C12H0AAAAEgAAAAEwRQIhAK49XQne9QiMs+N5wTaM7xbiPPaf2PSC3RSLtGwYc2g0AiA7BiPpFqDC1BDcoKO0XAf3jyrQQGVki5I1IE45zwaK+gAAAGcDQlRU+kVs9VJQqDkIiyfuMqQk19rLVP8AAAASAAAAATBFAiEA8P6T4iyYosU2f5VuSoh3pYKYt2s9jNgKhu/vbBoRaDgCIAyHAtiIpm9vbCwmd+EkpQ4tqeaS2yBxgayZUomft7uWAAAAZwNWRUU0DSveXrKMHu2RsveQcj47FgYTtwAAABIAAAABMEUCIQDx4JOINjJL2oN8oedrhNtYmzO970DO35kdqwnTb5kYqQIgE6urlAHX+4+3q9mW5WQ35TCaBz0aCGb5pglH7hWDlRcAAABnA0JMTxw7sQ3hXDHV2+SPu3uHc10bfYwyAAAAEgAAAAEwRQIhALY5+KeDJK+CiBCimD8eAvYHYgVH2E4FZuaIy0l9a9XCAiAnCViEqtXsc+LtYe1ezhsNxVsk7mQgoSotvDdAXbgOVAAAAGYDQkxUEHxFBM15xdJpbqADCo3U6SYBuC4AAAASAAAAATBEAiAW3cVVc2K0GI8aTcZtqxaMgNveIMrcckG/FVkav517AwIgCR0e3YdlOfvb0efQr9bvzyp8LmP2U+tIMnX5TxXwtBgAAABnBEJMVUVTnv5pvN0hqD79kSJXGmTMJeAoKwAAAAgAAAABMEQCIDuSUiwoF4HlRoAF9VT2bXk/FbM0VLqmNvsy6UM3r5/LAiBiTmf5M6LzXgFfpEMfJIKOQSwz3trb9IT4zorg9kv7wgAAAGYDQldYvRaMv506N1s43FGiArXopOUgae0AAAASAAAAATBEAiADMK2v3oJIg5PwNpHkc71scbdKBBVNU70glwbh44jNPQIgDxd1pV0a77SOaCRyatziZWx6TZ/zt17gY2kCkbFjjWEAAABnA0JMWlcyBGqINwRATyhM5B/63VsAf9ZoAAAAEgAAAAEwRQIhAJzlUDGgosDqYU3aUZmAe7ORoMUMjEwM9L+n7qkfFVNJAiB8u2fqT2eBOTH330WmLGjYCYRwHR1suHNx0EOFXrIkoQAAAGcDQk1U8Cit7lFTOxtHvqqJD+tUpFf1HokAAAASAAAAATBFAiEA72Y0ncJeQwbKJoMNcl4RqJIc5UDH5TRJfmlk3CXOKrsCIE5yEz7Ryk1uqZjuSGcJzTyVyEi2aTef0cwtVN5D50w3AAAAZgNCTkK4x3SC5F8fRN4XRfUsdEJsYxvdUgAAABIAAAABMEQCIFzPd4DCeARWxNZF/90L02GrvR+tyWDst2+MTwORuFt1AiBWmaD7Cyl22Wh+1uSv9ne0JH1CiGZy9xVFXBNFa3saUQAAAGcDQk5D3Wv1bKKtokxoP6xQ43eD5VtXr58AAAAMAAAAATBFAiEAlbaQQ/IsK0hJfmqBwdXpgLOL1Bwkpt4n3fM06nlECRQCIGle7mAERLLF6NxBzlCzmzugSde95rjapRF9A8haRUUaAAAAZwNCT0LfNHkRkQtsmkKGuo4u5epKOeshNAAAABIAAAABMEUCIQD1bqgc1qE1ME0ax/2lDFm8XY3cKoV22aNmGh9aVo1cswIgeJCP3iCzrr7tc2dlGggKimpbshMZmJZm/5tv7szjDsoAAABmA0JMTsop20IhwRGIin6AsS6siiZto+4NAAAAEgAAAAEwRAIgDERmUlZYebW5PJWT2XI0kws0f0oJ/IVZXCBK2SPQC0oCIAI96oYCJbfWkcPia2zihMGjfKODp9gH2Lte3xRf4J06AAAAZwRCT0xUnyNdIzVIV+/mxUHbkqnvGHdom8sAAAASAAAAATBEAiBIwsol72hU7WW95yg2CXXZz++ZdJTPdsKxOgjiuQ2HrgIgB9isXIz70na3CVnE617OSd9dtdnc1rHn773JpGraHB0AAABnA0JPTsw0Nm44Qsob02wfMk0VJXlg/MgBAAAAEgAAAAEwRQIhAJrmN+D80pfFUaBsJY1iVF9JhNiiCZ+qecFOHjw+tECoAiBNpZg0xWml4O4ZJ8hRt6v4MMLS6kAcC8Vf4Car9USK1wAAAGYDQk9VwsY/I+xel++9dWXfnsdk/cfU6R0AAAASAAAAATBEAiAHhMMFzrx2lZlEJbuThpOiAE4MLW3hDyvJbrmQ04qjagIgL8AC2Vb4R0NMVYdPRn8X2h+y6SEY8i5wtC59Sf70pNUAAABnBEJOVFnS1hWGg67kzIOAZ3JyCaCq9DWd4wAAABIAAAABMEQCIFYMogjBuTNTaKLD1pRwpS+9IuFucgzQAYaK/XlJKEXrAiByZiJu8+e7cakzkRJQihjfSqdJscQY0XjzWxabKTDqLAAAAGkFQk9VVFMTnZOXJ0u54sKamqiqC1h00w1i4wAAABIAAAABMEUCIQCx4B51GHqUsCRzIBkvuNBZw+ptu0MguAxL1KIwSiLJpwIgAnM+D8f+OkGnhNzmKKKqYNIC8Yv/rRV2WVNF1lOmp4EAAABmA0JPWOGheLaBvQWWTT4+0zrnMVd9nZbdAAAAEgAAAAEwRAIgXBVggMpQnSLlIhEkkEJYzf/UdXN//VcIghQqZDPZcJsCICcdRRME99aOg5KaUAGmdTFlPXT6ujg4MkDRHXH2AHcnAAAAZwRCT1hYeAEW2R5VkuWKOzx2o1FXGzmrzsYAAAAPAAAAATBEAiA6RKEiZEHZ8dzp/atj/5vc9Cr24NdmI/qTuC3rWTqiPgIgLwFRoimZMpYqG+kTu+ChGF7A+E7azppO0ZUirjGsy1wAAABnBEJSQVSed9WhJRtvfUVnIqbqxtLVmAvYkQAAAAgAAAABMEQCIEgnGNKR/Ut3iIiCPwaLAEMJKs5iISpg5+82EgTlhrAkAiA546g4J4zSEOUMOHTbKzqBYO4ZUp+/K7zZEdZK4spxAgAAAGcDQlJEVY7DFS4ushdJBc0ZrqTjSiPemtYAAAASAAAAATBFAiEAlInhvfAMU5/RgvmniPhYcHpThkcdUbmN0Nnrxq8naK4CIHMdz6o2qfZmyN0di6CAYn/WJdw/M5TXMHwx3i1hloUbAAAAZgNCQktKYFhmbPEFfqw806WmFGIFR1WfyQAAABIAAAABMEQCIFNdLPZTg7qaQVpM2NXSP7bcs1ZA1G5HQ3BPdiH/00qAAiBTA/O9tzFECjaxqxGOs5bJlUciDq+aBhH14x+3DOdZjgAAAGcDQk5O2oCyADi9+WjHMHu1kHpGlILPYlEAAAAIAAAAATBFAiEA/MXAHRJSHi4yDzLEn7gRVD5Nf6nyG0WQcuPoGzs+ZTACIEOFiEIyUwClwfp35oGLqvqHNFS42+6hCKogPplRlf/jAAAAZwRCU0RD8m714FRThLfcwPKX8mdBiVhoMN8AAAASAAAAATBEAiAdpjnDh/C7m+Y37tZzUSdMD/du18nAUoB/5nC0kIwfeQIgB/vHklChyXo67pQhI4N4B1uFHonl/dpEE5TFBIMr1UIAAABnBEJUQ0xazRm5yR5Zax8GLxjj0C2n7Y0eUAAAAAgAAAABMEQCIGXERidMHR/0ABmNhtQ+Ro/vNqgsu+qtbLn7vd0Fu27jAiAj6AC6qRqoxKd+Hvhc5mQgA3mlMK1sZPJhjeUXVE54XAAAAGYDQlRFc90GnCmaXWkemDYkO8rsnIwdhzQAAAAIAAAAATBEAiBE+WHZ98U6a8fELd8AYdB25JuB+u+lcAX/7deWH7GBiwIgQCrxpRumWsi8UNSmcGRIZ0WmQtFNb0zDa+Qmfd44vA8AAABmA0JUTCrMq5y3pIw+gihvCy+HmNIB9Ow/AAAAEgAAAAEwRAIgbXSddvglv5WPOPex/JT1l/7M09omKINoAADaLcUDaZYCIF9dH2yStATpRytC86oNJAZLNGotmMa1tnbYpIEOrrg3AAAAZgNCVE82kF/JMoD1I2Khy6sVHyXcRnQvtQAAABIAAAABMEQCIEYeFcAO/a1npw05Zez7axX5J9wmJsYgvEmGPLadIT8RAiB3YhiMjyX8gsF5/pX63OSqypLF+phhfEqKjICRum3/dgAAAGgEQlRSTgPHgM1VRZhZK5e3JW3arXWZRbElAAAAEgAAAAEwRQIhAMYjVXYXXi12dMbY8KLhU5QC952sBpTQFXUIsSgf3Nk0AiAu24/h8uOWKheJAy8y6w5rehh3b0ZrQ/z8T6A4PObn9gAAAGYDQlRVtoPYOlMuLLffpSde7TaYQ2NxzJ8AAAASAAAAATBEAiB7jaCWubIz8f6genXZqsPJcbJAJy8agq2pyfa+Hen2bAIgBYxSrQrQ1L5gFTp7HiXMcD01g/PR/nB0GGWZLn9iRusAAABmA0JUWuX4Z94eqBNG31GBuLSN1rC7M1ewAAAAEgAAAAEwRAIgbD7HAGsYaXDo2zBBzVs8LulfI5m8MrK5kdGrqQXajmcCIE3muIbtUjKoX+GwQr4Xv4K7ZgNcYe85WgNnyaa752ouAAAAZwNCTFjOWdKbCarlZf7u+OUvR8PNU2jGYwAAABIAAAABMEUCIQDJV/BYSRcU86mEdnvyuEHoWovxWPfDe6tUj3NM254vBgIgGykAkICu3QBwdeA9lrXTSA1iY/6pT1Iiydka7mdTERUAAABnA0JUSPrVcttWblI0rJ/D1XDE7cAFDqqSAAAAEgAAAAEwRQIhALG1757jsIdzbPS8FakUkK+NBVwbd6+f8XZphiblxy8xAiAMqLQ/U93eVao/K/WZ3D2WCSE6Nji3NIdqh9Keix8dxgAAAGcDQlRNy5fmXwfaJNRrzdB46+vXxubj11AAAAAIAAAAATBFAiEAh6EtMQNZ6gDsfTPFyi3wIAMUsNVTUSZt/4a7irUvMZgCIHuGHMBKaIA8cuyBa5XaLl192DkIEsR3Sh2YISjHHBXWAAAAZQJCWkN1562KAbjsPtBBOZ9i2c0SDgBjAAAAEgAAAAEwRAIgSzh16dMBugGASeEkQ1lL04pTVYMkvshGH+LcWiNlTEMCIHpOcMG9Qz2bu39bmvWzQULIJTM1jJvAEkBkbkXfESAHAAAAZgNDQ1MxXOWfr9Oo1WK37ByFQjgtJxCwbAAAABIAAAABMEQCIBm1t/TPMcMJyhmBwrFij3Cf3gf/o0zrjl0MpAUkg3RhAiAN53syQ1APc8sJ6zPBoAdH/ltrj/HRHL1DGEzGecWjqwAAAGcDQ0FOHUYkFP4Uz0iceiHKx4UJ9L+M18AAAAAGAAAAATBFAiEArll5C5fktn0UiugLjKY5BEpjTLdd1BhWoGCNxSBPS78CIFFY+B+8lErDFWGZ+eL3WHwv8dSp5uhPNlkXxIRwoEk5AAAAZgNDTkLr8vno3pYPZOwP3NpssoJCMTM0ewAAAAgAAAABMEQCIDQJTQuON95WRyGYFPwReK4p9gdvQuquRcAKQpB/Tfr1AiB/1qAeAIwW6jhnm3MmN9CI+br/ScIroOGQpu2IqvdPXAAAAGcEQ0FQUATy5yIf2xtSpoFpsleT5RR4/wMpAAAAAgAAAAEwRAIgTdnIGI7wavkacVuAi9pylru8+Rhsmilx4H/BNnXb40MCIBac0bVDcKq3jbWER+fXrK9pUVkRIeMPbUmxPcm7Md3bAAAAZwNDQVJCPkMizdopFWtJoX370qzEsoBgDQAAAAkAAAABMEUCIQC7jIJ3xJBBUd2t0uWnmTNIF5U4gfNxASOMwsKYaY0f1gIgHkSznIuaEOJUR6AwihAk0d4skRtvlFBj2h+LTO/zdZYAAABoBENBUkKlF6RrqtawVKdr0ZxGhE9xf+af6gAAAAgAAAABMEUCIQCAVZLb+2M7iWrcEYVeBkkG50GWvvOzfsA/BJy5QgwW0QIgNv5hyzHvkQmYBPt1Dsi0dkYb9XocEakz/4ochYzsscMAAABnA0NBUk2eI6OEL+frdoK5clz2xQfEJKQbAAAAEgAAAAEwRQIhAJV8vqJ60Wdw0WM5bdN1egTDUONtmHAYHuIkY1UnfeAuAiA452oRx0y0fyNTU+yatGeYDM63W3zYEvGLwHzAKV5nSgAAAGcDQ0RYLLEB19oOuqV9Py/vRtf/t7tkWSsAAAAAAAAAATBFAiEAife0BkpiZs3Q0ikxgPkB3Q620h1TYu4R2d1D4ltcUyoCIF2Jk6KDIQ0VwLORpiVSb/JtBR6XKMJ90Y65qPAvBDGFAAAAZQJDONQt6+TtySvVo/u0JD4ezPbWOkpdAAAAEgAAAAEwRAIgB6tBOa8nfURuWXPWXQ/17UCXZ73CQ69SWM5Qy4fLMm4CIDcEaO+8eK4n3TbgtjmNyuXUc1zvvDF5G4flbX+fu7Y3AAAAaARDQVJElUuJBwRpOvJCYT7e8bYDglr81wgAAAASAAAAATBFAiEAnxnFTjETUjEtrUu1KRgJyq9jpT9WgkelJm8XdS4aW5kCICcWD1kWTNeajWLwN/QNKTShOZD+ZCnpZ0otDCASZjVTAAAAaARDUkdP9JzdUK1AjTh9YR+IpkcXnD3jSSsAAAASAAAAATBFAiEAm47oilgOIHUN+dcgUN6tf9C1f6htG+QHlR6JE2slUzcCIFRvBLsLBAY8+yqegZMj2ZtY2jvyndGRpAJ+7OQVW4qxAAAAZgNDWE+27pZodxp5vnln7immPUGE+AlxQwAAABIAAAABMEQCIF13mYs9YAVs/hJVEVZxniinBWsaxe3SlWvLOnfdp7S6AiBwKnHZ9ilHQ1cfLKViW1UXVVDk6V9HVgYDWSPDUyJzOAAAAGYDQ1RYZiq8rQt/NFq3/7Gx+7nfeJTxjmYAAAASAAAAATBEAiBc0B3+1t2oQIfj9QRkSbt6UA4X6FOGmFcLU2zQv7ncWgIgP3Mf92Onp1n9gNntwQD8qzKxVZ7eFAwjYuiIwoB36l0AAABmAmNW2my1ig0MAWEKKcWmXDA+E+iFiHwAAAASAAAAATBFAiEAszQFCYZE1QFk1HuHRtJ/QYcE9dgxmMK+2IkJBH6xinUCIFQo1C2y9Ck6EN3P1gxRobXjeiaFOeA6kvcDsGxAVEXkAAAAZwNDQVN3lJLTZE3fRJWqLYDEaOG3vmrx0gAAAAIAAAABMEUCIQCoUc7JJg31RMngOoJfQg9eVkK9OBXbslAHGSImZVYxQwIgZYOyvWdK3I4l+t4jWCZeEwfFdLDXOuU6N44Vk/HxsjwAAABmA0NBU+h4C0i9sF+Shpel6BVfZy7ZFGL3AAAAEgAAAAEwRAIgOJwN/tXRsJAPjl1Dg8flBbOLZBCN/x2XGlxGTDGq8nMCIHdkHN53zsE0xiwvnb9QfZYTFprSCsrS0UwWxYZuNQ+pAAAAZwNDQkMm21Q59lHK9JGofUh5nagfGRvbawAAAAgAAAABMEUCIQDiKngImMt46IwBmFQmilshDPpfaZoz7W3/raOZC4Y1dAIgLrG6Q3Xhd1zqRsrc0poBrg6mFkrmsqvXJjwFIYwc80wAAABnA0NBVBI0VnRh0/jbdJZYF3S9hpyD1RyTAAAAEgAAAAEwRQIhAMi2TZMhHGiH2wufTUCSwMo68w+NjOTwru+dR6eAGMrcAiAjqlR5wW0bCRg10vIf6+PyeS6BHJZLApB93C+UpfTDhwAAAGcDQ0FUVrou54kEYfRj974CqsMJn21YEagAAAASAAAAATBFAiEAixeca26d9Lp9bAjVMoAlsp3T+A6tkIX1jyRgf9JNSFwCIClV1SuILw5Y85mEhT5uLbD7tbtV+ZuH9elriz02Q6IxAAAAaARDQVRTgpO72SxCYIsgr1iGIKdhKKM+TekAAAAGAAAAATBFAiEA/WNOCuhh5eZo5jG6waxrHpflqHwVRoKO7XGQqB7LUz4CIDtOH90tWWdfkBPq/5E/MTrLWy273iIliDN+LAPUVcp6AAAAbAlDQVRzIF9PbGRo4Uu1pFuWgTJ+FuUoCEudliwaOQAAABIAAAABMEQCIB4Xz02lPomNZ/lppms3UB9+Cyj/LtQipU2mXewDxDHoAiAxtXvkExkpzD6hn6AYjXpUUftyiOC1LnnW05Y3poyX4gAAAGcDQ0NDvhHusYbmJLjyalBFV1oTQOQFRVIAAAASAAAAATBFAiEAvPYy/JQeRdca/4t3fSkahMGBOAutDROxOm8cR25FP0wCIFahGxkyAPCIlLOLfYcd0mBR4x3wR/g84dIviASzKFO1AAAAZwNDQ09nm63FUWJuAbI87s77ybh36hj8RgAAABIAAAABMEUCIQCevOsu0dJnuWkRh2wiImtKXnZ2DAiiDZHBygjnfhxVjQIgXygZo83KB7bIXC/p3iv5v3VAcssWpBriRZE4+8A7v0YAAABnA0NEWG//OAa7rFKiDg15vFONUn9qIslrAAAAEgAAAAEwRQIhAL/aBwrG45UwnI5i0eG3t6hwVtwtrv18bCZLOfskvv0lAiBlARuBo0dJpKevA0+qTN/+s1Ct+wBU31i+uyPzqXwNAQAAAGgEQ0VFS7BWw49rfcQGQ2dAPiZCTNLGBlXhAAAAEgAAAAEwRQIhAN7VJ0RWYF3EU7tWdNwp8VnRwdZcpi5XxVqRtRu8KssbAiAhp9ovO2sdF+BwtSwIUQNGCPWLyw0+OT1WhJEqv6ylxgAAAGgEQ0VMUk+SVMg+tSX5/PNGSQu7PtKKgcZnAAAAEgAAAAEwRQIhAP6ojrCXwPs035FcGBhJQvDp78nJtlPlFljw51Sn4ROeAiA7v69W/qtsiaB7r87r2dJTMt7ixdaYWlTlRkVYxpUbWgAAAGcDQ1RSlqZWCae4TohCcy3rCPVsPiGsb4oAAAASAAAAATBFAiEArvTze4F6iz/DjfjXFxxQ/2o3ErMAbIZ6f/7CDvh7+UMCID5EFJ38XfmYaOBXMJqMjKtaFTxgMZveksgRz894Fe1uAAAAaQVDRU5OWhEitqDgDc4FYwgrbilT86lDhVwfAAAAEgAAAAEwRQIhAMjJ01K/LlVZlcYWQStXDcxv+JEL+H4DTIzfol9sSEkSAiBNQ4Bj6fm4xWW/iwa2+l5B2NxNu18oLuRWxkcx67wCYgAAAGYDQ0ZJEv715Xv0WHPNm2Lp29e/uZ4y1z4AAAASAAAAATBEAiAzfEYnnP3SFps6BfoMFgAGgjSB1gVbDTgZcUTe+WgTJAIgHdogCXnND52bFL3IihU0b3q13rCsIQFSIf7WuxbheeUAAABmA0NIWBRgpYCW2ApQovH5Vt2kl2EfpPFlAAAAEgAAAAEwRAIgUkP4v1u7+BZOR402c94HvnBVYzbkXaJcgo8h1wa2SQACIBlQ/wuPQ3CP9mTfQizDOOjDgmr0DQpCWSDmgCpmTZcBAAAAZgNDVFTj+hd6zs+4ZyHPb59CBr071nLX1QAAABIAAAABMEQCIHZbjpk4My1PTGRMsQcQ2X1vzbjm1heXbdDe3837ZT2eAiALpmFEujw6y0uFy40og0q2ebGRIDnRi4a3GomSMjkfYgAAAGYDQ0FHfUuMzgWRyQRKIu5UNTO3LpduNsMAAAASAAAAATBEAiBzT5bjvcA9d7aiJcBxAYX/z7r9VxY4JSptZ4JvZHmB4gIgdaHAWxDNlrlcMgVVU6hZ6kQo2StWj1lqIZgRkFioZYsAAABoBENIRisYqjdUitwYJkEbXaKqAm5+evnKTwAAAAIAAAABMEUCIQCe2DgP+lGSwHic3r54h+uhdAl8eKCdm4m7yD1Sum5OygIgBYMCjiv0Z/7He4QlFkIS4rOdI1oA2ouKBqUfsWJpPHgAAABmA0NIWjUGQk+R/TMIRGb0AtXZfwX447SvAAAAEgAAAAEwRAIgQ5MpHKHA++CFJOFd2Q5kE13DSqVWt6qxb2QUSkcgcpQCIBBH8WaB72xV7mDQ2vXQPliQ1ObQOjyoVmmCC3KlAfLcAAAAZwRDQ0xD00jgeigGUFuFYSMEXSeu7ZCSS1AAAAAIAAAAATBEAiAuWikiCa3rUsvl6I/EAafAsEKgMPLZyW1O+Bpu8/ziFwIgXIB5Nhkmyo9pNdbJR0ZBEh7BmD7bVif57dFUzjlNKtwAAABnBFRJTUVlMfEz5t7r5/Lc5aBEGqfvMwtOUwAAAAgAAAABMEQCIBBJxr3cl5YH0ya7S2dh/6QuBASeKGHqTxNUsQOZUckJAiBJ82FYspoO/CtdIDELkA4E9ScTPD3zLp9h3yrX9eqS7wAAAGcEQ0hTQrqdQZn6tPJu/jVR1JDjghSG8TW6AAAACAAAAAEwRAIgSyMLvV8XYRqjSWd2iCI81f0KWq61GTXQzkpXTdqOPF8CIHSoUrJV5ZASPSs6IQ7gbRRr35oCFgqCWgCnfkbVM35VAAAAZwNDTkTUxDX1sJ+FXDMXyFJMsfWG5CeV+gAAABIAAAABMEUCIQDEWUjuO6JYwXflwEAa6l9ClHaf2GaxSA5zgjpVLzQ4FQIgAgEwVZ6dp4gGuA9GBHogS+/c4ACRzuCZYy7FnNuGB0UAAABlAkNLBgEsjPl76tXeriNwcPlYf456Jm0AAAAAAAAAATBEAiBvyZUIULo+rDai3TDmSKdF7f63t4T5moDqHlWKehrPqwIgWe03SAst9i1ApTofNkIE8jtcMhybrH99SbdUPxDkMkMAAABmA1hDTAhDlxtKxuhCpRiqGE4CcdiLXLdPAAAACAAAAAEwRAIgERFYNo0GvaPjfhj7Z9Dwh2dekND2Zi3E0EATJmDj/FgCICByKgBza3CDPxPUxZFO/4DQRUdlIDc0pVnGwChBdyRHAAAAZgNDTE0O2DQ9/e4y44tMTOFaOwClnpDz2wAAABIAAAABMEQCIBAyr9t4aZEABM9bENRo2iEElMx8KglFo2dGeq0sZXu6AiAJNUNLOWQGeBPOeXQOWuS2YW6foAXjJlieCdkPddlUIQAAAGcEWENMUh4ms9B+V/RTyuMPfd0vlF9b8+8zAAAACAAAAAEwRAIgOcrvv2n9rYQuYTnTS5gzlRftFllPJuDSTP9N0Ics/pcCIAyPy/iiegPS9bbg7nsEsYQdqb0wJeik+LiTBTSm69wqAAAAaARQT0xMcF7pbBwWCELJLBrs/P/MycQS49kAAAASAAAAATBFAiEA1OPqpCauw04tf4BYQVj+4W+nwW03HNFUpKM2+XjFoZgCIBFuU3oPOA4BsLv+LKoLWlL7WLKoSL9Ol91QuFdPMI2IAAAAZwNDTzK0sdLCF+wHdlhM4I092Y+Q7e2kSwAAABIAAAABMEUCIQDkiPH8xAqqyeUoJ2i8Cxe5IqAugDKbA+1lSFGjJKk3LgIgF0Q/aR0bi8btYdmYbaBG1kRFyKamdDL7p9KPzuh1Zp8AAABnBENLQ1T2vF3bIbIrdqMccZqK6QQjIFXYdgAAAAUAAAABMEQCIEam1cKXQBHtpNZMWvysQ5CzG+kZXFSGefG155TM37B6AiBunkHcHb7uWZuIJipgkboZ1R0FcZv2LgF6daB4yVT5TgAAAGcEQ0NDWDeJA6A/ssOsdrtSdz484RNAN3oyAAAAEgAAAAEwRAIgNqCbLf1Ukr3MtDk6AKocuJK+5v2t5I+uBH9tI7UwS08CICdAUDFl+LS6zC17Vd/a794ZGpNcf+YlIGe6uuANu0o3AAAAZwNDTEKxwcuMfBmS26JOYov3045x2tRq6wAAABIAAAABMEUCIQC+IhJmmtFtsEJ0Y6hcRuEmRNuJgy4hPQGE+XcqhNfsmwIgFm78UuOm/hNHX0QvGiS/UN7mbtZxSHaGvDmpZK7nSMMAAABnBENNQlQ+3SNcPoQMHykoay45NwolXHtv2wAAAAgAAAABMEQCIAYwhcKE4fQWIB0hlvgdIgbtdNTrQyHDtrgfNSQRkwoUAiBfnSC5ccSjlW7I7u5HStjbFUub4MbaIdFZBJj3Yc/ttwAAAGcDQ05OhxPSZjfPSeG2tKfOVxBqq8kyU0MAAAASAAAAATBFAiEAsP0CnGjecqLTeadd+UsNaEMuyVpzVM4D9Fd8SeBWY+YCIA9aOa2uSItvo9tHGVtvu6UExCGBqMOO/FHzv+O4WgEEAAAAagZDTzJCaXRXSza87UQzOIddFxzDd+aR99T4hwAAABIAAAABMEUCIQCi2t0LLfCA+8+DLI09HUH32WUrZPIwEfEYCZMBDSu6EwIgdOGAXmdSvCCG2LuSQ0/CmfITc0CYc4iMY8Jv8hslp6UAAABmA0NDM8FmA4cF/7qzeUGFs6nZJWMqHfN9AAAAEgAAAAEwRAIgO+QIpsmw5YhC39dsh0//IIF1rxjo3aB4kJL5cn7/DI8CIDGIVZxogGOFd542lrZrCkFmdKSm6/vcqA9sIZdXgKdyAAAAZgNDT0Ky9+sfLDdkW+Ydc5UwNTYOdo2B5gAAABIAAAABMEQCICrMbfWM5iabM/pFC2DnxJHHHu3PGu8GaGpjQ8Ygz5R6AiBc8OW5DNEUvDW8FvuNU5rrKS+k9n/eoXufUo8O8Ub4DQAAAGkFQ09DT1MMb199VV51GPaEGnlDa9Kx7vAzgQAAABIAAAABMEUCIQD0I5RkR6NEB8H/KwnwmQk0FeWvGjFicGd+2CqqmdfIvwIgA31u+nlwG0FNLwmqF4NgCf6bhvduZiVhMTM/b8ha9f4AAABnA1hDQ02Cn4ySpmkcVjANAgyeDbmEz+K6AAAAEgAAAAEwRQIhAPb0YKJMGKDOeCJzveNUkRntyka8erT0dwJUCKhmYroAAiBxdMiEajxW7gmbqjOVCgWwtWjA4SoAkoBeVtmH1aTtIAAAAGcDQ0RUF305rGdu0cZ6KyaK1/HliCblsK8AAAASAAAAATBFAiEApgvBw3PgmEUy9LDKoJvYB3acexr2e283g6IUm3uTgK8CIEbHeMJGB9XpEuwrYGPtDQt8GVTH7SG1k4RwL23LFnPqAAAAZwRDT0ZJMTbvhRWSrPScpMglEx42QXD6MrMAAAASAAAAATBEAiAhrmEjLi+ubml2DcRdzDmPkColfr3ByEsMk5nR+bpn5gIgKiQUKy3BWS4tQLeax82VBnbpuzPESjr22NF86bCyUdYAAABlAkNM6B1y0UsVFuaKwxkKRskzAsyO1g8AAAASAAAAATBEAiAI4iSvnsTwmZiO0AKIcP3saCxgev669aHs6xhlEUK8qwIgK4fsRAP+/eEa1AQwJp1CJRiZftJ5aIsMAVZVbeTKAkMAAABnBENPSUwMkbAVq6b3tHONzTbnQQE4sprcKQAAAAgAAAABMEQCIDerQbVt0+se7Ezf4pza4MYFuphN/hDUblJNMY8Xab+TAiB7j6ouQaFCIw3wageOSv5nkSvu5h95x9T7cmXxrBC6SQAAAGgEQ1BFWLeH1OrIiZcwu4xX/DyZjEnFJE7AAAAACAAAAAEwRQIhANP1Ljz4x1kKG6knISn58x1Xg+x/KS3XLpK4VgZU7E5HAiAU3woDBFKbKuIiokyPe8rYOgtmaQDfFp787BiP9cU8bAAAAGgFQ09JTlOkjTt59DR3Ikkz5JLkL1ys9AkezAAAABIAAAABMEQCIDldDrIG8+g/zdXdNeQna9aC49rKc575wMHSQro5CkKnAiB3ucHNnOdA33iiLrDHV66xmN4kdBUKtfM4UjLsW5doXgAAAGgEQ09JTutUftHYo/8UYauqfwAi/tSDbgCkAAAAEgAAAAEwRQIhAKgEd+ZL3+d4qC9axYT97y0p9nH1eNKtXqLw2rJaxKfpAiBwDb5c1uFuOMsnMtmycQcBh13qU0e+k9j/jMaIl6tHEgAAAGYDQ0xOQWIXi3jWmFSAowiyGQ7lUXRgQG0AAAASAAAAATBEAiA6C75RCWGrxZic2//a1KeYDgJnJ3bzWU2S9UifIYdNlwIgY4ZLDeTiOGtqJqTWLVjkLUHISs5oc9q4IhyCGUM23i0AAABnA0NCVAdsl+HIaQcu4i+MkZeMmbS8sCWRAAAAEgAAAAEwRQIhAMUTw7kxDT86AQso1Gwt3IQZ3KQjZg5GkG4oT+oj4jUkAiAid3ilSP+vwdKVGZLNMCVX2wqFlfvKV78mkC/htX3bwgAAAGYDQ0RMipXKRIpSwK3wBUuzQC3F4JzWsjIAAAASAAAAATBEAiA1dOxWx1zeMemeT5OcWcO54+CWQJtGgfk3I04AQ7Sb0QIgA2S0YComW5DfcE3IxMpUtGlkecKk0rK7zXHclXo6pHYAAABnA0NKVDq9/zL3a0LnY1vbfkJfAjGl86sXAAAAEgAAAAEwRQIhAI4oE9Picz0fC6IfiplxyjtNogmlgD7JT4wfQaN7Sa6OAiByC2HL9/SWalukbInXG3Y2JCTtlskH3kFYTqukR8u4jwAAAGYDQk9YY/WE+lbmDk0P6IArJ8fm47M+AH8AAAASAAAAATBEAiBUe6ZDhyLY7IkH/9uLf/39akkClj9B8O6/RtEIPDsMEwIgHC+TTsTIHegakg8yg7TQMSVqbea+P0dg/Pf8MNcdiQIAAABmA0NQVJtiUTyKJykM9qep4pOG5gAkXqgZAAAAEgAAAAEwRAIgAeB+tlRiurBPX4j+V6Cp2rmvex5+J/o1OvC1JLfJuUcCIAsR9rIl6qxpqAwwzOtcpBncw1I3rWrxh0rX6voF62oNAAAAaARDVEdDnn0pvUmbbH2ipbLq/PSjnTvYRdEAAAASAAAAATBFAiEAvy37TfsWpCTeFs1WavtriyX8m8dKJHQ8lMVZbH1AiQkCICuRm9pt69JFyifYORqCuAIIZPAfuZKLLPCftGSMnzyNAAAAZgNDUEwkjCf4FO8snFHCY5jQlxXNNRQvxAAAABIAAAABMEQCIAkgGVyScNi9dd1AElIUmpqpNLByxYI9qH0MoZt2ZHbbAiBTXOFuqam7rq7IIXPDrvsH0Zavc3RyLf2sxKPRHTHYHAAAAGYDQ1BZ9EdF+9QfahuhUd8ZDbBWTF/MRBAAAAASAAAAATBEAiBza2KRTCRSc0wZ/cZt0aTJbMoRJe5hvFj2sL5aGalSIQIgG6m47fDXypKZ15RDzTpHf4M6uok8mnnA0R9mJMuLLkkAAABoBENUWEPqEXVa5B2InO7DmmPm/3WgK8HADQAAABIAAAABMEUCIQD670Mh/4fGpaAGnL3Ob23SsN+W+f7/T518585G4gfZFgIgaykTC5dy54oYxiHVWm5pl1l6Bwlo6H/OhC+uUBLFcMsAAABnBENPU03EvNZMshbUn9PGQ6MnYvNGJrRaGgAAABIAAAABMEQCIE4ognH0vqQcpHzT31PRu0fqtZ7IVB9CyouB5NRoZc/7AiBEGzgDR3aac1iU09nIC5ieZZMZT9pwUqXoB1EBp10BcQAAAGgEQ09TU2UpLurfFCbNLfHEeTo9dRnyU5E7AAAAEgAAAAEwRQIhAP6o6hioDTsPm6F80i4nMxj6xt2MgpEwXb6UorJ9Rd8MAiAxdGv+a3aJESL3syxABHjeTWfFW4Ot1XvsPdxi+vetYgAAAGgEQ09TU56WYERF7Bn/7Zpejde1CinImaEMAAAAEgAAAAEwRQIhAPIWYmJma0YCsQu81c7FCbP/oLtxIwR1Nn58fBY3hmkjAiBCp1a8emmMq8Djx93TUiVnczxeRXaUXGooM8Wf/i5rVwAAAGcDQ09W4vtlKe9WaggObSPeC9NRMRCH1WcAAAASAAAAATBFAiEAuTRTxtmraRE5YP9pZyVqofEpm4PSsSwKNf1ZGmTWjAcCICbLRlEYcj0rFyrNQj7ffZ/2Bz1gcQA29R+97IFssgfgAAAAZwNDWEMhNAV8C0YfiY03XOrWUqyuYrWVQQAAABIAAAABMEUCIQC4UQBgRvXxF2kOTSIb6ji7ecAWojxwFgDfMJWqoPhEjwIgQkJ7rLlmhH3+yVoxS5QNgagxouLQFsc9q1L65B+jmpQAAABoBENQQVkOu2FCBOR8CbbD/rmq7K2O4GDiPgAAAAAAAAABMEUCIQCbu9YG6QX7ZzSUrlGYvYGNwHx5b158bHJ+J9+RIrGzwwIgMTw5sYaQ9qE4yE7sa/e/yesQ1KkcpeJsLa5Zwn1iMoQAAABmA0NQQ/rk7lnN2G476ei5C1OqhmMn18CQAAAAEgAAAAEwRAIgAu5OHyJ0bEw+rfSoD/DuW97eqF3DQaZ9WbQvZdoU8g8CIF1oB8OKSmZu91rcBm1brMpiX9HC8zlrfveOA80OeO1rAAAAZwRDUExPcGSqs5oPz3IhwzlnGdCRemXjVRUAAAASAAAAATBEAiA7QZBHXQ/a6UXQy5NZMaWZJvA9o3xJ6nEO6b1dyHiHlwIgOs8M7QU7z3YF4oAKFLm+00TcLSoFpiGakcz32Z2/AWMAAABmA0NSN39YW5Ewxk6en0cLYYp7rdA9ecp+AAAAEgAAAAEwRAIgd/jw0QcPCS9v94TIhPlxeSKnbqRQC0bd2pX+7J14GokCIGuRluGDzRiGgjIB9W5WPmhaOMzeqhX2maVrOG30FrMYAAAAZwRDRlRZaVaYP4s84XO0q4Q2GqCtUvONk28AAAAIAAAAATBEAiAvzg6qBgrY0h+CaYBGgengMt10nBv0p9WYTPwkMA/CegIgVHnP5WlPXhgOTqJw1xhQW9XFP0pE7oRUkp8qHJZFqusAAABmA0NSQq7zj7+/ky0a7zuAi8j72M2OH4vFAAAACAAAAAEwRAIgBTVnP8biAI5Cqc1StccpihKP5SVFEISMZA/y0O4zQvECIC3XiDm74E8e85y3s2tOmKJ0hnUe6zgbHWW2Jjby2Y70AAAAZgNDUlTw2hGGpJdyJrkTXQYT7nLiKew/TQAAABIAAAABMEQCIDnGP0KT3MLWO80wjBKKCCQ62qvcgkqkV7CmcFEYfzHsAiA5JYO5Opy74aDTi3LX7A8pLA7/F6d5+B6tDNOuyaodogAAAGcEQ1BBTDGRCv9VRXhHVZcK4fvn/mXV8O6iAAAACAAAAAEwRAIgYDEF9QdOCVzlspKjqdSrWzA4CeInS1+9IhNk411i8SkCIFbAMAvQs2H2a9G5wIzU5Jz8DhH3j0zBCvcZXu+zfYXfAAAAZwRDUkVEZyoa1PZn+xijM68TZnqgrx9bW90AAAASAAAAATBEAiBrNtkgtNgsqyomMugfv016y79M79HWgkPd5QVQe2k/nAIgSv1AFpgadFmVe+v4fdFqhRXkx2VfDHrs/NZpYtm8SFAAAABlAkNTRrmtlE0QWUUNoRY1EQaccY9pnTEAAAAGAAAAATBEAiAyZCqeZitBdxt8JP1V0XiMUqSxv9XEb2llutLYZIGRaAIgSmEe93NyhrZc8C/qN5A2PESvdxxikr91/qaJA1XVEyYAAABpBUNSRURPTgYD4qJ6MEgOXjpP5UjinvEvZL4AAAASAAAAATBFAiEAhMjw6JDRXYaGPmeU7qRyJAIH3PG9QegjarXQJ3LaPu4CIA3pxdX7xLwKWgtMs82BHhtlnyFNMOmJYqHBKPXZaVySAAAAZwRDUk1Ukji/t4GlXqzDzwX335QDjBmM2bkAAAAIAAAAATBEAiALHNK2211BWHJrHEpY5h5uAddxRstyF1JbztcBO0ij2wIget7L8Ctlyz1SN8Z5ld3Lt5GxRpgCgKKbtxw0KkHvSjoAAABmA0NST6C3Ph/wuAkUq2/gRE5lhIxMNEULAAAACAAAAAEwRAIgdRa5VO/oY4Qs/RPsUrUoIkQZCvsWcIBuutoXsiKjH7QCICIJhVGJWCRSYzg2dXlBSEqYiPWBlVRuT50QdgtD1NdhAAAAZwRDTUNUR7wBWXeY3NdQbcyjasQwL8k6jPsAAAAIAAAAATBEAiA6xksZ69t8pPPZSTbp83ct3KFdJz6l+zm72XFUYg04rgIgWcdy7mV4LVBzyC6iM4Re6qdIlLvnFwCFw8Qeka8gO6wAAABoBENSQlQs9hjBkEHZ2zMNgiK4YKYkAh8w+wAAABIAAAABMEUCIQC0r01yxugsxl/dYcOjSm6jj2hkgS4ufaVhhFTrVZSBMQIgASOu3T6cdePJLhHqtpFsXMOucHE/B5o2ascsFb+KenkAAABnA0NSQ/QeX7wvaqwgDdhhnhIc4fBdFQB3AAAAEgAAAAEwRQIhAPW74UsdyKE419WfrBSsZr5oM1msfRRlSrk9XuIDQ8QJAiATha94vOlM3Or2iMbUYg4Z/dOGyx+IK6/JZj6DEyb4UQAAAGcDQ1BUiNULRmvlUiIBnXH56Prhf19F/KEAAAAIAAAAATBFAiEAv7KRDjTXpZz4KisVHwULqa4n2W46hFndfSudxsR31csCIHM6LyygLjHB3UCvsoo5I+y5k8uSCZUjfEYN7NvqMpe/AAAAZwRDUlBUgKfgSPN6UFADUcIEy0B3Zvo7rn8AAAASAAAAATBEAiBsfzgpDsWg3P+vDkPG3Cyq/JYnV3Bt9QOozQtoQkC0XAIgLFS6XTVFD6shNzA0Q7KdQwyIl64OhmUnYSkY1O1FFVsAAABmA0NGQ13/iaLKpNdrwob3TWe9cY64NNphAAAAEgAAAAEwRAIgLtk8OC56JgGvyayolaJ7YU8xMX3M5fXmeDTy5+a6uqMCICNP1l+1u/LToLq6KUEMXa6aBAdGJdcUukV3HZ5sKUCrAAAAZgNDMTAADBAAUOmMkfkRT6Xddc5oab9PUwAAABIAAAABMEQCIFGKUnAFqGcTjX6kkG2LW/ZBmmJWpM5egaCW8iRnx5XLAiA24ZXe7MroCLU76MzXamJeLL/QWfTfpdLod3HtdlagxQAAAGYDQzIwJudTB/wMAhRy/rj3J4OVMfES8xcAAAASAAAAATBEAiBDIG/Y7/WlwR/Y9QJ3xBEaXCJ4m027F2LgyhUaws4ErAIgKaP+HgHKGZUy01X637PfjuV1gAgul3PMqV9Eh0xlM10AAABmA01DT7Y7YGrIEKUsyhXkS7Yw/ULY0dg9AAAACAAAAAEwRAIgUbBtvwTIQkM8xe2o7oUEQkYUHsV9uT/phQgqXmV+/HUCIHHYd3c6d2nMcoxRO5IH5kL5VJnl/H8QrV2ghWN5u1KXAAAAZgNDQk2V79H+YJn2Wn7VJN70h0gyIQlJRwAAABIAAAABMEQCIA4t93hG1k5cHaMs8ixXkl/fZHUT5phco25DtkMFdGLIAiAkW7X1BWvPXOav1h6bzcTP7UOGTRz/l+7ZntX5n0o4NgAAAGgEQ0NSQuTJTUX3rvcBil1m9Er3gOxgIzeOAAAABgAAAAEwRQIhAMcY+g1JZ3sYRcQAM9XocEUHaVOOtblW42rma8DbdpovAiAUftS9A3Xs9C0D09Y0b5OlMUlImZMfePokcbWMjfz5EgAAAGcDQ0NDKFd6bTFVm9JlzjrbYtBFhVD3uKcAAAASAAAAATBFAiEA2yDkxIdqzrI5Os496f4HLalwHioVrD+poVTwDjrXpbYCICV9Ka8EoEY/uff6APM2TP5drlKFusvNYsXGhBo8c/uYAAAAZwRERVBPfPJxlm82NDvwFQ8l5TZPeWHFggEAAAAAAAAAATBEAiAz33EvKabrHuJbrw+nPMs9q/9MZP8gLCq4l9fIFz5SIwIgcu0wWA8J2zhW4T5VuD3P8lZOwDyGXF4yyBeF8H6py8sAAABnBFhDSEa0JyBx7K3WnZM63NGcqZ/oBmT8CAAAABIAAAABMEQCIFuPpGXWUjc+xQuNpJhbIcUMQ8nf79XxleNpViSlec5bAiBdPznv87hKLQCYSpIvx5NH9IwG/lEIBvNS4bcnJ9e2OQAAAGcDS0VFctMqwcXma/xbCIBicfju+RVUUWQAAAAAAAAAATBFAiEAvlXadYIkEhGL4KPaWdY1Ty4tPYIlsAbMkMjk/Zx56DcCIAtTso6gp0ZGqOB1OSaxtLmmhMMOYGLe1XOSZrpOkeDSAAAAZgNDTFB/zihWiZpoBu7vcIB5hfx1VMZjQAAAAAkAAAABMEQCICR3a6mwPj15Ib2445p2Bfk+5MXjTqn7ZRIajQgL3ZgUAiBp3AD0/995n8Xu8YapStahqAqh8YRLMfALkrq7PzvZ4wAAAGYDQ0xMPcmkL6ev5XvgPFj9f0QRseRmxQgAAAASAAAAATBEAiAhcbMzcMvnER4GsyEW3Te4KGaNns0Wv1B36Gw7IsADOgIgVeH2yiv51fMFDZV13KyKBj2Nj8BfaRkkuv/vVYmxeq8AAABmA0NNQ35mdSVSHPYTUuLgG1D6quffOXSaAAAAEgAAAAEwRAIgULq5u4XRgX6AnrS9aaZXTAqOlWo06g9iep8ToQuLpL8CIDNy6rlmznf9Nr//lJiEtSZnK2ZZCpVopJ2ES3KXPedUAAAAZgNDU1S7SaUe5aZso6jL5Sk3m6RLpn5ncQAAABIAAAABMEQCIH0E/PlLicVkpuPHpqKJHveuMDqr0kA47EpTfjzht5RpAiAgOj8EZojkBAsbFKqcLd+GPbwTQdvedHcqvesYZAhgfQAAAGcEU09VTLsfJMDBVUuZkCIvA2sKrW7kyuwpAAAAEgAAAAEwRAIgPPybT6TrZ1EfkS1wbvEoDZCjNAcWhcOc6RXWyHvzal4CID/o/VNrngXcR/dsTX6aDa3CHUsR6Ppe3YLzeKxBB1ZRAAAAZwNDVEZFRXUPOa9r5PI3toadTsypKP1ahQAAABIAAAABMEUCIQCIMgEUSy+LWD22JSPHB0UA9TvK/vk5qjjeu+KEiBDifAIgAjRm8ubMuAv3YtyW3wpcInArDIUf13mXYKdhwoMfdNAAAABnA0NDVDNvZG+H2fa8btQt1G6LP9nb0VwiAAAAEgAAAAEwRQIhAI0SyNvhQ/YEO5Q8D4ZzIF8qps+uh8TItqY7tneq2pOzAiABIjhy7I/jx9J8p65cakXUUZoAFysduGPiEO1eiJlzTgAAAGYDQ1RHyHxd2Go9Vn/yhwGIb7B0WqqJjaQAAAASAAAAATBEAiBmxI3XQehab1uqrJ0T3vTWuhZX9Hh/cGRUfvEq0DQX+QIgRn/Eh9xLBJr7K+6ncIpYEpb+amD/b6cgVOr2TNu0lOMAAABmA0NUTL9M/X0e3u6l9mAIJ0EbQaIesIq9AAAAAgAAAAEwRAIgPsZMY7yGBb3lzBF/Nve9DdfvS3pSS6eVfEXjmAPr1vQCIFt6Lt6O7CvU37gQ8wfIhF4/LDKFRz4Mfi/dxuULTgWzAAAAZwRBVVRPYi3/zE6DxkupWVMKWlWAaHpXWBsAAAASAAAAATBEAiBQdmLlKpbPZCCxC5e7FoFfHp3r46/vJk0N6aqloTRYwAIgJXLeAI6oxpS0g8V0WtOZbV36WqmQH3/cfojIE7Hzl20AAABoBENCSVgFw2F8vxMEuSYKph7JYPEV1nvs6gAAABIAAAABMEUCIQCkDVsXv00ZtL8CvyWO2ernlFUZ6eXFdRLIPtBQnf3o3wIgVpJa9V0PRwfbyQ50TwehoepDDR3xD3hlgPzxh/OjlWoAAABnBENSTkPJoeZ4yQJfDUzxKdbeDYDwfZejbwAAAAMAAAABMEQCIDjcOdrjVkV1+/nJ3pgmy4bVrlFWaTAhpCTWwB2RvffmAiAzrV3z14m0yuuSv9/bG6jy0GjefrDok5J+7mlO0h1LbgAAAGYDQ1ZDQeVWAFSCTqawcy5lbjrWTiDpTkUAAAAIAAAAATBEAiALgIqTj8Alu/nZz3xPtOotJdSATuzelA0uyqHlpyKITgIgUvy2+xHt5mFkeh8ZgdgRD11Lvin37hG+ZaD3JvxItFIAAABnBENZRk0/BrXXhAbNl73xD1xCCyQdMnWcgAAAABIAAAABMEQCID3WyW0rnmp4+jb+eq4mcYB/KnJ6/V+OgdxBmIU9F1TpAiAtQfWQTNnvEN/HNi6vYwLqpKGAFUIu1GlgwbooqqULOwAAAGgEQ1lNVHjCktFEXmuVWL9C6Lw2knHe0GLqAAAACAAAAAEwRQIhAJaRnFkq8Y+oGhRdj9En9glxgUm9JEj/tbr25tijrNMdAiAMDoa9+1uDWwQwun2SUkKZACA1tdIH0fVBGIh9BMEy4QAAAGcDQ1ZUvkKMOGfwXeoqifx2oQK1ROrH93IAAAASAAAAATBFAiEAujEMKsBNV6WOUVg0QtJu3nOIxJi73I2rYGpcheMT5KMCIFAJhlz/ZmNCxCBNZvDTagG+pQzhw2rgLmWwP2uE7fbDAAAAZwNDWlICI/xwV0IU9lgT/jNthwrEfhR/rgAAABIAAAABMEUCIQDXaVOProihaAzQLwuUexMGlBy2e2w8GwICbujQP1qMJQIgH+OxrcuJgKPHxhsFLEyIpTOVxedlozEXPVIs/kYDQCgAAABmA0RBQtqwwxvzTIl/sP6Q0S7JQByvXDbsAAAAAAAAAAEwRAIgJ9BgTw5I3jHar3iKLxjeN7DJJD+0YLo69/BD2ZpjyukCIFE8fu+X01uSP4gQYWSNB8zfue0sj6OmUJoy3anbnpB5AAAAZwREQUNToxEI5bq1SUVg2zTJVJJlivI5NXwAAAASAAAAATBEAiBuxFMGgLF9KPfKXX+YMBuBDBXMYVsvFz1W6jnH156rrgIgDedzQvMh6oGvTxCRTb7PoR40zDoxfBvZRHGp/0GJKX4AAABoBERBQ1j2umWbQZOStyLtY9T1Iygi7O/yYgAAABIAAAABMEUCIQDGndtTyysRQzL2V/238yPqVliWWw8DfdV4Ugkej7uYjgIgbddRgBDX6z/BgRV5i/xVpSF/vN0bQ5P9OwcsV2pGjg4AAABnBERBREn7LybyZvsoBaOHIw8qoKMxtNlvugAAABIAAAABMEQCIAHnb1lKRoysdRmTAiVwfMNIcRe5n6vBfvOIFGCDyFGmAiBfa6yDTLwoJG7VGLkHdFfwSZqB/NMgZPO5Gc0jS0h95gAAAGcDREFYC0vcR4eRiXJ0ZS3BXvXBNcrmHmAAAAASAAAAATBFAiEAsmEgTJcZF99e75NBQwRAG9FWnEZnywl+ofU3b8UxWocCIHEUEv+yPMpWVmViudAdhXv6+E+XuhGqnnUER2x1TSQWAAAAZgNEQUmJ0kprTMsbb6omJf5WK92aIyYDWQAAABIAAAABMEQCIG9t+lhVFCLMBorcIIncY4GLcmnU908EfEv8H8mPtn0XAiApw+1aPUOxpGnUfd7wEH9BUyMlpDl97YzIuIZCBcZwCQAAAGcEREFMQwfZ5J6kAhlL9IqCdtr7FuTtYzMXAAAACAAAAAEwRAIgd+7ASCIEtHduM+XySxzZ1g4Cl7L1QNypKHOJEV3H1VQCIEM5BqUy7XRrYj4sYoWKH+qmGD8YZuFRppDWUYZK0sC2AAAAZwNEQU6bcHQOcIoIPG/zjfUilwIPXfql7gAAAAoAAAABMEUCIQDL4haVcgVemxidnHzPqqUdI5V5EfYKR9T3IYK+4pDyFAIgN04qdb6oNb4JF0TDOk5644ISMqa78Kiwgkhr0vNlxO8AAABnA0RBT7ubwkTXmBI/3ng/zBxy07uMGJQTAAAAEAAAAAEwRQIhAMUhey1/sGTja+a+EmiXlMpww521pVxHaQxjBGcJ7scFAiBhI8nkv0TlZjZqucBVHrHdkB0cMzXaSYDRGTWTfzKPdwAAAGYDR0VOVD/yJ/ZKoX6hMr+Yhsq121Xcrd8AAAASAAAAATBEAiBzxQajSwjTGwMRZd1rUlaCcqRETOT81PvEAIZQePq+qQIgZhg1C7RVaAgtAhFRt4SMLemOdXcp0j938i+/M3DZkWgAAABnBERBUFOTGQ286bm9SqVGJwqNHWWQW1/dKAAAABIAAAABMEQCIDOljg9JITo0Iatgy29DKuMBEsxoGSVBR5DeBN9a0ytiAiAx8meiCVgkrh1eWodKBJtVlgDCBH1bIZ+ioHQNJjPXKgAAAGYDRFRYdl8MFtHdwnkpXBp8JLCIP2LTP3UAAAASAAAAATBEAiAz2vzQZOC6ZezyJK7m/uGuertO16oHU5R+xzXg7FvFUgIgc3BB7G0LjYeJvRgfbrBsb9cBmMHputymvOoXTAIJGX4AAABtCkRBVEFCcm9rZXIbXyHumO7UjSkuji0+2CtAqXKKIgAAABIAAAABMEQCIAUFoWn3aMTDxm51hZLZ4X1ntZ1LmYsG9oAkx6xHUy5IAiBJnB/ADSlMPhcd4HjA1To5kLiQhgnePJKzp+UzElLaLgAAAGwIREFUQUNvaW4M8O5jeIoISf5Sl/NAf3AeEizAIwAAABIAAAABMEUCIQDBXxc9cyRf3vSGxYPFVx+uRohsLZpqkUWdvnD3lrIxbwIgeYMkei0n0Njz7Kk7ICdNuiftfqr1KM0nzsLFfc7HN+8AAABnBERUUkPCBGTgw3NIbSszNVdug6IYsWGKXgAAABIAAAABMEQCIAZ/y+5LL7/T3o4MK0jKPani9fCxt4GJgDJLAi8wdpfCAiBejSugQbfQ/pjHFpiJJJZ0hoZpOdgP00rnQOw3nCO4RgAAAGYDRFhUjbVMpWnTAZoroSbQPDfES174HvYAAAAIAAAAATBEAiA4RwWqXjWaVBCn9ZYD6qkhQh5bb5DJw2a59v9kbdZGLAIgYL/Q0XwdwvkZBmgtII+6HDuGueiY0GXeBFAc4XuV2YkAAABmA0RBVIHJFR3gyLr80yWlfj21pd8c6/ecAAAAEgAAAAEwRAIgGZdtvZGexTXdZdpFzmkkCibb/53SYZijTAcrxdO0CRkCIC92DQXHkvqO91nJAWNlntO6oHLCBWhOvzOhGypcHzcRAAAAaAREQVR4q7u2RHto/9YUHad8GMe1h27WxasAAAASAAAAATBFAiEA835IZSYH4CWi/SCVWjNUk4gJo0Jn+0ZTD7iHb3PPnJgCIBudBvXFdTnt74tAyFZBNLxmNqyQ+3yMatVitVlbDZxtAAAAZwNEQVbYLfCr0/UUJesV73WA/aVXJ4dfFAAAABIAAAABMEUCIQChQsJEWm5lgdEagIbNIS8f5kI4a4j35fhBersmgQaIvAIgLEliGBUQzmuXsi3kbpADBqM9Cg2qaIu+0EuL8iarI3wAAABmA0RDQThvqkcDo0p/2xm+wuFP1CfJY4QWAAAAEgAAAAEwRAIgcjuQPNJdKYFnz5XmDdbKztOX5QsfozLqLpi2ZA0OjSkCIEZBSBBbf/RP18QDxj6ezSinVELM3qDhl075ST5XNU53AAAAZgNEQ0w5mg5vvrPXTIU1dDn0yK7ZZ4pcvwAAAAMAAAABMEQCIC4DNHtTottiZRu1MPp7efDMNe27wEWCwLtZlLrYP8HwAiAHNes3V8c67vdkSRUFB5N1kfw6JfnzHGIfy2ScMjjcRAAAAGUDRFJQYh148u8v2Te/ymlsq6+ad59Zs+0AAAACAAAAATBDAh9uW9fOAut22xKIJqdMdR31UisIqknboTAkFLOMzNgdAiATytoLjRHPNfrj8Gcko1pXWBEBLGWhO3F7rIWGny5G3AAAAGcDRERGzE757q9lasGiq4hnQ+mOl+CQ7TgAAAASAAAAATBFAiEAgJTer1I1dzybeFeZCykh15vgUBu06leDT9OAPvh/RCICIG0Art5VOgB5nM1SvaAdviIJNBGHE7FlLJQc2POdTJLKAAAAZwNERUIVEgLJwY5JVlbzcigfST63aYlh1QAAABIAAAABMEUCIQCk77WZFe2F9GmE9aEmZIslE2InwU73Vri7dVnacipSZQIgQ/3Y+NU6LpwGlnGWQYO4hNHaUqH6gYvcHyStXM4yrnAAAABoBERCRVSbaL+uId9aUQkxomLOz2P0EzjyZAAAABIAAAABMEUCIQDo/r+kQgFzhUrBFv3alIdrUVOgs6WR8R3odhKDUCV7UwIgE/3+CeGvFxPIdcRAIvWfmS6d9+LPRby6cBIpMkZ3vWYAAABnBE1BTkEPXS+yn7fTz+5ESiACmPRokIzJQgAAABIAAAABMEQCIBXjg/4+fdYdW1u4AbjiiO4w/iAWEWfqWHZGRjs64RmTAiA8RmxHFDTnmZGWsIGPlOISSlVzZDiNjuGerNyprZwpTAAAAGcDRElQxxnQELY+W78sBVGHLNUxbtJqzYMAAAASAAAAATBFAiEA3zIdNuKM35UKIkmaUtjrdDHHkv5S6KbZtejU/YdAOHcCIFkB6aNx656V7c+tQQZpu/qDD7WP400r//qsI1YKNv9rAAAAZgNEVFT598Kc/fGfzx8qprhKo2e88b0WdgAAABIAAAABMEQCIQC0UFU6rX+/fTpYqjM0Cj+0pHgVJzUrvUNo80BOglARawIfI7NzCWAJz56xAZDKs+nUChXPA389lcgDXBWaWepJJwAAAGgFREVMVEHeHgrmEBtGUgz2b9wLEFnFzD0QbAAAAAgAAAABMEQCICgEIuYHhOJHglE1yzKg11tynRVB7WDM2KyN4AMneZNLAiBk4s+FhFz5OGps8orp3qfmrIh7WxNwg9imG4Wwjo7hQwAAAGYDRE5Y5D4gQdw3huFmlh7ZSEpVOQM9EPsAAAASAAAAATBEAiBGUt5SDP/FMS0VYMeWO4esDuohOoocwMWagbitdTc8HwIgAd79v7U/hP2lzUe6dZovZOD5lyogA5NaVLuZ/d+Pf2wAAABoBERFTlQ1l7/VM6mcmqCDWHsHRDTmHrCiWAAAAAgAAAABMEUCIQCyRYgj5ZKu6e6azWg67+Ez+0m3OALF0cb1IFsOevvMLQIgBf3cjoz31ir2Iu9qa7XwQnWYm+tt2bVHgxrHjBaR/W0AAABnA0RDTgjTKw2mPiw7z4AZycXYSdep15HmAAAAAAAAAAEwRQIhAOxjAI/jce3wjHMMKlAP1luYcYSR1gVhwyRGlXhDCHhlAiAStkb9VeqfoM++9KVAcRGLKzw7n85m3v4F310iFDKYTgAAAGgEREVQT4nL6sXooT8Ou0x0+t/Gm+gaUBEGAAAAEgAAAAEwRQIhAJnUIiUPgQX1ucQOO6Wo1/1lgIHqt6WYG177WjpYzmAiAiB0z2GqlBMn1HUIY0jrZt7NCmbMoBcGgMuiaQtO/lh0PgAAAGYDRFRIWtyWHWrD9wYtLqRf77jYFn1EsZAAAAASAAAAATBEAiAZrJBDm0a0T65lB+6xcEVixoC/jW68KCDnioVG7OkvIAIgHJYC8Pf4Qj8Xrh1XJSrETkQGsxqKDEABcz7CyfBmhh0AAABrB0RldmNvbjLdlN6c/gY1dwUaXrdGXQgxfYgItgAAAAAAAAABMEUCIQC+rSVPaXEIEf5e3GW3gBbek3SNN+Pl+kAS7IvXAkFgJAIgBd6mQ0JmowN9enLMg5v2GCDN/bmvXqh598DiPQxc32wAAABnA0RFVyDpSGd5TboDDuKH8UBuEA0DyEzTAAAAEgAAAAEwRQIhAL9DFyDN1ENytogftK6xatUNzaFuv9RyNgK8/Ba4wzXCAiAI1EX+kWEzEJrYceTcQ7ztMjeoN8MBf7RbAtuJZ+1uZgAAAGcDREVYSXuu8pTBGl8PW+o/Ktswc9tEi1YAAAASAAAAATBFAiEAl3b4KrFXPFJwUjl7W2027JFJu3Ovtq+xqYFYPujJU00CIB8z6BPZcOKwf/DwzxEmuVYc0a+yc1bhk+BqtOwUAp2EAAAAZwNEWFJlzKJ5EIcnaFbpmxS8AfRmTDVj3QAAABIAAAABMEUCIQCT2i/BnWmxoaNiW5xq/RrRSn5MpYK/xLIOM4w6bfy22wIgJ9dUODrVaEbJlPe0ixUs3Gf4ObtRqTyhhfIZZTIZTfEAAABnA0RYR0Vx86OG0b0Y4l1w0RfnBn+gvZ0IAAAAEgAAAAEwRQIhALxom1URrb5LjwfsvI5p0BmNEqgyX5y6yGkWRTBhas70AiABToqHfAqOw8mH9hkxCjJ1Y13OD/kuwXD07u5snLj5KwAAAGYDREdYTzr+xOWj8qahpBHe99ff5Q7gV78AAAAJAAAAATBEAiAMtk9+Esjp7zXRyldxRwlqPCqXUkn56h8GanY5ZzIMswIgXSiRyb/kQp0Lygi1Rg0UejT8HJLLORE0EjO8yVpZehYAAABoBERHWDFVuaEcLoNRtP/HsRVhFIv6yZd4VQAAAAkAAAABMEUCIQCnPv9XAe2nrdwBGeseXqa4gaVRMuUcW87J6uVJft39gwIgIPPuHMvGURYShr6YIWuin7JLJ2p4ivIa2FTCQq8QDSUAAABmA0NFVPZgyh4ijnvh+otPVYMUXjEUf7V3AAAAEgAAAAEwRAIgAJqFqeoxzTQUIZZnMk8SjPib2XyXtnp/MCWbLcfgh/ACIGOW1/iNAF/dVfZUay39IKpyvSehoxKqTwZ4WI6PJYAcAAAAZwRER1BU9s/lPW/rruoFH0AP9fwU8Mu9rKEAAAASAAAAATBEAiATf/F7xSsUGBUFlY9JVBB4bumPHE3vC99hGifbtnUHzAIgaharAmgDRKstqnPgROIRz8OJKPbyZwTeCnx2FJLKfXgAAABnBERBWFRhcl89tABK/gFHRbIdqx4Wd8wyiwAAABIAAAABMEQCICeKPlaiFAX3mFuFE1/DKoV8iJm8tLV5giyl4yxC5Z3sAiBdvje1DHe1VjfsugjC79v7nfC5SrXbVkORvSIfXA65agAAAGYDRFBQAbPsSq4bhylSm+tJZfJ9AIeIsOsAAAASAAAAATBEAiA+DcGKYxXY5p3ies8lfOql3cmbBV2ZOCcPMB0s+ct8FgIgQoPYcrKZjVDzcZ2hGVSkcH/8IaPkoyH48hBn4tifhd4AAABnA0RUeIL97ft2NUQapaknkdAB+nOI2oAlAAAAEgAAAAEwRQIhAIqqwrTbWLkyfpjJFBqkxgST9q6q9nteSGQ0pUH2DoYQAiApfjkCwugM0IdybziuFOng4UjYoKv+/MnVqrGpv8VyjwAAAGgEREdUWByDUBR48TIJdwRwCEltrL1guxXvAAAAEgAAAAEwRQIhAKQbLIENOh1oAMS5FssHLsTD73FewRDVhtPyXc8Lw9hxAiAk/I30L1K/U5y4ZxmH1cE0FEGuvylQmBPAtpnRfNKUGAAAAGYDREdE4LeSfEryN2XLUTFKDgUhqWRfDioAAAAJAAAAATBEAiAQZstxCPZlCkbDfEtMz3wVjx4Devuj8lQybiHk86puOAIgSgC+hKVYNFkTJi5fhXb9y4YjVfHl7n2Rf6Lvq0n5alYAAABnA0RTVGjVNEHA4lP3bFAOVRveo9ECIGyaAAAAEgAAAAEwRQIhAO92KwS+OS2d2lgMt6cetx2m/pvvJSJVtSg3IUWYU3rUAiBK/NfOmhMAUCdyncj4YMS/r1ik4Mj1ijGANh/dMtSpqAAAAGgERFNDUAPj8MJZZfE9u8WCRnOMGD4nsmpWAAAAEgAAAAEwRQIhAJti6qdy7z1VckjhVy6lVvEkTG3Ey2pXM9nR9kKXgfQpAiAgEvjWStRK4CumHVVOqbGYQImUbaGfdxLn5ZmIcD2sUgAAAGcDREND/6k6rPSSl9UeIRgXRSg5BS/fuWEAAAASAAAAATBFAiEAk6WukLsn1zJJx6yx4kZ2Fwle7/9O4yH5tJdXD8Pc5t0CIGIutP55PDmvOZWeHcQyHfEZYso3Ian4VqWjlfKm1jsEAAAAZwNETlQKvaznDTeQI1r0SMiFR2A7lFYE6gAAABIAAAABMEUCIQDB4QlGl22mwKpoR5olMg4+v6ApusnoMLDTXPyS20y2TAIgUQAvHKP2AS7f5BepVBGFvJdwNE8G1UwQuWlGjVg06UEAAABnBERJVlgT8RyZBaCMp24+hTvmPU8JRDJscgAAABIAAAABMEQCICFw2OjpFK1usub7YZ2/9ujTWPuVKFH3Fmdz/+2pKr8QAiBoeSG6Gjt6yBjlJolApyaLUHJy+ujjSa/ywipt+YLTCgAAAGYDRE1ULMv/OgQsaHFu0qLLDFRKnx0ZNeEAAAAIAAAAATBEAiAbJmfy51XrWHDJhQJ+zWPOwh5xgf9MGbD9fbiRp3xJBAIgPjDlllyNnTDm8h2fDefEcnq8SwnHyDj7EkplaQYVfn4AAABnA0ROQYKw5QR47q/eOS1F0SWe0Qcbb9qBAAAAEgAAAAEwRQIhAIoha6pAfFJo5GN4Re2QsiIiVuJtia72CvvZHSfgDW9SAiA+M3gQBEgysJeQUbZ5EIZvmR5rbQmXcSRMUI7TfIqBmQAAAGcERE9DS+Xa2oCqZHfoXQl0fyhC95k9DfccAAAAEgAAAAEwRAIgVlwu099L0wtsgVoBNzkpkjY8OaYwtOZ7atja3VVLM8YCIAQUSI6ox3KgsmQBsBy3dE+Yzv88qguZvG931UGzt8ntAAAAZwNEUlSa9PJpQWd8cGz+z20zef8Bu4XVqwAAAAgAAAABMEUCIQDxk1SCtFYokxTSQC/c0BCe5jf/JfI2FAxgxyGgrGj/LwIgShpKvPzD0LcA7WPwY9cAEm0kqnOuhWwhKb9U152HA+cAAABnA0RPUpBrP4t4RYQBiOq1PD9a00inh3UvAAAADwAAAAEwRQIhAIVEIUCZhJhTgteXFGSiB2pudstCNsgG101mDH+vMhepAiB/wR+y7+99AJ1Dqk1MWMv2Uafag39TVadcfem3ye6BvQAAAGcDRE9WrDIRpQJUFK8oZv8Jwj/Bi8l+ebEAAAASAAAAATBFAiEA5oOhQH6gQQqH7gY62/puP/sUtx8qsuqEGnq1+dOUQWwCIHwm73uzfueLIE9L3WH7p6KhfTMtvo2wTBkVZw+ySFAvAAAAZgNET1d2l0x7edyKahCf1x/XzrnkDv9TggAAABIAAAABMEQCIEGLaa7gZJoh4SghEKSfyf+68PGdmEJAZ2Xb319SzcobAiBvYa9MVsC1zj6bsHO5a5WwMPn3DpgcntqTVsXEuUs8+gAAAGcERFJHTkGcTbS54l1tsq2Wkcy4MsjZ/aBeAAAAEgAAAAEwRAIgX0mnOZPLAWZm4fTkXoUhdfh/yhMouGgfTQFRIYCa3qkCID6y4tXuUuCGLABO6JHIfPcDAOfuGed5ZyNq3HaPRWXaAAAAZwNER1Nq7b+N/zFDciDfNRlQuiozYhaNGwAAAAgAAAABMEUCIQDYWmYcCxg4axnOERAAz+Y0ekh+FhTJtglRXdy59B9uDwIgYUvKtmpB0CFni+1RHMnbqaelCeEFaHteo/1c1EZjBCsAAABoBURSRUFNgvTe2c7JtXUPv/XCGFruNa/BZYcAAAAGAAAAATBEAiA3K5rfGu+8tni0vcVU/5xHCN7rvjqiqyYlKL26QVzynQIgQ8PuV5AlM5EuxOhRlHx1nBtYxei4kIsOVVvtbhmVT7QAAABnA0RSQx9KlWfB+YqMnX8CaCfwmbQaLlTWAAAABgAAAAEwRQIhAP4bsY1ZnxBtdbyRiTUim+O8OUrfK4LPrwZvtSnwImHnAiBymoP6G66w9df4/g5MArkS7u5cZD3a0IuQwAf0ZLqK/gAAAGYDRFJQJ5nZDG1Ey5ql+8N3F38Wwz4Fa4IAAAAAAAAAATBEAiAZt/kyn9urRXbe0PDewHKHNpGhAFkeqmqsbh4crgWWGQIgTDRd3YTQWxcj3jXi/8AYMcCZF52JhXHZddBQVe4EE1cAAABnBERSVkhi1MBGRDFPNYaLpMZcwnp3aB3nqQAAABIAAAABMEQCIHoWQQBFg3sK0SZuBrGFs5UkN9MNK6e4npnJI5HP0NwsAiBKCklTezwssyKqNcvGLKOl+6Kr8Exou6AVJ2ZvhZiZdwAAAGgERFJPUEZyutUnEHRxy1BnqIf0ZW1YWooxAAAAEgAAAAEwRQIhANJKUETGk9JvQrMLieshRDcgRW6rIqSwHsT6sBV1AVEHAiBtRnf3Ei70cEZZloNOHnFKNQpSGOywXHW9zH7QIoA2MgAAAGcERFJPUDx1ImVV/ElhaNSLiN+DuV8Wdx83AAAAAAAAAAEwRAIgLpgpSZt1YQaIaDV588+AxTWG04RpIugYTbyF5/AduRUCIBHXlHK82auwnTNdStbrQ9K1psBkxwZdfcoLk7hO7wHIAAAAaAREUlBV4w4C8EmVfipZB1ieBrpkb7LDIboAAAAIAAAAATBFAiEA8XKgi0kStFoFNQhraJaqfo5PL3XXSJEg4BepMc3KspECIGrQoYMz82CoJkPHRB0RHzwoAqy+l3ts91M9rYwdWMOaAAAAZwNEVFLSNL8kEKAAnfnDxjthDAlzjxjM1wAAAAgAAAABMEUCIQCw85tt7UcfgUoxBMe5Fcdm/M3/YG4ozO4pDSQBRBNEaAIgfMmdiXZPy31wjKjBKAl4ZGuLENlCA0nyRH510DHGcdgAAABnAzJEQ5/AWDIg60T67p4tweY/OSBN3ZCQAAAAEgAAAAEwRQIhAMn6+Vq3TBxDEtr0shRbGHKYL5062tTeLCN8JhpZIlNeAiAJwMKGRCSrIEmkLggRThPCQxYeK+OhMvpW+Y3B7oYImgAAAGcERFVCSe1/6njDk897F7FSqMLQzZesMXkLAAAAEgAAAAEwRAIgW1rzII+6MnSST1THnWNB7tOXUfUIexP0VTIFrDdOJL8CIFITkzmfnXUQDlaZjH7/2LmF+wyu3dx2TYfMKfXBBMe5AAAAaARWRE9Dgr1Sa9txjG1N0ike0BOlGGyuLcoAAAASAAAAATBFAiEA+vK61QMBYANuhRYEteEKscIN3cfnbeQDxCUu0cmAX4kCIH56lUYDRzSILFWz0vCHt88mk5l96p7ysG4KAcqOLlM3AAAAaAVFNFJPV85cYDx40EfvQwMulrW3hTJPdTpPAAAAAgAAAAEwRAIgNg3THFomFjou/IJL//aTmxrwtYUSN4/CKP1Each5wpMCICAbcWq+xB0jzCHObTX+33x0dlCF5G4HPiEa8Z+/DDYMAAAAaAVFQUdMRZlPDf/brgu/CbZS1vEaST/TP0K5AAAAEgAAAAEwRAIgVdHpGCG6DCAM2gDl30qxNeM/4MI96v51Hd+0MkJSaAUCIGKkMK1gYK62fcXiya8Z7dNUtcRWeKIy8wgA+XKrK/iNAAAAaQVFQVJUSJALREkjanuyayhmAd0U0r3npqxsAAAACAAAAAEwRQIhAOiMUCTXcogXv12hjsYEOywUZsertBeH8sSWwtDc+AixAiB9XCv76uIK7aJv3kQesLjb8tUbzHp4cdEOWKyXg3SfOgAAAGcDRUhU+fD8cWfDEd0vHiHpIE+H66kBL7IAAAAIAAAAATBFAiEAtnW5hRSHwuOjqQC5aKq8z7PCajDtirPjDGw8QI8l54MCIBT6+F3fMUGgisT9oG5B/W6kThsRAVrOErVH7nxFToymAAAAZwNFTVSVAb/EiJfc7q33MRPvY10v9+5LlwAAABIAAAABMEUCIQDJn7GV6gHmwMVtDzu8DIbI5RuJhtQvtOmESxNJwckgAwIgPdCeXpWjMVCZtQw6y54n0I8Z09LaWYAQxyUyoL4PPHQAAABoBGVCQ0ivw5eIxR8MH/e1Uxfz5wKZ5SH/9gAAAAgAAAABMEUCIQDOB3rftsnrBoo/FGUU5+ht3K4dGboAm2EuPHXSZy0Q/AIgastglpbPuUuhGiQsXWFF8HX+4uh7b2xwMpG72WuXHMIAAABnA0VCQzHz2dG+zgwDP/ePptpgpgSPPhPFAAAAEgAAAAEwRQIhAMZjT1rVm08S9wPoLWTMGFFVnFGbqAZTjSXHozsq5LmfAiAvE7kZOzF1YuFRloE3JP4gSrhJGP0JfX52H7tRQITmfAAAAGcEZUJUQ+t8IAJxcuXRQ/sDDVD5HOzi0UhdAAAACAAAAAEwRAIgLawIelCbJzjX4ML+lEeE5tp6LrI5OhLuQ+B20s6nI68CIETNP0JCjZnH5hQchU9KK7gZy9oi1d+L/xIrWHQCbya8AAAAZgNFS0+mqEDlC8qlDaAXuRoNhriy1BFW7gAAABIAAAABMEQCICXvC8++ZmhqyDdxVP5286xl8AFwX/YxlbZaDCQq674ZAiB+8W3tqPEhgcZZ8aWAs5s9vhSZcevhDQYIQ/XqUPq2UwAAAGYDRUNOpXiswMt4dXgbeICQP0WU0Tz6i5gAAAACAAAAATBEAiAvfon0Cr/jBrk9KN28rAEDAZeu50amaUSen7x6Kzoe4QIgBSzAoqZgEjtK/xv5vbJELa4g+OpB+WG3yn2JYaN+C0IAAABmA0VDUIhpsfm8iyRqTXIg+DTlbd/dglXnAAAAEgAAAAEwRAIgdHMQ63kY6U1InIbKwP5HOr4Qyt9oQKmgoVpJfpEevAACIBT2Kp/GoQbvz2gN6nS0ZY879EXYmEaFhX4dExX4Nhi9AAAAZwNFRE4Fhg1FPHl0y/RlCMBsuhTiEcYpzgAAABIAAAABMEUCIQDQ8Nexdw384tqEdHrN/CfLmMpOlvUJEN/R7Ehlw+wOOwIgEllpAoAwzMDUEr7GIihhqP3q6QBmDuu+19rNsl/CeQAAAABnA0VERwhxHTsCyHWPL7OrToAihBin+OOcAAAAAAAAAAEwRQIhAJmkTl/x1GhUGBuvs8Al8yRSdym1Cy25nGP0cIwPCxlrAiA8rbK8YlSnDFV/CmTiWtC6QL6GExw3glnr5icJyi2lfAAAAGcDRURVKiLlzKAKPWMwj6OfKSAusbOe71IAAAASAAAAATBFAiEA2dDaT1znfKhUHol+pmPF7AQ/El6xODg7yMTRqMIR1cACIDy2x9m4EwMmcH/sHkDsoK5+KdNPh2CdThZ4W4U3cUbkAAAAZwNFS1S6sWXflFWqDyrtHyVlUguR3a20yAAAAAgAAAABMEUCIQC9VSCjUn/cdLQ+IahYBwGB0Zud7igRuVCKpoaB7HUDRwIgMBr7B0vltDQQf97sd+ufQSDU5Cx81SSKRE6jwgd1OUEAAABnA0VEQ/od4u6X5MEMlMkcsrUGK4n7FAuCAAAABgAAAAEwRQIhAN4Ov1HKuQ11gQtler1p44PsqliuToMtGNhh3wTiVxGWAiAz5IX9hFUnM/9AWbDKfYRJCLGmR2FySTxGdp1p0sxtcwAAAGcDRUdUjhtEjset/H+jX8LohWeL0yMXbjQAAAASAAAAATBFAiEA7xYSpu4Xrit87S/mYpk1ds0q6aJG1dcdn7bRrNH0RkICIClbpGW5ha0EPFubSCsRFRADf3cywHf9E8ptQv+MVG2aAAAAaARMRU5EgPt4S37WZzDosdvZggr9KZMaqwMAAAASAAAAATBFAiEAiSNx72MZ2b0pwyXtkDty4NEZITFII7fL5RfmO6YQzSgCIAZL5ycJe1DPLqFN021C0+/x4Kg07S4naeqqj8JbvOhwAAAAZwNFRE/O1OkxmHNN2v+EktUlvSWNSes4jgAAABIAAAABMEUCIQDlQk5FH9SxfokiHwAVh9iiRksoyv7eqMITAQd+cN14SgIgGfNM4WavAnzXjo62zsE5xix4kyi1A02KlYzPXQc3xNMAAABoBEVMRUPUn/E2YUUTE8oVU/1pVL0dm24CuQAAABIAAAABMEUCIQCfWfDzVpXtYG6QShGzLgRUNtIKfImYM5J6akpKPqLdcAIgDbBFVfd/97QOxalL7yPj+aiMRYQ/GKi3kOxQe0pOCYIAAABmA0VMRr8heYWfxtW+6b+RWGMtxRZ4pBAOAAAAEgAAAAEwRAIgOjFnb7/7beAn6hTQpaXp8HYr7Havzb2qHwelzj+6R9YCIDE6NpGaru7Vth+RyTnH2bPYg3m1elb1KsCzgJ+eutmuAAAAaARFTElYyMajGkqAbTcQp7OLeyltL6vM26gAAAASAAAAATBFAiEA6/8JlbCwkaSpGuWa4NBjiv3OpZ3iPZK3AI33q56wesACIGyW9YNWkJaIRlq9McGInw5dRByJTfcnfx6KqnwxbM+eAAAAagdFTFRDT0lORBl6TETWoFkpfK9r5Pfhcr1Wyq8AAAAIAAAAATBEAiBURK1MG6dCQUXeEk5IDKuoYCwgQc5TB1EimYqR+eRMqwIgVJYfp0+EuI2Rc4yPmj/9heEywr/0sSP1JEpQu69vc50AAABnA0VMWalVktz/o8CAtLQORZxfVpL2fbf4AAAAEgAAAAEwRQIhAMIoqH5nAUZImm4gYmWlNOupm7kLwrXaaon+wuui1xFIAiBAJWM7mP3rLpWnYOvrWDJQOvIynrn1jD8rm58zhgMV1AAAAGgETUJSUzhkZ/Hz3b6DJEhlBBgxGkee7PxXAAAAAAAAAAEwRQIhAOaNFtYW23urZ0G+LUmdupjWri7Cy2SX6cF5hCf44p0LAiAR697ono197CcnVCA9CoT2euvKSeVIuSmqxGfl0pkdMQAAAGcDRU1CKLlPWLEayUU0Eynb8uXvf4vUQiUAAAAIAAAAATBFAiEAoCPdg0Z6TP7QIIgQWukibeKmx/rGMhascwz0lOp0ArUCIAO+i8XC1Hs+5jw0EhOwcO/Rd7t7HVs1JSjBWD/IqusmAAAAZwNFTVa4ArJOBjfCuH0ui3eEwFW76SEBGgAAAAIAAAABMEUCIQDb13vqxTu2TpiJbNiOxnjNUL+AdqHGr3WtfGp66sEUOQIgGQs8OargsT0mnlgKpjKs43Whg+dwZ49+JikZmP60qMwAAABnA0VQWVDuZ0aJ11wPiOj4PP6MS2no/VkNAAAACAAAAAEwRQIhANnk+JHmofeBFw0LaL6JhwbHFhqbyK0qeZGwFAlNTsCYAiAfahUcOQFVVzyjeamPebcUGtW5M4dKRw+6OjjUs1QEBwAAAGcDRURSxSjCj+wKkMCDMovEX1h+4hV2Cg8AAAASAAAAATBFAiEAt2qz13t5XBP/7AIboU43xVlZaqc3V8MG0KIPe6LeG1sCIGZ50Mx5RB5KNhTxqhplBQXTEiO5+JTjrBrN0cp8Zsl/AAAAZwNFTlEW6gGstLC8ogAO5UczSLaTfub3LwAAAAoAAAABMEUCIQCo5jn1pfJSgkJ7El9ukG+dIQPRL/KMoBcliHsdO0FgmgIgUmDD4zDFZVFJybXKeyOz+wltSl7wf7rzq0OjanMHahQAAABmA0VUSzxKP/2BOhB/69V7LwG8NEJk2Q/eAAAAAgAAAAEwRAIgEK6MHGwm01xRzRpSf8SQ0zaKcrlD31M1/YvpPp4qnZICIB+tRM+Yt/C5cYLPezvM8TmwKsHqwP9zxHMIP8A6YDQjAAAAZwNFR1RdusJOmOKk9DrcDcgq9AP8oGPOLAAAABIAAAABMEUCIQCCQ6NBFakYeaxp86LtNdtQKiW8rU5X7tqqRbzCkyqgXwIgcFLClWBmSWCFVB8SMvhXw2q1wIQaNZxB9h6soiEdoaoAAABmA0VOR/Duaye3WcmJPOTwlLSa0o/RWiPkAAAACAAAAAEwRAIgWctjWpcA78pQ3aqNcdGW1DBqKbdN7hvOXm5CHRhGTVcCIEXVPgsVvFRanIp5CkM5S3QnoA57+BmrZFmMfhDenOdvAAAAZwNFTkr2KcvZTTeRySUBUr2N+984Dio7nAAAABIAAAABMEUCIQC3o0cQ7dW2bzRZRY9y9ubV3loHQz4upDrIYoXYpmb0oQIgHCGCLLh+9HjFNZUm4ynQQDqh3TbmhWfUJUwMYfaS5X8AAABmA0VWTteArivwTNluV309AUdi+DHZcSnQAAAAEgAAAAEwRAIgevhxWT5bLSDLPd9VmhCBdKeETE8bIjg4xYd6C9PGdVMCIDvoSDQCCabuBqAgwXWdARA/Bg18lANO/xHgTSLLW2D2AAAAagZlb3NEQUN+nkMaC4xNUyx0WxBDx/oppI1PugAAABIAAAABMEUCIQC9kcwVRTbee6ZJrff4sRJNSI+g8LtVz9hFRC9fjXI5bAIgOhFSleXLoUxq75n/cHEsBj7J3pxK7RNO951qOsmGFjoAAABmA0VRTEfdYtTQdd6tcdDgApn8VqLXR767AAAAEgAAAAEwRAIgYtCzh77PEeGOyPZOjuZSphVYETILyTZlzgmCTRL8ORMCIERGOCHgrhEfpVRdFoDPkgw27qEjiaBHn7aKAS2RKNUeAAAAZwNFUlSSpbBNDtXZTXoZPR0zTT0WmW9OEwAAABIAAAABMEUCIQCCVc2VwIgPpoFUTMoRI3eUo+VWo7Zh1XW0k5NXnQF2BAIgB7k8/qsGlVFlUP9/IEukvAaIQhOTnSPhWyZU6T6UX34AAABnA0VST3TO2ncoGzORQqNoF/pfnilBK6uFAAAACAAAAAEwRQIhAOCvL6MPDgNNxWYmQnLkASlMaqBQp5zXWuL/nel7+3p7AiBBBvG88A6olBAuwWgZqy4lHayRy1uTEg1ZaRiZTVlB9gAAAGkGZVJ1cGVltnc0Uh6rvpx3Nynbc+Fswt+yClgAAAACAAAAATBEAiB9NSm9O5UG3tKdgEZzBBFIeMDPWN++XglVNPvn89tjrwIgTXoQC7yTGIl4MUMcIptoKqUI+ZtyB9P3E737ozdDixMAAABnA0VTU/wFmHvSvkiazPD1CeRLAUXWgkD3AAAAEgAAAAEwRQIhAII2taydwWgNiRxoBXksLe9C4LP33MVQAaFdnffpvRoYAiAuFOKPsuprQyK8Q6AtcoSi6Z0dQt9gFrwXUIiyIZELKgAAAGcDRVNa6KHflYvjeQReK0ajGpi5Oi7N/e0AAAASAAAAATBFAiEA2f1CLyrDc2+QHRVFY+nwBxkdqYJgH0xpxHMay94HEPcCIEm9KEQ0o10ocn61PcnsdKJxx5T3zEiTGLAMDSOH/Z5eAAAAaARFVENI3XSno3afpyVhs6aeZZaPSXSMaQwAAAASAAAAATBFAiEAl2AK0b5WIk5TMVLHEXQAeI5pXo2t1lS6nn2f5BseonoCIDIt1xj0NZ/Phq23gXw2V7xHxr1/9HDZRoyJHr8hGCyLAAAAZwNYRVQFTGR0Hbr9wZeEUFSUApgj2Jw7EwAAAAgAAAABMEUCIQDp6U7Aze68TEXAITUlMHui3Wk8LMtS/vHxQAzS6TwSoAIgXGeWbnUqFlLQhbFsyCBfv3UwanJvebw8Prp01BAZuOUAAABoBGVHQVO1Opa8vdnPeN/yC6tsK+e67I8A+AAAAAgAAAABMEUCIQD+Qsg48m4RqY0gnDQW2cv68EejXtEISdWcCHkDQDeEgwIgJTe40QPe7JuPP9xev7VXDhwEBixPdA5V92iafm7UXgAAAABoBEVUQlMbl0P1VtZedXxMZQtFVbrzVMuL0wAAAAwAAAABMEUCIQCElJiZy/TlxvTXyn//KNko3bSBrAzoq7DnCzzdJOclIwIgJJGBJnP10TcGybjGa19j+srmRcH4N/s+FFxmuwEwq80AAABoBEVUSEI6JnRt23mxuORFDj9P/jKFowc4fgAAAAgAAAABMEUCIQD4PaB1Z30Qoi9l0eENmfD6IidVyfhVE2NXXA5EkEPLgQIgTEIY7LV22pazclyfLYaYWLY+6MpC+eU/QAtn4HNb2zoAAABoBEVDTzIX+TR10ql49SfD98RKv0St+6YNXAAAAAIAAAABMEUCIQDJeRkowpXVNsXmkDh/f15jLe0g4PfZtCK++I/5bAORegIgCRpOUs/rzhq2ux95R4aFRmdqSvyHsIsh3Nx1dw6GB5AAAABoBEVNT062e4iiVwijWufC1zbTmNJozk9/gwAAAAgAAAABMEUCIQC2HaouHuK2giE5y9dGclxrtH1fRfL0wnUncNVv8sy4ewIgAvEMi/ZD7FHtH8T5/EDi4S4hGQ+Y0TJZ2qEc2ZyrNcAAAABoBUVNT05UldqquYBGhGv0soU+I8uiNvo5SjEAAAAIAAAAATBEAiAq77jIPc344M3py38/mZIekTc54SU7pRR6TBY+XPfawwIgfB26VhxHz0wtUsYm63OG5l9TXTA3HS56v11djIJBIOMAAABoBEVUSETb+0I+m78WKUOI4HaWpRIOTOugxQAAABIAAAABMEUCIQDLVtB/vPg+6Mi0B682oopLauzgayILpS3uCPbc3aFodAIgWaM6zHCJyXRYPtsMAPKVKcqvBDK100WagrwtiinqmV4AAABnA0VURyjI0B/2M+qc2PxqRR10V4ieaY3mAAAAAAAAAAEwRQIhAKM4hAlxlH7FTYGG9MQsN2Km5PWqszCVE6PiYyWs6MwhAiAqCBuassnWNhZivxOLo6aee128aVoHptdInlcZBDcxQQAAAGcEQlRDRQiGlJwbjEEoYMQmTOuAg9E2XobPAAAACAAAAAEwRAIgWW4gpYObNN6NolFxZLz20Sts6nwPw2tStAa/rjqiiToCIAd6YdfeItnz5gxU5XOKFuz9/AgebhE7pM7EecRfed+IAAAAZwNISUepJA+8rB8LmmrfsEpTyOOwzB0URAAAABIAAAABMEUCIQDd5FZwVSYV2S+pQztx3A673UJnjKSnsWqdHuUL4etopgIgbY02xBenGArmCsUTve0fDP6atBBJkDCA7nVhswM8hSIAAABnBFJJWUELFyTMn9oBhpEe9qdZSenA0/Dy8wAAAAgAAAABMEQCIDB2pPMCJSYaA+oURDBj5y1dmwkbIWw4FOBplgH0vOGZAiARaIjxHwckBmnHeyzUuaDs1gO9wYQv19EYXs5c8jtGowAAAGYDRU5DA59QUN5JCPm13fQKTzqj8ykIY4cAAAASAAAAATBEAiAj61WXPcBvxeD4OXjY+x7jGTgJtQNbF75ZEFbKfeNB1gIgPUxhUAAca5Y5Smc3+s0y/sOKHWu2PyTIQfCctpgF6KgAAABoBERJQ0UuBx0pZqp9jeyxAFiFuhl31gOKZQAAABAAAAABMEUCIQCxbeLkdu0mt6zg1GEgfAhifaqeCF3PvsznerWANrWYZgIgFoZgAjOV7vlcWu3D6Rfqea8n7Cd5w3WfJgvwoLmHr6EAAABnBEZVRUzqOOqjyGyPm3UVM7ouVi3rms3tQAAAABIAAAABMEQCIEEtM67FeRE5hMd3OdoQfGxSZgGbdImj/g2wwoNM3sOLAiBLOgJ2Pjv2t36LawEy33rJhTDOH9ZFV7XAT3Bk5JPUvQAAAGcDRVRSaSfGn7Ta8gQ/uxy3uGxWYUFr6ikAAAASAAAAATBFAiEA1nnWZjyQEW5cPMk1RgFKs0+o4pMMR0xq5v9pUu9IqgICIEWmbQ1ArcKmRsR+6XFRaSEDAllKHbLAfcaNFqOMKepkAAAAZwNORUPMgMBRBXt3TNdQZ9xI+Jh8Trl6XgAAABIAAAABMEUCIQDruqKkPb3uaYgTPexVKLZQIPfmxb3uJ0fazSQO7A+7YAIge+mqehsQiJFn67c13mVOZIkiRbIlTnFoPaB30rLNx+wAAABpBUVUSE9TWvK+GTpqvKnIgXAB9FdEd32zB1YAAAAIAAAAATBFAiEA7pEOp+7nuDc1jCphDDagTn7o0ub3MP4TwZIlpst0vr0CIHcSGlsFsYCunyQKYE5IA2a2gp49z1HvW0KxJkufmwVIAAAAZwNFUFg1uqcgOPEn+fjI+bSRBJ9k83eRTQAAAAQAAAABMEUCIQCHsh5mHpNiIL26E9zW1QwOddhmYMYCr/OH+jLrOgvL/AIgJz8G/F82cxvD+jNGq1E7h9HZRSyko0enmFt7Ppx5/TsAAABoBEVVUitX2ug2U92Z6Hb/HxG5cMaGuQqaLgAAAAIAAAABMEUCIQCW8za46biC4b1EEfzqBD26Bs4tTnmcOIpyHGCJjJJTWAIgIemybZ0bf2sOaVpizNVOpXtHqphMi0/G+DcRnEhWyrUAAABnBEVVUlSr3xR4cCNfz8NBU4KMdppws/rgHwAAAAYAAAABMEQCIHc2Gr1PT8Ia+GCDijmIuOThIQU5yp8vsGBk3bw4tKulAiBUuYGumu7Qan3qm3CeoyG+ssjDypgUG6LsaFqq5OZ7agAAAGYDRVZFkjEIpDnE6MIxXE9lIeXOlbROm0wAAAASAAAAATBEAiB9NhjyG8zdaDwKPYaE9eyNsPLMP9GK23cLYiW116zKGQIgI3zZN7Q8BP4lGq6rsffC8fyfQ1wrVrgVc0hUR8L8kPMAAABnA0VWTmiQnlhu6sj0cxXoS0yXiN1U72W7AAAAEgAAAAEwRQIhAINHzOFrQHIzWApZzdLnVfkDCWvkTQL67Qzac2lLirTAAiB2JU2NirTuYPPjy3frRcPJf90zpHsLcfjiQzfMgfUmwgAAAGcDRVZDti0Y3qdARegiNSzks+53MZ3F/y8AAAASAAAAATBFAiEAxUasuo5++e0+EP5rrmOq8hyz+QQGUY1E8jLYIF8QtwYCIFis4XeLsoKmokTccrRJiWdRQ646GpetBKWI34dOISXaAAAAZwRSSU5HlGnQE4Bb/7fT3r5eeDkjflNexIMAAAASAAAAATBEAiBHZhwVotWwc3eJDCc0CKPqfeDDvTJekTuIigNeSYj83QIgSTSQGn3GD4I2xkC3M+7U6KV0pobrHJAbumRCJu4dI90AAABnA0VWWPPbX6LGa3rz6wwLeCUQgWy+SBO4AAAABAAAAAEwRQIhALWMnGQ09YC2LJbdh6ZvgupuSAd420FfJ4NK6wuYAeU4AiBOBxdchiAuYKe4l2TKx2lmGLfpEtkTlR4+EzD+K88OmwAAAGcDRVZaepObtxT9Kkjr6x5JWqmqp0up+mgAAAASAAAAATBFAiEAo9QSBVDW18J+nYp6AXCJXn1GEk8ryLh+Bf1jdzedC7ACIB5mmdrahiDdZk8kNbv5+PDzPoJDy2jKWRhnOBNV8jt2AAAAZwNFV09ESZe35/yDDiAImv6jB4zVGPzyogAAABIAAAABMEUCIQCByicrhpwJ2jh+YX+eL8CnmPVH1qmPbczPGcJDuchYugIgFB0peQR5ogqFSC8rgp302jRa7OuxNChlb0/aDnLGBa8AAABnA0VYQ55MFDv+NfhVYks/hEZat0AaF6EgAAAAEgAAAAEwRQIhAJblKwh4k0bVPlzmiaHIjOfxzRgRVjyrwVtPGf5atYOZAiB7UAvGa91tXQ/0nPryBCUwJIEJhEbiTiGFUc7eaYq70AAAAGcDRVhDAMSzmFAGRetdoAoaN5qIsRaDugEAAAASAAAAATBFAiEAqVo1e+rcgITZienR+a41NYPXMX720+XtRtybxrCHLuUCIEiq8s7cbVerLSJWjenpQ1yhlx1x0ayUHz3CtRUksmn3AAAAZwRFWE1SyY4GOcbS7AN6YVNBw2lmaxEOgOUAAAAIAAAAATBEAiBKNexYghfokyHzv2Ot1pcsRhuXkrZWXYLiUKD/XpfxOwIgNsx8xohN/1QrCVBp9sr78xY6EOZWKJ/FlPEzN6b7THwAAABmA0VYWVx0OjXpA/bFhFFOxhes7gYRz0TzAAAAEgAAAAEwRAIgd2j4Eh1MJItgwxwBCZoVP1Z5t+aNtxQsH3LDaMJLNN4CIHhNvMWV4P2ds8aizInceduXoEbYkfSnDaAeqZW8cStjAAAAaARFWFJO5GnERzr4IhezDPF7ELzbbIx5bnUAAAAAAAAAATBFAiEA/azUBbXA6VSSXQsljj8UZJu2YcrND4Z99foG7RrCsosCID3YrbRe5tlJ8wqYpA09/SYBMXW4FqoKoL0LBfwSL/n3AAAAZgNFWlReYBaufXxJ00fc+DSGC58+4oKBKwAAAAgAAAABMEQCIFN3ryilye8jHNsQroaZFHCT7uxdTUVRQX9bJo8BEsfQAiBGr9VMbv7WaACh9EqyaHgZnJXLc6Fp8+tM/OSJJf2bNAAAAGYCRlR4pztsvF0YPOVueG9ukFyt7GNUewAAABIAAAABMEUCIQDHWN22PYzZI+LB8ETH5CU6BQfclJUgXYAmoj0tcHaulQIgF74/YjUdtGmafOXFSFzrtedx0bJhmEsroGa7qZcsY90AAABoBEZBQ0UcyqDypyENduH97HQNXzI+LhsWcgAAABIAAAABMEUCIQC7xvIBe5G7NgOpILGPIpdLj6xRgI2jqYm9Tk81/0xDvgIgJD4DrMjZAPAl0z+gBBTmpwI6bJXZAvw+T8iM+k62uroAAABmA0ZBTRkOVpvgcfQMcE4Vgl8oVIHLdLbMAAAADAAAAAEwRAIgFbGDWjwvff0++jE6LBx4FZJdJrGcfUWmB06jkCEYq+oCIHutzVGxIGhbPv1PSjUJPi7gaJuJ+chyZZMINoArDuasAAAAZwNGQU6QFi9BiGwJRtCZmXNvHBXIoQWkIQAAABIAAAABMEUCIQCnpocYqmWhE5GDs7+x5eIinnwveZrc5l8qUaE6nQCPhQIgIDDnuUJNjvzwh9v7QsH+Sd+wtZbzD1NOaSrlmyzzuRkAAABmA1hGUxavW/tK5+R1ua3Dv1yy8ealDXlAAAAACAAAAAEwRAIgGjkiG7XqZ48diwjlZo5Nm0yZNveRF+7L2QWHH846vyICIHt9TtjSvV3GfcyuYODoOV/dzHSIhKl7s1e8eYyCDO/7AAAAaARGQU5Yfcs7I1bIItNXfU0GDQ1deMhgSIwAAAASAAAAATBFAiEAjJ3l0+FSf2pRmRUxoQNFXqtoRapfqACffEaRBLSMkpkCIDDlBJDpYstcX3v9Pbo23oDDfUryS+HlKk8GUWmJicpWAAAAZwNGQVJ89tx2lIKr7i/3V5XQAPOBqAYt7AAAABIAAAABMEUCIQCgh787RJp1UYrDq+oigcxZL46Um2h+AA+nEEbwppxu8QIgA8O7sRaMV75fPsReFgcs5soOtaCQ2lxGr1ZBFjZjnigAAABnA0ZSRAq++3YRyzoB6j+thfM8PJNPjiz0AAAAEgAAAAEwRQIhAJl+4HpHb/YjBBO314xgVdlrDSz+tarxzSMsAPLl7FS4AiBxwjQiyG9pZf//JfAY2Xmkp0XJ9hZuo3Au8cEUOwgjUAAAAGcDRlRUKuwYxVAPITWc4b6l3Bd3NE30wNwAAAASAAAAATBFAiEApHbGhw2HxAMfYvw8ZIrQvBHDdvFOXrZT6r+fVskKbQYCIAjaKkqKrpJCp6QyTh0ny3MLGyMR6YrFU3AFrCMaJzbDAAAAZwRGRU1Jsm6Lm2z1PkmavbLIPhUze+hanloAAAASAAAAATBEAiAhBFhIT2xRYzJdg+V7GCJWtMR/hTfSLbaA7DQYXYQIPQIgJ6ebR9bjoenRxgTXyaVUT9f2iYMkF+WaXE3uxnHmm6QAAABnA0ZFVB0ofMJdrXzK92omvGYMX3yOKgW9AAAAEgAAAAEwRQIhAICVx3NOTrnAVbRo+5RDYBc8YnJYy66JiJfnCaazFEiPAiBu3/f5/bY/w2yMWt1voD+PH3jWDhdJsh+HzV+HxK6MrgAAAGYDRklI38PoV8jM6nZX4O2Yq5LgSOON7g8AAAASAAAAATBEAiB3P64ZUGaWBoIFIeiPebEKeP7tbl97t2bh0pcuM36Y5QIgZsjf1ViXfkWPQxPDzILLGKGu7zeP27elj5ZY/XNgUFAAAABnA0ZJRFL7Nsg60zwYJJEvyBBxyl7rirOQAAAAEgAAAAEwRQIhAL4RKc+ygn6yn9Y1Eb1h/932fAN9wScX6EE380hAyItgAiAXiVrKFDALb9p4oR+lVOFfSG+hGISiIQ4UdMbOsjrLhAAAAGgERkxNQwTMeDtFC40R88fQDdA/33+1H+nyAAAAEgAAAAEwRQIhAOz79OzfWFJygxjiRjrkuk1q0KUCOLVN7rUVOJWqldIpAiAtlcO7rJE/zzxmVbGSY7QK7yv4Bi+fm8tW15hwYuuZvwAAAGgERlVDS2W+RMdHmI+/YGIHaYyUTfRELv4ZAAAABAAAAAEwRQIhAM9xZFkb/DRN15tkaZXt1CUxdp9Dwt9onRHd+eaUhVIZAiAyGgrx136hXxhCAsrXLWr9dKPbHEXovzHZoAIEc7hOwwAAAGYDRkdQ2ajP4hwjLUhQZctiqWhmeZ1GRfcAAAASAAAAATBEAiBYLoZWcxp5XicdAioejqOu9QiZ7wse9qeUTgB+Y6EgawIgTDsr9nCjHLcPlcV4ApVimndyJIVlow0JiwFOolJAvfgAAABnBEZOVEK9S2ChOLP841hOoB9QwJCMGPlnegAAAAgAAAABMEQCIBga3rZ4Y3QAH3nxn59HsvGxlOw2iplOo7sUROK4MSg/AiAeDkOhAmSI5u6ATZ4UKVzoW7Fa04k80HvYNzlPxwDULgAAAGcDRlRY1VnyApb/SJXaObW9mt1UtEJZamEAAAASAAAAATBFAiEA6+/dYuIOrYRtuijZXqJut7AovxqpUOF7VYC+XPMh6R4CIGymee2QMR+TuT9XIuSr60tnNS0awPymZI1st7JgYVD0AAAAaARGTE9UBJOZprBI1Slx99EiriGhUyciKF8AAAASAAAAATBFAiEAzcfy+vsaMr4vOI4ac/rMj7iHG8tm6eOLoK7cRNJN5dwCIH4Mlc/eRyXUzyCzusGtasVCIfJ37U6akz8ZYx+iNO8+AAAAZwMxU1SvMNKn6Q19w2HIxFhem7fS9vFbxwAAABIAAAABMEUCIQDYDzqLT7U5500ohb/sW4IKepjYUiijB90cdkRZAwsf+wIgPG4BNxICK4dyECcCqoXTdHBuiZW4z1KJ2+Q7TtdhjUAAAABmA0ZSVkjfTgKW+QjOqwQopRgtGbMfwDfWAAAACAAAAAEwRAIgV3itrHur39/s7SbQuoVEqvhMKUGvwsRoFmQA1HKU6L4CICLWSeBPWbmSRrdw6O6N28ksxa/0kBkrXr2WQARSdeDNAAAAZgNGTFKa774LPDup6rJiy5hW6BV6t2SOCQAAABIAAAABMEQCIHDXcQjbNdhnaeIs5c2RTYXLq1qfXUgsLTpA6TH47xtBAiAIniMhiYBl6Di0Z2KRo8Yt+ofHGXnzuv1Tt+0jN+JfiwAAAGkFRkxFVEF3iNdZ8h9TUzBRqa5lf6BaHgaPxgAAABIAAAABMEUCIQC/yb+stETcqBJ1EsgdJK5p7VrhYZauW114lRCWqpzWbQIgJrL4ghsXbogPA4Er2/sDRwQzJiqnXGKnrI6yo2d2I3YAAABnA0ZYQ0pX5oe5EmQ1qbGeSoAhE+JmreveAAAAEgAAAAEwRQIhAO2KRA7kkFQw3Wgix3qiveTbmHnzQmpVIwKULTexqS5RAiBzSdBouFnNU4lSzLlTH2aly8nLJcQbQ930M4eVGEv8dAAAAGcDRkxQOhvaKK21sKgSp88QoZUMkg95vNMAAAASAAAAATBFAiEAlQCfVST7LD5wXgXnFDlZdbH1n5dXKo1JTaOauBnkPPECIBhack/6lXyDSDhqIN0JbQu9jU/c4n3skNxm3WiC7/O0AAAAaAVGTElYWPBKisVT/O21upmmR5kVWCbBNrC+AAAAEgAAAAEwRAIgZ8PVKZC/kI9MmHr+CdRpvgAB7zVk3/nERmXNa/xDKz8CIAOn6I4rp81tTbkYLsoPsWzlxusa+CYVKntjuT8YWHzlAAAAZwRGTFValUtd4JpV5ZdVrL2inh63SkXTAXUAAAASAAAAATBEAiBRsMFQvRGzOzcTnRj1i0u9Fdiow55Nt/P08yG8PXDKkQIgCDDkneuzb0NCLnEt1agUap5u09Gm6LX8gCqaTkBihF8AAABmA0ZZUI8JIfMFVWJBQ9Qns0CxFWkUiCwQAAAAEgAAAAEwRAIgbDgzKOSe3goUuJoMfORhJbYcktvIYwsjnmnAFv94VVsCIHl+FRPw3Z0eNHuMPz5R1Kxb9Ta74/VDQcg870i1FJeIAAAAZgNGTkJHso82W/TLONtLY1aGS957xLNRKQAAABIAAAABMEQCIECWiovEsPlN9jXNMPWo+01Bd64MW2CXCtE/EIJ0WvqEAiA/lREIQCSsNRRcW2S6YmtQOjNVjmJtqVtJEfwTAqwsnQAAAGkFRk5LT1MHB2gfNE3rJBhAN/wCKIVvITewLgAAABIAAAABMEUCIQCnHqxOk4uPji8apB0iRL8EpwvVFjRoLtOQQanCYOzbdgIgKkHhIaXR7Qmf/2Y2sMniVh0+gmQEQmT3zH6BFYMmUJcAAABnBEZPQU1JRvzqfGkmBuiQgALlWlgq9ErBIQAAABIAAAABMEQCIH/BoNC1jBkGUZh23Y6RYYG4jeWQBg2x+wKbphRW5JBuAiB5Gbyq/n92lwi0UvRnfUOFaJjOaLTgetKt4e2z+QNO/AAAAGcERk9PRCoJO88MmO90S7b2nXTy+FYFMkKQAAAACAAAAAEwRAIgVB1I0ITogfXhTKqxq68Zj3ekIQqXPhK/QbJatPhu5kcCIHeh7jmDRSZHO2KlOWKVjhZpJNu5BVDzfKeThMJYEMUiAAAAZgNGUlg2pzVX9b3lGV7DnsqC0ouKNtIRQQAAABIAAAABMEQCIGtMQhmkY6ASHM3TX/K/X7almv34tvV+E2J/z/ju94BbAiAlMrHGfvFYU7AlglMk9ATtrtQaeNW9tR2T/IO8C9FS3AAAAGcDRk1GtND9/ISXrvl9PCiSrmgu4GBkorwAAAASAAAAATBFAiEA7UbvhbbnzFPXUMh6dhoWehURquZH0ClCZQy4DcU0XeQCIGcsQzgTZb60VU8dbAQRI9tg1H9WXWPVjU4ZoTm0zVoHAAAAaARGT1RBQnC7I49t2LHDygH5bKZbJkfAbTwAAAASAAAAATBFAiEAuqcRRM25hroqYF8hVrXfE0Qy++wuqpUNFtquqrqRceYCIB383b2ZCiBRgdQ7m74MJVnUmzUHyCepOJNKeiqMkub0AAAAaARGUkVDF+Z9HLTjSbnKS8PhfH3yo5enu2QAAAASAAAAATBFAiEA2zSdM98m7QAA21aKGNSZEtHUBHCqg/Z0rYk3/WjsRKMCIGy/Uz4We0JuENALxcMGVXDO9nti9E28Zi/zA+pPIZZGAAAAZgNGRFojNSA26RGiLPxpK14uGWaSZYre2QAAABIAAAABMEQCIDjzIbYrZUxCuUBws0Z/Ynlx7bgM1EInzEPqrrQeL1gYAiAe7KmRXlzpmgHCyUFhssEYDQIKDemOnpmQcIqI9wZKqwAAAGcERlJOVKOuIjBOS+wFMn54EnaLESU7WnyFAAAAEgAAAAEwRAIgVTGvei85HqwQOTlCW5wfelQlT9fuyOXm1N/08dv5LMkCIDL1zPsWNdyINgDuXaGNUSNIZ7EjDajGKO5FdbDOINa1AAAAagZGemNvaW7lruFjUTEZ9PdQN2xxh2a0D6N6XwAAABIAAAABMEUCIQD3JEt2ZsYGRxylfWO4Rzn5QUeV2xkZUg0jWFYfzZsuFAIgCVj5GPDtpSmIbzIz8nsNzQi0TydJ6Tp1FoR6IQYxWfQAAABnA0ZUQ+b3Tc+g4giDAI2MFrbZoykYnQwwAAAAAgAAAAEwRQIhAODQQoJPfJBcISyqMz3716r/+GbS/KtBWaemTbkp78kyAiB29/I5FEDCJqyCeNJ/yIS+ZMw5a0Ch1tsSchvs7H3w7gAAAGYDRlRJlD7YUtrbXDk47Nxog3GN+BQt5MgAAAASAAAAATBEAiAeL9kGDZzFdkFlBgtpuJ2MkD/l6kUpqKvxb1mkny1cNwIgDqrcYdWca/gAStG0xG8M9DXgPNVeSSRuuxJUFLYkWPcAAABmA0ZUVFDRyXcZAkdgduz8iyqDrWuTVaTJAAAAEgAAAAEwRAIgNXVLA4oFkPYoN1EK71Y8HQOP4eIDmTpduAj32lWxLroCIBPFQD47YgCCH8bTiLH+ObArjx2tw6OJyJGnbIFvwmLDAAAAZgNGSU4d17KHi21Wce1gLmCBiw2aDNHN9wAAABIAAAABMEQCIA0Noj3n2IvvaNfVyHrrbeMgYncFIoRnV/gw45SWbaQQAiAd7e04jsJq7Z0fLgLSN7wzL5soVVjrBDLAXfhUVbLdzgAAAGYDTlRPipntihsgSQPuRucz8sEob20gsXcAAAASAAAAATBEAiBiRz0s4frg5CD7BaRzORO05i5jq4OCeP+u9SRvMAIwQwIgX4SIuJmJwS8BVAkB6xVwRYc6+cFINxPpuXQT9lTWytkAAABnA0ZZToj8+8IsbT26olr0eMV4l4M5ved6AAAAEgAAAAEwRQIhAIjDqq6OQZLdACQEvwvdSew86uYxG36wuXdFuXS8l0+pAiAkHLIRuqm5Lon98cUBTuCKR3ayqjdGAHSbhitM37D/FQAAAGYDRk5ETfR7SWmykRyWZQbjWSxBOJSTlTsAAAASAAAAATBEAiAs57mNsddIxVfdEad7tdB60RhA9IrsOpVnqaewae6GFwIgJqgAT41lqNt2CKe87iveEr7rTVNXdOOiy+08Ojghz4MAAABmA0ZVTkGdDYvdmvXmBq4iMu0oWv8ZDnEbAAAACAAAAAEwRAIgXw46fLN7jOwODR8KYM2+L4u2rgaLyDZXXulE9qbYkpICIGeCQntSP4ylSIylG1UW/o/aLi9yijhqYgHUDjOIcXCcAAAAZgNGU07QNSoBnpq511d3b1Mjd6rr02/VQQAAABIAAAABMEQCIC+ymUjhRNPAj3EiOcTbEDIDgBwCwSuASaZDc2tIx24yAiBVIHObNySiL6vDQRA0RkRLGFsCds5Lfq1b+BzbKzWsrwAAAGcDRlRSICPc98Q4yMjAsPKNuuFVILTz7iAAAAASAAAAATBFAiEAypFSDa3v1X3ZqZs6kYCqzo7Xnd6xv1pdJcT0xyIXTO8CIFTg0iA/uVDLw6thpc4+TslEMwf+YbE+hxmtrrgIK8MGAAAAaARGVFhUQYdcIzKwh3zfqmmbZBQCt9RkLDIAAAAIAAAAATBFAiEAmctgSTjx5Htxhvoi8RVlYuVItLmcdqlWv7wQtTL/g9cCIAWS1MAd/GYQSoPjeAVzeSvy2HlfdxNxJ3Wq8RsZoVckAAAAZgNGWFQYKaoEXiHg1ZWAAkqVHbSAluAXggAAABIAAAABMEQCIAEKpHUFyEQ7DkurfPTdLAR43F15kG3m4ckV0NPlWF2LAiA8f1tMwfA2HXIeThe9kP6R9vpWa75SKHAt+wgRmk13bgAAAGYDR0FN9nRR3IQh8OCv61L6qBAQNO0IHtkAAAAIAAAAATBEAiAls1qGwArTjcas1kbvTrgam2oIvk69PqqyPj9FZ+oTTwIgG3VlnnV6Obvm+Ej+6ERwWa/dfQQ9h8oH5MMbqhtdvJcAAABnA0dYQ5U+IpRbQWcwutBQCa8FtCDlmOQSAAAAEgAAAAEwRQIhALY/1iTUYVVpn8pYaVjEKin8hZ1+dg7NuGn9eJAeMeXsAiAFtLtUEnCjkOauHI/BjZ2kKMFXL2v6TIkDvMITyj3K/AAAAGgER0FOQcDqYwb2Ng/n3Ktl0Wvxo6+Sx5qiAAAAEgAAAAEwRQIhALrbf3QtKkKscmm5QwFIcTSzEOwcYtXnbBmFG3LsCUs1AiBGaFHioF9tpYmsucbpHHtfwjfRH2PSczuFElb6XY7Z+QAAAGcERk9SS1uxYy+gAj4ap2oa6StGNcjbpJ+iAAAAEgAAAAEwRAIgR6dnZEOz40t8dcSfWikXK6SgNiypZhZsyyfIaxD//UICIBeeTn/Ox5uSrd0MKHaCOu5rMrfIkcaqDZifzGbbzq7MAAAAZwNHQVRocXT4xJzrdynZJcOpYVB+pKx7KAAAABIAAAABMEUCIQDyQa8KhYgVjesJzcyfAH4u2MHJj3DYxFODttoSFEc7owIgNRalmBg73OPRmh8QUdKpKeeJT7T9FJow9AYreIyvi1AAAABpBUdBVkVMcIh29IbkSO6J6zMr+8jlk1UwWLkAAAASAAAAATBFAiEA9ipb3Gr234Vv9oRToDvG3O/xd8U/10GvHkywsXVO4ikCIEie8LJis6DBMLu3Cmjvm6AaxBU8lCdmoubZ2uniPX8ZAAAAZgNHWkWMZemSKX1fCSp1be8k9HgaKAGY/wAAABIAAAABMEQCIBH90xlLIcxwAPKLskdYmjhsnvPJ7PqxhHIRtw1YEi8OAiBirwNwUVH8zk1rdJ2fsgYdfwJiHIMLzZQb0xCh3UFdVwAAAGYDR0JUdYX4Na4tUici0mhDI6C6g0AfMvUAAAASAAAAATBEAiBoocnW8IhvfkyM+kt0ho5IcZXY9jHl0WyahMMFHUbAQQIgYFb9buI8FTda0xZ+CGe5l5mbuHvFHP5CTSosq/49OAEAAABnA0dFRU9PDbTekDuI8rGihHlx4jHVT4/TAAAACAAAAAEwRQIhAOP7qySbSxibNtP1Gt9w5beA7LPaelk2lIs99M3eXt0MAiBScuHE1RsaAx+WoH1xE4J9xqO9q1hyBztq/L2i0Ni0vQAAAGgER0VMRCQIO7MAcmQ8O7kLRLcoWGCnVeaHAAAAEgAAAAEwRQIhANwbT3cL/K//KW3Zc9DTn6P1F2Ijwq6n4Az9xas5jqqAAiAP/ytKANfZnbG8O1VZpCw2GrF6PCfjQ4UsEJJ4erx0qQAAAGgER1VTRAVv1Anh16EkvXAXRZ3+ovOHttXNAAAAAgAAAAEwRQIhAKXZ5wzL+Co6hyCXf5lThBBU54mx2PTwqy8YPgy6xF8IAiARaOHL/kHCRz3ufat6ks9OJLi0/Ar7qKZSuNp8avN73AAAAGcDR01DaP7AvMYXJ93sXOziaDAno4NJJxAAAAASAAAAATBFAiEA9lgGV+OiW3Qw4V+R2PWN9sD4fzJOZ0HglN4d5PXouxgCIAl4WIihLxpA8hSu6s0au+0YSTL7Bz/dTefyP9146UBgAAAAZgNHRU3Hu6W3ZVge+yzdJnnbW+qe55sgHwAAABIAAAABMEQCIAiE1f2suqWjY48Gc/uLoO2XsfOpOmbFZqA/43VZFL8jAiA/rDYnZ8grFw8qyZ3VAPM48H0R/Gd2IpdOMxyTDWFARQAAAGYDR05YbsiiTKvcM5oGoXL4Ij6lVwVa2qUAAAAJAAAAATBEAiA7hOjdC+NpB8ZbT4HbUmwVXa9pD+U2arxnYzyzRc9UIgIgfA0KH97Xa3fX2zF8jKcNXc6hIzqZKNXT5nmXnp8ZcxMAAABnBEdFTkVt1OSq0ppA7dakCbnBYlGGyYVbTQAAAAgAAAABMEQCIAzYzVubIxp1t/1P4JozTA/Z6jFTLaWKZq457wo8i1G+AiAsp/FRtc71EwRK11xRbVFA9qDndmBnbqask+SMjW/3bAAAAGcDR1ZUEDw6IJ2lnT58SokwfmZSHggc/fAAAAASAAAAATBFAiEA5BvKOC14eXnVTR34nbSlcQCpR/pz5VnxWme19t7R2LgCIADRiaXy5kNUGz33Riu6I2d/Kn1XIOBe2xZz03RbeRUnAAAAZwRHWFZDIvCvjXiFG3LueZ4F9Up3ABWGsYoAAAAKAAAAATBEAiAD7MxH0vRbYias0KDujaVFxL42QnsiZVNgAuq9yygvCwIgCnpQ/d8kIOKHfhdLBUv8yAkdMFQ7xWgy9+OgcfbRh54AAABnA0dFVIqFQoill2A2pyWHkWTKPpHTDGobAAAAEgAAAAEwRQIhAMyUve8dntafpVOpt+f37b6dx6H95Sz4UqIry60Y56OnAiAVE7k5aheiKL39vGikc+dsGXORCO+P9wQuDPUjF3Ml4wAAAGYDR0lG/NhimFYoslQGH3qRgDW4A0DQRdMAAAASAAAAATBEAiBVYNgAskoFXQKQdlhnA0tHh34pAHx+fBaSG7a9ZCCQLwIgL0QTabsMrkwasjXDAMKVEDJaRGPTCV4d8fChV0oVQBsAAABnA0dUT8W7rlB4G+Fmkwa54AHv9XopV7CdAAAABQAAAAEwRQIhAM2MKZoXLPs7yfZ/qBC0hUjxNXqFaHcIEY+k2at3TF8kAiAjn0U51TlZnkuhcHb5WntCgwluBqb+txcWCi9fikAY6AAAAGcDR1pCna6Lf2036o5dMsbD6Fam2KHTs2MAAAASAAAAATBFAiEAjTEUCFa0s406cZeQYKWdtG+dJYvQNlTV1Hr6PKuyJYgCIE6pknysi6nvMjjBSSgkPxLjQsI3NtkvtNZpsBXrqlkaAAAAZgNHSU2uT1bwcsNMCmWzrj5Nt5fYMUOdkwAAAAgAAAABMEQCIBg8qLSjaZLMeDx707sfXs7/ZWSEcFSd3mvN0x3nDO+oAiBP2ZlVKlSJXqpkkx1OiO3r35GykNZmWIlHMK0N2THzuAAAAGcDR1pS5jjcObatvuhSa1wiOAtLRdr0bY4AAAAGAAAAATBFAiEA0mE+smCTljQ0RiWtbV20Pw9p0qaUutSpcycNFFnwsPUCIFzGiPWMl6TTPzig2BTm4X6gvh/DID18J/LiHys32L1uAAAAZwNHTEFx0B241qL76n+NQ0WZwjeYDCNOTAAAAAgAAAABMEUCIQC6CAA88IbCsvNe7o7FF6km7QSbWdHgj6M2zPMJ/HxhggIgBAGtDfK/iefEmGVujzP8OIwTlfHNVFGlbTblEUsPw8cAAABnA0dDVaTsg8iQeIjQBqN96/dV7jl2bziuAAAAEgAAAAEwRQIhALmAmVfu+PD7l/TL2YNIc8sxWTD+htia4bFI3f9uaZsTAiBT08L6FgEwllU3mGGwBiY5WUHUIsHM7sYzQi5Mwr8r9gAAAGcDR1NDIoulFDCf/fA6gaIFptBA5CnW6AwAAAASAAAAATBFAiEA7Q+DGkWU6YlFGzej7BT1g0V/Vshic+xrRFNJWHDEzRMCIC5c5yXQGspMmEQAeW14wV7OOLgpQIidc7FUfkgU76QvAAAAZgNHQ1DbD2kwb/j5SfJY6D9rh+5dBS0LIwAAABIAAAABMEQCIB5dzBkc/Of1wCLNdgA5SDG70ST1y5zq40CSrJ7WP0/KAiBeC33S/wperYBxC+YY8Tdeiyvg4uiOhul11VKjfV6y3AAAAGcDR0JYEvzWRj5ml0z3u8JP/E1A1r5FgoMAAAAIAAAAATBFAiEAnbqLY1t9WOYglxT5OzwB0lrR9sDYAFnEXLGHQ9SBGMQCIBUPIGIau+p1GM5MchVJGHu9eQ5vcDQ90O2GHbEu4aDKAAAAZgNHTVSzvUnij4+DK40eJGEGmR5UbDI1AgAAABIAAAABMEQCIE5WsyoW6yNqYfN7OlkzNzkC+JEd8E3j1qUT8knw+wkSAiAp0MCd7jn1ziK8THh8ak7agpK/Obq28l1XqAmu0PVuDwAAAGYDR05PaBDndogMApM9R9sbn8BZCOU4a5YAAAASAAAAATBEAiB8A3eQTb8B4kC+wSkZoDLgugAR9wGv5wXxsIBCyJXRjAIgct+iUcIRPzm4hPPpJU4YItqK3hXMZpEce+/6jSYYefcAAABnA0dOWSR1UfLrM2LiIsdC6ceIuJV9m8h+AAAAEgAAAAEwRQIhAJbqSvyclIOjesZgaKxLIH7A2jNQpOK+bxJGEpz72nXhAiB1pPG7vfHR+PPIi3IxpsEyQxJpZ0WNphBWE16IxvroowAAAGYDWEdH9raqDvD17cLBxdklR3+X6vZjA+cAAAAIAAAAATBEAiAHaLx2PmFQFw/pMEmzjWolY9M9nbFcWdXO6aCDTAcIVgIgKvAEZo6M8KZiVLYlOyJNfNO7ydZpKFJTDIwrjoKpeS4AAABoBE1OVFCDzunghqd+SS7gu5PCsEN61v3szAAAABIAAAABMEUCIQDGDo8Uh6tbsCPVJvcEG+nc1yYL6zowp5ALsk2/p9S9BgIgM23nRjwJEYkO+YowwhnNQUIoLt2YeUs/lUIFKmVrLkYAAABoBUdPTERY6rQxk88GIwc8qJ25txJ5Y1b6dBQAAAASAAAAATBEAiBD+tL9Atep1wciIHBdRISJB0SSNsmDgShRV4PQKNECswIgaw20wIC4bRPWHoYYvfknAci1PFUwCeaHGLy1TdiAARAAAABmA0dOVKdEdkQxGalC3kmFkP4fJFTX1KwNAAAAEgAAAAEwRAIgQUYHRHdFQBBzkybzYKa1pgDHK1lD0+tA8SoXcHg9pIACID1DJ2Skos2aGL7SXwoiHz9liz9Ggz+mA+7tA96GEdKSAAAAZwNHT03TFBrNP13FMgdzlv85hLZwNSNPQQAAAAAAAAABMEUCIQDjafdhy4oQRXvoz578VJWTCqMJZQgwH7x4Dii+lITDMAIgGVWA15ng1BfUBKJqW/bHZafQ8rfqLpVmViH0xLSG6/UAAABnA0dPVEI7X2KzKNDW1Ehw9O7jFr76Cy31AAAAEgAAAAEwRQIhAOJdifL/uSwveMV0qFuACbmkE9xhDit82nV3Nkw6PTBHAiBJTOnoyky1VzYuvC9LUZ6LbUKSLZdVDNsimh8mIbtCkAAAAGcDR0JUy9SRgjRkIdO0ELBK6xeJNG2mzkMAAAASAAAAATBFAiEA83KbjbCRtsT651TRmCjo3PRrFV+5gxiJW7GpuymznD8CIAwp7zC2/vtgsYPKG5ofP+BBHh2V6vm1/SUAJookDKCjAAAAZwRHUk1EtEQgjLBRbBUBePz5pSYEvAShrOoAAAASAAAAATBEAiBEg94d1lCFgKlXvK2P35PHhhr4QFW3fwmGwprJO5L0VQIgOhBHHJ9lzrq3J9IYcCJsSE/7aPSQelEWjS4B2cvpkGsAAABoBEdSSUQSsZ0+LMwU2gT64z5jZSzkabPy/QAAAAwAAAABMEUCIQCMyFgUWb7H6bJRn7IV5I/vgpcNbLQhM9d4gU1qj77nAAIgU/+vfm9oj5MgPFrBWzPT5uwOMtUC4sx5pYR3nEeeKOcAAABoBEdST0/BcZW95J1wzvz4qfLuF1n/wnvwsQAAABIAAAABMEUCIQCjjzr1E3IJIPbDtpojiIUEuH3rjKryzXC0xB+QSOzEwAIgKsd5PEww9cPBameCrfIEb1vqksrk9DiijAYv81OKucAAAABnBEdST1cKmpzmANCL+bdvSfpOezimfr6x5gAAAAgAAAABMEQCIBSoabBcR3ALLdAAs2jlnFeeJApaAswfAMJd6hPOZh5EAiBIvvXwyly8Bw1qWL/9Rj21wP8cQ+87HsxkonQCa07i5wAAAGYDR1NF5TBEH09zvbbcL6WvfD/F/VUeyDgAAAAEAAAAATBEAiAcVd7qEXBQAct2iCRTlnc/RtrKA7/WRATItE7HAg/cogIgacii9pv1fhJ0q58n4NkYprfeTM3pFEdn0XWMS6+nOKUAAABmA0dUQ7cINdeCLruUJrVlQ+ORhGwQe9MsAAAAEgAAAAEwRAIgOSL/thvygH5z/WaA6M4HVQfT9DWUmoiCta6F5bxhtIECIAiWR2pLaRZrqb2daZoEnLEzzWZBabVmBTcoH0/4f3dEAAAAaARHVEtUAlq62eUYUW/ar73NuXAbN/t+8PoAAAAAAAAAATBFAiEApA5TI2Vb1KApGk0pFL4+2Y1KByOwYwNZhO48GqCT1OQCIEgxgxfN0U51Yi+xjRDQQcSFyM2qThDUXe43RwHYU7NdAAAAaAVHVUVTU73Pv1xNkavAvJcJxyhtAAY8Dm8iAAAAAgAAAAEwRAIgfpHgL6ABAjzFVuNMn8AktTWEkS4/aNTX9uHIu1B4BX4CIA4P8CDbcG1pw8evXRl1Z0RtlcnxX2AWuW4L5CiLntyLAAAAZwRHVUxEmEc0Xei2FMlWFGu+pUkzbZyNJrYAAAAIAAAAATBEAiAUztoFBWqRSSvV8orcupLDt6xXIptDmkzv5f45QHW3qAIgSdfgl/mEMl9+Jqz4qBBVal8wXwykRVvSNkTXyQDjU8kAAABnA0dVUPewmCmPfGn8FGEL9x1eAsYHkolMAAAAAwAAAAEwRQIhAJotuEI0QJB+k4DFxRuYxJKqgg+Pe0YIUcjVVrml0ao4AiA9tqwv/xKmXbcpeBrvTXLOoKDNmx5SBqKqOdcZ6/qsyQAAAGcDR1hDWMowZcDyTHyWrujWBWtbXez5wvgAAAAKAAAAATBFAiEA6BCZxmLGMcRse4zYFEvgli2Gvdlr3fgWko2lPuvjhxECIB3SV8VCRewBMX/9ZkY/u0pBYlDTBTtciQGOceCNwVB1AAAAZwNIS06eaysRVC8rxS8wKQd6zjfo/YONfwAAAAgAAAABMEUCIQCv00p8/7P7GolXTrk3/Of7Jvq4WxX1Utl72qzIvIqduwIgdg7TMUspB0zpAEpGrbusj9y8DhwxMaQv0pc+k292VvsAAABoBUhBUFBZWlZ+KNv6K70+8TwKAb4RR0U0llcAAAACAAAAATBEAiAbEsTdVphvL9M8CDfj8yf8aLiG1KdR1QWkKPuJB692EAIgUBjB/mOceAhoPaSoqpcpi1Wq7Zv/3kP9fKkwgXVx5VIAAABnBEdBUkRcZAMcYgYYZeX9D1PTza74D3LpnQAAABIAAAABMEQCICZ/aLG+Fnk3yQd9LgeIcKLru8WVAPgPMykF/oHoWIamAiAwAthzMo6FntQy0B1kDj/LsxdSyZcWr1HrJoSxqDh5OwAAAGYDSEFUkALUSFt1lOPoUPCiBnE7MFET9p4AAAAMAAAAATBEAiBoE/oIl61VrtDApcfYov71poK1dA4Vb69j++PwKdZBegIgdIuLDrfPZYELM4RCVJWoucKeArJBjUihrq2fm1o0tJMAAABmAkhC4kkvjSomGNhwnKmbHY11cTvYQIkAAAASAAAAATBFAiEArRWglpuiV1ZOKYIgUbU41dmvxROB2X+Wmh08flsb4DMCIGTslFyICS3L7+piKwP94nZF3wkGIyAlvh3rgBKJ08lPAAAAZwNIREf/6Blrwlno3txUTZNXhqpHCew+ZAAAABIAAAABMEUCIQDk07beFtFl1DtitxuL0u8C7NN2uR+2gb3uUDII4WD0kQIgARCZ+ughGQXfnhCpfCrFWOBCi44SAVc1cuYnEPZgzRwAAABmA0hkcIRUP4aOwbH6xRDUnRPAafZM0tX5AAAAEgAAAAEwRAIgUm0WeJZLWPml+KjOSHtsJh7wsWQcde4QMrjUpADWBpMCIGyl7DEmbEZcX8JxpPqMBje7j39h7XsUJSPadGS1DcGMAAAAZwNIZHDp/weAnM/wXa50mQ4lgx0LxcvldQAAABIAAAABMEUCIQC80qolkXVIdskkGEAA/2pEwmKHVNHsB5fvBd2lgNVqlwIga4AN3tV+fgerH3bRkiJssWPEyKd2tW/bK63OnYH4JYkAAABmA0hCWuNOGUTndvObklJ5CgUn69pkeuZoAAAAEgAAAAEwRAIgcp2QOQ86l+rT7s+q2NxX4ws+hLt1H34jYp7+wADiUVoCIGW8QMN5/YntUHe4dn/U7jfS24dmfhEgDZl3q9iB3YXvAAAAZwNITFhm62XXq46VZ7oPpuN8MFlWxTQVdAAAAAUAAAABMEUCIQCMDhRdzSIH8aQq8TA6jDjKsYrzJy98gPQXmnZd8dq58gIgQDhnGSVGwkKcSa+eP/GMv5/6t/+L0y+l+4089GTSPBMAAABnBFBMQVnkdykvGzJoaHopN2EWsO0nqcdhcAAAABIAAAABMEQCIAfZqoDScNvWZEf36aZZVMhGs0yHf5Dqx5LERbRCEUBhAiADLds2oV0OTABgYQWLoSpHjUEVLSrUVMn+I+9yRgI40AAAAGcDSEVSSRyaI9uFYj7tRVqO/darqbkRxd8AAAASAAAAATBFAiEAjWIUVdFkoasLLvFsBT9TiWaZR+52+RFok5exHMlRquUCIAwwKaWnVwol+81qaCr+mhmZmZNk76dll+X1WIOhp9zmAAAAZgNIRVnpyefh2r6oMMlYw51rJZZKb1IUOgAAABIAAAABMEQCIEKNkSaXjYEk42anYXm5N6HK69NUYsKN/4/vWUa0DcVzAiAFIBcQ26GcTfPqvPlEzZllgXektwiz6xDaZCUMBSF1cgAAAGYDSEdUuiGEUgocxJphWcV+YeGETghWFbYAAAAIAAAAATBEAiAih1hyfTwIWU8siXDaU58lfpzaThyjl1RcJZ7mwNMeogIgT1M9C+ysvKtdgzeKTIL1vjH8VTVZK/IXT7iI/4fMuDQAAABoBEhJQlSbsdsURbgyE6VtkNMxiUs/JiGOTgAAABIAAAABMEUCIQDLP5+nlIpvTYD4i3V/QuSXoL1GJEq81OAjO1+7laUseQIgJjPWbzaIC9YWMmHqdnY9AEZm+XNP6EI6afCR+xx9MnkAAABnA0hLWYislNXRdRMDR/yV4QnXesCdv1q3AAAAEgAAAAEwRQIhAM7PqxusLdzISnommAP0z9Ya7cWPwtH6t0PzTRJJZWPsAiArLbuBP12Yyj/BWwRgO+60zI7PF1ANqdXADL7mIKXsOQAAAGYCSFYUGrsD8AHe3tmgIj1P8m2SkRe3LgAAABIAAAABMEUCIQDlahIfJGp3g8frZSwMCJCK3aAAJGxl7uImpRA00q2WLAIgIItOXgYEY0dbZPNGgRvyYCN+gbJHP34C3zPmCYopb4wAAABnBEhJTlRs4h5fU4PJVpHSQ4eahqYCXghwwAAAABIAAAABMEQCICQ4MkmxEC3GkLsMp+Y1vU8KQmaAk60qbUy9E+GDQLEqAiBGhd6HywrdWyDqEn0ERcPwxICOIRNbxCoeBtxG1Rj7WAAAAGcDSFZOwOuFKF2DIXzXyJFwK8vA/EAeLZ0AAAAIAAAAATBFAiEAjAOu2D2hqzZS8x5tSbP2FyRCJeZCNzKkzBuNkpnVBl8CIDZOrbBiivxiukf2SSSCECj/jCJJm8OjpeQIUNbKO3wgAAAAZwNIS0cU83tXQkLTZlWNth8zNSiaUDXFBgAAAAMAAAABMEUCIQCr0P7elVDGOF9uOyiNRUGlsHigTXqWzqeAWH8VEpAEqQIgZbpa5bcKpvtqn0LG+NfVXSgB1+fQZFNv2cQOBJ/XXmIAAABmA0hNUcvMDwNu1HiPY/wP7jKHPWp0h7kIAAAACAAAAAEwRAIgW52c+QaE/IJ1UhAERGtgvG1U14VjKVSInmb8X9t88/YCIGkzM2JM+8TPAQ/CXche3He8+9tRwaDdGd2PsBE1IcgNAAAAZgNITUOqC7EM7B+jcus6vBfJM/xrqGPdngAAABIAAAABMEQCIGCJA3AYnkJVX0n+x24N3HVpb14Oztf1iWWfN6esXDhLAiBlqvqenzTIzaksULjzouolWvcUn0jAIv85sirz8JW4LwAAAGgESE9ETLRde8TOvKuYrQm6vfjIGLIpK2csAAAAEgAAAAEwRQIhAK06LzN6iHxMmfhku9G4snTlPV4Psyqxsjnyqd8zvjvYAiBXOEm8b4r8+5FrGMjiEBJjyRC74t3bilq8nZHGSBpPOgAAAGcDSERMlcS+hTTWnCSMBiPEyaeioAHBczcAAAASAAAAATBFAiEA72sfP3VfDMNH9AJaIiG8bGPOIsPGUgLMAV19rXjAzSsCIGUTsugl5SdErMHWK7PxrHY1Jfom97R0AIxMZHBaUgVuAAAAZwNIT1RsbuXjHYKN4kEoK5YGyOmOpIUm4gAAABIAAAABMEUCIQD96RsD1+/yW+AmFyA4mZFe5O6uBQlIPqgmqguBRS+CggIgJTZIwKea/D3/n68M+Fg/7nXUjAKUgTIBAXIWJLf9wacAAABnBEhOU1Scn+O9YLIqlzWQi5WJAR548gJcEQAAABIAAAABMEQCIF977fKOGkrUZDIf28B/pY0BhB2UrOE0M6E9uqe+wpsPAiBxAD2Qsouv/6M808f2yqHdm51ArTbZeuQV5CxQ1VqzYQAAAGgFSE9SU0VbB1FxOyUn1/ACwMTio34SGWEKawAAABIAAAABMEQCIBO5tZ1I9OM+PB3SPZkbla1hYKX5coJzUjxb1pOSpKmaAiAZBUybSC02FtFwWaUiYnsn+N7HVSJs/jdK9nlUxQHxeQAAAGYDSFBCOMamgwTN77m+xIu/qrpcW0eBi7IAAAASAAAAATBEAiBQDdz/PrQ7BwfryMoCSkvu2BRy2OYjFZgu7kTyanpS5AIgP/APnwE/h5zxeTioxtC+Y5XUVi+MqhOsDDiyCi9caKMAAABnA0hTVFVMILfEhr7uQ5J3tFQKQ0Vm3EwCAAAAEgAAAAEwRQIhAK6xKtI8mfplMJZRA/foH5KAGDQHt4KAiSQy74bwZQXvAiAq/oJ2GsHvoKYqyd3aFs1dyKfX9rQgfew3GtnlfBmaPQAAAGcDSEJU3WxouzJGLgFwUBGk4q0aYHQPIX8AAAAPAAAAATBFAiEAgvAx/3OEpSME2uNObYUcX08XAFl8hTpXQVd+tmZhSjgCIFxk63YNrp3wX3PQYZipiaPhCIAjWiXBfRTVNKBNfPXVAAAAZQJIVG8lljfc10x2d4Hje8YTPNamiqFhAAAAEgAAAAEwRAIgZQ2VaSMK63wsKQOHD1fisxg5iBtmi0vB8k7/4rMPQX0CIBgi/AZXsSqS4ylvZp0mqRWBnhdFjH0aaOa9s7LzBSFCAAAAaAVFTlRSUFvH5fCriy4Q0tCj8hc5/OYkWa7zAAAAEgAAAAEwRAIgMRSeRYbQ1OkZ8pCtNxvWtq9CTEw49dTwT6XXpDWWDTUCIDDBgMKsB39mIXKkoruaFjzPjxSgd/lEySIO2t4Don5EAAAAaQVIWURST+u98wLJQMa/1JxrFl9Ff9syRkm8AAAAEgAAAAEwRQIhALPVURyjgkPY3EE1FDC629RHIg/BoKQFPBEE5cpAbYqnAiAqeqP9NYEbKfveSuAYk1QA+Z/sgUOO9UonmMB5MKjyMwAAAGcDSE9Umvg5aH9slFQqxezi4xfarjVUk6EAAAASAAAAATBFAiEArF37sjGTdmkZiT6btt1T9D3A8qyr+HQeWnQxeIn+H28CICmYwr1K8PNndPWBYLcEzv+CdOKOt6lZbxW1esW9N6a3AAAAZgNJSFTtqLAW76ixFhIIzwQc2Gly7uDzHgAAABIAAAABMEQCIB+Hs2JGInYtv4QzvAixfD/D8DFIXwxn2ok+vIQC10rUAiAx39nUGyJ8IsfR/yOo5QSW2CSMALroFq+k8WCWSrhWAgAAAGYDSUNFWoSWm7Zj+2T20BXc+fYirtx5Z1AAAAASAAAAATBEAiBnqCtb/tAFjEfqG8yuSIUx/bfUurAxjFiy/Nf+/DItqgIgZ5zkLNMDZAnHz6BeWUyUI/vcDHJAtC8ciKOybWXz0P4AAABrCFJPQ0syUEFZDj3jsOPWF/2NHYCIY5uod/6010IAAAASAAAAATBEAiBVXO+KJyxG+O7GmRuKuABmgUEaCnCqWISaw/ZuN8L7MQIgWyKE1R8OK6BRhD21hZKYWwQaYD5X9730Tdppxn8kbp8AAABpBVJPQ0sywWtUL/SQ4B/MDcWKYOHv3D41fKYAAAAAAAAAATBFAiEAvQq/VGzd4S5As3XGBWKQM5u2Dxyh1oxsazmPJaNaCksCIDsKFslrXLZzOg+CxprJBwl4cceXaMSLoLkouefS1Yx8AAAAZwNJQ0Q8INZ7axrgmF+ROrtzl7q8L7saHwAAABIAAAABMEUCIQCqx7UBBGM9Cw6NMPjdoQ++v0Hg82nx8L6op41iorFwcQIgImvb9q8iPKNn/Rn9oi0Hkz4BDssUg3tDMYbj+WL0A4UAAABmA0lDToiGZspp4PF43tbXW1cmzumah9aYAAAAEgAAAAEwRAIgEJyne9BmcfwW0EEG9olGn9UfBCqtRZbh8tgkT6VDe6MCIBFIAho0EFgFjQSrU0EiAU2rD78MH3Tm5HlsjjJQIyaXAAAAZgNJQ0+jPnKb9P3rhotTTh8gUjRj2cRr7gAAAAoAAAABMEQCIBQtZtuz+Axikn4gP0JOtHOT6Uz0gBJwtrgfENcJ4a7JAiAF0dLtAISbbnSooETHSps1hayWXPTmOQy5meXyudmpUAAAAGYDSUNYtaXyJpQ1LBWwAyOEStVFq7KxECgAAAASAAAAATBEAiAXMXVvceBRJC+Dtgj0WPrNtfKJAk9vawSFxwcgsXCCFwIgYO1KWbe6Sd9mWH5KqLZCCBd2nvzqBG6m/ea+tRscTLIAAABmA0JMWOWnwSly87v+cO0pUhyJSbivaglwAAAAEgAAAAEwRAIgEpYMOSyuB3NTOFodjAgRYUA0kznTLrmOLY+j0ihngMICIAnaaCowCkiKtuxXqcLzhilEJR2s5hBVGdvTqsu0btMQAAAAZwRJQ09TAUtQRmWQNA1BMHzFTc7pkMjViqgAAAAGAAAAATBEAiBMe/MuS9WZ7ogeboEIwk95sKUT9wDXVdDZaKXt/f3ZIAIgY+0mhi5uB0aGEQx2ffo6V0lR30WNVh/fS7bU0VMKhFEAAABnBElERUGBTK/UeC0ucoFw/aaCV5g/AzIcWAAAAAAAAAABMEQCIESww3iglwjCc2AT9/dGfnkHOsEE16dUt5ExHuGPl2gDAiBZz746rsyMcyUxRoAZ3kgtuhykqA3hxUVsS1DKwFDc+QAAAGcESURYTcwT/GJ+/9bjXS0nBuo8TXOWxhDqAAAACAAAAAEwRAIgFULAgfjJt+W0CS0udU6KfiYeePAt1oOSbQr0drKmkiACIBzoswOWYY0s3RGmhR8JElaoA2X5uqac6tYasUKKlcOwAAAAZwRpRVRIhZqcC0TLcGbZVqlYsLguVMnkS0sAAAAIAAAAATBEAiASoeiECqas50UJljjAj5Uvxn8vscT/VYaoAKYfMUiAUwIgfsSAVHUMlntf1U/dQpy2/sc35XT8D1ZSqsYAs5QKxVEAAABnA1JMQ2B/TFu2ciMOhnIIVTL36QFUSnN1AAAACQAAAAEwRQIhAO5Nc02sg0Tyr5hZ9svNPhu5xlZH5y94p6171SxOuKg+AiBjOK//E0l+plsF+rzVGnkfmBJcGZ5FR0Dssqhg171cNAAAAGUCSUeKiPBODJBQVNLzOya7OkbXCRoDmgAAABIAAAABMEQCIF79XaySiPPhsI+ZlmYTHjXG4X4t8ENkkuct7VzKVq8/AiBIgsVDWVdxoDaFYx4WHoRdsNIJNlHYq1kJpBggmJYRjwAAAGYDSUlDFmYvc98+eeVMbFk4tDE/ksUkwSAAAAASAAAAATBEAiAzGJkbpvpXEWPx1U5Z+O/D30opZIU6FhPYhCAWRBhAwwIgdMG1pjQdXJJMbol05SIvOYKgIT32AE48jRg6TsIEYbIAAABmA0lLQoiuloReFXVY71np/5DnZuIuSAOQAAAAAAAAAAEwRAIgT1Iy2mF/LuagrXwBIk2JQWo2OrXw+36ONja5+ykTadkCIGKHaXho7NpJoKNBqsIpAEiWbGjJvuopjIw4mseM+91yAAAAZgNJTVQi5fYtD6GZdHSfqhlOPT722JwI1wAAAAAAAAABMEQCIA5Pw1TqvUGsZZJoCuftMQtEIWVBxfAVrCMsqg+2txkuAiBdwXZRkGXgCgdnbsMEiOnNYfCQ2mz/+LT1TJT+oJUXogAAAGcDSU1D44McWpgrJ5oZhFbVd8+5BCTLY0AAAAAGAAAAATBFAiEA5eX2Nvex8lVwVHF7+ncWEGANRqOgPn7uXdWKzbg2FGcCIEQhvqSPkrclubg35F0hr8JQSxnY650ySr8jaR1OL1kGAAAAZgNJREhRNsmKgIEcP0a92otcRVXP2fgS8AAAAAYAAAABMEQCIBr/+rxkELm9cRIsjZo2nv+rjD+86a3DjJ14B/G8XvrOAiBbocLtnVtL17G9u0rZ756zAOyR/htxdshqPMH5xQagqwAAAGcDSU5E+OOG7ahXSE9aEuS12qmYTgbnNwUAAAASAAAAATBFAiEAijqAWGL/pDJCM++v3dER1oWoKK68FQjoiuLGu6lS+VUCIHcdUl2ZbKwQssreWVUvP/RvqVypvm1eAIdjhO6jHAgXAAAAZgNYTku8hnJ+dw3mixBgyR9rtpRcc+EDiAAAABIAAAABMEQCICkL/pxJgJXdluV8e4cuQq8PU4bnn7dTsMGe51LQQTPbAiBXDj17qG1fl/2bOMfu9jhoIh6+mIuLs99Wz4iYTdtUDwAAAGYDRElU8UkiABovuFQaQzkFQ3rpVEGcJDkAAAAIAAAAATBEAiAL9Q67UnFJL4+Fzf4b6kZtGwkke6rZWyvhpIuuoTsGDAIgcntk/nKYyLqD6jrmhii5jPRdMDZx/b6l++g4nGBVX8IAAABmA0lOU1suSnAN+8VgBh6Vft7I9u7rdKMgAAAACgAAAAEwRAIgRq3cZyqv/SymElXfya/lu5AjE1nEDHW3J8ge3SkzD1YCIEfjJAJC9VEE7P/LQcosKCdOqJmMRh4XG2u+uVOUmgfAAAAAagZJTlNUQVLHL+jj3VvvD58x8lk5nzAScu8qLQAAABIAAAABMEUCIQDXjXvpYuZMmCWHDiLAfvamr9UFf2y8UPhbaGiEIForGwIgNl9Dn6aTZaOVjFkWh9dt3xhXK8794a/H3o0rUP6JvH4AAABnA0lQTGTN+BnT51rI7CF7NJbXzhZ75C6AAAAAEgAAAAEwRQIhAL/n2xdZXOVxQNXwfdlllpWyAY722dzck1lAh9cvbUcoAiB9X9v2nTJc5A+v5epRwwOD1vDPkpVD0obDUMZrWSAUaAAAAGcDSVNS1KKTrou54L4S6Z6xnUgjnoyDoTYAAAASAAAAATBFAiEAvP3TAbHxzwGp3DoY2Ly9qLK6/hf9xnliiN9ivtMozDICIA7v5hW4h692yobcxZZ5qv6xPoaUeDMbvPOdORdZui2iAAAAaARJTlJNSOVBO3Ot0kNOR1BOKiLRSUDb/ngAAAADAAAAATBFAiEAs2Imjj46XaN+SeWUZMZnc3ME/Pab8lVaidesTAmAAG0CIEB8r1e2Gb003jPBnF4aVLQuDEgFaC/Pdyqzhw8LMGrNAAAAZwNJTlQLdlRPbEE6VV8wm/diYNHgI3fAKgAAAAYAAAABMEUCIQDxF/IkzIa8lVW3FeDraq+rHt+/5Z5gH5/ZzENpGUB9jAIgJeDr9tDN+Wp4B094wtYE1ZeJajvylQVhxMBrQBKa4KIAAABnBElOWFSoAGxMpW8k1oNnJ9EGNJMg23/vggAAAAgAAAABMEQCIGY7KU6ZTiOiGFUs/S7ZGwGXbKledOahd2+5un9wlGAUAiAcLODy7CwAyQ3oS6VOaESVpl2TMWJs7kJK5SZARNr9dgAAAGcDSU5W7Og2F9sgitJVrU9F2vgeJRN1NbsAAAAIAAAAATBFAiEA6oa81kcrUJusSfuoz6mhQf0KB5s/o4047XjTFAe0Mt8CIHGWqO++5+tD+jxJUhj29Rac8dBieE8LNhUBA7okkySzAAAAZwNJRlR2VJFaG4LW0tCvw3xSr1VuqJg8fgAAABIAAAABMEUCIQC1YEzXXCwHOU8+29BjMfYidYEmS+3amRrRLUwi9U9usAIgD4ojfIKiCQ6JdUSIaz0UntEgF5raTTcEBqU34QIcKvIAAABmA0lIRq8SUPpo197NNP113odCvAOym9WOAAAAEgAAAAEwRAIgCNTv+z1N4tUcmH736qG5KNEMjc6VwgJddSUE60DswYwCIFFdLbEAFQ9NSyV97x0ok4nepZBN6jIEo+wBKiyN6Lf3AAAAaQVJTlZPWESFVh23ZhT/cn+OCj6pVpC4sWAiAAAAEgAAAAEwRQIhAPfwW0YPqqcHFPUB+4c/Xa4Y5zjihI+JZNxcxviMVr4fAiBB3/mYVz0WzHmc905h2EhKIs1xs6N1rOnJBspwKYOyqwAAAGYDTklBWcJLSQNnbLuzqPEHfvACnmQZzvIAAAASAAAAATBEAiBwAFJYQALv9YoJfIsTYacpuGJeSY4WT4AL7g7i9pZWDAIgTr8uHv18OM9CJ1jqWkVKv4VxhqmhbZCZsaem3S14zb8AAABnBElPU1T6GoVs+jQJz6FF+k4g6ycN8+shqwAAABIAAAABMEQCIFol+zNWpAw9CTp62TNqV4pYclOmcRQXkoWh8rYNqoPEAiAand7Ho6XW0iNY/ecRzF6XA7ic8yaAzZgX/A9X5tRBjAAAAGYDSW9Uw0sh9vjlHMllwjk7PM+juCvrJAMAAAAGAAAAATBEAiAOJ/lfxmWk6gH1zc8l16zTKAfv8HCS+rgtXS2nUbfDQwIgAwOJ6AnHrhkIL4L5p+kyu9xLwCEU15AnQ9XX+XtYhVwAAABmA0lUQ15rbZq62Qk/3IYeoWAOuhs1XNlAAAAAEgAAAAEwRAIgabvqNfygpXH2w5nzCdigQ8k+JPsmW56E1uf6BJsLYmYCIHo0qq2fLKzxA/ODWE5iMZYwBiGNgC8ATKyXUvdP2OvKAAAAaARJT1RYb7PgohdAfv/3ygYtRsJuXWChTWkAAAASAAAAATBFAiEAvOYWXsZawN5si1/c3u+4jYrxosZ52DrcEzh+r8D1fVUCIHDKMnhQmF6gsRI2bET42wZL4O2Wd8NuMDtyogTcVsx+AAAAaARERUFMyGo6yaSZeSZjHmWOYyNeyLUmyX8AAAASAAAAATBFAiEAoE32Q8/IPGwIWY/rWwr7v52oFlDDcTptipj3ONypOgYCIBs9Rp+9PpNlJZifmIHVmVkDPjt6CeIQH3GFxNlsqZSNAAAAaARJUFNYAB8KpdoVWF5bIwXbqyusQl6nEAcAAAASAAAAATBFAiEA+pBMoSL64Lb9vJCxy30pFAKjeN/kGfEKroa9rumCV+ICIAazpbZ2obR2ZVaZt6DvQOmuqXKp9w/zNI9J8yg6KEy1AAAAaQVJU1QzNAz3E7Ecm5huxA1lvU9/vVD2/y1kAAAAEgAAAAEwRQIhALYpLoiiENA6FgmoPRmLnyZRlbUc6bdMytXsY3rBa03gAiAb2HOVMdEDbP/n2gXaluzM5dwt9q5cGU2YGDEhxoAiVAAAAGYDSVRUCu8G3MzFMeWB8EQAWeb/zCBgOe4AAAAIAAAAATBEAiBDc38k/lNwHac6qWJUyn8BLSv3JS/OWTvF8XlTc2wZlAIgVN0PhycC+jlF1EDOWOPvXhbCDQNpHmTrc5Fh6b5sM+AAAABnA0lORyTd/22LikLYNa87RA3pHzOGVUqkAAAAEgAAAAEwRQIhAP6Rcvb2Lm4r6XDvR637eiZDaCTFzjSjdq+E9UHz9+1PAiA1BE4okoYjrwXkgBfK+dAJA65ojqSXQCoCKMv9yvo9dgAAAGcDSVZZpOpoeip/Kc8txms5xo5EEcDQDEkAAAASAAAAATBFAiEA6OavRbX5yf7XtFUgF4QBBaCzwIxQuDkXaDS+OxWro5YCIADlbrj/BYtRN794QltAfxU+Cigso+2c28EAnuf6YSARAAAAZwNJWFT8pHli1Frf39GrLZcjFdtM58zwlAAAAAgAAAABMEUCIQDyq/DI+rdO0EPu/7moB3MU/l3QYlxHHIhGE3sJbhL9GAIgAcou+X4cPbT9sTPiicHHXpdy5j7mwk/R6MFja9YwhgQAAABnA0o4VA0mLl3EoGoPHJDOecemDAnfyITkAAAACAAAAAEwRQIhAPpNxtDNKznDKQ+NT/Isx69bS9CYpuqTM49IqeDyGn8zAiBEo/Emedxi71BJKFRBroh1ouDQIhEHocf2WcGG7vjU5gAAAGYDSkJYiE45AsTVz6ht5KznqWqpHrwlwP8AAAASAAAAATBEAiA/5kmVwlBrtQ2/co9cKT1ryF6Nhg9qZj4cas1Z82y3mAIgDmHZ0VkaQkk51QNItqpIp8Ey6gqG+9Oq9nUSD4SWzb4AAABmAkpD4tgtx9oOb4guloRkUfT6vMj5BSgAAAASAAAAATBFAiEAkR+BBnS8Qkjhx58xvOT1u104T7bv/1VDCprxwu9KGxgCIArXasUquzm7p/+9GE7yGJHTzfxgdoZLWHvc8bhosmttAAAAZgNKRVSHJ8ESxxLEoDNxrIenTdarEEr3aAAAABIAAAABMEQCICwIbSB0EGhOtO4vzjakdAruKwB2geTKgL6oHOEQBkLkAiAjMsMk/6iHQoVegAFqE6TyFIM8Rm0ayQ4wbJnuql42owAAAGwISmV0Q29pbnN3NFAzXtTsPbRa90808shTSGRdOQAAABIAAAABMEUCIQDSe8Oykpyl9DnNVhkZQ38OxtS/VwkUvhV5FykctKprowIgLLiOOG31bewuJQ1kRjIs2fiklln5tpkBZ+v1gZaRqpgAAABnA0pOVKX9GnkcTfyqzJY9T3PGrlgkFJ6nAAAAEgAAAAEwRQIhANhlx67NCcUk3AyELtwWDq1mtUdYa/aUMU7xFzDE22vUAiAVibHBi2LnJr+C4hvN3rnO4Y1mB/V4wb3nDnpv+NxMkQAAAGcDSk9CFygNoFNZbgl2BIOcYaLvXvt9ST8AAAAIAAAAATBFAiEA/D3/+0hZoEOeF8YzZGLwHBQsemY3XiVTTIohmMBYjXsCIFgM9eJL9oX6QutHA/7kawSpCa++GCc3AiN7SEk+DSq5AAAAZgNKT1nd4SoSpvZxVuDaZyvgXDdOGwo+VwAAAAYAAAABMEQCIDpmXfSNDSEK3MXYxVRGjC0D/2kCJJcOLk8bn36mfAU4AiAFI7litOdjwuHXDTM2JZtYXnVD9tUFxAwk6RT9RUvOjAAAAGcDSk9U20VcccG8LeToDKRRGEBB7zIFQAEAAAASAAAAATBFAiEA7AnW5GfzfNcelvbn1knL04M/iswIh3MwQVF5uGalUkoCIEfU3hllYRZZBP+gXXhyF0HIe5DAxd+P2JBRrRLGsdPSAAAAZwNLWk6VQf2Lm1+pc4F4N4POvy9fp5PCYgAAAAgAAAABMEUCIQCXA1FHWvZzytxiTS/qljMlAvslIOYbwX4wTCuuLoUmhQIgYIuoRiMgXzYsrZhDPfeLSL74/PcrjRGirywf2/t04EYAAABnA0tBTfjZ/UnQUZp7k/POgMLAcPEpTq0mAAAAEgAAAAEwRQIhAPFFpNAR6IYQxXCKA8q6mtda1vUbcJUZgF/wCiVX/sROAiAVhxn9/mCCQbhnT9LWgXmVzf+QxhDJ2HfzdRl7XmW9RQAAAGcDS0FOFBBDSwNG9b5njQ+1VOXHq2IPj0oAAAASAAAAATBFAiEA2Sc/rZJStaZ5m9iREqHHRp9I6nqOaSd+3Ru51mMwsuECIGqmMyoBhpFujRW+IhlUCQShFnzA264WQRtdsmdztgupAAAAZwRLTkRDjlYQq1450mgoFnZA6imCP+HdWEMAAAAIAAAAATBEAiB5RMjNBJzawTBlA0Z55/jF0nIK4x9ctjidZ69MH7GQYgIgD8501XnY+8fI44X1HtjjIxXvHqpUukta5wnmKyMGiwIAAABnBEtJQ0snaV4JFJrcc4qXjppnj5nkw56euQAAAAgAAAABMEQCIACwa/Vj9V2gaxQraBboJEkqSGJnPymEKqi0byOn3L5XAiBJMJRk5xI/ed9bzq0GaisK+SmWXT2dxoOjJO2jL5cLBwAAAGYDS0lOgY/GwuxZhrxuLL8Ak52QVWqxLOUAAAASAAAAATBEAiBpynS4rD1MvIk3ovh5lq016ARMJo9BFca0/FWCodXBNQIgMpWfOrEJkUzjuFiqxKzZSxuQrEJ6CSLq8LxKk5/0WBQAAABoBEtJTkRGGFGd5MME80RP+n+BLd3ClxzGiAAAAAgAAAABMEUCIQDHRpz/QcFatr+fJpg0sCJTQ/gIAoCt0m7Y9ZiIOrvTBwIgU8PNR1Xf0JZHVZYu8YBFQT4xZXkikskuuMEl3luxC8YAAABlAktDDW3Z9o0k7B1f4hdPPsjatStSuvUAAAASAAAAATBEAiA+ltHfk7aGRyhyz2N+DBlNvTYMD9yvRfm0ePxHbqNhzwIgJpwVUNbAGWifupJuvbKLUmbeVeg2W238JEjtg221bAcAAABnA0ZLWACehkkjtJJjx/ENGbf4q3qaWq0zAAAAEgAAAAEwRQIhAKhKTeBdk0UxLSRI8Icvs7ljUzZJ5IzfNmZx8IR5ftBNAiB/NqVvBQR2XbOB4CPwNBVBV/TUYCgSqW35gbruDhjB1AAAAGYDS05U/1wl0vQLR8Sjf5id6TPiZWLvCsAAAAAQAAAAATBEAiAoovl2TJAz74Psq12YaBIymrrFGL8n9fSZ302fcX3RWgIgbWsl3A3xz888vBBjP+FnrD3oBJW4r7DxLaKUqYkkfXUAAABoBUtNVEJBK91sm/G/OWo3UBquU3UbmUa1A9oAAAASAAAAATBEAiAS4ZHG8HSxyAzMJokDml82reBVs64jgbNUGmDwdtP+9AIgBqOtSJ6VPExxT3fYIjorUqS+LQ9KBr07PbFLiZh3XYkAAABnA0tSUyKaVptnPZCM7okgZYrnvK1o59AdAAAAEgAAAAEwRQIhANJdC+i99fYz3YO7a+VQFDlDDa+G6DW7wGsYbMgxZT09AiAmXMM6aqm8nzMxO8zE/x1UNmg336ZsosPMdQMK1+9b+gAAAGYDS1BStcM/llyImdJVw0zdKj76iry7PeoAAAASAAAAATBEAiAoY1ww7ts06lc+1+TFABHtT00qIZKS7zN1Hp50fGBYZQIgNXvVdjZuxeP3d//FWj66auueKiLO1Q1gG2/Go7mDDiAAAABoBEtSRViViPwkqXlvvYcJUaLNVMbx8ksufAAAAAgAAAABMEUCIQDKhBnGr9EQ35Ql8SDo5JuFUcVS54kZ+y/vPR2fsJYWbAIgHH4tgwZwmxzDOEIjlU+ZIG07aTNNKP21nITqn9eS9tMAAABmA0tSTEZOvnfCk+RztIz+lt3PiPz3v9rAAAAAEgAAAAEwRAIgMW0YDkqYdMR9F3jbkcAxvXNQ67kNUUQKKdObaazz+C8CIGsEWrEu44bJq+BP/4LNHaQ/hpNyyzXnjLnd8rQ5HXlOAAAAZgNLVUXfEzj7r+evF4kVFie4hngbpVbvmgAAABIAAAABMEQCIH0o5OAZ3/dVWDVSNX1CW8dh/JnDgGJ/2pIiV20V/TnOAiAhnj54d75xma97hbXL4B19pvLfnvILsVBmsAOFnfuH8AAAAGYDS05D3ZdNXC4pKN6l9xuYJbi2Rmhr0gAAAAASAAAAATBEAiAZ3C2cv/G/5WyafhVjLtEtL7JJsHcXAlMPM1X/uJGfIgIgKtcDqXDgyO8eqwVgNuhdK6wU2o9JDiez34m4xCiJ2VkAAABoBExBTEH9EHtHOrkOj72JhyFEo9ySxA+oyQAAABIAAAABMEUCIQDtxGu67LEzqPigVDct7tQ3sslbyW9RV8A07OvVAr6R/gIga5g1wv62drDOy93LF5fJo9zIhjepNOttty8XPjFCUuAAAABnA1RBVcJ6LwX6V3qDug/bTDhEPAcYNWUBAAAAEgAAAAEwRQIhAMYt9eYqwqkK4GryUb+MeHOL0zNfRK4Gp5izLTkUX44aAiAg7cx7EMJcAt9s7rSMIueFDRYiLOizZK6mRuTV7j8YrgAAAGcDTE5DY+Y0MwogFQ27YbFWSLxzhV1szwcAAAASAAAAATBFAiEAwogQr8tzCjpOMTv4jarFnZbhGLkNMY8xQIV+xiXUSkECIGN6v+teWUBNMTHOlBtMhU2Cm2LZDfMrbJE8+FnYmVTKAAAAZwRMQVRYL4XlAqmIr3b37m2Dt9uNbAqCO/kAAAAIAAAAATBEAiAZE76ZsfkaQeJ3pqjkYkjhSyYdjtHxfXajfnzaY7emzwIgHcs2ASHnBM8M9HFMIJUATBqdXBP9fZKnag3+NX4MCOQAAABlAkxB5QNl9dZ5y5ih3WLW9uWOWTIbzd8AAAASAAAAATBEAiAwEmiqX1bCleML/uxp0/0uQniXnyUH9FEqPsn42aOxPwIgLJotnvAgar0X0XR9yG7igmExeFzzqfgpVvcm6C1FJ+0AAABnA0xDWAN6VKqwYmKMm7rh/bFYPBlVhf5BAAAAEgAAAAEwRQIhAP4Er5lb+Sg80+VOpnYyPS4oHvPHH+g0IWBzlEu8Zv0JAiBDB49xaj7T/zudgmF4V4sKUgFiLjcqjX7SCfAb+pTiUwAAAGYDTERDUQJ5HKAvw1lTmEAL/g4z17bIImcAAAASAAAAATBEAiAU57l4XGzb8PVKKLd5kSpIPAM+pGzgUfxdVNT3B1GhzQIgWewtr2etHEskhpN4CTBnBQkZSn4o+ODiIwxuTwFvNOEAAABoBExFRFVbJsXQdy5busizGCrpoT+bstA3ZQAAAAgAAAABMEUCIQDMK9ErO5WZqQ27BYZxT2mHxa518rRZxb5p7PK7ctR2rgIgLmNemvEfcFxkrW4q10YXL2cGXeUOVNQNH9kJ6OqmH8oAAABnA0xHRFkGG28mu0qc5YKKGdNc/VpLgPBWAAAACAAAAAEwRQIhAIWSsYNH27DDxUc7zWk2/ZmceENL+HSrTvhBilvOOnsMAiAVoZUB17Nhtp1Wuqk9V29q9/2/tHJ97BYcOCNo2HdMpAAAAGgETEVNT2DCRAfQF4LCF10y/nyJIe1zI3HRAAAAEgAAAAEwRQIhALT8QGSR0yvPlQX50+XP2O1IVPR7ubCvulU3Zl3Qxcj/AiBgblEX44+/CefCZGico51o9Fd1APYQB1nFR8CoBgCvEQAAAGcDTENUBccGXWRAlqTkw/4kr4bjbeAhB0sAAAASAAAAATBFAiEA8M1+e9KBiwndM5YUlYxjEuFWjPYs4KecUdhFlw7t5QICIA6HQLlG2nHrEiOPouQVZE811wL23CMqbnBHlv7ofAeSAAAAZgNMTkQJR7Dm2CE3iAXJWYKROFznx5GmsgAAABIAAAABMEQCIAnl3kHBjLQGdUx/HiMhc3OV5ZdwZETO3dJ1ATQkOPa9AiA2r14ILaO1VX/dDAYvmqGE3hxBZEedWSg4Of8PpOWXugAAAGcDTEVPKvXSrXZ0EZHRXf579qyS1L2RLKMAAAASAAAAATBFAiEA0GXKWxADpu77arg9moMomSD7tzNr+YORymd+AQ+PF9wCIC6KDrawqhwenOnHGcfea28cKHnKee8FeE0MJSSNd3Z6AAAAZwNMRU/5e11l2msEaLkNUx3a4qaYQ+Z5fQAAABIAAAABMEUCIQDADMNXES+XGxiFpoO+zT8+llHQgQQbK1sys3v/Smo2AwIgOYiuTKqMUxB2snsMdIpjTC39OIqTKq1eCee1FB3a0gwAAABmA0xFVg9MqSZg762XqacMsP6WnHVUOXcsAAAACQAAAAEwRAIgEe0ny8RQNv6jVhF/logU59HpBpnNoTn+/Cjg4NR6+TECIEswr10k5qf5XW37z4YmoI1zrdhbfseq8UqgNt3ZN9T5AAAAZQJMR8Ug86wwOhB9j0sIsya26mak+WHNAAAAEgAAAAEwRAIgZehGLcAMjelD71M9BhB3aIapM7kKxGqnK9wjyuuMODsCIH8S3y+zernorU5vMJOg4sgaY2yxebdNcCC6drj33M2+AAAAZwNMR08SOrGV3TixtAUQ1Gemo1myAa8FbwAAAAgAAAABMEUCIQCTfnyNT1smwzJDEgwctoRPVZ9iihKC+8vycc4/0fmGlwIgapBGGuVQBNkUYSO+6D3enSeTIvu2RIIcvTkx/VuyG7gAAABpBUxJQkVS5t+/H6ypUDa4524fsokz0CW3bMAAAAASAAAAATBFAiEAvBoQ4SqLX6C61GcpfQ3/22lmedHKznd4+RCoiMnLr2ACICQJIVGdLb86DVR1Zq/O5QxdEsrHyl5vOKbz7Dt8d3FNAAAAZwNMQkH+XxQb+U/oS8KN7Qq5ZsFrF0kGVwAAABIAAAABMEUCIQDftjv/cDEkNIEdKr6g3ZCi0RIiPt4JfGWqkJLUIT5VrQIgGfsK0pIRtmEGPyHjanLjQ6fheHlD3XSv9lXKViiT5nQAAABnA0xJRuuZUQIWmLQuQ5n5y7YmeqNfgtWdAAAAEgAAAAEwRQIhANdbUP0RJyZRI+ecJpBPsU9WgjX1LjhFebt0t8zMGiiWAiBKlyvY9bGB2amZNX9LWZj0fKWm5M0uUKTSurJeiGnoegAAAGgETElGRf8Y28SHtMLjIi0RWVK6v9qLpS9fAAAAEgAAAAEwRQIhALPQfGmx8Zj5lR46fl0mNAcdtZjkgEqHJ7xwELaIPI+2AiB7qpPfRVv+qXiKz8FULwszX5whSnlNzktd5oZZaA6efwAAAGcDTEZSx5jNHEnbDilzEuTGgnUmaM4dsq0AAAAFAAAAATBFAiEA1SbLxYGzmzHUcx3uKC+MkLp4vbZmOebfwJ2YcF52oSgCIGNr1IPieItg5RfQYcfQPx/ew/tdF1B7WKDGs6ANCwWJAAAAaARMSUtFAvYf0mbabosQLUEh9c57mSZAz5gAAAASAAAAATBFAiEAs3Z1Vp/4DUMVXZqokuwV/YwgO5M1NbzyzsJXFyq/pu0CIB3cL9OOot7zuKNBHX4BQ6NCZn7/4NU+KzSdoWpGIx97AAAAZwRMSU5LUUkQdxr5ymVq+EDf+D6CZOz5hsoAAAASAAAAATBEAiBlG97Yg7ixhaJghFAgaux5+aiEVAZzX1eyp3xVn9tRkgIgIWLTcuIJwEsDdDNns5BGKL2PZLGA8Tz7Hn3xYAYG3XIAAABoBExJTkvi5tS+CGxpOLU7IhRIVe72dCgWOQAAABIAAAABMEUCIQDTORPUDf0wPZ6jmrQuaIoG4383E8JFa8td3YRSzk+SFgIgFU/q6QANxjVHScgPKQ8KT78E2GQ1xvcxgAUsdIk/Z0kAAABnA0xOQ2vrQY/G4ZWCBKyLrdzxCbjpaUlmAAAAEgAAAAEwRQIhAMypSXa93nqGTY+xZSmt73TbqsLZBFhPNTktVJbuFqTpAiB2/eNc36pyc1n2aRo3xe97LROGlo/5TbPUtGe7aAwJkQAAAGcDTEtZSb0tp1sfevHk39axEl/s3lnb7FgAAAASAAAAATBFAiEA6ZeM76FyOoHDInA5YF3bt3BL4RFOhIGnVQlD8i4vlB0CIALI5QVsyfiXs+qyR/CxRYUFecl9zF3AaT2DUtSSWIyGAAAAZgNMQ1RKN6ke7EyX+QkM5m0h07Oq3xrlrQAAABIAAAABMEQCICrdR80OgfwiOtS2pujkcFl+uiQM1BxtG9udR5Q481l+AiAGquHV4kIfWvj4cyU3pzBEDYJEdFG0oh/Hl/EVfnCFSAAAAGgETElWRSSnfB8XxUcQXhSBPlF74GsAQKp2AAAAEgAAAAEwRQIhALE5z4ovSmz/38EH8l4zsWC91HiuJ5ze5C6BoFrGiMPaAiAfmrMjBpylbtVma/T9GRzEB8AHdUeTeVuN2HG8VyEYqwAAAGYDTFBUWLaoozAjadrsODM0ZyQE7nM6sjkAAAASAAAAATBEAiBOT8w2gDXMc6febVy43rYgSgBWcdsXFoRmdnlsubBosAIgacVPC+KtGALjva8U85k0GoXV/lwXub+iMFp91iE1J/IAAABnA0xNTCW2Ml9bscHgPPvD5T9HDh8coCLjAAAAEgAAAAEwRQIhAKJe76KBUyTXowuICc3n989l07UWnpVt18ocOma2jC+GAiAsfqSaDNgSVG0LGdo8i+tiEVdoRvCwwGtz84/fBgvKgAAAAGYDTENTqhmWG2uFjZ8YoRXyWqHZirwf26gAAAASAAAAATBEAiBq06+SU3GnzYbstZxJKNjfLmAR92F21DRrm+Vw3qcmmAIgERztBlkRkWkAG28TNPw/oYZDEdHZx7WVprPd2QbFUSsAAABoBExPQ0mcI9Z66nuV2AlC44NrzffnCKdHwgAAABIAAAABMEUCIQDS1pzE1OkrDYSpU0ZNYBeiW9XJn1lYhl8ZzgWzFpPKTAIgFbUnSd8GpBNd6+FgI7PoEwhDuBWX69VqgGng+KJMx2oAAABmA0xPQ14zRkRAEBNTIiaKRjDS7V+NCURsAAAAEgAAAAEwRAIgHor4KQ+9DMoBE+HLNhkn7FkKNeGewoHYEIUq3aKhD+cCIHhxDgco4/vYGVBkaVrgLDkHa4sMo8FneOI3oT1Dj51QAAAAaAVMT0NVU8ZFAN17DxeUgH5ngC+Ku/X4/7BUAAAAEgAAAAEwRAIgLI2Hc0IHY33t2NOusVVDsilW+nlFO8itfp/61vWW6t4CIDOa6Q2ZsRDhbAQXMkKmQ7tWi2GkNqz3pbtCxJlTQLgeAAAAZgNMR1IuuG6PxSDg9rtdmvCPkk/nBViriQAAAAgAAAABMEQCIBfKucXSb+EENu/vrhg40rylsOWUUkirTxbRdWWByfj+AiBpcxZEGHMvjeJMqHeUYKajVOiEIeXapG98YI4drUvJbwAAAGYDTERYnvoOI4fky6Aqbk5llLj03SCaC5MAAAAAAAAAATBEAiADjbxXHyUQnZqMh7zXnPIe/MBkzSXFoeaZnH1E+88+vQIgW8Z+oQg3papscfw6gVcJzYOZc/ufwDMrwkeUDwjKnwMAAABnBExPT0slPH3QdPS6yzBTh/kiIlpPc3wIvQAAABIAAAABMEQCIHjqGeViSIqTboAbOeLEOxCbX3UfT4fFEJHvXU5/CUkYAiBezvYLR1AoZg58eMlaLfDoNLzJvIVA1tmSQT+vk0I0xgAAAGYDTE9LIa4juIKjQKIighYghryY0+K3MBgAAAASAAAAATBEAiBRzLgCK6fJg4CyiKss0VpmIKTbLLzx/X4evAGSs5lfiAIgar5a6EztEM2U+3C8dF83Ggo/fw0HlhYiEBdVpczr3AIAAABoBExPT02k6MPsRWEH6mfTB1v54986dYI9sAAAABIAAAABMEUCIQCyYQ8OZFzDIYxM5pmyf99bwfL5RJnzoabWrgQCeDo5mQIgC0jMrzdJ43pMla/Hp3oe6BM1BPNoZlKgzR5vRVZkJKwAAABnA0xSQ+9o58aU9AyCAoIe31Jd43gkWGOfAAAAEgAAAAEwRQIhAPM4XcyAeZxaySqfVY71b4BzPa8qwFTVVivpGEJl9tMkAiAW71dJNGlVRXmIdLmW5d0Uc3JmKqmUK4BXeQrXEOhEswAAAGgETFVDS/sS48ypg7n1nZCRL9F/jXRaiylTAAAAAAAAAAEwRQIhALd4/tjq5Sbo2HGB29pmB/Vb+VrmOjlmTDksiBl0eBDIAiAXLmG7w21p8VLz5fHz3JAAup4q3Wsy9s+NuPPb9YUZKQAAAGYDTFVDXb4pb5eyPEpqphg9c+V00CulxxkAAAASAAAAATBEAiA9r6qcdbMYQ0oIThYVHWNgdh8+GntYY3WAxU/SHA2WAQIgXca28y4C8cUNXjsnB7W+2NQ380EpgoMeb++VLzdoR0cAAABnA0xVTaibWTSGNEf25PxTsxWpPoc72mmjAAAAEgAAAAEwRQIhAMk/obY3A5c0dNT1uQIkL+I2TiafXKRkoi7qmutvkPkvAiAbtN0H6FUajnqer7S2SSrpMbpq1/O2KoyV39EE68nRbAAAAGcDTFVO+gWnP/54748ac5Rz5GLFS65lZ9kAAAASAAAAATBFAiEApgdzNnlECeXHr7Xh1FViR3KVENY0lObzuVYXc4+Q5IQCIA02Rwn7Mp4z8iuyVttR7jc9AOMoCJ9bDp4XNfxpvgdLAAAAZgNMWU1XrWes+b8BXkgg+9ZuoaIb7YhS7AAAABIAAAABMEQCIFalFQdeFTF8sCo1xHyCDfercrRMull1HypK7Hd9YBT8AiBw2y7td/BHJEERaoMfWD9VAACBZ2kgFW/BMlN+TlNFhQAAAGcDTFlNxpD3x/z/pqgrefq3UIxGb+/fyMUAAAASAAAAATBFAiEAsXNqsRzZnNLmDFx1Ofngben5LYB2K6OFlZvmBgPDNdQCIAbswFup2ff2Y6SOXyrHGBvKKBE9P20m+GP49d7oxkczAAAAaAVNLUVUSD9LcmZo2kb14OdapdR4rOyfOCEPAAAAEgAAAAEwRAIgLrEMeGx6nE5ePxa3uVR3FNXdSY1L7xKur2rfTvDcgRsCIAP4VGv9nau6FJ7sTqlFp3RnYMT8cebMYGsK1qMR3ed9AAAAZwNNQUNMM0UQX8xs3CnbkQWP+q4zzKW82wAAABIAAAABMEUCIQDqt8Cs5gHJSjIaG0DZtN1UcMFsiqGJJ/LdUNbVpd4WpQIgC37tMuTD4r+9gJY373sLlX2lSOJHBF1oY4IxP2uUiJ8AAABmA01YQ1yjgbv7WPAJLfFJvT0kOwi5qDhuAAAAEgAAAAEwRAIgVcp9YvHJDf+HtY12pcqsxXaOvpeKr4r9JqDDL0Y5LNQCIFEZl9cZpeCdJb6eDvROTiQ8bO93TIGAGkZhBLKbPgjOAAAAZwNNQURbCaA3HB2kSo4k02v13rEUGoTYdQAAABIAAAABMEUCIQD1MRxhzzg+GqF4Mwvg4OvfAcCVEtIQA0C1r7AsaLrVxQIgcyoAGJ1UbQdZS1q3EJO/CxE1hG6Ji2hytQTp7mRT+ZMAAABmA01GVN8scjgZitiziWZldPLYvEEaS3QoAAAAEgAAAAEwRAIgPmR6d3Tt9HPhmPlxAD2e/Yt4KbNJMZmNXFliEQaTjW8CICgHqjAj7uEvubIJWrCYOnEWxhcHE9ToZ3L85PU2WKz/AAAAaARNRlRVBdQSzhjyQEC7P6Rc8saeUGWG2OgAAAASAAAAATBFAiEAuumBQAH3CM5bdRv/xhBW7t0He046+LfMUqY67easDm4CIBZels06vHizVuW1IUcTHUHj3318vo17ZjG8pIdwMCTiAAAAZgNNSVTiPNFgdh9j/Doc94qgNLbN+X0+DAAAABIAAAABMEQCIGn8fCABk77xmiEAeib6LVGV9RBszeGDKmHiG1qflRwYAiADijQ+Ryqgs+P35+BWhA/E5gt/JpYTu4c7nmisKbvjXAAAAGYDTUtSn49yqpMEyLWT1VXxLvZYnMOleaIAAAASAAAAATBEAiALykZxVgNVNKT6iur/+WezhF/DzBH27qRG0oMQPY0j9gIgbrLmqQ3WewvEWoZg71AcVglSxnHDL3OUrCOnQZGsTzEAAABqB09MRF9NS1LGbqgCcXv7mDNAAmTdEsK86qNKbQAAABIAAAABMEQCIDFk8I00jrqrk0lDYyMCIz7U2eQqe6VevBvKrEJBnt9TAiAQ4hB/jwvPDQmtPaK45YKg9Cj588Rft/VZ/VH+5qCxtQAAAGcDTUFO4lvOxdOAHOOnlAeb+UrfG4zNgC0AAAASAAAAATBFAiEAtJmOJFONvIP7kewCGylEQNvLbAkDR0/MDBIzgR3wQ4ACIH7g8wHBfhqsyfsEMropWRgAobglcs5avFqsusn/vByqAAAAZwNNUkyCElr+AYGd/xU10NYnbVcEUpG2wAAAABIAAAABMEUCIQCoXmvsq/9HjEJxCjnvvrEv3YskPmBSFdb9xagO+ybkiQIgfHHGzbHI2xyjIFeAOED1lHlqq7abLknXJTNUhcc1zGkAAABnA01SS/RTtbnU4LXGL/sla7I3jMK8joqJAAAACAAAAAEwRQIhAM34VJvJnislWhHW2q4s0KEgDngN7Qz8egoJBaihcM9+AiAHI9TDRhcqxxwIUKdH5ucjKwl5itF0q1dwQit28jcOHwAAAGgETUFSVP3MB6tgZg3lM7WtJuFFe1ZanVm9AAAAEgAAAAEwRQIhAIZ75vN7nu5d6kjxkEPw2tNBDfSYUzsQ6pS1zb32EG1nAiA54TN8Ld3VRkKzvckD0Y2EfODY0q5tk/i6tYYez8/U2wAAAGYDTVZMqEnqrplPuGr6czgum9iMK2sY3HEAAAASAAAAATBEAiBwk5BMxnHt994z+LvlBtspXQqOwuvC9ndungqk/WJTjwIgLDJ9skAn2vqQx5NJnnyRelbWe9WpX+RaxxRc2xcGXQEAAABoBE1VU0SlI4O2ZbkdzkLdS20eD7N9Pv/kiQAAABIAAAABMEUCIQDDoit3LF0ClBFSpuuv4hGpR+0y26kG8i+jMEyAdUD+6gIgK8lVd6qX0eaOiuA+RKBmS+aXgPs7gDr4Rb21JKQ6JrsAAABoBU1BVElDfRr6e3GPuJPbMKOrwM/GCKrP67AAAAASAAAAATBEAiAA2Pp7bkCaDcVXI7qXUXnn0RgdH8ePzL7OTlomSBQ2agIgOSfYSnEMiJLQL3OGrSAUfHX7pL3UhrAlbs0AV3CnylsAAABpBk1CQ0FTSO+7PxBY/Y4MnXIE9TLhfXVyr/w+AAAAEgAAAAEwRAIgMjQFJ5VR8noKpDb4heEw09hOI3HgoPNsWRWEkaX5AfYCIGWyZMRxT0fasLTx05BW6kx40WfpxjZN7NiGiMBzby89AAAAaARNQ0FQk+aCEH0ene+wte5wHHFweksuRrwAAAAIAAAAATBFAiEA+1maWL+RrpA864K6t6oRmn4zBTlvyDJTfryJIJHWSO0CIG7Vsz26lGUlwNmTTh9DIxAlsW0TR+gq9cabCLr4XYzEAAAAZwNNREFR21rTXGcahyB9iPwR1ZOsDIQVvQAAABIAAAABMEUCIQD4dkAIKVQe6rMOZSsgvSQGzx8I43S5QxIHDs7vCMS9ygIgSvxLS4xTAJ3VqocJkhdkibaxJ10oIJn/Mtyq6ceq8Y4AAABnA01EVIFOCQixKpn+z1vBAbtdC4tc330mAAAAEgAAAAEwRQIhAKb4lLG2qC7fpJnGqdW/YOBQMW/OIihI+xDwMqDjvikTAiAfEQ/XEq8TW9vSNbZJeVrYACkfr1GQ3k0/6ETZ9ozccQAAAGcDTU5UqYd7HgXQNYmRMdvR5AOCUWbQn5IAAAASAAAAATBFAiEAgxTSETYnwDxK8FKzsbXpzHQ9xUON7T84t1xgNicL6mYCIBpIDcgSH2T8C6dTqbBA/KHy0/sBLnzNPjVqc8umiRDxAAAAZgNNVEOQXjN8bIZFJj01ISBao3v00DTnRQAAABIAAAABMEQCIDD3lHQID1KxOOlk01qY+RI0LEhny18sewTzjXUFOr2lAiAdnlQn94wHL2/I+8E4y12uy+bsr1v5TP193/eT/58rYAAAAGYDTURTZhhgCMEFBif5edRk6rsliGBWPb4AAAASAAAAATBEAiARAH5mejvgJZJ8sSvDpB8qN1HNW3d9gLrvNv6Wu5nU9QIgRbMNdP+iq1QSLxHYx5lK+va7gplTFfUJMWGrQDwu3RQAAABmA1RFTOwyqXJcWYVdhBun2NnJnIT/dUaIAAAAEgAAAAEwRAIgEpyd0uoDp/UxlA5R+SDfw5AIjZhfN6bnh6U5hU3h470CID855XKIpuKLhJNr1f6GmXs7l4DJFiyuGzXWg7MJHwUpAAAAZgNNVE5B2+zBzcVRfG929qboNq2+4nVN4wAAABIAAAABMEQCIGxlj2fxZFsP9saVayxJtZFKFydpcX/mZQVG5Hjy83TOAiA9j5G7YCl55d+9xBMtyTrqdGnvITSScOE/DNaj4NZ6CgAAAGcETUVEWP0egFCPJD5kziNOqIpf0oJ8cdS3AAAACAAAAAEwRAIgdxwYynbSlZPiirjKJGFBGf/k78gSnIdBXrxjy4FlTScCIHc20eMvWCViaMqYo8Rbl5YND+0hTKv9LWUIWO0syA+fAAAAZgNNTE6+ue9RSjebmX4HmP3MkB7kdLbZoQAAABIAAAABMEQCIBuHjNsWpAatdNoBF8eB4DHRfkyXgoXdyERlu5amSbsWAiBL4vewyrSDI/elREKUmK93pBRBVUAZR4G6e5SqE31GggAAAGYDT05FTYB1Ca7OJMD6WhArajsFnsbhQ5IAAAASAAAAATBEAiBojpBzVGwAJ67/SRE6VmZ99ePAKWZRYtoXp1h+gHbcTQIgFyPZPlrIfxaFxqLWMra+hSl2Vep+3XMnOWUjxrtTUx8AAABnA01WUIp35Ak2u8J+gOmj9SY2jJZ4achtAAAAEgAAAAEwRQIhAK7cU7vQ+RJxaDQHFiKm6/NBbLiKHz5lBxYnaetuKXgTAiB23vDXgfi0i6F0xnr0ED6Txajaj4PqOLWy9Jmjn0+Y4QAAAGcETUVTR0IBZ9h9NcOiSbMu9iJYcvvZq4XSAAAAEgAAAAEwRAIgXUUGSl9hr6hdBGOYdV/Rdvmozq61eVO/0UyxZfWd904CIF7OohObiTg0amssVgvn7sLAANrJ5QEhiDO0wol6im21AAAAZwRNRVNIAfKs8pFIYDMcHLGprOzadHXgavgAAAASAAAAATBEAiAcpRNGtl6eDZXjpmM2libRtYw4PKOwINnYd0AmPESvswIgG/MeS/TC4zrKb1XTlIJn+3B3Wcck/RN+6Y0luVqjsA4AAABnA01UTPQzCJNmiZ2DqfJqdz1Z7H7PMDVeAAAACAAAAAEwRQIhAIMo3Vnb0yb4EUMA1meJTg2Pfi8CvXE3LFJB8znG5IDRAiBGKLgXD4ULmeMxspdU3V1aLjJq2xLmN75Bfd/qlJFpTQAAAGcETUVUTf7ziEtgPDPvjtQYM0bgk6FzyU2mAAAAEgAAAAEwRAIgHHINiwZFGfQuVKvVxOlJ9tLWvMbdW1IHKt+5SZIM530CICLB8xPlZiXqucioOumk72Zhj5T8xMm+IV/DHisKTEfcAAAAaARVU0RN12Ct37JNnAH+S/6nR1xeNjZoQFgAAAACAAAAATBFAiEApn+K92BQqwxa5RaWNdi3eS9aoqg0zaAKIQLpLA8UeoECIBc1k8f+WeI9mUVubC6aGYqdxApMf8zkoMSnwoLrSon4AAAAZwNNRVSj1YxOVv7crjp8Q6clrumnHw7OTgAAABIAAAABMEUCIQCauIiJZsZbwIAwYdMFnVFZVxsYzEL1DOdGpuqU2Dr3fwIgODyfOPoG9jtfhJeNuFbHyH4WWUN2/ZOmuYtBFF3bVU0AAABmA01HT0A5UESsPAxXBRkG2pOLVL1lV/ISAAAACAAAAAEwRAIgCKhvQo0uL6ApIeIl5PYxnEO0bKmeaDWESrgWRHs0gIQCIB3UHMQJ56xFn+zftwKi8XswtxxLVYT34enu/nwMdqShAAAAaARNSUxD1xe3VAQCL7HIWCrfHGa5pVOBF1QAAAASAAAAATBFAiEAztnmHhCLwN2i5EasPjLuLNBVIDT/o0FlHoVko8FfjzkCIBDEEqOHRi2b/J+RREiAXRp+OOV3KAYb68b6H6FAP3y7AAAAZwNNQVMjzMQzZdndOILquI9D1RUgj4MkMAAAABIAAAABMEUCIQDCmxd56iLnMaptM4mnZ8p0TH4xlpd1fdUK+QOz5jW/lQIgNVC2tx4NAI+GAN76TLSZgJaEIHuFWwb+RZYuSiB4sXkAAABnA01LVHk5iCtU/PC8rmtT3sOa1ugGF2RCAAAACAAAAAEwRQIhAPWUX8zhbMRoog0fUUznXNajpGw3FnMIU2DO9ANbHy7pAiAnS1GSDH/Ap679pQAYOORdvstf0d3cRHCmgOKc2pc7LgAAAGcDTUlDOhI3040PuUUT+F1hZ5ytfzhQckIAAAASAAAAATBFAiEAixNIrrapEtrwvxhQ+B5SHf3k3YZTTQjYoOBWdbP6JRUCIEBQ7V5l8UckQs4Ls6LKMj8FGgCEEleB/t5Z9p1GxGFSAAAAZwRNT1JFUBJiKBsroEPi+/FJBJgGic3bDHgAAAACAAAAATBEAiA/1hxYHMieny0sg8ZIr209cAYX1iDsGidmGvxytyXKiAIgFl7Vsu3GdzP48d4d9ISRHQveeSQQ4RAnKsGdw5I/ndkAAABnA01UUn/ECAERZXYO4xvivyDa9FA1ZpKvAAAACAAAAAEwRQIhAJlgKvVx8M9gZF8A0/+tVkXsXKHW8mml4DqpY/6iKE4DAiAXi2kAv6FgT8ushplUB9KDll+UGsZLalktVojpbrQ49gAAAGYDTU5FGpWycbBTXRX6SZMtq6MbphK1KUYAAAAIAAAAATBEAiAofBnAW34xAAYumHHXJ0pQ9MF3qbxLYqZcAltSsV3ntwIgDnfOT1FgmiFCtWsPDEdyL3hdsJgheNC/MSmejIW/4eQAAABmA01PRJV8MKsEJuDJPNgkHixgOS0IxqyOAAAAAAAAAAEwRAIgAULN0lffWlD8Q2Wlqm2iDJptPRMsY6WbBrZeesWB/4sCIHy7o3recPx2RluTckIvcwyp4NKjWtoJ92FFv12VVLlWAAAAZwRNRVNUW41D/95KKYK5pTh83yHVTq1krI0AAAASAAAAATBEAiBnT/UaWe+5lMsNtZRvdn4e7j/pTzQ2UiCzLFEvXkDOIQIgObcnVGjI8spp0DVqifqm5WTZ+tsK0Dfhi2sh7XXaBLoAAABmA01USK9NzhbaKHf4yeAFRMk7YqxAYx8WAAAABQAAAAEwRAIgL86350Gg9QiDfcvb9qxFc++xr+GtIPnxSK3fmt8YwLICIBJMBfJAkBa+gGzPV/nlKKhdpkU0Jrb4DptdJtJqFxaeAAAAZwNNUlAh8PD9MUHunhGz1/E6ECjNUV9FnAAAABIAAAABMEUCIQD7msiS2c18OyNH6Z/OdamSYnRgR4h2xZffCLCMbEndQgIgKAlocDZKRnR621dFHKFX3RWubltayaq+IVahyTxt6m4AAABnA0lNVBMRnjThQAl6UHsHpVZL3hvDddnmAAAAEgAAAAEwRQIhAJY+QV/qP2i/bzT8xpoLwTdGTl+G7qeT3gjIBmS387OkAiAWyRt/myXbMSvEl9NXHJDRZieO5Tt8ZDI84ZdngUSZiAAAAGcETVJQSHsMBgQ0aEaZZ9uiLRrzPXfUQFbIAAAABAAAAAEwRAIgC65gOmfObocPFt8IclHDCRV/oD4Q8mESxSGDywoCAxACIDZ8T5mPb5j8QMi4Oaj1ey7hQRB0DXi6VxOaC3HHZsiEAAAAaARNSVR4SlJ9j8E8UgOrJLoJRPTLFGWNHbYAAAASAAAAATBFAiEAmjUeNVpPrFZHPWseni1sK4jdi8M/FhTcWVIbhw+5+BICIGaJd5sMVTDu8T3iJ+LgpYRdiMrmHbY1xOx6eeTNrWAFAAAAZwNNT0OGXsWLBr9jBbiGeTqiCi2jHQNOaAAAABIAAAABMEUCIQDA6qNMh3yXwGavW1HJVFsAsRzUOL/WQjNlJ2Wa+dnyhAIgFN2BwxFnmGUBoI6mBJ3lFFoA6jDihF7FdFq1XCaSe2YAAABmA01PVCY8YYSA2+NcMA2NXs2hm7uYasrtAAAAEgAAAAEwRAIgWACLdMWNbEyWtysSYQlABSZQsyQAdMmbqd764+kMXk4CID7AhYvFPvDGv5hwfO7W1VjFWZuC2a+ut23Loy5gjqJZAAAAZgNNU1Boqj8jLam9wjQ0ZVRXlO8+6lIJvQAAABIAAAABMEQCICtoIRHGPqFsk4vhDWjTmOImlweS20ylRtV8w/mL7QheAiATNL6D0iX5lFl6I3T6Uc4JmN+mR+3OKVInYFPIgVAS7gAAAGgETU9aT0S/IpSfnMhLYbkyip2IXRtcgGtBAAAAAgAAAAEwRQIhALMFiumMptV7GF84hugTd9Py7vlOvTNP/IBeW2CJNWB8AiAcDkBWlwlW4oWSymnuE6mgsNKFSx4tmGbQoZn1CKsL1gAAAGYDTVJWq2z4elDxfX9eH+r4G2/p/76Ov4QAAAASAAAAATBEAiB8Bao++uru+Cq6/zVlm8ZJdvB57UIdxaW7BTEBpeG2gwIgc0F9gg/E7Aa9ah9mMfhnIUofB0y+X5hE7ZVF1iSTXWsAAABnA01UQ9/cDYLZb4/UDKDPtKKIlVvs7CCIAAAAEgAAAAEwRQIhAIfLj6cDsKTrlUOGjl+3HjFCEYh0cux5JP4qOdmFWxSVAiAXnxTdUF8eZG43IwmC2/cz81itdXe1dMeDFWirdODRdAAAAGgETVRSYx5J/3fDVaPjjWZRzoQErw5IxTlfAAAAEgAAAAEwRQIhAPUEzPb+E5xkllG5JEuZiyH/fv8TfZNHg0VW3S7DDf0LAiBnjtwtE/WMkWMwhW6EdGxMh2hYnr3z4bfNAI/XuYH7wgAAAGYDTVRYCvROJ4RjchjdHTKjItROYDqPDGoAAAASAAAAATBEAiBzby/wYyblOxdAVo9eFQc3wRmSLZ3Iz1tSYiQ7KnwoXgIgBbfyWP4yottRAH2mFalIaOBaR4S8JKdQ6KjQnj749QcAAABmA01DSROKh1IJP0+aeart9I1Lkkj6uTycAAAAEgAAAAEwRAIgKN7PjNlCXl3EDX5X5UQSClzCDqP61uMjgioSPard210CIB54sn6LnuNpH32dDNBUeFwENq+bLVi/8riSTvYKF3aiAAAAaARNVVhFUVZp0wj4h/2DpHHHdk9dCEiG000AAAASAAAAATBFAiEA0rAL0UqSXQa4n9G4R/2uPjPENxQb3rMqg51Phk6ncaMCIB2mtbCnTBr80kRu8nSN47XE5ugbNLsBTUIHW3bJcgRPAAAAZwNNSVStjdTHJd4dMbno+NFGCJ6dxoggkwAAAAYAAAABMEUCIQDWaTlVaiIwu7eFBfa7DNWqHm4JSUDHfe3ffjgGw8ZpzgIgDHK+s8TKtZg8g/vst4PwD4Y0+cp1+qx4Q6NfyVKr7ysAAABnA01ZRPfpg3gWCQEjB/JRT2PVJtg9JPRmAAAAEAAAAAEwRQIhANWkqbRiFsTCAgKIQXY9nzthJxn5UA7hFT8BLOPckMCdAiBTcdKMwSadOrdD7ayKIXJwE1B7+4Q/jp01LaVCgxpuAwAAAGgETVlTVKZFJkxWA+lsOwsHjNq2hzN5SwpxAAAACAAAAAEwRQIhAIx5wKQxv2+ig0x3ge7liPtYDhi+v3/b8HsEk93pq4IoAiAu5moJdssCAL+sVIUprsX+MiFOWoJ7wo55hVMwVMeb1AAAAGgEV0lTSBsiwyzZNsuXwoxWkKBpWoKr9ojmAAAAEgAAAAEwRQIhAKuGNHUUbrc7Inh5jASKnTqf/IbK47SSoXL90BLhBgXqAiBPgyVm6D1HQoHYs3xeQN8gHK7T1bwBrR8FpEsaaJRi5QAAAGcDTkdDct1La9hSo6oXK+TWxabb7FiM8TEAAAASAAAAATBFAiEAq+u6uLpEuaxoqFmfRZ1Lw7rlLoezbvy+EIodcfDK8RECIDuKWaBt7lL8RbI7FHmPRbyVaGkd95JEwy9eAGCJFs7zAAAAZwNOQUONgN6KeBmDljKd+naa1U0kv5DnqgAAABIAAAABMEUCIQD5o+6hl9WmZFLXH4g5/lSZDe79gSJuQ73FpKR+SG8JUwIgLssLh7YG2CuGectXSWUtNBsYygA39PehJV56siXIfSQAAABnBE5BTkr/4C7kxp7fGzQPytZPvWs3p7niZQAAAAgAAAABMEQCICxFZrIDRHEBoPxCFjr6lHldBn0Tk7F9MwWqGlpDeigOAiAxv68BvCdulKJrfjaNko/eV4Eqasl1tHLD6eIZdH8oxwAAAGcDTlBYKLXhLM5R8VWUsLkdW1rapw9oSgIAAAACAAAAATBFAiEA36zuF1jUKTwI60Qbu5qPzYR/7QoyD22qEv4vjJUuh7kCICIAtMBLu5rI0q2WRY/FStjNoWJLFKDdCl68yM0BpyenAAAAaAROQVZJWIBHNl31ulifkjYEqsI9ZzVVxiMAAAASAAAAATBFAiEAxI1Vy+qj2LhwzHDIDXS+UoJhPFi+q27t5Zqu75fyGVQCIAoXbOHJNGveP5Z4sKvZJJlr1RpKnzI5SIorT6CkmmhGAAAAZwNORFgZZtcYpWVWbo4gJ5JljXtf9OzkaQAAABIAAAABMEUCIQCwGsCtN6+FaP2EsNjo89RytKXtXWM5VCeGUoKqDjHT0QIgTVwVonsyebsxYg0J9anuBhQ4s+/gGd1+aL/+PKIUNRYAAABnA05BU11l2XGJXtxDj0ZcF9tpkmmKUjGNAAAAEgAAAAEwRQIhAPBuo2wuHgfq+GSD5uStz/DLT8IDdjc3Xobp3kQrUtGoAiAvdwHCQBWPfKR94eAHVTZW23c2K/afgN2nutCwxJpz1wAAAGgETkJBSRf4r7Y9/NzJDr5uhPBgzDBqmCV9AAAAEgAAAAEwRQIhAOSqd2kHzITAnwAqwYclwqCmwdetOSHqUhwd4+gmSGmkAiANP32bIrJB+3aXJxfJ8FlU/Ohw6KkgtVJ7h01vwhReCwAAAGYDTkNUnkajj12qvoaD4QeTsGdJ7vfXM9EAAAASAAAAATBEAiBxOG54Nl07Fe5wO8Zgl03W9oCDEwZqPXe/cRPLhjc9HwIgCVHHpODmE7OmWB97RffWUR+u4tf2VUa7M6IxbOr7UYwAAABnA05DQ5NEs4Ox1Ztc40aLI02rQ8cZC6c1AAAAEgAAAAEwRQIhAKq8pJd4lJ0bdSo8MBqqHWcARm5jpH1wja9kzkEqSZy/AiBgXPjJkqGUghyvdXaDYl/HuXHO11xpfHUfo0ghUATpCwAAAGgETkVFT9hEYjb6lbm1+f0Pjn3xqUSCPGg9AAAAEgAAAAEwRQIhAMqA1bDZcT8svLdKwQ65+CzPlksvzq8aAMVwTpuhk+EKAiAX+uNXdXXlzTQK4fq5XXLa4A3Av2J7TlWSDS2iZ8uADQAAAGcDTlRLXU1XzQb6f+meJv3EgbRo938FBzwAAAASAAAAATBFAiEA0h6Z7wZwvLXR32UA2CvnHfZtGitTldmW8uwdKeyI49QCIFZUNJO5H5iUEXJ54R+d52j6DXh2uKPZ5zNnSThCqJSiAAAAaAROVFdLIjN5nuJoPXXf76y80qJseNNLRw0AAAASAAAAATBFAiEAx3fh2FK1oR69xJdcDpXpB+/cqo2lytK3+DaiqNtZ+JQCIBqgWzuKc340fY169N35krw9+4lvLblsIlUg2kdNj1cCAAAAZgNORVWoI+ZyIAav6Z6Rww/1KVBS/muOMgAAABIAAAABMEQCIEJILiDitdU0D25qR46IUepZnKDoEjhSHx9/tGg8WN8DAiBgHOwyO5YWsFVNvJajjt/6+hLis+M0cK7zf78qZQt7tgAAAGYDTkNDXUjyk7rtJHotAYkFi6N6oji9RyUAAAASAAAAATBEAiB6bg3CCCaCSLp6jUrRmr9PgyshMh2qqc1csw0HmwYbNgIgD29LnU5DQOBiZsT+viiJCljuz0ScqO0d9hkLu40uUggAAABnA05US2m+q0A0OCU/E7bpLbkff7hJJYJjAAAAEgAAAAEwRQIhAM4noxlz10wurHyCep+uDqGJe8toWeKVVfvWuaPCB7HtAiBz+q2b9YVI5fuVTBNKloZrWFB1TGV9aoYBfBZTaxGOHQAAAGcDTkRDpU3cezzOf8ix4/oCVtDbgNLBCXAAAAASAAAAATBFAiEAp+5SlxrbKEJPeBZjvEm9lIH6qXjtU6nI1bpYqADwLZoCIDbDrrwFsEqbzzHTx21skWxOD4FhsSD6cXasHnFZTuKBAAAAZwRORVdCgUlksbzq8k4mKW0DHq3xNKLKQQUAAAAAAAAAATBEAiBLlkGoh/LIVhSbZ/Fg3N4DlIpx6YIW2e5CcbHQg2QQegIgKqYWIhO51nmRbT/BtjUPpvIAgfefI+0Wi5D1/MsG8G4AAABmA054Q0XkLWWdn5RmzV32IlBgMxRam4m8AAAAAwAAAAEwRAIgWlShVW8Z2GMVrDumnJoygV19o65MX9fyd4OMb4BSBesCIG9qMjPPoz3HvTMK5yvhTH4SLdzfAx7DerpnXob6gbu6AAAAZwRORVhPtiEy41psE+4e4PhNxdQLrY2BUgYAAAASAAAAATBEAiB0kG0jHBzp2JL9sbV5X544on110gVCGz1c6AOnogiE1AIgBDaWP1ebkUMa7Vc56mJmUN7kBU7eJ5gPdM9LYqWt0H0AAABnA05FVM+5hje8rkPBMyPqoXMc7StxaWL9AAAAEgAAAAEwRQIhAIxvTIWvKoZYdOPRGK258ouudKP77NxfbcbUVPf6uzXBAiB8QVVQlZnxVN8f5VrWc+Dq6pr23Idjz2lSLV1DEDgxIQAAAGkFTklNRkHiZReplnKZRT0/G0iqAF5hJ+ZyEAAAABIAAAABMEUCIQCPHXkK+iO5Y665EUPKRiyBCa8nqmdxncHwJ59KpJwDoAIgH1Mj5uUIDw1SI4VkF6iif7g4oIhqSufNC0k/rWPK2FcAAABmA05CQ58ZVhf6j7rZVAxdETqZoKAXKq7cAAAAEgAAAAEwRAIgcgABNDFQVhLiFeTN/vMt+FW6cLw63KwFE6IUSYRc1dgCIE0vuRjLTvpOq5WTR/uYHawWi9uu8FDm4vAwzc6EX1fHAAAAZwNOTVIXduHyb5ixpd+c00eVOibdPLRmcQAAABIAAAABMEUCIQDBioB9fP843gf+BErKEz7rtG8Ll9W+yortJalCMOpLcgIgflahg01Q1FSKvrScqPcfv8YB3MwHFSV6jwYt33OKj9gAAABnBE5PQlP0+upFVXU1TSaZvCCbCmXKmfaZggAAABIAAAABMEQCIF10Stg4O17BXZU+UTtskpbPQOPlkQkfTxvEGx9zlQPBAiB79JWXCpH52whNbfptizy+LTFBJs0q+dDI76xFclWb6wAAAGgETk9BSFikiEGC2eg1WX9AXl8lgpDkaufCAAAAEgAAAAEwRQIhALuUE+gRh4/uQczITHv7z1nd63KcHF9FhHNGLlMhkRNZAiBXeftWjPn6Dr+plC1OqK6rlk4mo05EyNtQ4YNi3rrbKgAAAGgETk9JQfyFgVTAssSjMjBG+1BYEfEQ69pXAAAAEgAAAAEwRQIhAIGDduI1ool6M653y5W5whrRgr+ALLHnhoXJmSYv3TT9AiASsrJWn01o7c3xfZtIXyybfl7kFE/lQSr97KhUomu0FwAAAGcETkxZQc7kAZ/UHs3Iuunv3SBRD0tvqmGXAAAAEgAAAAEwRAIgM0W0XCYQ4YriPanTMa/+5hPGbRqCK2+tWLvljlCk6g4CICU2eLNg/5VGuLeBZOFaj6UC3yiejWmwKnn7sZbsYdhrAAAAZwNOT1jsRvggfXZgEkVMQI3iELy8IkPnHAAAABIAAAABMEUCIQDOSW/+orM6GG88UaSa7LIbj27QcnUS4zlQm6w+Agl3ngIgShi6udEX27PBc56rUQ4zyM/EJQOJVZMLcZrgSlimxLIAAABoBE5QRVJM5rNivHeiSWbdqQePnO+Bs7iGpwAAABIAAAABMEUCIQDqvbzYc2x+0JJ6J3L5b5GFdSB2gl7ZtiNcTU+ibWYQmwIgWL/d0tz9E4RXFNXF+v5j2A8kITLXE7wetpdkvcmXsI4AAABpBW5DYXNogJgmzOq2jDh3Jq+WJxO2TLXLPMoAAAASAAAAATBFAiEA4bAHhtX29h4O+5TiWX5UCKtBfgnoV1YcAl8OgbL2K+8CIAT9pE+S3b1z4mbqqwuTpKSczs4wifzIW0MFKwPFVH0gAAAAZgNOVUckXvR9TQUF7POsRj9NgfQa3o8f0QAAABIAAAABMEQCIDJAXYWglLOiak1Z36XF5rCQWT/dqvUXqYb85uCorGzhAiAklZzQ/MtZfUcIJYP7Irw//q07Yy4BSlV/1W65UKovUAAAAGcETlVMU7kTGPNb2yYulCO8fHwqOpPdk8ksAAAAEgAAAAEwRAIgCBaRP0ye5JWpfP46jrGzsi9nTpBNkdhj/SqpoUmU2toCICnwsPT606ikxJ9c/wFo3oz/AIgsIZ1D2WGeJcuunWTaAAAAZgNOWFh2J95LkyY6anVwuNr6ZLroEuXDlAAAAAgAAAABMEQCIHUvZJuxD4cgmSek5OGmyOOo9PrgZQtYKJEcpbdq9GxJAiBThQyLSC4dJGhSSiBPjrpOR8tDZ/mS8FEj1hzVpe6mEAAAAGsHTlhYIE9MRFxhg9EKAM10em27X2WK1RQ4PpQZAAAACAAAAAEwRQIhAOJFgxB1pc1wSeu+cQ4+d3m1uRuhkto+ZF1R0UkAyx61AiAS0/QrTX9lnSKUgQrJL3oTVhZRJWFs0YbAxIz0H16CGgAAAGYDTzJP7QCiy6BmcUmZ7HAzUOCltrerZssAAAASAAAAATBEAiB8sYLhHmzcYpjSz027tf/F2vq+sqRU/q4Ha4n/HQ5QLAIgCdIXs0Fbr9xBl6jY903VrT3ewlQdAn96T1TCLTt3ONoAAABmA09BS16Ii4O3KH7tT7fae30KDUxzXZSzAAAAEgAAAAEwRAIgdnmCCXozZ8Ig3bAmepY6RYRp0DmmgjJgIyco/zO2iFkCIHUWIBEWuZy9G9GUWoqIbxwDjVyMLEeCoBKfR2pSgl2LAAAAZgNPQVhwHCRLmIpRPJRZc976Bd6TOyP+HQAAABIAAAABMEQCIE1izQn/3lO/sY7hG16tkTm/cNFfHRYArXIo+z8f8ABaAiB5u6XZ+l1MrT3dQikrWbrtm5OyIycH7x5trAKfvFwTsAAAAGkFT0NFQU6YXdPULeHiVtCeHBDxErzLgBWtQQAAABIAAAABMEUCIQCtisL7bWLoGWpQwIBLWCubutijvwaEJcpcOGnSYN0dHAIgOO3AxDvnsLmScAvEi8Rt9isKv7FTTUsJ3AcnpI9DR8MAAABnA09DTkCSZ45OeCMPRqFTTA+8j6OXgIkrAAAAEgAAAAEwRQIhAONHfU0Utg1M3nLXLhUzGo3b9RVNGogWN8qqFdQZ0/4bAiBSNvLJf7Y2Rb0+i3e+Azajy3JYFYLNfiLGtbSvFLo3MAAAAGcDT0RFv1LyqznibglR0qArSbdwKr4wQGoAAAASAAAAATBFAiEA/fammp0L2k6nysWZfolgBxwftKnps9Hkt5rrLse/OHACIHQkflNp4A35zyLYDLkvpKg9JiSsGLugs2nDjPXg1H46AAAAaARPSE5Jb1OalFalvLYzShpBIHw3iPWCUgcAAAASAAAAATBFAiEAqDyuuYX1dGZNa2oewMKdnPnEFqaMzhP03q6yrwCv1McCIDIuUWPfuwYg2Z5xBupgA5gA4a/tRhY6077mjYZtbbLxAAAAZwNPTEWdkiNDbd1Gb8JH6du9ICB+ZA/vWAAAABIAAAABMEUCIQDtwg5IjeIBN5Vk0x6D+k0QjNOWeMhWObs50jDnYR9kZQIgU4lvnzvhL9iib58hp7q3apdpuowHSeX0nYKgDc4KSYYAAABmA09NR9JhFM1u4omsz4I1DI2Eh/7bigwHAAAAEgAAAAEwRAIgfyKZQ6BRBCW13Ktc/+D2BGnT0FxVV6G76cCgfUtwTmYCIBHNEJNjyHXty9tdels6tc43JtmjzAgWj2krSGLItPT3AAAAZgNPTVi128bTzzgAed87JxNWZLa89F0YaQAAAAgAAAABMEQCIGu3TvyGzDCVJkanbP5iJUvofpQMIJ8yfMKPO4C6EHVqAiA0ECh3SXvNK/NxOJMdnfCwZOH5C1F/g/GbGL41VV2dTgAAAGcERUNPTRcddQ1C1mG2LCd6a0hq24I0jD7KAAAAEgAAAAEwRAIgVs2pz6az/5QwyWPvgnvF+G5YsJ7k7lfikihn2o4bvrMCIAls9iAbHVS2c7Ah3nhk9QO/MVI/2F+ZeqOyn+WrFmWPAAAAZwNPTkxoY74OfPfOhgpXR2DpAg1RmovcRwAAABIAAAABMEUCIQCd24JjGtkn7UJtz4vNT/7qvvCM7yldpmklphtTtj7ClAIgYFujAdjQUjehIQNfFHtI7x+uzz5zLcuxLsNZWGFbJ/QAAABnBE9ORUuyO+c1c7x+A9tuXfxiQFNocW0oqAAAABIAAAABMEQCIGEPY4wWsBlIJmWsw83BdqxhnROGEuZ7Ghb0WhuHfISvAiAQwA/tJIkgcIA3dkTUClFg5tgzoWZ0GXD7SkJgjXOjjwAAAGcDT0xUZKYEk9iIcoz0JhbgNKDf6uOO/PAAAAASAAAAATBFAiEA8d0wRo3bwVj0DvauSIoSD8KXo0HrhK8dnVZoEUWjnyACIG9l0jaSg0qLCozeFy45/F2YLte2lcrplre/eB6WdRBJAAAAZgNSTlT/YD9DlGo6KN9eanMXJVXYyLAjhgAAABIAAAABMEQCIFoLTM5aRYE0STqaAplSS4U23+iOwy/BNErvyK/ANKCSAiAW0HW3upLE4uRqGFhUW6yQPjCV9LtLY6lTjKwBheaz4wAAAGYDb25H00HRaA7u4yVbjEx1vM5+tX8UTa4AAAASAAAAATBEAiATukOTCR97LG9RvBcSKyWQC/naPf0rfccdevNdn49kbgIgBeE8I12dBb8KTns+I/GZfV2tu+QiZXzk9z4R2yJMR24AAABoBE9OT1SzHCGZWeBvmvvrNrOIpLrRPoAnJQAAABIAAAABMEUCIQCL2aXspNxg1+rl4HDxoWmhjS16f1q2yuxYMmjeHPQf+gIgEYzTFZC9oq0/fthq/3zB0iAzVXfkmi03HTzGLXUIjJ0AAABmA09QUXdZnSxtsXAiQkPiVeZmkoDxHxRzAAAAEgAAAAEwRAIgMy9ybNtCBx2ZnTIydDQI6b/TLFFrIaBZiadmFO0YtZUCIEj/F1XItJNRIjoHLyiC3tn9g8MgwVZzJN1EoahFUux+AAAAaARPUEVOacS7JAzwXVHuq2mFurNVJ9BKjGQAAAAIAAAAATBFAiEA/snA8H1yxsEM69FT7ve7jbg1YEC2Vgyoee/eHQWV+NoCIAjG4P2wqsRVgKPCSMOJI/OXGmu9YINbmPtzfRnt762DAAAAZgNPVE6IHvSCEZgtAeLLcJLJFeZHzUDYXAAAABIAAAABMEQCIC64xCqAbsdiwMv1de6Apc0k6IcTXyltfZvoevb7b+oXAiBTogdtt5sHqYA2VjVYqWqsVk9kQJdBTQk9O8W6nGSAnwAAAGgET1BUSYMpBIY5eLlIAhIxBubrSRvfDfkoAAAAEgAAAAEwRQIhAJ5H3w6rafDAfgnNqIm5TmkYMmDf+MxleEQavlz2R/FsAiAjS7poQmt6jfboVpTXUOZLVPtUtpczeg4fIaBaG7AY5wAAAGcDT1BUQ1X8Fg90Mo+bOD3y7Fibs9/YK6AAAAASAAAAATBFAiEAncYMtsvtgsWGOL8hxV4JFdJKvCA/XYeTswTU5rS8rMECICeBZpu2G3IoTzsLx7hoheLS9OKlFqOxEpykm4VuNZAxAAAAaARPUkJT/1bMax5t7TR6oLdnbIWrCz0IsPoAAAASAAAAATBFAiEAvVobqCPgeswpBpDxRQ4usKnrbjtl+bspFIMhI7NmD/ECIHjGlqPCOrL4gqQYGYBJXX2PG2RVDgy1N/paEUG4VszWAAAAZwRPUkNBb1ngRhrl4nmfH7OEfwWmOxbQ2/gAAAASAAAAATBEAiBD5/MGnvLSY+QZXzlqMCrckKtC6e0VN551/co0FeCf2AIgfEYNvurVlaHwYvhj0kN+tafbsJQKEFX3Hde7LzMCnhcAAABnA09SSdL6j5LqcquzXb1t7KVxc9ItsrpJAAAAEgAAAAEwRQIhAPXR8UxeWjQFp51HZG0IpgwMC7dgBmCfB6OGfct4y1uOAiB7Cy3biugArOqV4aA4C7E60+igSR6NHhW5R09DAVr8LAAAAGYDT0NDAjX+Yk4ESgXu16Q+FuMIO8ikKHoAAAASAAAAATBEAiAEPx/qUcyo2c2PJnsPpInFQuxMw+Xv5IiQq9H13RlqsgIgWn+orumTfTKTRCu9rcC6q7/kW9PTKML03tx1lLHohfEAAABnA09SU+uaSxhYFsNU25LbCcw7UL5guQG2AAAAEgAAAAEwRQIhAIWKDit9NmYzprccraDxlg9ze9U7ok+DkYfW0dg5SGM2AiBfW6Fx5y5bEw1O/8vf1FLdUsgMAgnxUKa1RoU9qvFvOAAAAGYDT0dOggfB/8W2gE9gJDIszzTynDVBriYAAAASAAAAATBEAiB7Ez56/d46VFWpSS7/xVFBieI+6izbzo5yBid16/zKmAIgFPnIRLQTYzEBEgnc/jf/9iSSNj+IPf7V757r4yU9zy0AAABoBE9STUVRblQ2uv3BEINlTee7m5U4LQjV3gAAAAgAAAABMEUCIQCF9uXrAbKlXnzxkDMp7D674akPxQ2YU5x5nfXli0S72QIgFmDCBa2QmOVuxll4s2U5UR1eaKIPHkR678XS2wi3trIAAABnBE9STUXJbfkhAJt5Df/KQSN1JR7RordcYAAAAAgAAAABMEQCIAdlKiAECMCs9fUg1iOnQiqfugvO/OZNt5gLAKvFUQRLAiBuBV+9HGAPeFBnlpDePB7ud8BaI86JF5RMXLwLLZU/7gAAAGYDT1dOFwsnXO0In/+uv+kn9EWjUO2RYNwAAAAIAAAAATBEAiARQd8y/rR5dhsaTwSmXnMcDEs5S20G+p15GK24Z4QcogIgPQ+WoS9gxefJ5vUJ0YMqwjheJ4WwkOKhBBWpgTBjFl8AAABqB094IEZpbmFloVAUlk8hAv9YZH4WoWprnhS89gAAAAMAAAABMEQCIDx9uWwzeBd7zqoQSaDeIHj80Yx+jHKhKJqD+4Y+0E+3AiAklGG54eZYXdgOjvFZmLCfMo6JZ8HHq6U8KKA908ph9gAAAGYDUFJMGESyFZMmJmi3JI0PV6IgyqukarkAAAASAAAAATBEAiAkUL7lZTtSky3MZhjjMtZjfOhvNeK2HueK1sHnYou+zwIgZC1Au6AQ8LkzeEUShGauH9MrxwzB+cz5Lbu+BfkEOukAAABnA1NITIVCMltyxtn8CtLKllp4Q1QTqRWgAAAAEgAAAAEwRQIhAOEVvclNMDbONTKuX4nYhJDVrhbdJpcO9tSi+pXzeSjDAiBQO11ZfQQlNbQdOSxIZiK+OvwOGf6V7Vashz1hH/yMSAAAAGgEWFBBVLsfpP3rNFlzO/Z+vG+JMAP6l2qCAAAAEgAAAAEwRQIhAJsdEfCZw9pkDHrpzLmDb1aSUuYhr8/BKQk8N5GirUG1AiBuaMkKfWZ0crfedFbLFtxbkryxxpEukHfwJVu/w7yFLAAAAGcDWFBOO54JTVYQNhHwrO/atDGCNHumDfQAAAASAAAAATBFAiEA5SCzZa5UYFMlZrfv2TIz/BiYEfetPEoSgBGsF4rJYpECIHXIrd/LFC8cQfdOcLZL4cZ3I8xEhOFlC9PXTIDqG5TBAAAAagZQQVJFVE/qX4jlTZgsuwxEHN5OebwwXltDvAAAABIAAAABMEUCIQCrM8HqFMhm8bVgx8EknRTUm1q+GmqhqOPskPeHT3xP5gIgAxu/0fg+iooGPt3XdaiAKM5exXA/5dwcWea94uywe2QAAABmA1BUQyqOmOJW8yJZteXLVd1jyOiRlQZmAAAAEgAAAAEwRAIgRFs4gVyCREL0jb3EhYTjTJ66Qrzpp2Mug21ymvTbCqUCIEuzYuD72qBv0br61DlVtyouKpc5SEE6Gov7Ktq14yrxAAAAZwRQQVNT7kRY4FK1M7GqvUk7X4xNhdeyY9wAAAAGAAAAATBEAiAUcxxthhwXEUHhOg+fY521v/P9reNMx3MmiWQIBl9aYAIgCwdPaDKbitx5bA3fMqsBq0H0/uvUwrBH9axMD40mwrQAAABoBFBBU1N3dh5jwFruZkj9rqqblCSDUa+bzQAAABIAAAABMEUCIQDWlKrvnW07WlSf9WgiSutpPrAuy6l+OqtFw4sFlI/CSAIgc5zaEHkPyYeWtRNQVRScLCkhGuwMmeL+48534Y0uT3AAAABqB1BBVEVOVFNpRARZXjB1qUI5f0ZqrNRi/xp70AAAABIAAAABMEQCIEEC2e4GfE5CTfDl4a83hhSax4ooZ5sMNXFIIdtRE1hYAiAfd61QO1gWNTQEH1qjgQEL2kyRC3dyo5VWafXEeAtFEAAAAGcEUEFUSPgT85ArvACm3ON4Y007edhPmAPXAAAAEgAAAAEwRAIgQEIs3oFbw0C5jY2G2B3wjnLcluptijMvQIpHVM1O6PoCIA3B3R6LR41xoxJqtesREvyct4ALk4UC53pY5e9qGK+oAAAAZwRQQVRSn7poTXfS1qFAjCS2Ch9VNOcfW3UAAAASAAAAATBEAiAUyGxQAHHnI48eHax8wCM7hfkINjSyGdVJfQcP/SW7GQIgbhCQBYhmmCSNuOApR0XJmRDt1/fKGfzhnlg2TaVFBBcAAABnA1BBVPOzytCUuJOS/OX6/UC8A7gPK8YkAAAAEgAAAAEwRQIhAK072fEev0jiXUI663zYw7pGO3zhGcn/lWKhPoHPtsuZAiBhO9ICcshNcMmgCX9DXSuCN1gCUjWD8z2sFBwplkSvpQAAAGcDUEFYjocNZ/Zg2V1b5TA4DQ7AvTiCieEAAAASAAAAATBFAiEAl9GZ/1/PiUvEMMepZGqtD4EOVOFuPQAxL/aFPXH+m4YCICf2qRYYnKCa8OLKp60ovbbHVKoEXw1DJlX0TEDwUvp8AAAAZgNQRlIvoyo5/Bw5ngzHspNYaPUWXefOlwAAAAgAAAABMEQCIEa6w57dDJ4gyb+H5gOwPOSSHz/PfeuPeBj+ZXiRUBh7AiBFh3ISGSIzQc2mfY1aoXM+8j1kM75NfjSBk0HybZCeXAAAAGcEUE1OVIG00IZF2hE3SgN0mrFwg25OU5dnAAAACQAAAAEwRAIgQ46BMjXSiGyKOsHzqq/0EPpt3vAX5p6CxpqgvjQM3IcCIBYisXJK0WaEyApMXXEV28kIE6SxVXedkguYrHhwhg8vAAAAZgNQUFDEIgmszBQCnBAS+1aA2V+9YDbioAAAABIAAAABMEQCIAUFKceN4F0+1WOIJ9NUTJeM5iO9i80F+j2Md0tvlmuaAiAFyczpKh/iRZu7DFNS2nRol4pPdQTR81Pndq/ZkLtjlgAAAGYDUElUD/FhBx5ieg5t4TgQXHOXD4bKeSIAAAASAAAAATBEAiATSqbYIdSUI9cJYZUn5hSudxBICR79xrNxoP8OWHyD/AIgLiWP8CY/re6dmGS29LFI/uJaRxkMXsiNAm+PTbRL2AgAAABnA1BCTFVkjeGYNjOFSRMLGvWH8WvqRvZrAAAAEgAAAAEwRQIhAJuUL3w5jS4DH4jQXeNY44xrVV377vu4fWqCatuxD+/AAiA+Q+Vd+0taUym+nwqoJu7eK+V9j+usDn2tLkGufezjGQAAAGcDUEFJubsIq36foKE1a9SjnsDKJn4DsLMAAAASAAAAATBFAiEAohe4ZZDuJ7afy8SLQQUko9TdPhoj6Wraz3czBMj3w5oCIH8lMiyzvczaXV7ViDdqH/m2rF/Id9om/eN/F+leNCy9AAAAZgNQQ0w2GFFvRc08kT+B+Zh69BB3kyvEDQAAAAgAAAABMEQCIBtL8WlyVKfbNBNVcOqxHkrG/6VAH32NtX7qR/yInPx9AiB0eN7f2begfJuL1ozAmjCRBzgcBz2I6JJpDBZ4Ar6KmQAAAGkGUENMT0xEUxSLtFUXB+31Gh6NepNpjRiTEiUAAAAIAAAAATBEAiASgvbl6GLC7ZkEKKpn/QwI1mmbtnc1Cqiudoh9u/vL/QIgTw4TN+ilTyUnaPZDZMoHTCibu3H+aPvr36bszTZAhAwAAABpBVBEQVRBDbA7bN4LLUJ8ZKBP6v2CWTg2jx8AAAASAAAAATBFAiEAslAHzEl3C81idC5bMiYbHYs/BLUacIznemVvDNPk8UICIFwVYQcZRY8xPr3U3MuYwT1Z2LVipdZDTbHhJ3b/qwtLAAAAZwNQQ0wPAuJ3ReO26eExDRlGnitde17JmgAAAAgAAAABMEUCIQDS10kVJC+P+b2mfug0MmScD8fAawQeSMQsu8kmKDxekwIgRTFxjR2woAs/rOMFIxRYxFUVPD+x1k475RPfgi4oIswAAABnA1BFR4rlamhQp8vqw8OrLLMR52IBZ+rIAAAAEgAAAAEwRQIhAIOtxobnkDDlnwwlqcQf7s4g7l94eW9kWizZ6txLaP1wAiANpnNiFyT1eWbwFQpcpmWFGWvQJzFAgGz/FH7+6Gd0DAAAAGYDUEVQuw755hf63fVLjRbikEb3K00+x38AAAASAAAAATBEAiA6orIj6G+Aztmk5IuDvNYfdxzBugwa8N1qkEAPvLci/QIgR6yoEQlUkUjvsW7AnUXaGml4YCe8ZwtR+OQGjmdp6qQAAABnA1BSUxY3M7zCjb8mtBqM+oPjabWzr3QbAAAAEgAAAAEwRQIhAPfFaG9hxMXdIXYAyANxNdY2DlU7M36eRoFtksLgnFxhAiBZPxq+4cgd3cat4tDTaM2MYPIvikIW800JhpDJaQHRgAAAAGgEUEVUQ9HTtmLZH6qkpdgJ2AT6cFULKz6cAAAAEgAAAAEwRQIhANTGmKgXjCFwGdouO08epUlU0tp5qgV6NscWIbZ+d516AiB3hIkOmm89KuFW89S10WyBt4bOBNFPmTTdG5NGv4bhkwAAAGcDUEVUWISWnsBIBVbhHRGZgBNqTBft3tEAAAASAAAAATBFAiEA97WHcDFFdMRm3FMmgTDa2mBSSOX/2oQlk64irMKX4qUCIGgyj8Jmr0dzP0/fSI7KQT19yvF5Cyjq70c4VhWDAt+vAAAAaQVQRVRST+wY+Ji0B2o+GPEInTM3bMOAveYdAAAAEgAAAAEwRQIhAPI6u7JAAdeszIYDdj93JSO0N/jLfQeFmO0GTw+3QqIUAiB+cWkjOss3jQn6SyYy1iSctZfgToBEr/zDj+ZNlYoZ0wAAAGgEUEVYVFXCoMFx2SCENWBZTePW7swJ78CYAAAABAAAAAEwRQIhANAr2NJae44GjTehdNNVYPIj+pkzbtNGxofLle2umjxBAiAp9WovPNWMHFfjKvos2TVjSUVNRW4tWKRafkVu8TMDuQAAAGcDUEhJE8L6tjVNN5DY7OTw8aMoC0olrZYAAAASAAAAATBFAiEAkKn36aW2r2uf1ksZsJTjw40AKaySYKk9X3ohrozxmekCIAyci1ARu5X1hiKXZqX/3eCfJ9qhdaIZ1TvMS/ofGGuKAAAAZwNQTFLjgYUEwbMr8VV7FsI4suAf0xScFwAAABIAAAABMEUCIQDrnniABBSQueqbQsc+xaH+pwwdeu0yD2fIXWy/G3XgIgIgM7QgpqNJhAlAacewf5AAqeb2pN9knnttj3UpHOxxAd0AAABmA1BOS5PtP74hIH7C6PLTw95uBYy3O8BNAAAAEgAAAAEwRAIgNCpXdmy0dtWVI9iXi8ZQz5aLQKXNr0mr4ZlUj/Oy62oCIA2btprJzJyP/k6BMaGM5TQ/FJtZynJFimd/fQUAOFxjAAAAaARQSVBM5kUJ8L8Hzi0pp+8ZqKm8BlR3wbQAAAAIAAAAATBFAiEA15BoJxCbYKFRF5HUiyfxwWJYy5IeNGuFmNvK+CZxEF8CIBSvhmq15pyXt2lAGcemJ1KrphkNy4B2IrIy1U4dAWgOAAAAZgNQQ0j8rHp1Femp12Gfp3ofpzgRH2ZyfgAAABIAAAABMEQCIAbjwbAoeUkH/i9Z9Sci7F72+Y6qmJsdcqiRf1ytapVRAiAquLqjxID4exgc6kNavm+lmcB7etkfgUaepyfNY4QwlgAAAGYDUElYjv/UlOtpjMOZr2Ix/M054I/SCxUAAAAAAAAAATBEAiB5+DI/PH+kaPmnim2kIxgB+crrZlJN2qsa+RtMRx/gAQIgEwsQ51146rxzGIPE/ZDFjQOz0JKZ9oMlDpE8oXwSKsEAAABnA1BLRwLy1KBObgGs6IvSzWModVQ7LvV3AAAAEgAAAAEwRQIhAOkzPRSYayFsCdynkZlMIJ3h2FAJrJRLPATLq8c+W3pRAiADQHjWgCGB5EPOJNVBgk5U+s3JNYeCtfc/UFHVm15WFAAAAGoGUExBU01BWUFqJWKKdrRzDsUUhhFMMuC1gqEAAAAGAAAAATBFAiEAhCx8KyW26L1dXXGxy1PzjKtt4ZzHOZ71ESiVrJHOQboCIHK4+7dKy0jbiebOcPaTm3vsogli9F0rlzD2znv+pVRsAAAAZgNQWEdH5numawaZUA8YpT+U4rnbPUdDfgAAABIAAAABMEQCIFwolMFMORVWz5/bOswtgLy868gnekXwE86Fej4XbHV+AiB4YA6yV9Yby4JELvPjhlz+PuRJhm+shEBFJ7Pk7qRHrwAAAGYDUEtUJgT6QGvpV+VCvrieZ1T83mgV6D8AAAASAAAAATBEAiAwoJPQJiDqnfY+XyBedesTbQ+m6gN36sDjl2IcT2ndrQIgGXZ20qe+hKDJhKplMLV6hMRNnEP49cuIQJY+72h70gsAAABnA1BMR9s6B0JRIvLJyql6j3MY/Mgxjk2UAAAAEgAAAAEwRQIhANPr3hNtNGLP1FgnOY3ce/pmAo8CFITNKMm8CsGEcAcOAiAicNDFgdkPKmkI7newGt71EiuLtUHu8894iUEp5lmA4QAAAGYDUExV2JEsEGgdiyH9N0IkT0RljboSJk4AAAASAAAAATBEAiB3Cx9VArlHDK4T6KZgZHcND7jKELqfYT3sli1uDKU2cQIgExUJJYeRlv7emyC+3BRkN0z6dgc0KIztAyqCK9Z8tsMAAABnA1BPRQ4JibH5uKOJg8K6gFMmnKYuybGVAAAACAAAAAEwRQIhANcDjUx3CjAtC6AGZMFzRfwGX5csjgBPv0N/72u2BBWRAiA9Tl9DzESgiyucFJ1yiW7F4+7oD0C/is5HklE/5p/IaQAAAGkFUE9BMjBnWLfUQalzm5hVKzc3A9jT0U+eYgAAABIAAAABMEUCIQD5opcdu0GMDSQouk44fhd1s6dKBQjE7xMZtGPF/r4svwIgCDSC9ltVdYWVWSz6zKt+Xsc69Lsg13PHJpgWUD7jM7IAAABnA0NIUPPbdWDoIINGWLWQyWI0wzPNPV5eAAAAEgAAAAEwRQIhAM8z1PUtJTzURw+tS/FlkESfp3tU1io8smT1eUGGKvSTAiB01gkZP6gaVVb+u2yDrTky5MVWX8LdaPikQZktjRoB3AAAAGYDUEFM/trlZCZo+GNqEZh/84a/0hX5Qu4AAAASAAAAATBEAiBjQwG38sanBaec0nY7yUBVPEDuaJDk62B1mdjtc6N5eAIgL7Zg3FNKhaut9AGeZPIi9y14JPAE/bzjYddKBP4LSPYAAABmAkFJUSHjSOiX2u8e7yOVmrKQ5VV88nQAAAASAAAAATBFAiEAruGqLvgmnEsurWo4Y0CPY9Ze3/JY8hFvS/3z2Q1TXHECIEH3svKdW0xbCkxFQB6q/YCCkO1SliwLr+GwlR1FLQNMAAAAZwRQTEJUCv+gbn++W8mnZMl5qmboJWpjHwIAAAAGAAAAATBEAiArs/agX/vYpkOl6DWwzOLPQSjjNhzHNDAonrJxdbM/fgIgKQWC+ag+aw0gFQ+xvPNGWo0Y9jWubTWqH2d+hr5qecQAAABnBFBPTFmZkuw89qVbAJeM3fKye8aILYjR7AAAABIAAAABMEQCICdxcRhBEM2tEn2QKsKCUEPb/hMM5hufgSuKcDbzep+gAiBdWvN8FecH2sR/FFgkWes/Ttyu2gJh5FHi/0wd8stgIAAAAGYDUENI4/S0pdkeXLlDW5R/CQoxlzcDYxIAAAASAAAAATBEAiAuqsLbJy3l+jgXYSOfz6+XQH2/BvzgNDzAKdybmGBIgAIgDl7D1iHRRoiQkeZFpfMEHlTohcPcoo8TBThAsO4K/2wAAABmA1BQVNT6FGD1N7uQhdIse8y13UUO8o46AAAACAAAAAEwRAIgJCOFkJ2G18dxhvKu1nUyGBjlCn/lAAAlshfzcull7c0CIAiHFQ6cewESsHW4tjZscugDPFHIaWTakVd/fEJu5oXFAAAAZwNQWFTBSDDlOqNE6MFGA6kSKaC5JbCyYgAAAAgAAAABMEUCIQCvHjAyjfeyBA1GNX6UTFN3hCrAwDfTnHZ0NdPaYlYpugIgMGdEszsIVzrhEw84qS3x1Czlqg67H2RVY0o2/HNeQGIAAABlAlBUZkl6KD4KAHujl06Dd4TGrjI0R94AAAASAAAAATBEAiAYQbDS0/iXz33u209n6nd+u7L5p6ZQgr0kQQgRc8cyzgIgaKkFEWhpMB+Ssj6tJCAMTYhkLqSP4YanUGuJ13Z6IiEAAABoBFBUV09VEuHWp75CS0MjEmtPnobQI/lXZAAAABIAAAABMEUCIQD6zLK1BIRt3LoFlViEIXULwbarhMYKs+nPn51v/xHlBQIgH1c2/E3k7bl9Q0Ibte3mm3BRy1yDerfJMXpg+ePGHC0AAABnA1BPU+5gn+KSEoytA7eG27m8JjTM2+f8AAAAEgAAAAEwRQIhAI+ixDKAfsFIMEdjvUPiK2thiGYqU6heKYwC+Z3On2I6AiAd/yln9SQhAqbgBUjknlgYl+o6A0nU79M3dRSgQgeqQwAAAGgEUE9JTkP2ob6ZLe5AhyF0hJB3KxUUPOCnAAAAAAAAAAEwRQIhAOCKeRFwGvepgUx4wU4UlpcRT2afVb6bF0pHO+Tj6a8PAiBPrIgwzFJWkT+W08NzbIG3IDSOOgkHiZWmjWbWi1l8xwAAAGcDUFVD72tM6Mm8g3RPvN4mV7MuwYeQRYoAAAAAAAAAATBFAiEAnnFoxxSOMGjpKJxOU+tOFI5M/ai6dan2CxY5bRM/51YCIAaT5Wb2/b9jlqGFEc32mA3UL2UI16bRbPhDIKVQEUvKAAAAaARQT1dSWVgy+Pxr9ZyFxSf+w3QKG3o2EmkAAAAGAAAAATBFAiEA6QwMyQnlR0nOqcU988BqNY6UT7L5lT9Vat8DCK95FsICIHbxB0E3ieZ+T0ifzW2VfTJYtnJnl8A5x1ceWjtwxtxfAAAAZwNQUkWIo+TzXWSq1BptQDCsmv5DVsuE+gAAABIAAAABMEUCIQDWNSqlWP/wK3t1CCvRdKuJgRlbmAHjpbkkj92zQl2F7wIgEBh6sGqoAffPMqHQVTvmbYK8k0D/jnHeQSltTKkPJxoAAABnA1BSR3co3+9avUaGaet/m0in9wpQHtKdAAAABgAAAAEwRQIhALZGNdA+ix9dHfoHuuu7aa+ehH/krhUM76YWpaF56tGRAiBaQh9g08vlG2xUASeb3HloN3VC+1BvrpGsZ7VDuK+mygAAAGcDUEJU9MB7GGW8Mmo8ATOUksp1OP0DjMAAAAAEAAAAATBFAiEAgeDTbtwS/aadvTeYe/I5Af1XPZr8/ly8c9sD1fDbnx8CIGW8E7jdyM1+8+aALXuvMEKSL/G0ZcAqZlgpIAMAC3DWAAAAZwNQU1RdSrx3uEBa0XfYrGaC1YTsv9Rs7AAAABIAAAABMEUCIQCzHvqD3pwCAInYdQ56bJCYBK/7KmP1SFX9xhDt1O1TVgIgJevi9/9yElfuknUlzREcXEU63mbmBM1BZgssB8ubZEAAAABnBFBSSVg638SZn3fQTINBusXzp29Y3/WzegAAAAgAAAABMEQCIHMXONSF5dE/xb32IVl2DblS6lfmyVvFU7TehYg3on/aAiAUW3mQ1N7Ov8PU9E9QVa16bqLGD+c98fs/ScW2Kz7pvAAAAGYDUFJPkEH+Wz/eoPXkr9wX51GAc42HegEAAAASAAAAATBEAiB4ThEB1aLPEG2zsPGGdFnZEbWtHqGz44/sgkMsB5P40gIgT8vQaFDMouE+8gxz8r06ui+Y2bQeQDxWPJQ/m63TnzsAAABnBFBST06jFJ4PoAYakAf68wcHTNzSkPDi/QAAAAgAAAABMEQCIHkcWyn+w3obaTzS3H5LaMOJEpkQhBD5ahOD+ZLmstNtAiBFmlfaqCqAn0VQLI+472zzHw+FNWjn4sQgXgVBVVTedwAAAGgFUFJPUFNv5WwLzdRxNZAZ/LxIhj1sPp1PQQAAABIAAAABMEQCIE9iaT/bXuSVHDetOqq1cAYAAnmMGy+8LQF7D7VTelh7AiAHpIIoUhQaU223CLOontBCBLOnuoDWml7a8/+mut9yuAAAAGcDUFJPImu1maEsgmR246dxRUaX6lLp4iAAAAAIAAAAATBFAiEAgPY3a1nxNCMtbMu2KZTkzwlS/5agTWQLhCV+w8YGVQwCIFk6Uq9mBt+fCkWizvApnzXEW4zB9+gFACaDM2ogCDe5AAAAZwNQVFRGiaThaes5zJB4wJQOIf8aqKObnAAAABIAAAABMEUCIQD1Xpz03tZ3tDrsw1Lq2QNBuL4RlZ2j25Jg7qNt3Nz6lAIgBuCN41HBHEz84vhxtff8HbeZ5vL24S90Mzel6QNhU2AAAABnA1hFU6AXrF+sWUH5UBCxJXC4Esl0RpwsAAAAEgAAAAEwRQIhAMbbHGc4zzqrka+4B3BYar7U+gOax4/9VY2AkmTsFBjAAiA2/S8I1ZW8e6Wbgc35zZ4DWqaNXI49qkZGmWKZRCzEyQAAAGgEUFJTUAwE1PMx2o33X54uJx4/PxSUxmw2AAAACQAAAAEwRQIhAJ+NRUOecfDrwxKwV2glc8eJnOHdDVBoZpU/cefg37Y1AiBToSHERZCACk7StyJL0vTe9/jvrCgtS5manSftfZEtvQAAAGcEUFRPTklGWDxbhuAczTDHGgVhfQbj5zBgAAAAEgAAAAEwRAIgBIA36LJ2ppiGNytfYL3m7tTq88BfZMHjyfS2lbRIvy4CIESIQd0sDMOuB4FdFo6+Hi/cWuWCxNR7DTshVegsKZhIAAAAZwRQVE9ZiuS/LDOo5mfeNLVJOLDM0D64zAYAAAAIAAAAATBEAiBJ+HNhNIEcFBoclvug8cs/s66BtRveVeNpTu/ywdHHewIgGoUimBllFP5ufgMTqv2hmtMw1sDkNtBCCbCbXy0tN6QAAABmA1BNQYRsZs9xxD+AQDtR/jkGs1mdYzNvAAAAEgAAAAEwRAIgfSgwXb1kNWTCrrj6ATq7SrTt/QIfRedvmIK2u/Z/LXwCIHA5Mm8IgtQ7/Fnar0GmTccokSewGx2Gf4et67A780uiAAAAaAROUFhToVx+vh8Hyva/8JfYpYn7isSa5bMAAAASAAAAATBFAiEA2CR2KlNiarlBJKCAtvS5mSMOErBJWwSJ/X/52GcfWhwCIHczdcDYpXzSJIjY4kBuZg4psEIZvpkcOLpX91UNXeXeAAAAZwRQUlBT5Aw3TYgFsd1Yzc7/mYovaSDLUv0AAAASAAAAATBEAiA/zpov5WHng1d2Yyu1Bm3LJIoGWxgdd+G77AX4s4d0nQIgSsoXkP6qqhrqyQjQCTqS6e/swIezszSE6td1vOJEZKIAAABpBVBZTE5UdwPDXP/cXNqNJ6o98vm6aWRUS24AAAASAAAAATBFAiEArMo3B6S2AOPr/Mb5mo3jdZuIYKKUjz+TsWYHw5RravQCIA6Yh+xykenpuZuwhUbKfDFLIl8qJtRgL72Mzh8xn4WwAAAAaARRQVNIYY51rJCxLGBJujsn9dX4ZRsAN/YAAAAGAAAAATBFAiEA2py9EmGTQ30X9ZcV7S7mCGRZ9c0+jmP15o30L7IoKs4CICIn4dDbPkbw0fiyWxU/wWsdQRJX6nErVx+rmRIx5crNAAAAZgNRQVVnGrvlzmUkkZhTQuhUKOsbB7xsZAAAAAgAAAABMEQCIHxIArVZDL8s3ngWjgqtX7wi5ZJib2tH1rzJ8YVKgGb4AiBDztpygkVoPE2d5c4+rerSzs7GjPgfMNDkJ+/WaR2Q1AAAAGcDUUJYJGeqa1ojUUFv1MPe+EYthB/u7OwAAAASAAAAATBFAiEAwECfABiswF35j1zuppJgIJnAJhyF5vYLxgeVL6V7z2ICIG2WOYQa/eC8k91Hdlt7YcUKQ5D/g5Ui5Ip4TKKn5DoeAAAAZwNRUkf/ql/8RV2RMfiicTp0H9GWAzBQiwAAABIAAAABMEUCIQCYz0tlWgbAKxJGo7w1eBtITzWfkDZAjWRuHMyNCgUiuAIgSerMmzF1WFZxsOyhYidaBo+jouR70K1SNA4OMpVKuFkAAABmA1FSTGl76sKLCeEixDMtFjmF6KcxIbl/AAAACAAAAAEwRAIgclsqwVEiw4j4TyWFVuLXv0S8aHw4rJmtsx4jqXZ5SDwCIDgVayaeGZ8aboOMrEGeS9AoyTa0mqqUmMjMGbT/uIy1AAAAZwRRVFVNmmQtazNo3cZiyiRLrfMs2nFgBbwAAAASAAAAATBEAiAzkCJbRngTgV47bHbh6Do1zvmxMg+HC5S40IqSnEaSRwIgGP0xBSsOnOHLNGLMNCVeJ/R+nSawkKB1Z1/HBo3Mm2QAAABnA1FOVEoiDmCWsl6tuINYy0QGijJIJUZ1AAAAEgAAAAEwRQIhAP/factcpfLeWAoHltBAB7r6TbSgpt9z1rofP9sVA/guAiAR+UrFSSXuocazOGHLhbo+I397FoujKlL1Mpy8TArrQQAAAGcDUVNQmepNue53rNQLEZvR3E4z4cBwuA0AAAASAAAAATBFAiEAm0n3D2ri+gyqVsyHEIsnSTEb80ujMSnfiKPARcMgaZgCIAErl359BS1J3oUbCyaa0v3JD00Oc4Y8snmCJOjMQoQxAAAAZwNRS0PqJsSsFtSloQaCC8iu6F/Qt7K2ZAAAABIAAAABMEUCIQDa0wINBEvePc23kqEXQQ3xY1DunHJpG6Lzt5h5r0OcKgIgEkVgc95PHk4vN65t/i7W8aCXFfA8QQYYDfQyw7iL+nUAAABnBFFCSVTLXqPBkNj4LerffOWvhV3b8z45YgAAAAYAAAABMEQCICH5dFQnrpEIrXsG83owNvumf9xWq4MUSHCl37v8O/tFAiAycuya6aETEj450Gxa+ujF/+4DtoNgwQgLQKziZB+fFgAAAGcEUUJJVBYCryx4LMA/kkGZLiQykPzPc7sTAAAAEgAAAAEwRAIgA8P9lokWVGF7SGghGWnQmBrBb8IK6xVb/FYX77Bjs7ECID3Cyur/JQHznuMtTqZCou+HhvAJdumFvThHZzD9rLHSAAAAZgNRVU4mTcLe3Ny7iXVhpXy6UIXKQW+3tAAAABIAAAABMEQCIBAQXdkwvVCooxOnTLQRQSO5DQ/bK59CXdmeZxqdymN5AiAPExDPr7JhrjyEGqWojc0kR5+B931leenuiAwc+oL0PwAAAGcDUVZUEYP5KlYk1o6F/7kXDxa/BEO0wkIAAAASAAAAATBFAiEA5V5yZyoczMga3wuiGlHCj4Gtg0+aBcRTv28Qay1fkAgCICd95REaJ/FCRj2JTKrwLP6WlEDN1wlHF95zLw3W0YLbAAAAZwNSQU9F7bU1lCqMhNn0tdN+GyX5HqSATAAAABIAAAABMEUCIQCwI/Is6Ao9UQVvWJCpei+vL94hWBHISlpFMwMMbAqw7AIgN2cljvOT0RlOdLwJmSng43wWqrzbZpFONflb2dpG1qYAAABnA1JETiVapt8HVAy109KX8NDU2Ey1K8jmAAAAEgAAAAEwRQIhAIXLd6Pvlp9qKbpCYZLz0Y60j1GK0Zy5xfpCG2jqyhbsAiBzyXJxretbtpWtnJEp0ROArkkVYOpZGLNegXxDdRnKngAAAGoGUmF0aW5n6GY6ZKlhaf9NlbQpnnrpp2uQWzEAAAAIAAAAATBFAiEAp3D/aw4dsm3/h6U8KfoMYzIYKTJKNyW444ry5MwxWQ0CIBXsDm762S7AS84WE/wyQcotp8dNn3RoCDIdPNx8w3qcAAAAZwRSRUFMkhTsAstxy6CtpolrjaJgc2pnqxAAAAASAAAAATBEAiAZRGhUCC7AKIOhaWoAMHIadCnHUgAuQ39oXFv0LzrEhQIgEA/2XIjI87rbkntEcE/bhgDRumaImU3ucTECU/rbsjUAAABmA1JDVBPyXNUrIWUMqoIlyZQjN9kUybAwAAAAEgAAAAEwRAIgSMXrJDzj3GU3Ri0h6BbsyX7XQAB9zTprTZfeFHiILUMCIGyw0AJetUx0f4oHI5DItQ0rX9foVgeBYdGNkrPsq4o4AAAAZgNSRUF2e6KRXsNEAVp5OOPu3+wnhRldBQAAABIAAAABMEQCIF6rgkFRzJmPq/biZA0/Rji2DY2Hs1Z/cb0aQl1Pju0WAiBY4FQM75DvZT1b5sQGp1GgGllA2sccNYX4qXy7McXmLAAAAGcDUkVU1zlAh+Hbvkd/5PHPNzuayUWVZf8AAAAIAAAAATBFAiEA5c8vIhtHWOtfNCmB+qzqiL7EHxrcbcuiksWZgxcyOS8CIFmvNGRUCVJLB07vY8ysT1GUJT0MicdAzvsCHLB+r1ieAAAAZwRSRUJMX1P3qAdWFLaZuq0LwsiZ9LrY+78AAAASAAAAATBEAiBYsPKIjWK+UP4o9b9G/bc6qiSIzrQoa7d+mDZlFNoVwwIgIVomfG9cWbUOvV/+DXvs7Dy2VPt8SmVqCavpIpIZEU0AAABnA1JFRHaWDczVof55n3wpvp8ZzrRieusvAAAAEgAAAAEwRQIhAPEo5QHx0AH7gxCv3phZ0r2SrSoWChCcdzH3wpPEXLSVAiBKFHhLpZ/Bc7u4ZRUL71ozY48+87Men2okUZA9Je72mwAAAGcETVdBVGQlxr6QLWkq4tt1KzwmivrbCZ07AAAAEgAAAAEwRAIgOY1q8aRBNW/+1chPmZK4ZWYJ0b7kPYrt7/NI3HhxeuYCIFObKUl9fYJGo7WYHUv+OxeQFjoMDfZDTBtr/Z+oTDqLAAAAaARSRURDtWMwCjusefwJuTtvhM4NRGWirCcAAAASAAAAATBFAiEA801fPlSI/j7a782ilEwXW4b2JpqHyUaUO3D4ZQzoRK0CIBJsahXATXRLhOxRJsXIr5mALkuC0/jTHXP/WhyxFj/6AAAAZgNSRlLQkp1BGVTEdDjcHYcd1ggfXF4UnAAAAAQAAAABMEQCIHm7FGThwZf0/exJi2FBuqpDt/QpsQUKtdUc1wJPAZ+eAiAlC5hqPeXR6OSM4QU9gQo0PKwGjLdFMTY6qK/1Xw88QwAAAGcDUkVGiTA1AKer+xeLJ0/YnyRpwmSVHh8AAAAIAAAAATBFAiEAupYDWpEWOTnAXE/IUVkPD0QXXw3hIfUM8G6Vx7aBTmACIEzFkwhvJTg42Wd6mo0+ky2l7e0/f1lnZhXt7fS8gI2kAAAAZwNSTFhKQtLFgPg9zkBKytGNqybbEaF1DgAAABIAAAABMEUCIQDFvvlNBEDjuwGYLg9NosBNIMnDiZtfEYMHM1PI/GIzoQIgdVeFrcOFIOnPw9O1XubJ4br8UJ4IHfd+2G9I5NEFv4IAAABoBFJFTUkTy4WCP3jP848LDpDT6XW4yzqtZAAAABIAAAABMEUCIQCYTB87SsaTFGZxcmUTLaA1+kRC8ZWOd9SKh6GzAmzdQAIgdiPbYJ/vbBY/hCiqPpIuw+m3Z7PR3UKFXzW2cDqVLJoAAABmA1JNQ33E9BKUaXp5A8QCf2rFKMXRTNfrAAAACAAAAAEwRAIgLeCQr7dOxbGavh6CAyolI/8pai3xT1bQe+eBSZQ3xJQCIFzcvp5btJRju0UuYN5xbRDaw9Ev/jpQMCETL+o0GvLvAAAAZwNSRU2DmE1hQpNLtTV5OoKtsKRu8PZrbQAAAAQAAAABMEUCIQDW8PnQ8zleEKdtAMKvzNcfR2VpD73Zkvj4m4KiV4vgIAIgQperg9h0NJ5RrB2mqk1eX3ouVVqvyc395RiVyMky8NoAAABoBFJORFIJlr+10Ff6ojdkDiUGvntPnEbeCwAAABIAAAABMEUCIQCe+ifYdELzxwbnoE6akiHvsLSaWeyBW2T/tVJKeu1PGQIgTfClmJFzFE/PQyvW0lcHJeBTvz+GFdV/ndIcMSjTjw0AAABmA0JSULIsJ4alSbAIUXtnYl9Sluj6+VieAAAAEgAAAAEwRAIgYprZYoC4CqFBqwXy88TZzbOhydTn9fqs7pMxNIh5kDICIGci+rQJprPTPRcSTSVm5IIHemTajNS03SLbOBCrkKqXAAAAZwNSRU5AjkGHbMzcD5IhBgDvUDcmVgUqOAAAABIAAAABMEUCIQCpFrJ0vbx0A0uvdeeGPGcxjXAzapn8Wie8bYQ+YQgc7gIgdLo/IjAV99WcAHdx/HZ0rZdDj/5s6FdVmZ60gFs7e/MAAABnA1JFUY+CIa+7M5mNhYSisFdJunPDepOKAAAAEgAAAAEwRQIhAMQY9OHJJzIYxEM2LJcm3U+D4iC89+uDEVjw64ZfAfCrAiBvNuL0SdCGiTmwpdBLl4WdYB3zrZqKRMX3UZdaFL8hzAAAAGQBUkj3de++T17Obg3y97WTLfVoI7mQAAAAAAAAAAEwRAIgNVNXycmEbp0XpNoYaO3t/SCHlsNcJnJFGpdNKvadBL4CIDHaLRJbe+1Mwa4B3TLqDxE8ku0WRuIVLHMFEQEpgG4YAAAAZgNSRVjwWpOCpMPynieEUCdUKT2IuDUQnAAAABIAAAABMEQCICFkfbx6lxWy2O3Yg9jku++dC9HCobU9/x59yu3odA7lAiA2qnXRqNixCFyBjeMeCT+qOix91NmnV9sTG3HyRb0xMgAAAGgEUkhPQxaClrsJ4kqIgFy5wzNWU2uYDT/FAAAACAAAAAEwRQIhALY6hJt5PBVrp0QNUTc1tlgslb2fkuzz5cx7wwhCyNV9AiALhkvBuATWmPIV2kzz0VkpcpfVneV6KcnCplFaaRE1RgAAAGYDUlROVLKTImAAzL/ATfkC7sVny0w1qQMAAAASAAAAATBEAiANm9A5TzOe8AtCYFJHQyNXlc9doE10FxsCCS5+bSAatgIgHYRH6Q0e3Dw6XAwxmMU0SCn/ld12svMQWu79PdqIK5AAAABoBVJNRVNIjVaClBzkVpALEtR6wGqItHx2TOEAAAASAAAAATBEAiB1W6FQvBgjzjq99qyCfDl9CZnehasJqoUn0rQ08G4aAAIgA4SGYW5Bf8LqXhAyvRuVn9ydFlDo57MJaBemJ+T0vlAAAABnA1JDTvlwuONuI/f8P9dS7qhvi+jYM3WmAAAAEgAAAAEwRQIhAPJc0oHepJbpci382TWJmc74CLJDc8fI5VnAygF7yUqdAiAxpRAM54avbi2TFcxLQFvgoA6zPfQc1WBT2lZ+TyNrfgAAAGgEUklQVN0Acni2Z/a+9S/QpMI2BKoflgOaAAAACAAAAAEwRQIhAMqDeZWIXmRwFYUsUyJooWftt1oqDXhO6QVbxVowIJRLAiAxRcKnq9fFlrdVWN8aXRW6ombt9MjxUUQbfVGjeqnh8wAAAGYDUlZUPRupvp9muO4QGRG8NtP7Vi6sIkQAAAASAAAAATBEAiAxawy/MVMJF323X80LkCdEYytF8sDeuaxkXW7VBSUBOAIgXDVjIonFK8pgkE0W9yWwMWhyyy8iGTipDhQuDu1YWeMAAABmA1JMVMztW4KICGvow44jVn5oTDdAvk1IAAAACgAAAAEwRAIgOqpfQJoT7liaaUZoYEAeHPbmebFdzuD/KnDDH7cbX5UCIA/PvRnNm0iXzvCLq9Z23ZcYJ3RTZ4DPJZ0c+YTv94GuAAAAaARSTlRCH+cL5zTkc+VyHqV8i1sB5sqlJoYAAAASAAAAATBFAiEAydRt9dtK0jf7XItvw0JcqUsvb4nPdwCpvCN5eCoWsBsCIGnOCuZsYUaNHU8ZiZyHh8/fXoDopaWw6UyLS1lCI87ZAAAAZgNST0Mby8VBZva6FJk0hwtgUGGZtsnbbQAAAAoAAAABMEQCIDRIrbu9WaSuYO10hnwpyXLqNi9deQKUD0ExdbTsoThYAiAsVo0xYXbMyR3JL9IRM97nOboTAvifxJDcfg6FvNU6MAAAAGcDUktUEGqkkpW1Jfz5Wap17D99y/U1LxwAAAASAAAAATBFAiEA1lTGBDVbovye+QsemIO37Uq2f5Aq4m7USuQuZOT6XnoCIBZCRedsnoqgvhGvbmkHoQfiqVsOS0K6qcoDGybrlQRlAAAAZwNSUEy079hcGZmdhCUTBL2pnpC5IwC9kwAAABIAAAABMEUCIQCYY/GsGw/1VsJvqzBix7j7wcBRDf7CmsrBmOBnw95A8AIgDU8Qu1H0K4vvoQRLXV8IhsxKRkCbgEAEoO4BDtjYpCIAAABoBFJPQ0ukAQYTTFv0xBQRVU5tuZuVoV7Z2AAAABIAAAABMEUCIQDNX/3l3ROPQWLF3iv7gQy2/G4OhsDOf6AMGm4yQSoX5wIgJGtodT6qCXPmaubqVK/ro/xPK1iNcTeMAYf5x42Wq88AAABnA1JPS8neS38MPZkelnFY5NS/pLUewLEUAAAAEgAAAAEwRQIhAJsFo9UmdoFxR9MQVWt7WhMZ0m7EJod71W3PRNssAdrAAiBuMeUpmg1vowg3uU+epjiL8q5FxRzgvNADth+rQc85SAAAAGcDUk9NrKyluIBWNmCOFMZLC//8LessbOwAAAASAAAAATBFAiEAzRMFqUpUy3f+K2WoOhRECjRSLn9IOxh6kLbhotjcXRMCIH3ZffqSAng+wEc+NzF+iLC8Zd3hSXK99PAU+NrqismlAAAAZgNSVEg/2POali79oElWmBwxq4n6tfuLyAAAABIAAAABMEQCIE/EN8yEDLgmFXztfnJ2C9s9I4UtRCNKx2WMC0plBwOtAiAn+CyZ6t5ponC4SuP04PdEyX0pPnDNw5qQQOBKzPDazQAAAGkFUk9VTkRJk8uVx0Q73AYVXF9WiL6dj2mZpQAAABIAAAABMEUCIQDGmBQTGBWDrfal3/k+n1Xq4U5Gs4DqYwCQSYn0NYEr3QIgJ9syUbBSX1q9gnKeuH1tUNBKdHNVPL4hpsUJUceQwJAAAABoBFJZTFTTCi6TR61I6iCO5WOpzf2A6WKnJwAAABIAAAABMEUCIQDP7LXc+t2EDbNaJS+1LB3U5tlyq1mDHg3TJJjiXrzZOwIgIRpqgBZnj6xtqqFYR3yIXWOva4IVIWbgAKUekmOqjl8AAABoBFJCTFj8LE2PlQAsFO0KeqZRAsrJ5ZU7XgAAABIAAAABMEUCIQCUQVdyXKVzMRsa9ojmFpcOjT1fLQ/81tD4R9qf0YG+7gIgWA12uU0+W0Ep2+km+2f6nynorq833i7NSk4Y0xFo008AAABnBFJVRkbyeMHKlpCV/93e0CApDPi1xCSs4gAAABIAAAABMEQCIDjt9WArj4tUmMtMhQCbUO/O8H8iXF7pCrvofqz17wEbAiADdwc+18EJbfMD3pqGgboO8tXydMP27srUhzvbbLDG1QAAAGcEUlVORd7gLZS+SSnSb2e2Stp6zxkUAH8QAAAAEgAAAAEwRAIgLuXH9vwikezQd9DCynybnmO5Ix5lch6aqfhtdf9LfZsCIHPxr5Wf5Do+qj4xezJ6Flvr50PS+Y0eVpPHe+J8VwayAAAAZgNSR1NMODvcrlKm4cuBDHbHDW8xoknsmwAAAAgAAAABMEQCIAJ8/zPro0Ap9GLeX8jhTXzGS+5zXkKl+5mQHUMLiILtAiA/JZ2f2Li/g2gTf7T7YQQ+li/jD9TTeZB6OO6RV5+++QAAAGsHUy1BLVBBVB7I/lGptqOmxCfRfZ7MMGD7xKRcAAAAEgAAAAEwRQIhALwTToohIyLhrlpkFFK9lsN83jsYlEAcQkyOkbdnGUxCAiBId85QEnZgNFEIa6BohkGKD/5qM/5WpsyIm461nAFBlAAAAGkFUy1FVEg+uR0jfkkeDe6FgsQC2Fy0QPtrVAAAABIAAAABMEUCIQCOcmbUqUL6JD+GxPIo9mitth+ChKL4UDrn4XCoNZ+ZawIgMkppSqa1oBaioK1eUo1vj7IC9rLx2N26wmG39OT2RBMAAABnA1NBQ6vBKAoBh6ICDMZ1Q3rtQAGF+G22AAAAEgAAAAEwRQIhAP2e4TCYygJ/+5HlGhjOmUcOI+vwHzyRweAmWwe0tVnJAiAiIre3yLI1B0CHsUu/yMIldRS/x084+oFCaxm7HnzoQgAAAGYDU0tCSvMoxSkhcG3Lc58leGIQSZFpr+YAAAAIAAAAATBEAiB0hUS6hjeqgfP0AS02tb3jQJQ5BitwaOE9TRJMzWEXVgIgXq/+EY+YPWwuZOoUhb/85EB0/168rpgo4YIN+LJKTXkAAABnBFNBTFRBVtM0LVw4WofSZPkGU3M1kgAFgQAAAAgAAAABMEQCIGbt8ZIE2W8TpoUMXktrgh+c8Di2m/1bw8j6chqZELQ+AiAkO6V/UUYErYlZCU6Ds/u1DVtV6jB4Q1xcDCVcI+IoRwAAAGcDU05E8zOyrOmSrCu9h5i/V7xloGGEr7oAAAAAAAAAATBFAiEAxneru5q7xkxDcN0v+TFmYoMXVG6twaBOH7OWQGB+b1UCIFvKSZuBYOyqVTFSZHWbVZTofwJH2CeXS8mFMV6VQJOUAAAAZgNTQU58WgzpJn7RmyL4yuZT8Zjj6NrwmAAAABIAAAABMEQCICX04BSFkOSjgVx2+wUJuuNG03C9lYdJfedXsxMXYr/AAiBbhubjNRhiiM3uF8KqyXJWmEZFEigShzjqfGGrAYjlUwAAAGYDU1BOIPej3fJE3JKZl1tNocOfjV118FoAAAAGAAAAATBEAiAnZ5solCvqjH6gfOnLYHHN28grPdO+vOkwii+6BelYZQIgbXiVYLP7fVu/tsIysxF3VYtqc3bj+xEikQ6Nd/7Zb2sAAABmA1NUTlmTRneekPw/X5l7XqcVNJgg+RVxAAAABAAAAAEwRAIgMvL3ZMME5tgzFTrPXi4K2l107cBR8P9q9tNVojCNTicCIHtmsUbmqGwzcf6wZa5n6gImLoJYJA1bR2R8Fn/FVyuTAAAAZgNTVkS960uDJR+xRmh/oZ0cZg+ZQR7v4wAAABIAAAABMEQCIDYcZOun05wcPcA/7i5Zg7Ija2H5NL/QUgzDr3dk++5sAiBpVB8UX6QArbmxNfrByTId9XK0R0HoWPR9f0wJHU+/0QAAAGoGU0NBTkRJeP4Y5B9DbhmBo6YNFVfIp6k3BGEAAAACAAAAATBFAiEAuTcOpnPX/B4B/+DUi57aS1jDQDvct15rZOrYh+Cvq1ECIFQ6HaXc9CKiSF7RxWX8IrML/ODbJHRAsoO3Flhm8G47AAAAZwRTQ1JMJNzIgefdcwVGg0RS8hhy1ctLUpMAAAASAAAAATBEAiBRefUgjCA5fzWjFQwkXFzPO9+qb/DoeWitLusACANDywIgOgwmcXNUDlOkku3b6BEzmvqPUeh5uKQ7sRHpEapajSMAAABpBVNlZWxlse7xRwKOn0gNvFzKoyd9QX0bhfAAAAASAAAAATBFAiEAwmaEUIpUk4EqdMOFsDq6N1sZFQ6cba4SJGBIffJmSykCICmrgDZK0qXaExJFxnM0lj6YZCOv4ZuWiKYdGlTwx0rHAAAAZwNTR1Q3QnV2Mk/h82JckQJnR3LXz3E3fQAAABIAAAABMEUCIQCPNuUAvuYP8XExZZIVjNyeO7CwGdTpsEwUyDHHqv5yowIgL+CjC2jeMemT9JULEaAfnlmY2yTrevr6SH6egtVX6dQAAABmA0tFWUzBk1by03M4uYAqqOj8WLA3MpbnAAAAEgAAAAEwRAIgdwTG7BduYctMDkdfbpr4VY5W3JsTPgQd7lfo4GrdhDoCID1tLBu2CoS/fm4Ax6a7uNFyvL6kaTw1MQy3uMElctEgAAAAZwNTTFl5KMir8fdO+fltTQpE47QgnTYHhQAAABIAAAABMEUCIQCdzzX7EMPBiGrNDWfIcMZA4ukavk4lKOQdJz/q3zi+2AIgMdNupGunXHMo7KePiNjKFBguRapbO/PWb9HXWYIBUk8AAABsCVNlblNhdG9ySUynQYVTLcF4lScZTluchm3TP06CAAAAEgAAAAEwRAIgbfjq3re0U+doXGnhGpKWQmVj3WDboRxUc0jSutdOQkkCIGBy47fm8FAvS1FuFLUaMYarAlZ2f0ckNAR/+nsUihJfAAAAaAVTRU5TRWdF+raAHjds0k8DVyucmw1O3dzPAAAACAAAAAEwRAIgS+UHBdnsmaQrHKOd4TIvHRap0HilXwEktFugzxnVOEsCIHafAm8bgMHKBrcYE/UEWrZ6W+LLzjfwyi4W0eijzuQ+AAAAaARTRU5UpE5RNyk+hVsbe8fixvjNeW/8sDcAAAAIAAAAATBFAiEAq7gw5bOp/rj27DAYcfE0CPN459AJqJF30sOX1kaEjhACIEiGFpTVGYdjrMdgMQgPENu3CUUxocA0p2xb88CeRdNnAAAAZwRTRU5DoT8HQ5UbT24+OqA59oLhcnn1K8MAAAASAAAAATBEAiAqo8ERbnyTSFUNfykVfN+gXa/qnmp+HXsNb8VrF7oEGgIgRe1gRdjJLoKnTJAL4CBp8a3OuTWt+r8WG10jrHDx2joAAABmA1VQUMhtBUgJYjQyIQwQevLj9hnc+/ZSAAAAEgAAAAEwRAIgLA1j5sEHtt6gL4xXFlI/Qm1UIeCBFf9O5IJdbLJy5icCIGu4oKz3yDVaXRKzrluyRbWQjhitDIA8zIBKFW0oHchuAAAAZwNTRVTgbtp0Nbp0mwRzgM7UkSHd6TM0rgAAAAAAAAABMEUCIQDoe/11zw8/8dksCl1FloqMitb0AXMf+3gQDnASqqgUxwIgKpYmn54TAj7/Vp+Dnh91dWpk5rZrOFzAkqX0xKI33BgAAABoBFNFWFmY9em38OM5VsBEPoG/feuLWx7VRQAAABIAAAABMEUCIQDlSDSnK2vgSew1Qf/q9otbbcFxhAXozvuKXvVJhWzuIQIgYNNKbvfQjIPnpGgOUUxiI0uOJUF/04Jpf9dOELE7Q4sAAABnBFNHRUyhzMFm+vDpmLPjMiWhoDAbHIYRnQAAABIAAAABMEQCIErkQ31xC6YBQZiwrB0IJWRypfOqFp/98Qb3Ov899AIQAiBwA1PqqTR0KtLlnq/JzG6MUlQq4TK4iDAUYLv2PypceQAAAGcDU0dQM8Yjorqv640V36885ECV7+yD1ywAAAASAAAAATBFAiEAkcHsHov74QIV+ygYji7/mARTg62no1hmltDKQufKcXUCIHDRTeJ4GfT/59cI4kmtj18iy9zgQKawF+E8KYUwMSrmAAAAZgNIQUuTpxdNr9MdE0AM2foB9OW1uqANOQAAABIAAAABMEQCIFuqXOGIB7RIBMtnDwD+7ICY1seYTLgn9p50EEKCW396AiBal/OxxamJhIC1ZdQwsMfhPUaLPjIVDLIC9YiaRd0p9wAAAGUCU1O7/4YtkG40jplGv7ITLssVfaPUtAAAABIAAAABMEQCIBheDlM55X+JlKspBMZlXgmiIRyD8KHIpjbQQHM7JaAFAiA5qgPf0/n7fzkihuYcLU6iBmiSNYT2uVxziMzJG88JywAAAGcDU0hQ7yRjCZNgoIXx8QsHbtcu9iVJegYAAAASAAAAATBFAiEAygUXYG0bLGBgPh7YbREd30HO8jERLn28hw3l7GXWJL8CICYYh335TzFX9CBwShWATIe8WYaIdxN4LWTU/pHQ+NDVAAAAaARTSElQ4lsLugHcVjAxK2ohkn5XgGGhP1UAAAASAAAAATBFAiEAiRQyuaxQlFhTVA8YA8Z9aOVAEwE5Joo0Es9JdKDLGjECICUzF7z9gNUN3/osBx245CQuN89hP5OtWHqoc3HTIhYIAAAAZwRTSElU7y6ZZuthu0lOU3XV341nt9uKeA0AAAAAAAAAATBEAiAZN/PPMGowGsfHnyZJHDlRv1IbBD9nq+pdjWkRrJHH/wIgDLhksh6uLxC4xayO+drZ7Q+8tCbFZtT9CjShwcJ/ZS8AAABnBEhBTkRIwbLz76hfuvsquVG/S6hgoIzbtwAAAAAAAAABMEQCIDwX0jFeVXr9PUvZg1j1SXIsXNtYjO+pF3qvzC4f5pN7AiBOBdo9iYtSCPI6l/lXtmp5dXC/Rd/BBvGYpG+zfl9yRAAAAGgEU0lGVIoYfVKF0xa8vJra/Ai1HXCg2OAAAAAAAAAAAAEwRQIhAJfDuNajzH2RjM6kS1oMt2YZqOVYmxKWdQ3CcyM/DKJ6AiATByLaJ6dkC1tAb8FDeptTp5UoutEaaMyC7DHfG+RmHQAAAGcDU0lHaIihbql5LBWk3PL2xiPQVcjt55IAAAASAAAAATBFAiEA3CVznouGy74ho4ztXSVcXLyGTkrzdWBUNrot4dUfzdACIFKPorXCTr2j8a0MA/L1vIg0OwRPhlbS8yhBLOeMAnkBAAAAZwNTR06yE1q5aVp2eN1ZCxqZbLDze8sHGAAAAAkAAAABMEUCIQCwb2358Iy5GHC1/ULqJWPEeS33elpMKBbcTstpcr3QBgIgaiIEx4iBDYwi4OiwvVOMnBFKvPxD0l/vBcEvfRoZtW4AAABoBFNLTzFJlOgYl6kgwP6iNeuM7e7Txv/2lwAAABIAAAABMEUCIQCaFaw7TI4mxkv1pT7AKE6CRcqVM+CG4hhf3tNr3uOGdwIgd169RyxJsXTuKxEdr1/jOkwr2jRccw+nn8nN95887x0AAABoBFNOVFIoWQIe5/LLEBYuZ/M68tInZLMa/wAAAAQAAAABMEUCIQDlxJul30zp3VJG5dh2yn8FIBggyhWeEicFxrfii+wzhQIgUXZs7hbgflcqAw2WVJey89j6DAuvjsI1mdZ2GmkPi3YAAABmA09TVCxOjy10YRPQaWzomzXw2L+I4K7KAAAAEgAAAAEwRAIgX9jg0HHA5XQ8JMlub9W5awzYtNBhw6wSz7YDu2PfvhwCICi7gKPdjuRzQOWNFkeD/4kWMkEiGNUV+4vyhKTSARGKAAAAZgNTQkHsuPWI6vWozp2WSwrOzl2VThMOLwAAABIAAAABMEQCIHvotNCVsB/Ai6RM2IKaTFQHMAdNRem1sMAhGk75aLq9AiBm04jeF/v3RAHuVPkzfK8dIqplBvfVNHr7ZzR5gTZKTwAAAGcDU05Hz9aui/E/Qt4UhnNR6v96ijufu+cAAAAIAAAAATBFAiEAyblc/kHBtVI04IoIe3jzWkfA3Jcrk8lLNsoIs0VvlsQCIDTKCrqBD6N+2nStP6Ns+eF7YBJEa4ZMT88YCGgO6PXUAAAAaAVTTkdMU67C6H4KI1Jm2cWtyd60suKbVNAJAAAAAAAAAAEwRAIgGzaa9sogkgsRcr2UzL17frfS6Y6i4FnRE8mpq+TWz5YCIAjIsWj5cPYuV0gBlUaOpbq9QGyaeO9GL0ESiFMQ38jdAAAAZwNBR0mOskMZOTcWZo12jc7Ck1aunP/ihQAAAAgAAAABMEUCIQCk0sVq5o4NJYz1H5X3wrgtxdayzsefeTe/fn9uSS/CDwIgd2zkiG2NNMvFfawANSlQ33cTAVYR5ocjDEqinKOxnowAAABmA1NSTmjVfJocNfY+LIPujkmmTp1wUo0lAAAAEgAAAAEwRAIgY/AquYswK6sspq9C1EqT/CrJuF1j8HRevqpuCGwKUwwCIHjwll0gPoQAvUoA+0tKvpdKAW2rlPHmyGyTBARaY1dKAAAAaARTS0lOK9wNQplgF/ziFLIWB6UV2kGp4MUAAAAGAAAAATBFAiEA3+deJo0wM5Vm/vAmFIXvLCiRa0lcQT+sCY8+JOwNB4UCIDFliZgRpadmtpY1JNJuqyYyvahvodV5jXUYe5FJXOIWAAAAZgNTS1JMOC+OCWFayG4IzlgmbMIn59TZEwAAAAYAAAABMEQCIDpAck/mVJLcTjNXWWpdieWZVJ0VjjWKcBQXP+6exJ31AiBsdxpQJvs2XN7DS+0H4p7eeJ0EBuULgo1sL/yDwnVkjwAAAGcEU0tSUG402NhHZNQPbXs5zVaf0Be/Uxd9AAAAEgAAAAEwRAIgBhjfy5Ztaid4UJRPKkjy8cLAhv0zXYtgC6YY+AVjLa4CIH3+9sSS1M4Wx+ELT5Nx+oTkJDX3V84eNInsmv39ych4AAAAZwRTS1JQ/f6LerbPG9Hj0UU470BoYpbEIFIAAAASAAAAATBEAiBoXwd+c3PRMHEFvMxZjRrjGe6ONOZPLXeiU34ysNPpeAIgJtFnfacrIJisyJ+gDD3Cmv2Ey0B1j1II2c/7Vl/3zXcAAABnBFNLUlAySkjry7RuYZk5Me+dNfZpfNKQGwAAABIAAAABMEQCIF4zNDv5genCp9Ow2ivN3AMTKxHr3C5SqfMMIYXCc8bYAiBGYNLnKwfaLP92TcLN0MXVdCVjpwDxkuagGLSmxV4RIwAAAGYDU0tN2ZuKf6SOJczoO4GBIiCj4Dv2Tl8AAAASAAAAATBEAiA7PBa3TLj2gARvwhv+aT76q04tyFfxxZA/aVYeOG4RXAIgTlptJXqejJnHniibdU/kY81B28a94qtqi0aZ8LAq+14AAABnBFNLWU1yl4YrlnD/AVGSeZzISXJsiL8ddwAAABIAAAABMEQCIBDgC+hxb91ZVes8TGuifnMWoNom9A0aOpSZ9DhJRtcqAiB/KjVCiPogzaYuvzRF0rt1wYmCyPSoI1vq9mq7B0G6IgAAAGgFU01BUlRvbetdsMSZSoKDoB1s/usn/Du+nAAAAAAAAAABMEQCIEQYzH+vPAq8/WebgwnbQyFVPwnjIyu0Hpzf4vxJEoHmAiAPWGbmtwT+uMHUnYvHiE/MCFGyCsy7HJPvgGeq465dWQAAAGYDU01ULc+qwRye69jGxCED/p4qatI3rycAAAASAAAAATBEAiAhBckifvKDq0SjAegCTr7hx+n7IGpbXKtlzWF52f/3gAIgTgw9M3k09uk1793zus4EIOM4QYIGZ5Jpzx3wYXBC2eoAAABmA1NMVHpf8pXcgjnVwjdOTYlCAqrwKcq2AAAAAwAAAAEwRAIgLo48C1JrI+Sha2Fz2r8l9FcWfka4y5qCgZEtrkmZwyICIFJ+v/udvGK2hSkOPivpvo605+EG+NYY2xnCcIsFkchHAAAAZwNTTVRV+TmFQx/JMEB3aHo1oboQPcHggQAAABIAAAABMEUCIQD5tqUTgqCXJzHx7B1PYZ/lVgunc9hZhOYH8UBCWvCFKQIgPI6uXn8OCds8ocZTHgp6zBCp4s6YVhtmZ53KFmkGlHsAAABnBFJMVFm+mbCXCfx1Owm89VepkvZgXVmXsAAAAAgAAAABMEQCICl2Kwut2K/W0f46ztV9CZeQTaLzXHsi0SJZ744+mYh9AiA4R6dk125I7wN+UXJdYMeq95D5xTkcQZt5tcmKuA+tXwAAAGcDU1NQYk1SC6suStg5NfpQP7EwYUN06FAAAAAEAAAAATBFAiEA5qKdJBD5b4BQ7I6bNui8EL21PUTUaL8imdor02BoCj4CICfw78A/GvIMEAviFPwWcpJJ2oYyN9o0H+Wrx+iLvWdvAAAAZgNTTkP0E0FGry1RHdXqjNscSsiMV9YEBAAAABIAAAABMEQCIFoeW9Pddtw3ENqbNOon/RPuaiL341etii6z4INDjkV0AiAestJ0WryeErTsFexXoZxS41CwXshrHdiBh9X/Zw6J0AAAAGgEU05JUET1iK7rjERHFDnRJws2A8ZqkmLxAAAAEgAAAAEwRQIhAKzfVyB2hmYM/8KFzr/TrvIrv/sAAZd7E5xresIrfiaPAiAXw5ausHBgidOu9p3RuV9rCjPrMa+npm8X5rMEuNU/rwAAAGcDU05NmD9tYNt56oyk65loxq/4z6BLPGMAAAASAAAAATBFAiEAo21Bih+DR1DJLuSfIPPH2MIrMwLX0uSVPjILe13/NkUCICCB/9x+tWb6rB0wyh2amyRuCTnuVaOuBEUnJO9R/nIjAAAAaARTTk9WvcW6w52+EyseAw6JiuODABfX2WkAAAASAAAAATBFAiEAlJfhtkA0zWEeOxIaQ4XLsdzRO6SnBVMPHVR1AuTT/sECIGFGczXV04OjrBTv8eaG1zbQsShiVFuBRk0LxHB/PqVwAAAAaARTTkJMGYqHsxFBQ5E9Qin7D21Ly0Sqiv8AAAAIAAAAATBFAiEA/hPBr1D//ehToLCg9O8Xvp2emrEtzVDCNrMNR4R4058CIHtxOJcEQvrI6e85l2y9WbR71yUykg1jL4CQnmpQgcGSAAAAaARTb2Fy1llg+suOSi38ssIhLLLkSgLipX4AAAAGAAAAATBFAiEA8IMS6cXoij0dKYCjtjh4v3NUdt3bnA+ayjQ4GTGEgXMCIGFymMepehoz9Zfp4K+TXnnn3LfJ4Y5yqPjD1MG0ndstAAAAZwNTTVR4643GQQd/BJ+RBlm21YDoDcTSNwAAAAgAAAABMEUCIQCPZkIOY7quEV0P2Vs7KuJvCRMcdaFBcZrUENhnNJ/XfwIgQOFEVVbI3GxD5QadDc43XICBuzsM25+iduCH9iyu9YoAAABmA1NDTNdjF4e03Mh7ElTP0eXOSOloI97oAAAACAAAAAEwRAIgaGjf1TJQcwWIHRieA8g9VdzQ9S8DvoegD4KlQWDfFQYCIE5q/nOvpJ5dJ87jxoBWKjrScoSb6PUADLwqpZJNnPgCAAAAZgNTT0wfVGOLdzcZP/2GwZ7FGQenxBdV2AAAAAYAAAABMEQCIFtSUhsf2or0ORWcb69bptM634FpvPMxUplysEndNaowAiAyHMAILj1wWFtD2BDnEfhsdsnzHkK84+k0ptVbhfPXlgAAAGgFU09OSVEcYqyit2Bds2BurNp7xnoYV924/wAAABIAAAABMEQCIEIYKdGVt+/S6Qr/0tcU3WmWxPSCg70XRr8SqTj5vnUVAiAcjbNyhHC1I+3jq1rhQU/LqI6W2+zBE0/pEazS56LI7wAAAGYDU1BYBaqqgpr6QH2DMVze0dResWAlkQwAAAASAAAAATBEAiBosoY2kG4pALbboMk69BwIWTvnbGeLnCU+UiObg2PhXgIgS5uLFu794ZL0FmxO0+y37CqevnP3AjL1FZADrYqUX84AAABpBVNQQU5LQtZiLezjlLVJmfvXPRCBI4BvahgAAAASAAAAATBFAiEAvrOyplUC0U6cJHwCzXSU0KKd3tXjidodNX9VkRE5WQMCIE8W0c15XBIRPruAA6xabuFoPtHt/m2k0sMVrUei6QZ5AAAAaQVTUEFSQ1i/ffV9nacRPEzLSdhGPUkIxzXLAAAAEgAAAAEwRQIhANww+3pY7vh4Or5uGRHPmrcCJdQ+zY+XM5AbIW8PDc+xAiBVGw4Y0x11jJ5+r40gaUDl0UZ39cYiXwFSkT1GHR1ElgAAAGoGU1BBUlRBJK7zvxpHVhUA+UMNdO1Al8R/UfIAAAAEAAAAATBFAiEA09KAGLbKnTBmfZg3ZFxt31KhztYYYTBLNHNWcI7NhYICIGb/o2WFQd4IM3/7RZNI6w7xzvezs2e2QkoPXSb99nAXAAAAaARTWERUErMG+pj0y7jURX/f86CgpW8HzN8AAAASAAAAATBFAiEAk20pIfwAv7GSYiuwJVTJn5TpvdlWesYrFiZnqXYBkEMCIDdbBtkQy5jTO9AjVIZwZA3JT1AIlmRP0lk660p8ONv5AAAAaARTWFVULILHPVs0qgFZiUYrKUjNYWo3ZB8AAAASAAAAATBFAiEAvjzFn584wHN6QlE594fPvE7m/kbzNWg7Yz0tOwjYF18CIH8KVJxyXcbTUUZM9AzXXZTZKiSRvbTBXHPKBQ5K2n9bAAAAZgNTTVM5AT+WHDePAsK4Km4dMemBJ4b9nQAAAAMAAAABMEQCIGZdsj8hQm2uDeoaE/45atWSGIcfBS/+9MBzAg+LqSOYAiAZ0dvg00nGZEqVKnBsrV26t7VMK8IBPuz7h4KJCmXT0QAAAGkFU1BIVFg4M92grraUe5jORU2JNmy6jMVVKAAAABIAAAABMEUCIQCm2kAEuvuT1GHmwt55h5sbG4mrLM8Uc8FpDcx3sVkxvAIgCCi7Yra5hfmSHuCx5a/8ELMAZUiqozqFaQca9LgJh7MAAABpBVNQSUNFAyTdGV0M1T+fB77mpI7nogutc48AAAAIAAAAATBFAiEAri7CzriXSBUtMJi8+6diec0APURDnJ2t+r3mHQegqFsCIGELqBo1elm9vc41ffcDm0qu9QclMBM9ELjjY5cuSto7AAAAZwNTUEQd6pea528mBxhw+CQIjaeJeeuRyAAAABIAAAABMEUCIQC3kmpmGNP7bWtffL0ldm1ZN1BnRM8Yhm8tirizjMyQtwIgF9uy/AGBGOb/GXioBxxKPTzHA2Sy+mNdaUHvqO2ty+gAAABmA1NQRoUIk4nBS9nHf8K48MPR3DNjvwbvAAAAEgAAAAEwRAIgaEhFzR790gltoZFX0+YPGniN1cTvyQb9aiQugEBys2gCIG3YoMbAa8Cv7usYwPVVGTlNAJW1+iYlfqsmTXGpMfbSAAAAZgNTVEIJvKbrqwXuKulFvk7aUTk9lL97mQAAAAQAAAABMEQCIB0a1/nL1KGX1qAsE82Pqd1equH/HakX7584fpAJc5iGAiACl24A6NhET6BaD/E5L9+M1bQ5qm2syG18/2oalW/uvAAAAGcEVVNEU6S9sR3Aor7IjSSjqh5rsXIBES6+AAAABgAAAAEwRAIgY7eGy/cp7iG6cF53RmkKQTMzKvWm9k5tYeCLjy3Zxe4CIEbUY4epwFJX3v6rVgnsuf/HFCGWhg6XPFpeDXOL5KgFAAAAaQVTVEFDUyhnCPBpIlkFGUZzdV8SNZ5q/2/hAAAAEgAAAAEwRQIhAKXMgT6xZencZJ9geJKvCxVw3bBlR2FZmH439rrYEC5CAiAPy8fF9UtE/Yz2hIU0Nc+/IRwxoN/TgmQWMMwu0RdX5QAAAGgEUE9PTHebe3E8huPmd09QQNnMwtQ603X4AAAACAAAAAEwRQIhAPw7dIUtmEVY4mnqVfd3GAyEKGZGQgsju3duCGFUu6XOAiBCKXyfRI7fVbI/2RXALfHv+mafa+VlodTenGwzFGWD4wAAAGYDU1RSuuI1gj1yVdnUhjXO1HNSJyRM1YMAAAASAAAAATBEAiBf6QlkBGPJ3QAvExe/gQ5HZ3eDBY7AH/lZQOXcDr2vAgIgZQw5Gx6sLiscMtu4VgsaFKNCML2YGGpWIQkRA+BocnIAAABoBFNUQVL3CmQr04f5Q4D/uQRRwsgdTrgsvAAAABIAAAABMEUCIQD5Pb+T0tYiiH9lVdWP4o7FHyUmVen/lb1cQzEV5OiOsQIgIpenp9/jkvbN6/yOMAHHqWwJ6s6pKCVG2u4GoKvWSPYAAABoBFNUQUOaAFyaib1ypL0nch56CaPBHSsDxAAAABIAAAABMEUCIQD/tHChYINZzuwwkjhSYC19nqeQFWwuxtuApsgvSB2I+QIgAa6pDljXP92g3zwlAozyd4+4Ju/qp5PyE/YWNWPCsRAAAABnA1NUUOzVcLv3R2G5YPoEzBD+LE6G/9o2AAAACAAAAAEwRQIhAIc8S9PYSGbM9VWPgISkiiNLep7LRZ6HTelPxnzmRi/nAiBBEeHa8mQ/wlCdhPYzKSPhR2kCCBrTi/gMqu1E5qU6AAAAAGoGU1RBU0lBY3TqkWk/Hsy093BaHLrZlMC4+HQAAAASAAAAATBFAiEA32WvzMITOCqM4MuJJq6TapxGrEMGODvh5J57B7wyTtACIAMhqD2zFlfKDRa7QisgH4CX2lxpH+Ju8CLs+2IXZ5a0AAAAZwRFVVJT2yXyEasFscl9WVUW9FeUUoqAetgAAAACAAAAATBEAiAbUpLy4sjPh1Xu59d9kCQatcbuxqQfFAHJOIyLbHCgMAIgS/YOjNwBBdkkXLWTjkBBsbv78cJ8CzxC/G9o/VyMoHsAAABnA1NOVHRNcP2+K6TPlRMWJmFKF2PfgFueAAAAEgAAAAEwRQIhAJS8CuTwcFHbMiQVs3vxKNz12xFSeoADkyVB9ncqZ7T6AiB9NYanIrnsMP5YR7jHq0v7d199MgppAI094K8FiAhX4QAAAGYDU0dU0kiw1I5EqvnEmuoDEr5+E6bcFGgAAAABAAAAATBEAiBbArR0WGWkVol8DOgQoTshzo//cv7CuUZK/ygPCRbSdwIgA1996Ft+vAey+oO5kgdS1OzIwo1GnjdIsSN3Xxcy8XkAAABmA1NUS65zs40cmosnQSfsMBYKSSfE1xgkAAAAEgAAAAEwRAIgaaTMMhWMlo1MZMc2Jtzc/Xa4as7ZPDpE+a2KtmsSHgMCIBgRFw4W5HxmaOQ8kgJ58y8HTfsg0pTd8vGIJeuSn0b8AAAAaQVTVE9SSACcgO/09dj8orlh7mB7ALnGTvnyAAAABAAAAAEwRQIhAKTQXtA2HDlNHjeAxXwiDcToWrqbE2H6fvHJ3doU1S+1AiAH9/qpdP6mxAnLC7uCCPci94axNVlstItyqiwcDnPx8AAAAGYDU1RRXDoihRDSRreKN2XCAiHL8wgrRKQAAAASAAAAATBEAiAYADuY+jyTYJIOG6nN0+LvyxLZ/Rf1Jg3yIiGIohJOGgIgDjOijGn4sDja8bs0HAon0Xi5edUf2PpKZTlXgsVLjJ4AAABoBVNUT1JKtk71HIiJcskIz6z1m0fBr7wKuKwAAAAIAAAAATBEAiAUgAFGfkbV90Er6gKkR+AWCV+bwR1inEhWYaLxx8UJXgIgTVmg5anDIfyFdwxrdn3SKvaRG0zW7Gy9HHrAXBcc1HIAAABpBVNUT1JN0KS4lGy1LwZhJzv7xv0ODHX8ZDMAAAASAAAAATBFAiEAvrUc7WuB3LbyKSM9DNI5dXLWH9RY44WPClU9K6EwQzACIElMjiUroLhEJCuSGsQjt4eKzk3zmBqDCIMWi0VmEBBsAAAAZgNTVFgAa+pDuqP3pvdl8U8QoaGwgzTvRQAAABIAAAABMEQCICKxz0aYcjZXQcP2FUI29jmzZfTv0Px1k6+pWug3jgYWAiBz7AiyQ2ZMVyrJyx0p6e5XVGbx/eHDWbKU9frGTJWJmwAAAGcEU1RSQ0ZJJHN1Xo35YPgDSHf2FzLXGM6WAAAACAAAAAEwRAIgdwt+rbHlcqj1LpW4qw1skS/+/9Ae5ZBcH3rUNRpCRIQCIHIe4XJG9p0StM0yv6hPkMKAqVJhBgVdgz4bVtIC6m1nAAAAZwNTU0huIFDL+z7YpNObZMyfR+cRoDpaiQAAABIAAAABMEUCIQCZoyJ5SGzCrNmO5Uze0dRt0KlG6HUz8TEJ/s5UA7riGAIgMV4rr9fZus1MQISdRJuwKPIDWPfaCYYPH/mLTdJHhsgAAABmA1NUQ2Ka7lXtSVgcM6sn+UA/eZKiif/VAAAAEgAAAAEwRAIgf6WtyFj6hlw9myCiFxV6Dw5ucxJpfd5BzzEO3Ebbt8wCIGbHgrWow/g9TWXQZ7v9+4UAIwqrTT1IDTb6Yex7vENpAAAAZgNTVFUDcaguSp0KQxLz7irJxpWFEokTcgAAABIAAAABMEQCIBjMdzltCigyjYNPQdD7egG6VKITAed84SdSj1Iwz34ZAiBQyQrxjSHHQqRrz+6dEq9gOzUvpHiO74AebvWG3vEpiwAAAGYDU1VCEkgOJOtb7BqdQ2nKtqgMrTwKN3oAAAACAAAAATBEAiAaCvGY8g1JFdKKF9f2vAhzGEtOivLtrNbmhCPJiPe69wIgVgCh6OYHOOeH8f1uzclciFb7bfNQlenvT4DBMr5jxcoAAABmA1NVQo11lZ8eYewlcapyeYI3EB8ITeY6AAAAEgAAAAEwRAIgNv5YGHI/a/h1nmqt422/VKGdvMmjXb1HAMPCg4n3/7YCIFc/sj6BWdTUVi4o1i3ioNPI+KSsBB4b7bBm+C/xO508AAAAZgNTR1LLWgW+8yV2E+mEwX288DmVK22IPwAAAAgAAAABMEQCICPqN3xkz+3nmPj1xxMR6Rt+Ut16co9J6hDnpRnQk25FAiAyEqNE4LPrZvVgMOqytUeIUy4SnkkgJNpq+DS0HYYR4QAAAGcEU1VOQ2sNe4NXu4Ud6fGVMZnDnHvEZ1eWAAAAEgAAAAEwRAIgN4vU6XWSqPi6NufHn4XTXZef+1N6tdCdouTyyJCyfVwCIG6wii+ZFGYH/INAxRdM7nGYnrOS7giI+t0yHq3un+hIAAAAZwNTS0UT23Szz1EvZcS5FoOUC085VeBQhQAAAAgAAAABMEUCIQCEdaRiAuGIbuz2wVunjMPTsNcNznNbIdtUDwqo9rwaHQIgY9KWR4VJG45uigUCKi03ijaw73HTWq6hQGXMo0UYeZ8AAABnA1NVUuEgwey/3+p/Co8O4wBjSR6MJv7fAAAACAAAAAEwRQIhAKScgduzH6UD+l5UBCbF0LwekB+FUW/6Y3tF3bBfLWjsAiBYLjRiIGyYZ5KVwQ2VqbPIRb7D7hXubI682X71zNS2IAAAAGcDU1dUuef4Vo4I1WWfXSnEmXFz2EzfJgcAAAASAAAAATBFAiEAy4TqvKw+PIXprsdxDYh8gOatS3mh4Ng8+YdolMdmHFECIHNpDtJctU/MbaodWK2rxT/W6zHDXiodKst82qoEgUVrAAAAZwNTV02eiGE0GM8D3KVNaiz2rZNKeMehegAAABIAAAABMEUCIQDZbtTGJAXXOp60iMsDw89Ux+AW+ic9TaQpGr5oWs8ijAIgAJV5A2MuNiehO/eBaW7UpqQAWkd+9gU5pYuIMumdnwAAAABoBVNXRlRDC7IX5A+KXLea3wThqrYOWr0N/B4AAAAIAAAAATBEAiBDQ7BzgZO2e+Dun+6MAEWwwKWgKl3F0XM1uiOvIzCm/wIgQxP6O3zk8Np/mo+mnShooyIxvMw9I5WFlLoil5eSF28AAABmA1NZThCxI/3d4AMkMZmq0DUiBl3AWCegAAAAEgAAAAEwRAIgXEDEBQpRf+cwchU+uB73YSm1xi3xLrqjzrpqWxhfxYUCIEeJHxUSE8Qb/YjX2tgIonT48siy33VoYU0L/Rx5+CxtAAAAZgNNRkdnEMY0MqLeApVPwPhR2wcUamwDEgAAABIAAAABMEQCIFcHtAoyVl1OoMJ+L1qqO2qhSTHNVIBUJ3pRjAJPC1WYAiA3Zcw7cVCOI8KHpgP00BQayuXXBDKLd5JlWJmWDBqSygAAAGYDU05YwBGnJADljs2Z7kl8+J43ddS9cy8AAAASAAAAATBEAiBtE6rotTuFDup0f7EjQtT7pjpfPujYSL3Q9lRoxZUG9AIgRsqUJ25eCLSZT1vnyBEV2KTB0+aVLbfINfQ0RLmS3x4AAABnBFRLTE4GddqpRyWlKLBaOohjXAPqlkv6fgAAABIAAAABMEQCICtDXghKnS/3A7kKjsxZzLdNDHHk9ciep57nfAvlTPCaAiAfZhkjhm2klO5xG19Lx4liPTBXHjW0zr1cUoKgaJ0WfwAAAGcDVEFOLDYgSgcSoqUOVKYvfE8Bhn54y1MAAAASAAAAATBFAiEAuQCh7r42o+ab44zcPGWW5Q3/PFDAfXs76lY36ki2r6wCIHabyv76tdo7VKEeat/FBmL1BSdAuEpb55K0Ytn1gj4LAAAAaQVUQUxBTx1MzDHatuog9GHTKaBWLBxYQSUVAAAAEgAAAAEwRQIhAJ3qKQW5MWf/ds7R4c6lwIbpmYoK7AIrVayTbF+phh7TAiAhjdeHC89PD8VChP1qSjKc+DMmmd+2S1K3cDEgl/+syAAAAGYDVENB+g714DTK4a51LVm9uK3N437Xq5cAAAASAAAAATBEAiBB58LU+Ix5zZZx4LrJchZU+G8xJWlhhLQIbGY5f8XKwgIgRr0qDrOSJPmHmRTR0hUruh5An7Sk+WzZBqvkYLoBA9YAAABmA1RHVKw9pYfqwinJiW2RmrwjXKT9f3LBAAAAAQAAAAEwRAIgGEWkY3Pux8rIIPH/6CKjvd0Eju5LpsthQC2DZ6BpsDUCICSNIgfHXoZrexq9O901haBRkq/5nW89+vP43tCxwtt6AAAAZwNUVFWc2opg3Vr6FWyVvZdEKNkaCBLgVAAAABIAAAABMEUCIQC0elUvcJv3kyO8VZ/T2iXJGkcRkOXXIyyssZSN32vGDAIgHUb1HF59vhB7vpqyNPu2MbYFHrVB7+nfiHMEq8TbqdYAAABnBFRCQzL6zNX8g8Pkw8GsHvNdFa3wa88gnAAAAAgAAAABMEQCIHj75RnLuFc5c3K9z6Wnx4ESqkeg5aYIJRwy8+DAPAlWAiAod21Zqr0p43uqvdXKDIRxiBa90eghTlJv3/42+xpMkQAAAGYDVEJUr+YFETQaN0iN4lvvNRlSVi4x/MEAAAAIAAAAATBEAiB0f88IjyIv3ob78EtZlVy/obW4Dae2MI/b2E3cKTQPvwIgLqnIYVtQLr2NDFYf0/Go4j6aWGAwqNZqwXPcpxj3TUwAAABmA1RGROXxZsDYhytoeQBhMXu2zKBFgskSAAAAEgAAAAEwRAIgXwshPpb0vlQv3SkRgM60mSQA/QxlMPbNuhedyZXWBhECIFqrVmx2meOmmvHklNZIHmu4/mnQibBYT+ldaI2tE+daAAAAZwRURUFNHHmrMsZqyqHp6BlSuKqlgbQ+VOcAAAAEAAAAATBEAiAGSxPiixYy96xcLS9MfotNl5q4IECYHkqYii/DVW+CpgIgJudD7A+e8TypDUj3t2KEAHWIub5cMX37i7fJLzf5W18AAABnA1RFTIXgdjYcyBOpCP9nL5utFUFHRAKyAAAAAgAAAAEwRQIhAN2AkOs39DI4Ery0V0/r7UuSpInP37L1Uic9ko8bpYQmAiBjN8Oxdtl46ykf3JzNUo6QEYLNnbUPy52liMhSv8lUYwAAAGcDVExYs2FlUKvIr3nHpZAt7576O8mpUgAAAAAIAAAAATBFAiEAsPpnTYsZS24pHv3VV1gv+XySjNm+2vy9FXgKa09K4VUCIBzlYq/1w81m/d2CG4Ph/O/8rC0Db5sLFKsmkteU0Y4GAAAAaAVURU1DTy/CRqpm8NpbsTaPaIVI7Lvpve5dAAAAEgAAAAEwRAIgSSAOhPFdT1vgTTB81XiGGO9awIr8YPZfjzXUBe0BEn0CIDNEyd3U0SZbO67q32UJInVoViL+EXixOnvmHBUz+7+SAAAAZgNUVEGqtgaBeAmEHosRaL6Hee6vZ0TvZAAAABIAAAABMEQCIHysIocT2Pmi7ONtiIamRp6BG7d2aV4zhdY0NouqA6keAiA1VWl+5GUym7A44Yl1awdSsDZAErhloVg2KSSHn0UULgAAAGYDUEFZuXBIYo22tmHUwqqDPpXb4akFsoAAAAASAAAAATBEAiBgscdkY8XP7yktDy8H9U+Jm8RNCBGVO3b4TKheDraD3AIgHckVSBtHGc+Jnamn86gYiZRU9t5heVg8YVJ4cdtNS2sAAABnBFRFTlhRW6Ci4oavEBFShPFRzzmGiKaRcAAAABIAAAABMEQCIEIWCyCxY3LokqIyWZI0d6GhAGTO8pnbUrbrdJMxEoOhAiBarI3O+ovECvk9K4Gu7j94lKngyw80q8fFzL/N6nkPGgAAAGcEVENOWCjX9DLSS6YCDRy9Tyi+3FqC8kMgAAAAEgAAAAEwRAIgFuuSICybLewmHGEuVE7CEDb0G7tXydfAo5Yh6eztytACIDM61e4fhfqW4SY+X+aNMFWo9XYPoyV9Se2kFwrrp8WuAAAAZwNUUkFE0qxlwTkWiwLxsngbYGElyjnq7gAAAAAAAAABMEUCIQCw1ymIKtclLhwLigtfNdPq2zbjiRXk/TVhHxl17mKOiwIgfY0U5NQYCi33GkQz+lGN3Hg3v1mCZ5TuPN2HSVz88lcAAABnA1RTV2uHmZvoc1gGW73kHooP4LexzSUUAAAAEgAAAAEwRQIhALq5WwUmvKUfcIdH5D2V7MLuNJ0WSCnIcpf8eNpU/Mi5AiBSUS3RGG8ludd8uXQIw4KI9f0m4RI8/Y+e4eTu/Cp+AgAAAGkFVEdBTUX44G5OSoAof9ylsC3M7KqdCVSEDwAAABIAAAABMEUCIQDn67tTajTBL4HfjiHZiGUr4ulYgozt1wFEA2vMGzs9LQIgKKeIMHPDot0kf2Sv23l/h42WrRzRXLgae1YcNwcBL5cAAABnBFRoYXKWww1Ume9uqWqcIhvBi8OdKcl/JwAAABIAAAABMEQCICa3AaYGRZUySbDaQaNtRd0rCy3E6aVRrT54viSr90LPAiBfjL01ARHpLw2DbKGz+sSOix4w/YmL2phf0sOOC5TVIQAAAGgEVFJDTlZv15mbH8OYgCK9OFB6SPC88ix3AAAAEgAAAAEwRQIhAKs1SOHUHBsL2MqR+15BwDd3GM4/uiRpXUDqjpxI7KWUAiAVOnSfRWj9K/e7eJ1Nuee//Srse2d7shrWCb+JR0f7cQAAAGYDVFJDyz+QK/l2Jjkb+LqHJku8PcE0ab4AAAASAAAAATBEAiAzSYViI3myhn9AvyuPXig9KP+AyXjJhhfaWrnOlOq+VQIgYzPvPQPT7UCQ7IUMvhDLSXFW+s2m2EqPcTv3S/UOGeYAAABnA1RXTi7xq4omGHxYu4qusRsvxtJcXAcWAAAAEgAAAAEwRQIhAMRac57tRvCkLDJruhrWnF0/fgDZSH94uz/+KdnIE6jJAiAI2w/i8LCaC39krKsiEKMAI/vr6rrMAgNAG89uWnNf1AAAAGkFVEhFVEE4g/XhgfzK+EEPph4StZutlj+2RQAAABIAAAABMEUCIQC/oInuf3K7gB6TBVT68KVdOOGMfspyuNj2j9ntpXjRHAIgK4ti5CRrGieIWkrEA8Z6WYzhFO4ZI52AeERjfQR7AJ8AAABnA1RJQ3JDCmEq3AB8UOO2lG27G7D9MQHRAAAACAAAAAEwRQIhAI9luvudET9dRl4hLa48uvmHjJpCduLZScyPH5bX04WvAiANT+gPbdquk62FORmP3e6AAs0Y/Ye7iHJnqGxR13NlzwAAAGYDVENImXKg8kGURH5zp+i2zSalLgLd+tUAAAAAAAAAATBEAiApnOpHHRtfJc1EZdpOoM+dds0fkQfyaJy3grCQLdnMogIgFjGZ9cwT24S78Q+czhxd3lu0zXBx29QgkUc1M/4N0WIAAABmA1RIUhyzIJ1FsqYLf7yhzNv4f2dCN6SqAAAABAAAAAEwRAIgff3duT0lvMrS8srL00j93pQbQO2pQCGJEl2flQyVSuECIGOIwS+S8f/l53Ob+huyvPjPz2/waR4tTqISWZ++WPvKAAAAaARUSFJUTycFPzLtqK+ElWQ3vADl/6cAMocAAAASAAAAATBFAiEAo1k5eyIqfDzP+KAbrlfRVr8/vUb7+/YrKpFTNO9VacYCIAQPNkfX+wIhTsCnLjobg4/RTnojVQQ6OPyeWSo07mm6AAAAaARUSFVH/nuRWguqDnn4XFVTJmUT98HAPtAAAAASAAAAATBFAiEA10cQlZOV/TYew1S6OrL1QAvKkU9Nz58f2AcvztcmGi0CIAcCUW3W0qdQjla6G2Qw6lFNxG9lYWoDanu0472tlnrXAAAAZgNUTlQI9akjWwgXO3Vp+DZF0sf7VejM2AAAAAgAAAABMEQCIBZkY/zzA7sc0EcUl8JouH9Rhnz8spiR1/9Bl6R5ZzlmAiBkBeA2BuXGAKGWbro9Edk6gX0Y/apqfyztumjC7FTAuAAAAGcDVElFmZln4uyKdLfI6dsZ4DnZILMdOdAAAAASAAAAATBFAiEA1OwXuLwLt6De+0X+7R9Qa3NN+IDqKCl2q36Zl9xG/yMCIHece0k7WzlQvYgMBDKCAuikNkyf3X8R3qDTECd0KTasAAAAZgNUSUfu4tAOt9643WkkGH9ao0lrfQbmKgAAABIAAAABMEQCICmGZ2HRJqSVfCIvsrGxTzKy0lnWM0HJCLFBaRKMArGPAiBrfssYrnDAttIqPok74pyWRleu+IsLUut/xqqf8ho0bwAAAGcDUVRRLDwfBRh9unpfLdR9ylcoHE1PGD8AAAASAAAAATBFAiEA8Bdp+Sfr1IwqA8UoXkkdW/y4foUgDDXunu+95gYL09cCIAalQWYRf7i02pTGwOgVEZjg3mfpSh9HyXty8QHwK8L7AAAAZwNUSU+AvFUSVhx/haOpUIx995AbNw+h3wAAABIAAAABMEUCIQDR5dSj+pGkWje4E7VjHeC4gNht8yboYOWhhWg4bQMlbwIgPlDMrmnHXmodnTz5TxL/eIk9HuzFoeG6rvFAKWfD87IAAABnBFRJT3jZR7DOqyqIhYZrmgSgaumd6FKj1AAAABIAAAABMEQCICrQr4Kdox403GtdlE0oGZjVTYfkaWGbO+WLWDCvMgdmAiBzoptXmJhhFwnZOQue918UHCI7SFP/ltHB2DK1HG/s0wAAAGYDVEtStFpQVFvuq3PzjzHllzdoxCGAXl4AAAASAAAAATBEAiBhMjIGyu4su7jolineAM/qpggmOzHzVupVWydn4k6IIQIgARJz/DBLiY6XLSqauuk8QJVl/0OGDJJciGz2a5Sw2dwAAABnBFRNVEcQCGOZ3YwePec2ckr1JYeiBEyfogAAABIAAAABMEQCIFFKJ3oV0MJ0uqbEp4X+/2luZjamBDh4LChISkST7EsgAiBRs17jY5DIm7sbg/1dWO7rdIz0q+q/qC+p9fHfoRvprQAAAGcEVE9LQUyoGdcG7lFcgbEWUb8akCNEIj0EAAAAEgAAAAEwRAIgKREj9iOfxAvZjk+TIInTGet3iQyQ20qiCS4tNxVPIU4CICMAIw/gDtgm2zmLKCtbGqGp2LsOHKktPwY2C8k7nV3HAAAAaARUYWFT53dabpvPkE6znaK2jF77T5Ng4IwAAAAGAAAAATBFAiEAje5d42k5gmJG0/a2NVWNVfYgtDIzeEbeavRaBAMCl7cCIFGMXL9RpbLyVJfhjDUkbkLUxM1Ho6XaZTVwY9KZcTWJAAAAZwRDQVJFvxjyRrkwHyMelWGzWjh5dpu0Y3UAAAASAAAAATBEAiAa7lSu3O1eFjpPUeXzcJNnW+lJg6duU9BOxV0Fy491mwIgCcfUiKgSvLgd41wlJmiKRkciJIoOBxU/RD4wBRjLZNUAAABnA1RCWDqSvTlq74KvmOvAqpAw0lojsRxrAAAAEgAAAAEwRQIhAPlti4JcRGRTzLAVmAYk8YxUeEDo4WDoOTvpoJxz7Q2pAiAEp8R+nn9jQZkTPjVky1QwtPwhgN8qVjPlx5ECEOqLfgAAAGYDVEtOqq+R2bkN+ADfT1XCBf1picl35zoAAAAIAAAAATBEAiAPI2chbO6a6m0yq4q5VV6W543ahGNosVpPtbNufXaEjgIgHHDS3iCH5YFVdYIxUCj5EHbzjoexIqshhLQ00+dBykIAAABnA1RFTt0W7A9m5U1FPmdWcT5TM1WYkEDkAAAAEgAAAAEwRQIhAJxZmZxnnRNh5Cn53TTeVJw5LaarDiGBjCqk9QQpK8KoAiA0FmHf3/T/aBC9he36epREpfYDUCOG+xOmwXLiGXjDSAAAAGYDVEtB2uG68kmWS8S2rJjDEi8OPnhf0nkAAAASAAAAATBEAiAqZJk4lbnFGrYF6caLEKbbkbQ5x+xjN9r0Gta47HLQdQIgfk9eOIWUqFAv8sOFLQLoaDQeigalpXzqxnLQeGJ1O0IAAABmA1RPS5pJ8C4Sio6Ym0Q6j5SEPAkYv0XnAAAACAAAAAEwRAIgT3VI2UBzPBRyNwBKn58lE99SRKm1eLUlVPCCNJkHHMACIEifmeXeaoeS0LGkc7zSb0vz8kehE3n4T3nKlwFOS9rwAAAAaARUT01PizUwIRiTdVkXI+c4QmL0Vwmjw9wAAAASAAAAATBFAiEAlW2zY0CRCs4Pf4IOCr9qrNWuMVmdW1XGCQMPPSPFpnECIHHlSeM6/mzvCi5KQ72UScqjaRhDQXkv5T4SaTTCeMlPAAAAZwRUT09Sjrll7pzPvOdsCgYmRJLAr+/Cgm0AAAASAAAAATBEAiBe7FXAo4B1NTnxGgKvWN/LesFXHzLb++YuxJdoSC/kmgIgecpNWl6NlXAhc5JakVKvSY6BQ7JWoBntlp7swy9wL1oAAABnBFRJQ09/SyppBgWny7ZveqaIXr2Qal4ungAAAAgAAAABMEQCIBi1xlO9sR4SzfYg8CF2qZQ0hqbLiozdJtxZP65G5viFAiBty7rYhEazOVrrd92arBDrkVTbV6+dWBIJWezDvDXkYwAAAGcEVFJBQ6p6nKh9NpS1dV8hO10ECUuNDwpvAAAAEgAAAAEwRAIgdNbqyGD0ABlb5P3E2YEE6wEyjeGA/y1EOWCPhWn7BOoCIHew+MqaJVdU4eQ6jBZ8TEdgszYh9C2eGLQiC05FHeY3AAAAZwRUUkNUMM7LVGGkSakAgfWl9V204Eg5e6sAAAAIAAAAATBEAiBqmWIZVP4R2PyWKuJZXjTcdElcJookBMpzF44pFFlHPAIgdWVxOhtOzT6KRKHRvl5Bua8+3UNdw4ND2IoFVBfQvjcAAABoBFRSQUsSdZUS0yYwO0Xxzsj3tv2W84d3jgAAABIAAAABMEUCIQCLQrWvXyTUVq8eFxNg16blhkaEN57G3nw4O2sNOCpEAAIgfNL7uxnBpkh8nN917f0BQL8gfo6VXX6eZeIlNlsftw0AAABmA1ROU7AoB0O0S/fbS2vkgrK6e3Xl2glsAAAAEgAAAAEwRAIgFrp4a4ieOzkTfiVUQsn3DEG3PHoBliRCZ3gXWeZvAtYCIH2g772eLwUJePhwB5At/3LUeYBjvzsHtR2mjrBk/ZsjAAAAZgNUTVQyCfmL6/AUm3ac4m1x966o5DXv6gAAABIAAAABMEQCIEYKsBac/YgHrTxD9u7JKclmJ9skival0T4jRAqS4mYkAiATUBfc/HDcj7oimC8qePSsBQj9vtKDbYrjevGzpqF8oAAAAGcEVFJEVDP5De4Hxui5aC3SD3Pmw1iy7Q8DAAAAAAAAAAEwRAIgKa6BFVhk/5ruAkIMl/W7RZAHawrDRYFtFjYkHmBDePkCIGtuBpbJEMNl+OM48nnZZDQFbaknx1WpdhHAzMuapfzHAAAAZgMzTFRDAkE2jB0pP9oh26i7evMgB8WRCQAAAAgAAAABMEQCIFI59wTHIsEpMPrHR0AsV34ujpQEQXibChZ5e+FgWjLsAiBuKc7PhNc5sB9IsfMssBfjjyb1cv3zNhGCcoafCHEcIQAAAGgEVFJTVMuUvm8ToRguSkthQMt78gJdKOQbAAAABgAAAAEwRQIhALklAz6Q3OCej+gFTWevskhy9c64fwKYvTxTatb40O3GAiBW26rBkHZiqIgKdOR51qstY43NhnQbL7Anu+kmfl2nBgAAAGcEVEFVRAAAYQD3CQAQAF8b165hIsPCzwCQAAAAEgAAAAEwRAIgC+oBW/pszQR+G53s19ZSXUDHA+suVELCjeHcaf6seTECIHEgw3qsG+uG5WnkeAt6/ef/ma1mc54mK0xVSt0PUMINAAAAZwRUQ0FEAAABAPKivQAHFQAZIOtw0ilwAIUAAAASAAAAATBEAiB1guHDgqMz2emdRQEAP1BGiEHDe8gYRwQspi2ruDDFewIgCYfdn+UR2dmcTS+qo4N4GllAlCG+NeKRuBq8ysAyf9EAAABnA1RGTKf5dsNg677URlwoVWhNGq5Sce+pAAAACAAAAAEwRQIhAJu/OmyRSn3Fv1gNMk3d0aK/Dct0fe5Zc5ME8GeWvHFbAiBm7jFAY20w0O7IuvLd/Dj4cyXTQcNQyw9s/9FzMWTq8gAAAGgEVEdCUAAAAABEE3gAjqZ/QoSleTKxwAClAAAAEgAAAAEwRQIhAN58+GYGqnhCvhGufGSS2+HA/pBHlzPJlR6xA0cmhGntAiAQE/hHDNCby4n48iRepS9YaekuTBCw1whabzOekA/klwAAAGcEVEhLRAAAhSYAzrAB4I4AvACL5iDWADHyAAAAEgAAAAEwRAIgALLl6eoOSAQA8mefmsVTGDyfc6fzZ5/QRuItU+RyCqcCIG5oNSYw5TISVtfJehU3IAO9bsTgze0cnrd5R3h1njbOAAAAZwRUVVNEAAAAAAAIXUeAtzEZtkSuXs0is3YAAAASAAAAATBEAiB5PKv1qE/061SOXcUsT9603eerpeBXYI+gn/DtdOu+bAIgbAaFYN5AMk/FmQaeBftbQAvjToEmm0WdsfdjnYOW768AAABoBFRVU0SN1fvOL2qVbDAiujZjdZAR3VHnPgAAABIAAAABMEUCIQCsRwJXst3FAJ0juHz25WGUiK1EdgOWDiCp+NLAYPeDQgIgU6nTrjpqvZ/w/wp6T138rOC2Ht484+YCm+KW6J+smjgAAABmA1RJQ2FLmALUWqG8IoJlHcFAhjL5AnpuAAAAEgAAAAEwRAIgD7tMNxrduHDEseALIVeQ4zPkvj31DZrUjXsO9+hX3+cCIBJnQ2XnsC6LcRzQpGsp//JCfHFZhR/j5l8g99rTX3qcAAAAZgNUREgqHbq+ZcWVsAIudSCMNAFBOdXTVwAAABIAAAABMEQCIFd/evkOFZ/v+8nLCbelgchvT6Y6xZVWa8rV1pOJqxZvAiA2DMu1sdmKpcAxRYfwvUTPboryqPRKTnpLQynCN8NqowAAAGcDVFJWcpVez/duSPLIq8zhHVTlc01vNlcAAAASAAAAATBFAiEAjW8GDmYkM1bXoXqrliTMnzb7socpdyL4NjDrpr7rWwoCIBaEiq0PWxpK6oELmo4sKp5OesXOOtBtTNDj35BHqRVjAAAAZwNUVEOTiUNIUrlLutTIr+1be9vF/wwidQAAABIAAAABMEUCIQDuKOF5RxvoWyd9adufWpXrYRrMByWNvFt1RCNqXo6xowIgWCaJs2msXt7zRLRyyvOVMkK9kpRCNJSCXz1UZ/O4+e8AAABnBFRVREFeMALf9ZHF51u53triaASXQuaxOgAAAAgAAAABMEQCIEvS5XaOy4fe8llYbusGYYPR0CA/PtafgocxwnKJg5cUAiByHOhOXIwBVuhXv5Ox7DBJa/g1ksyVQYLGsjrg4KQ/MwAAAGgEVFVORWtOBoSAb+U5AkabYoYCTbnGJx9TAAAAEgAAAAEwRQIhAKj3UdOb9Gt61JhN7jaYfcn1H/zppi/sG132+9CHxw0uAiAzJdgDy49k+dVsgx8cJITdLVZg/7tp5SMFCIslrtsbBgAAAGcDVFhUokKLbRz/qJdg15eptaJjQs30VF8AAAASAAAAATBFAiEA7ByM5R4CnMkE7Xf3cKWlcX1KP68O2i0PjEnCAsgP6ugCIDV0Dlc5VVyGVp2L/aQyU5V+mRyRmKU74sG1uw+tcgcnAAAAZgNUVFaoOL5uS3YOYGHUcy1rnxG/V4+adgAAABIAAAABMEQCIH2ZnGmKvHAlYA7GzFaVz+o0UZAQl8z9Sf85FHrkyriFAiBDYA5PYPZX7MIw6xV8AalVFOPLSCpEm5u+ml5UJXeUkgAAAGkFTU9WRUT70NHHe1AXlqNdhs+R1l2XeO7mlQAAAAMAAAABMEUCIQCYhU3GwuEnDtKlML453tPocXtaxOhhCyfOPuz25GYZCQIgY6O1HsoLpcv6KKTytze3maJWKw3UfyReYdcS3LKjJsQAAABmA1VVVTVDY47UqQBuSECxBZRCcbzqFWBdAAAAEgAAAAEwRAIgToyJcC24xua0sru9hHXSF8SuVt4hdhVOe0+0ArYC86MCIFabZygeFK2G0Wt8roMVQhZbZ9GNTlm2RetnBCNBdMwuAAAAaAVVQ0FTSJLlKhojXZoQPZcJAQZs6RCqzv03AAAACAAAAAEwRAIgYCfsadD8QwGJDKhCO/Yo7F2Ba6zaZtZh2C3PGWlu68ICICTHo187OiZnDV+dNraPEJxzgQYslaIHe/rZRadLVVUEAAAAZgNVQ06q83BVGI/u5Iad5jRkk35oPWGyoQAAABIAAAABMEQCIHAtAgZJ9iWC2YLu008REh2YJBYYCUeAc2YM9ozzpY3CAiB8vUupL2+rHUzayHzvcyQVgtk0xv+/7TtsxBSSy6fnegAAAGYDVU9T0TxzQuHvaHxa0hsnwrZddyyrXIwAAAAEAAAAATBEAiAXaReyRabmOmaCmforxsSliKVNtjd9Dydhoq3LmnfMFgIgedn/0Lq4uWJe145lE29zDjIDOPnvYPKOrsTRffqlLk0AAABoBFVNS0GOWvxp9iJ6Otde00bIcjvGLOlxIwAAAAQAAAABMEUCIQCS2oDvFlyyGrD32NiITNx81ARGX0xTW7/sk1ClEpm8qAIgalKKch5oKduIYRLmvQfrbmxXeBn0wmVr7Fker0RKAjoAAABmA1VCVIQA2UpcsPoNBBo3iOOVKF1hye5eAAAACAAAAAEwRAIgWf9r3jU6nJS5WJnb5qeZpLdgtz2MnYHfmn+2Gm7FE3sCIHh7ENQIXjQkKyybovffvzNA/WuIj3AALDE7Z3XlHOnsAAAAZgNJVUM1jXrLNgrqTUlbh+Ekb7dSt2hDUQAAABIAAAABMEQCIFQJYOuMmPk7DRCmCXOPyX2rL3HnzaEUrPTiU8xGpsHlAiB6o4CoN6ruN/e4dOFVzJJRV26EJ5rRTzvxyhjwYym61AAAAGoHVW5pY29ybokgWjo7Kmnebb9/Ae0TshCLLEPnAAAAAAAAAAEwRAIgCReYJemDTutiy8ynQw2ye9+9R5C8C+kH1jGRsSSSIMcCIERsqxirrI00zl9IAzNWprOP6YEGc/5l+zt63PK/+nU2AAAAZgNVS0ckaSeRvERMXNC4Hjy8q6SwSs0fOwAAABIAAAABMEQCIFhs4hLXDU+emQ0dVlBkAUmfwQutgiZmUuKy9fPAhko6AiAWZXbx1yRlw2XAGUWvdna4z1zK01w76YoA9Zj2BQMi3gAAAGcDVVRUFvgSvn//Asr2YrhdXVil2mVy1N8AAAAIAAAAATBFAiEArIU9CKWz6f9T1GAiLnca4ztAlChmgWCNpGSciOWUrqcCIHZPWVh7rZkz+y6bpOAuLSlHkfi/cpvN1k6Z421is5oiAAAAaQVVVE4tUJ4zGWNuISbjwLyeMTSuxeFQikbHAAAAEgAAAAEwRQIhAOXaBtROvKTZFy8dPlPlJ5ugzND1WAqRk7PNRTDgzZ6NAiBY5hL8W7IJMtSQRAlPKA/ef26g5IAftu8Xuio/xP9B3QAAAGkFVVBCVEPHRhs5gAXlC8xDyOY2N4xnIudsAQAAAAgAAAABMEUCIQCEsNDtlQRwmPZdHokk3RxpT9ZLTg8DwOqa1olzoWbT/gIgX+mn5biK62I0VLvqd8KfWPAeb2pMbn+Nnuy95RRE238AAABoBVVQRVVSbBA9hcFRB9zhn1p1/HRiJ+YQqr0AAAACAAAAATBEAiA6lF0fdspDhnd7b9OuW6N2Dlkfd3+mPZsshbooCzgsLwIgY/zekJV9gcYJ44HiHgfa3iBo9BZJFBGvWqWxnDTedAoAAABnA1VQVGyojMjZKI9crYJQU7ahsXmwXHb8AAAAEgAAAAEwRQIhAOe9T/4JA+YaaGS7To50ByButHUHpDXarHdqrWlMIOaYAiAeLGUyqRoZHbOZ3ffGVLma6zBZGpqHW3UtCWRkLd/b/gAAAGgFVVBVU0SGNnwOUXYi2s2rN58t44nDyVJDRQAAAAIAAAABMEQCICrjG2ABoTBWNfIJDLz8XU9oA7IHgP99pnK9/vJarXbmAiBthsy+WSk5Hra9GD+fnABY0HXRjad8zvXaOG96YordRAAAAGYDVUZS6gl6Kx2wBiey+hdGCtJgwBYBaXcAAAASAAAAATBEAiAnkTCvcw+XX2H0uD+tzZHqw1VB+Ya+hVz+IQAFgzD16wIgQnTj+A+IQ2Di7C4MaYXQuOSFl5ITIsroF9vmSGptPBIAAABmAlVQa6Rgq3XNLFY0OzUX/+umB0hlTSYAAAAIAAAAATBFAiEAmJX1YLUDDStC7gAldp84/AbHldXDqKdmE9mK0RxIF0MCIBqnA8YVSjsnJq16FvhXlQJ3blmWuJKKbKRXluSUUKnuAAAAZgNVUUPQHbc+BHhV77QU5iAgmMS+TNJCOwAAABIAAAABMEQCIE8an2wnFwO+tIH7gy6XKKLd5yzcmmvrtib59atmK9oPAiBk9KVFxe4Y+P1Uz/G3iNvZ8wDSGUuJu7xvYivLaYjVwQAAAGcDVVJCkxaEE591bCTsBzHp90/lDlVI3e8AAAASAAAAATBFAiEAgJl5k7aEPHU2bqSIiGZau+44UWjE/daTcvdUIPm93X0CIDmb/v8oAfkLnJ5C9muEodONLZX++43V7M8ETjzDVStUAAAAZwRVU0QrPs+Ae4oQ4FPVJzMS8jhOXVn4EFcAAAACAAAAATBEAiA4beArQlEAMGjX6cPeCt5iyQGITi8ajcAnr0SE2/Zi5wIgJlfQ2Ka/Fpbi0NYk+Fs90bMyWX7ZBM/iIJn6L+fxKI0AAABoBFVTREOguGmRxiGLNsHRnUounrDONgbrSAAAAAYAAAABMEUCIQCy41hybk5qZ1LPNEAXwOnUW5qQQSB1jUX2GygE+a1SmQIgFRYe8o2MRIG9lDLBNWLe+czmiLz+yJbvJEyaIT8QbN0AAABoBHNVU0RXqx4C/uI3dFgMEZdAEp6scIHp0wAAABIAAAABMEUCIQDfFeZEmKZss2QeirlllB233mQhMhTjShU6jDbPlATYYAIgfyqpanl/CpaaJzjbYLi49WnY35gwyohF2honJgoqb6oAAABnBFVTRFTawX+VjS7lI6IgYgaZRZfBPYMexwAAAAYAAAABMEQCIHjGbM6j5N7bFaJOw8eD17WCzSYNr2L9Nq/pqCEqNErtAiAWC6jBxLaoqmVlvtIGMqCRru63v9rGf8ZYmmAxrL9RHAAAAGcDVVNHQAA2ms+iXI/l0X/jMS4wwzK+9jMAAAAJAAAAATBFAiEA/hg0JDgIn+MriN631R9ZIV8sRuMuupnpXZjkZBZ19wcCIF5p6xr/71v+0Zk0zEkiSzELXLV6WLcc3IBF5xqLFYLgAAAAZgNVVEtwpygz1r9/UIyCJM5Z6h7z0Oo6OAAAABIAAAABMEQCIFSjN4cgOL7RtmL02YjJppLW7aMWOAOKFHrJhlMja+GsAiBiBTXS9fSPeDsgey4W+qtEAYCfP05rowJ2PThz9TytPgAAAGkFVVVOSU/LfSwxuH4OiNUUjIi9et/flsPd+QAAAAgAAAABMEUCIQDGm03Jo5HpDuYOV7X4pMGG4Y+nz+pL3S4kgudQ7S4qmAIgX+5fHFexXgWWA1Xz6jN/MAcdtxavq2jDVBs5paKDexIAAABoBFZJRFREX1EpnvMwfb11A23YllZfW0v3pQAAABIAAAABMEUCIQDsiFre5q1zPe7UYU0bPYgpCh3LtS1lk2Zg+4uBe3OrfQIgX8WPJIKFrHEPOdTlUDaS1eFPRwo38tOr4fabgeL2jPYAAABmA1ZMRJIqxHOjzCQf06AEntFFNkUtWNc8AAAAEgAAAAEwRAIgLeiIAfwVcU4mZDt+JosM/JVbwmPl86/M6dJo1jbSMwICIACCKNkH9gqzfAX3ZUmrJXSwzFfFWBOnnSst6umI9kBhAAAAaAVWQUxPUil+Tl5ZrXKxsKL9RGkp52EXvg4KAAAAEgAAAAEwRAIgTEDgvU8NmwZZDV4ZkIncxIYNX8lG4nObxzkrHfMYoZwCIAKntPvEilEORwrJzsxKe7secBCUvjbgNUPaWojtnCrlAAAAZgNWU0xcVD564KEQT3hAbDQOnGT9n85RcAAAABIAAAABMEQCIBTYu6LGk30PPPzxQbYbCh8BpSVjSRKcghcj9uX+PgTMAiAHV1FzdJuOT5notnEKHv1RBftwDNhZQx3j+O4AuS50lgAAAGYDVkVO2FCULviBHyqGZpKmIwEb3lKkYsEAAAASAAAAATBEAiBMhwAibIluEaiDQSYPRVlCyCJvW8+nLR/uXcaaWv7pOAIgbEN8mwDNAVvV4Ocll7XD8Cz2grpP5r2o1nw8CtuDLsoAAABoBVZFR0FO+t4XoHujtICqFxTDckpS1MV9QQ4AAAAIAAAAATBEAiB90fd/MlAfNtuw7aOpp6A6eu4K4n//EdoO99XNlhBGQgIgZuB4pmog27hxNFfjj3kq8KSbfELKjCI0R4XSjBIgUgAAAABoBVZFTlVT6+1P+f40QT24/IKUVWu9FSik2soAAAADAAAAATBEAiAa7oCDyP775gYXK2tHjJS2c6ejGSdrnUwJX4tuItFjiQIgZ3D30xaBtYLx4olyoBXlNgepCznMuVUjda7/LcnsfxIAAABnA1ZER1fHXszIVXE20yYZoZH7zciFYNcRAAAAAAAAAAEwRQIhAOBRL8WUCelrf8xqr2G6j34zaFxUg0pDe5wz9IMI5vakAiAGBIDwQ56urTOFINu1JEYpX/UomWpNWP+8siXqrSjOMAAAAGcDVlNGujp511jxnv5Ygkc4h1S45Nbt2oEAAAASAAAAATBFAiEA51sqznizAvZs+s+yeoyOKrefSvrxzueOluSNSqm+A94CIFdebe4tctCnIl7N0SFQrnVP6ixbbJcnbe7XzWcj/OpMAAAAZwRWRVJJjzRwpziMBe5OevPQHYxyKw/1I3QAAAASAAAAATBEAiBwVgAdDn60VcU6IMdBiLvku+kKRK9m/R05xPYUFd/o7wIgWmTwIuXY6oew/OxyouCj4tDTqbZdKjgibp+A+6px9lgAAABmA1ZSU5Lnja4TFQZ6iBnv1tykMt6dzeLpAAAABgAAAAEwRAIgEQ5rrEJyydbBIlWZBgGQDM3y6ZHsdJVlNMCjS7sKPxgCIGt/7Yugh436bSAKU+QFaeB6sBIeOLhTfkIIz9ItBYYxAAAAZwNWUlPtuvPFEAMC3N2lMmkyLzcwsfBBbQAAAAUAAAABMEUCIQCYwVeFzNYNnq8dEdNPJpWJPxS3PqU1ynjnKZPh7cDtSwIgUPLAqTXdyQjUgmDcepGLSrPPkHAxIWH954Y5uCDzchoAAABoBVZFUlNJG4edOBLyreEhQmRlW0c5EODK8eYAAAASAAAAATBEAiA65FFyW+AHtLpQbnHaHxlz2k+DZ1exEiM5N9+T/TjvVwIgAiy+7fI4KuhGT1C4yAtC9+HRSG0Xy1JZDsci7iy8oqQAAABnA1ZFUwNFLmn/zZxFyjT/TZuiIJ04qNVqAAAAEgAAAAEwRQIhAN2CIkoN6B+FFvVzp7VSUQnz8pXVmIE7OWptwLCpF/I3AiBc7kXFdHV3gTZJhR/qZT8p9ppCo4XTxHT2Zz6qK5UaowAAAGcDVlpUlyC0Z6cQOCojKjL1QL3O19ZioQsAAAASAAAAATBFAiEA5Tx9qp81tCCijdq6YWeqR/0gqjVFBrEHoNZmpZvyM44CIDY/Tc0aGClpKz3a+cvviVvk6Xqp1ag2cgEM/pGVt+0sAAAAZwNWSUIsl0stC6FxbmRMH8WZgqid3S/3JAAAABIAAAABMEUCIQCCswkxwsdwTE661Eel2xRJ1msrhu+OYt5e6RlrPQIVwwIgKCh5Ehwgofscqk4JDBn/cJyMCraarksSrPXljf7OxFgAAABnBFZJQkXo/1ycdd6zRqysSTxGPIlQvgPfugAAABIAAAABMEQCIC7dvKhTAgBqpMG5afPQdyoRdPaf8dAmZBOJqSt6hQp1AiBNlm282Ksm+gRxj2RbTpjAcQfU0N2F+eN34eyuKGcqGAAAAGkFVklCRViIJEj4PZCyv0d68up5Mn/eoTNdkwAAABIAAAABMEUCIQCEEZdo7pMbMGFXvFkG5FhpU50d4w6WvxJ+IyJOs3KbmgIgYW7Uq0mqg78ukAVi+t5YVV7PZD7oKrDfYIFyzPPK3JMAAABnA1ZJVCO3W8eq8o4tZijD9CSziC+PByo8AAAAEgAAAAEwRQIhAMiu6uUBznasMH1fhGMBOy+uLN4oolwZqAPXNprtrHkUAiBlp/LGkWLbGW/UYgnWmHVxRX1X5a2y83nLgwVu+dR1GAAAAGcEVklFV/A/jWW6+lmGEcNJUSQJPFbo9jjwAAAAEgAAAAEwRAIgTkNWh1kwTVu2i8HzWrqXk0ATQlHeUBnZOsGq3KiyfuQCIDYJxWF3jcKF5OFguu/m3IvcNx/AtVwlNJ1pvzahB5HxAAAAaQVWSUtLWdKUa+eG81w8xALCmzI2R6vaeZBxAAAACAAAAAEwRQIhAKZYwrrGRGh0A9i8y4LftvaSbaJDjiMsdZZ1mkgSbQ5nAiAztm9qRVfU2OITJo2Dv/OIUNNf/2V52HJRUDIgb+0q8AAAAGYDVklO8+AU/oEmeHBiQTLvOmRrjoOFOpYAAAASAAAAATBEAiA8yFyktkcCVm4OJAdfhKAGmaufNHjvh65LtqlDNmGvjAIgdm8gab7AGKKFcvKdpkTMqE8f9qrjpS6NOOSe5w7q2+0AAABoBFZJVEUbeT5JI3dY29i3Uq/J60synV2gFgAAABIAAAABMEUCIQCysXrSCrmsfUXOOTvoC7rCEn4Raf1bZnnAlEyhQvTKiAIge3vQzsB4/ZptxcK8Nn0PdcL8jKb6kmOJOuliRVxKJXkAAABmA1ZJVVGUdbMWU+RtIM0J+f3POxK9rLT1AAAAEgAAAAEwRAIgRYjO9uG5ryP06GioB677KULAPlHEJnFbEE0Peep1VuoCIDCjcynAXSewnJOm9wORWupH+NOkHr1lt2PusNTc9AICAAAAaAVWT0lTRYPuoA2Dj5LexNFHVpe59NNTe1bjAAAACAAAAAEwRAIgVUNioub9ob9wWfkV6ijUjcyVC5Lszehl9GGorIW/V+oCICs9r+X5IwzE7K8Ua9UNbOfeoSYaBekzUnzWoOOz9rpGAAAAZwNWT0PDvJ63H3XsQ5prbI6LdG/PW2L3AwAAABIAAAABMEUCIQC3gJ2zuXLGcy1H7z9luY89Z7WWbMxLgaX1lFKJE1VRPgIgNL/ILaeQubM7Hf6SuP7tyR0GOyNgFshrRYE0pxHrXC8AAABnA1ZSRfcisBkQ+TuE7anKEoufBYIaQerhAAAAEgAAAAEwRQIhALpkBCRmLh/z+6RA88J8BwWcR1jNr23uqD/3zriNNii3AiAN9r0SIcCxf/p4k0iJxtCJzlf36YAlBwK8nu437vNRZwAAAGUCVli/OLoqkLgl+6AvYEWaCX+yAhNGhwAAABIAAAABMEQCICsLsiPt1nlyrhETllSmLGXlkvbnISQBgHQNnTaF0T9VAiBNKlekw66qYpFvjAGCtOSiGzXLHbZAHJ4IMEAqbb8I4wAAAGcEV2FCaShr2hQTot+Bcx1JMM4vhio1pgn+AAAAEgAAAAEwRAIgZf9++09/+Qn1mTGwhStfxtwv7u2LW+NpFrss6kWQJmgCIGOMDcJeJ22lCbV0niV2IyKMOYBWVBoNWa06ddjQNAjgAAAAZgNXQUJLu8V68nATjvL/LFDb+taE6eDmBAAAABIAAAABMEQCIHAYGrC2SAkO+sry5WG9rXbseOp283WZ7kuGfGRWq7ovAiBWz423yqSVMe+lqauLlK/28adsyQPUonO6THsRPpns0QAAAGYDV0FLn2UT7SsN6JIY6X20pRFboEvkSfEAAAASAAAAATBEAiBiE6C9s/X8zneAEZXwHfGeH3L3mxynIBfy2hJf3ej5OAIgKcl4JaSqcWikZpA5JkdeKBR9gAGFMET/gOVweIUPEmwAAABmA1dUQ7fLHJbbayKw09lTbgEI0GK9SI90AAAAEgAAAAEwRAIgUPCznp/sd1EM9pKqfvVEdRtVhV1otlsLJQrmbmTUEfQCIFEAJiod0e+wsUEZwwpoInuWBWVlJenqM3uC+JKD7XEjAAAAZgNXQVg5uyWfZuHFnVq++IN1l5tNINmAIgAAAAgAAAABMEQCIE6xudydBHAeNCKL50atc/LqTtnrn+9Chxl7iG5yO7klAiAFUyLnMFFCkDFs9Ez10biJruBnqQLNo2swcojIqjewMwAAAGcDV0lOiZM4uE0lrFBaMyrc50AtaX2UdJQAAAAIAAAAATBFAiEAnF322Gm4l1c6z2TagrAtvyTFFi9rxJ517PWZ4JMCUUQCIESXah29eEtEyjFqxgYTwKbhAMV8uN3v0R4Kj+PrbVTaAAAAZgNXRUKED+dav63A8tVAN4KVcbJ4LpGc5AAAABIAAAABMEQCIHNIxCwMm3idfNxBfwQJuf4CyfzdCpbM3hoqLjoNp8IcAiANfEFMikZEaOsHLTFL2G5R9j5XPjh091ZIqqiiO+GG8gAAAGcDV0JBdJUbZ33jLVlu6FGiMzNpJuaizQkAAAAHAAAAATBFAiEAynlges3MlNJeJTDkYe6on84DtBQnwPuu0xTBjgIh0RMCIEtKq1f/paOSoHdUlf6v+T1xixzYel2Aa+MenkXY9H/yAAAAZwNXTUu/vlMy8XLXeBG8bCcoRPPlSnsjuwAAABIAAAABMEUCIQDa6SPtZStMVHKoIXAioN11ODHkEyt1WeVNDE7TnbKooAIgGd6cXqXh1Ks8H6K0lyIQRKBdVysWwf5lu7nbPJMdA64AAABnA1dDVGoKl+R9FarR0TKhrHmkgOPyB5BjAAAAEgAAAAEwRQIhAMTgBSRgHa5kxc7VYtxFMYL2zqV51yROYRDgJMTPhnCzAiBGIYjikgv7lvueBK2Z6FSU1A2k8EBzM5t9F6VXpfMWSQAAAGYDV1BSTPSIOH8DX/CMNxUVViy6cS+QFdQAAAASAAAAATBEAiA6sy+amSIHL7sZOBMHQoqw16ILG/K5XihJM1MGZgZl3AIgM5G2QUp6/iXKLHhMPN0x8EsjUIv1/TpjtHJfI+HYezgAAABoBFdFVEjAKqo5siP+jQoOXE8n6tkIPHVswgAAABIAAAABMEUCIQC0fuhVHBWiz2gcZJZR6YfX5SfEgdJ8ONoflxqCQnkr0wIgacP2iKxUk6I9q1eY48mwdIR2UGnh1L4UMhquTZLLjL4AAABoBFdIRU70/pVgOIHQ4HlU/XYF4OmpFuQsRAAAABIAAAABMEUCIQDQYi6D+8RfF8Thv5V3cPChc7kp9vJ7udVlIdCmPKHE8AIgWgwZqjEG2pxqEuApJZ5j09Jo1uAPSl6km/DwiEqu+nIAAABnA1dIT+kzwM2XhEFNXyeMEUkE9ahLOWkZAAAAEgAAAAEwRQIhAOYDkby9+IWU4xBI4bJiWch68L8Vuf60cfeGRu0CBHnGAiBfbXihk3arTzP0UcDAvcd7RSL55CdWSvrI/0lxfBevmQAAAGcDV2lDXkq+ZBllDKg5zlu320IriBpgZLsAAAASAAAAATBFAiEA4u02hXUKwaC33ZjO+GQvI7ODm7ZWBEyE3fLGlySsI54CIBJoDdjTwveE0+ObFvZbfyr4bQGtOS82Ym0iJdnOkZSxAAAAZwNXSUI/F91Hb68KSFVXLwtu1RFdm7oirQAAAAkAAAABMEUCIQDDHw8sGG48KGn437BCLvRagP/b5YARF2KmsQlFahOWHQIgffdUDd0VIcbqk0LhYDZ4HNEL5pJrVUHT9Aj1+7bFLcQAAABmA1dJQ2LNB9QU7FC2jH7KqGOiPTRPLQYvAAAAAAAAAAEwRAIgOSSZ6Pf9XAarW1WCT4HgSSgh7YR0CmOAP7FT3eidneoCIEZwHbEiCSY6l1J19hRQ3kLiYn9NmZph8IXdys7Y12N6AAAAaARXSUxE08AHcrJNmXqBIknKY3qSHoE1dwEAAAASAAAAATBFAiEAqdPDRjTfwh+0671n3GeNeWx+3H5Jlm8d0RBa0i+nMqICIDmf9BBN+tBOEy5X8npRnyBObAgz6PAKnVDYm+YhMltfAAAAZwRXRE5UGDQzy7X0tSr/FQn3hkyi925NhTUAAAASAAAAATBEAiBRSqionN40NL8hfg84M97j8FUySetI5+iRijNRghTFDAIgfVvbksCY/bL/AdHmtzvTTChemhyShiLihwIeT0I4oMQAAABpBVdJTkdTZnCIshLOPQahtVOnIh4f0ZAA2a8AAAASAAAAATBFAiEA0D0DuN22m9HPm15acNivNIZIbC406l2pLsAseS7cqvICIH/O8tkhbnWm0oTjjURv0GAUHtJ7Ga8arFcKLdC8O7lDAAAAZwRXT0xLcoeB51c13Ali3zpR1+9H55inEH4AAAASAAAAATBEAiAsMs1xZvLi7eNP6paSmGHgpvEPICDWevdY8q8uPEbgUAIgH2K28mDF06/8wOANEnPM14Dx27yNMtYgXKe3lx44GYYAAABnBFdPTEv2tVrLvEn0UkqkjRkoGpp3xU3hDwAAABIAAAABMEQCICaRi89drQYW38BT0tf4uXr+oMH/7VLnCj3Kr5pbjH69AiAFj4HJTn3oKIGA9BuTzv6Jlu2Qq1Vq+lIXn7MP8dgAfgAAAGcDV05L1zpmuPsmvosKzXxSvTJQVKx9RosAAAASAAAAATBFAiEA22LV19KYSXPEbUJNe1XFldf7+o3XcHQb8TDs1ICzqUYCIEgN3/zr5pKyWinW5hkZCt1Pf4nFrB2QiOaqbAiK68e1AAAAZwRXQVRUgppMoTAzg/EIK2sfuTcRbks7VgUAAAASAAAAATBEAiBD3vOgrFSYNbpOvNvgf6aMl++cKvxFYlYmMWf5GsHSlgIgTVpewlbV2azuQfKhtW2IurqKiwTJiBaNvqZ5Wnin67oAAABmA1dSS3Ho10/xySPjadDnDfsJhmYpxN01AAAAEgAAAAEwRAIgG/cZ66zBbxFuHDp/Fiw8Q8KYiDGBzqf75AJE1BaLZ3MCIFpd+uZubxXnWkYs4GMG4pqzjydDwV26pnxh07drT6sqAAAAZgNXUkNyra20R3hN16sfRyRndQ/EheTLLQAAAAYAAAABMEQCICB60/MGtu2R+nqLbUioRv/TeKqkAO4tp7hCIPg+AdPDAiBfDdRRLochro26Ib1EK4SHFkQIvJw79UM6J3xNmndy7gAAAGgEV0JUQyJg+sXlVCp3OqRPvP7ffBk7wsWZAAAACAAAAAEwRQIhANczs9G8SaBWmOFNiGmDTPGRG++JzZjqjTj3w3K4GgB7AiBvtD3t3HUItWfzMLopLtoSmUEJNUNMuXlf7CbqFWDdLAAAAGcDV1RUhBGcsz6PWQ11wtbqTmsHQadJTtoAAAAAAAAAATBFAiEA9E25uFLHMOSkq5ZuUp4lOmHygQ8jbIO5MuT5PP/Lkz0CIC+C3Nwv/0OW7zQvvzsD/FkZbGsoJIRBnlbMLoGr729xAAAAZwNXWVPYlQ/eqhAwS3p/0DovxmvDnzxxGgAAABIAAAABMEUCIQCepuYJYuwOJ4aAIoLqzghgeXRwhM+ulKKEFAadADVL2AIgYnbvToyUEvO2hCAaUyg1aGRaqcNmFpW4lDcErDZ7XqQAAABnA1dZVgVgF8Va564y0SrvfGed+DqFynX/AAAAEgAAAAEwRQIhAJ/2Hv7vr+IFMfsPv5wUrbtjc5noL2OVvbcsfDK8NefdAiAyolp7YHONwTDTTPe95lscfAnQSYCJR7Kv22jhHWqLzQAAAGcDWDhYkQ38GNbqPWpxJKb4tUWPKBBg+kwAAAASAAAAATBFAiEAmQR8g3Qz49HV1vfPN2ijYuzh4zeGD1Aen/JEwViCm6wCIHIHC6yakxR6C3o/EGEd426NJhj7O9GXWINi3lgUK5SMAAAAaARYQVVSTfgS9gZN7x5eAp8cqFh3fMmNLYEAAAAIAAAAATBFAiEA1UHuGQBzmbNPtD5Iqk9U50PDOu0FR7cmrI35GPivTcYCIC37dnR61mSFSCjaawppLFrlGdzt0diJiD4xs4ttm+bEAAAAZwNYTk6rlekVwSP97VvftjJeNe9VFfHqaQAAABIAAAABMEUCIQDAFHNG4Je0DWu9eIFQ+yDxoxA6enq+v2N4RrQRP9jr2gIgZ5x5q2+rsfUQyg7pHnymAUDkZmMgf16mxCs1r+zPf3MAAABmA1hTVFvJAcvr77A6VtReV+TzVtxNswq1AAAAEgAAAAEwRAIgR5ciJ4sT+teoChXJaQzAEamBnoLZE+JzTrrxpH1LVpsCIFoG7MzassTSvqZMgtf4ncw5+knAkTzQ7+eCpzhMEs2cAAAAZgNYR01TPvCYSy+qInrMYgxnzOEqo5zYzQAAAAgAAAABMEQCICkSMtAIIm6OeNmxybUaJHHP29XCaTQ6u+a5TTAHLnxXAiAbwN/Z2jEkT0uDSDAoO2bDDJiYXh1Zyx+FekjUpGT+KQAAAGYDWEdUMPSj4Kt6dnM9i2C4ndk8PQtMni8AAAASAAAAATBEAiAmBiq/Bd/fZZaotdxQS26IM3gCViwX0fzF4cEWB46AEgIgZMHpUag3o5GjoHljfdjbtv5LGZNHs6vW1n391SRULRsAAABmA1hJRLEQ7Hsdy4+rje2/KPU7xj6lvt2EAAAACAAAAAEwRAIgFgOeY6/D8B5eZD/+epmS0a6VH1WDC+LCeW7gdGB/ecECIGxiDEXgSF2BDTlc7UyC/acfkWcCtOrfVoCPBn2hzQsoAAAAaARYRENFQasbb8uy+p3O2BrL3sE+pjFfK/IAAAASAAAAATBFAiEAouTsNqmRxgc6GzL/z/gdoHOZ79fWnh9u9CivHsJXQvsCICiiyGQ6bNkyhV7TrEzc+HHVqgzHJJWvuRYDl5/F6s8RAAAAZgNYTVgPjEW4lnhKHkCFJrkwBRnvhmAgnAAAAAgAAAABMEQCIBEy0alqObOHujx0HnbgxPKMrAcNmof5+2p1uYnBdkaYAiBBwRDQGFlVKIOAhth/P4KrCxWVIRsnN0KoxoVcz4VQDQAAAGcEWE1DVEREn6TWB/gH0e1Kaa2UKXFyg5HIAAAAEgAAAAEwRAIgL1abogm3F9sEd7c9/SRyXmU5ehCTDZ2elTafm44fEd0CIDi56Ieh7b65KyI68t09ZQJT/794gco3cXh6EKOobBlJAAAAZQNYTlRXLm8xgFa6DF1HpCJlMROEPSUGkQAAAAAAAAABMEMCIDKS0IXlMWWRd2IXpQEiGzoa6OBVj75QfDjEy8SbwRDBAh87zg9VVtfwIDpUTQph/5n42BUcTs+/oZPBdQ4xdsw/AAAAZgNYT1YVPtnMG3kpedK94Lv0XMKn5Dal+QAAABIAAAABMEQCIDkn/51R0rr6YqMQ0wci1EQyR0lUL+nI6AOq7zah/7sTAiAcK5vX43JGYB0SkImyRYNoB7a6cSqyNrCUAA6oQs1QnQAAAGcDWFBBkFKK6zorc2t4D9G2xHi7fh1kMXAAAAASAAAAATBFAiEAnYeAeqOO0CL6e2GyUIzorVOC+9+CG5Za0BEZwRBQDn8CIHGNpmS0pNTl4FA9O0TcTYsOv86tKe98W0HQjlAeGT/UAAAAZwNYUkyyR1S+eSgVU9wa3BYN31zZt0NhpAAAAAkAAAABMEUCIQC0ftH1bsrGb8f046pHdFDWgztlTSWkhEzH+lSj0/joQgIgL2dUjgBH2GOCnA5XgZ0InNuBwY9yiBCgsyFb458kDpsAAABnA1hTQw9RP/tJJv+C1/YKBQaQR6yilcQTAAAAEgAAAAEwRQIhANY1HWH1O+SoTGqbUCKCBFvQYeoa5SfEXIN9Zs4Tmv8IAiABkhpTxA/HW7l/+CXHiiiX37/GMlVdW4m7x6NUkhQ75QAAAGYDWFRYGCISb+7bTH1h7s2+NoL+YekTg9YAAAASAAAAATBEAiA0//w2IjGGDq9BFiEmHf+SZ8ApWG0F/BovB5adGKPO5gIgNb8y+VjN+6oRRgXI02thsRbQEjzx4yIYqHRofdleiu8AAABmA1hZT1Upb2n0DqbSDkeFM8Faawi2VOdYAAAAEgAAAAEwRAIgFF1a9/tiYJCwmYZfX8ERcMylFRA0fNuhRAB1XtBP6+cCIBw2HuD76Ge+NPjymRjQoWJSi8+2WD5EAzf5xQYXiXjYAAAAZgNZTk4bx8HeCsbvT97DXAUwMNkM9Ux+mgAAABIAAAABMEQCICteXk9c4KOYHSDPEmMIlvUnqL6NRTCbKZM9bDeDFBM+AiA1inkR5VZqfKCUGjspBu9f+Sur7+gJrAvZDmKdLY+cXgAAAGcDWUVFkiEF+tgVP1Frz7gp9W3Al6Dh1wUAAAASAAAAATBFAiEAkIxzoUobSAv6Wd1HqgdkIo0oTDQfb1hlwQ/U75baEcMCIAOYlWbXYKva42TfM1aRQ3bS7r37GvlV+J42kyENpPtIAAAAaARZRUVEyieW+fYdx7I4qrBDlx5JxhZN83UAAAASAAAAATBFAiEAyKAQaGH8hUxDUOyGw+RNk6Lg1qHRMKP9Sae55Fg6TuMCIEefU8JQ+Peow2PJt8xC+U8ZJnnSk0gudq1lck6Vx4F6AAAAaAVZT1lPV8vq7GmUMYV/2003rdu9wg4TLUkDAAAAEgAAAAEwRAIgUeWLxpV5bfmrXjKXwyeVkbCdZ6y8fkcXk7dVOdNJf+ECIAdgimHlXIQGskkXqf/st2q7DuG9jGY7GWI0LSGRdVyuAAAAZwNZVVDZoSzeA6hugASWRphY3oWB06U1PQAAABIAAAABMEUCIQCW9wZhU/YTKBKB7sDRgMPIDKk9//bRjMzrpIRWLbvqOAIgT6XUmg+MNMp9J12HwEVD7xL2+sySkcLxQzQWT//w0MgAAABpBVlVUElFDzO7IKKCp2Scezr/ZE8ISpNI6TMAAAASAAAAATBFAiEA/heX6zN3PuKhP8mf6EXlbCR+fQbqLu5v3RSYHOPQSH8CIBteuwnZKQN5imHsPU9udVExJnHBCEb4bn0RWvU2mxlhAAAAZwNaQVBngaD4TH6ehG3LhKmlvUkzMGexBAAAABIAAAABMEUCIQD389a+5ALkpEoaG1L/UIKZm7XHTLg+5eb1dAdqpN0FAgIgccTlWUMA32bRfV2ESv9V67g/tFFJrHi6YanhlUYqyNgAAABnA1pDTyAI4wV71zThCtE8nq5F/xMqvBciAAAACAAAAAEwRQIhAOanqzQQtgfh00eZAxr27VOo4u+RcDZWSBCUbjPGl4MzAiBVuiaCeCac+Z7/QWBD48TJTMOxZMGIqepPjPp0FbyIFQAAAGcDWlNU44axOe03FcpLGP1SZxvc6hzf5LEAAAAIAAAAATBFAiEAlJR/JM9CV4lAzx+Gn2W7TrOIbm+D5UQTpHVwhplQKm0CICw3Mb7Bybq41Ro4c+wvma3uPsYyD3Ov4wNQZtyAAwHzAAAAaARaRVVT5+Qnm4DTGe3iiJhVE1oiAhuvCQcAAAASAAAAATBFAiEAvwr0R3ykK/2VcORcajrbnAgU1dL69DH2Sgw8S6ikiYMCIF64mHpI7JM18/ecT5o6LcQabOhZ5ny+EugO6BwR3ESNAAAAZgNaU0N6QeBRel7KT9vH++uk1MR7n/bcYwAAABIAAAABMEQCICE0lOjl4/qtCEWASXj9AJswdTOg2pAuudMlZ0rOzpZkAiAr2QRTJ96LYdH2TAkWmkmOKSj4RxIfrFz8NGpb+fesWAAAAGYDWkxB/Ylx1ejhdAzi0KhAlfyk3nKdDBYAAAASAAAAATBEAiAx1qmvYTLmiqiDVU8ENZz3mzAq3KT+EOcJM9zgD0+ojAIgWaHIz+Tjq59IN+u9btGaQaYNhc1ZSn2WtV1gbKVtFvsAAABnA1pJTAX0pC4lHy1SuO0V6f7arPzvH60nAAAADAAAAAEwRQIhAJXZiUsolGP5z8usN+RTOGv4MlZCImq1Tvs2CeYGOgKzAiBxvlzKYzy0vt7jG8cBKsEM3VmHEsNqsBWqEmwqXkBbJAAAAGgEWklOQ0qsRhyGq/px6dANmizejXTk4a7qAAAAEgAAAAEwRQIhAKXUuVxHAPdpk80dx8GV87+7tk0VLp7Wd/SwbyBsXmKLAiB91KG+lpd6YG0I7fFu4OmspZKiLyH+P9DxEm73ucv2cQAAAGYDWklQqdKSfToEMJ4Ai2r24uKCrilS5/0AAAASAAAAATBEAiBa40VHCbkCB1RWqF5eB+OR/saQEEdHT+faxNHIHiQ9iwIgRvFz4aT5WRea7pfJBxr8Fo3s9QAb7PmBIF7fae9PN4kAAABnBFpJUFTt18lP17SXG5FtFQZ7xFS54brZgAAAABIAAAABMEQCIDTrgApeivQBK2pOBEihcLn2/2xwLOPxLuCo6fyNZP11AiBWont0X5XMeCwraznHot5yYxtTIUSrF6ziO5oP1qUZnAAAAGcDWklY88CSyozW09TKAE3B0PH+jMq1NZkAAAASAAAAATBFAiEA2j2tfEzc7ht3q+rnmGe/n6rIAetQLoxqfZmO5X9hqxoCIHWnp1QFQ5puuo/Ig951TA09A/RZAX3LMW6EiZuLB23GAAAAZgNaTU5VT/x39CUan7PA41kKaiBfjU4GfQAAABIAAAABMEQCIATaA2Zp0bGjC8LxSEjqlV+mLVgrBQ9uBbvKE4oKYuJhAiBGhB2Ha3ALgTkrpSCsbcLQ5UPIDpinL8ijlXaKLhUwFAAAAGYDWlBStbj1YW/kLVzso+h/P9292PSW12AAAAASAAAAATBEAiB9NHHn5zoRIJphtYealiV59oTDVsAZxqlqPI27dkLUWQIgfNW0lC54ZlpibV51e7WQoPBGRntjiMbNCQwjWPdNAEEAAABnA1pUWOj5+pd+pYVZHZ85RoExjBZVJXf7AAAAEgAAAAEwRQIhAMRg74L/+1vMaS1S0pBtmEiQEmrno/0tQS2RQtSjmxwnAiAnYQZ013zrmLApzUzqLShE9/pC/GkB+rPpPWm1fdfQhA==";

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-app-eth/erc20.js":
/*!****************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-app-eth/erc20.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/erc20 */ "./node_modules/@ledgerhq/hw-app-eth/lib/erc20.js");


/***/ }),

/***/ "./node_modules/@ledgerhq/hw-app-eth/lib/Eth.js":
/*!******************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-app-eth/lib/Eth.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /********************************************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   Ledger Node JS API
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   (c) 2016-2017 Ledger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  you may not use this file except in compliance with the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  You may obtain a copy of the License at
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *      http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  Unless required by applicable law or agreed to in writing, software
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  See the License for the specific language governing permissions and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  limitations under the License.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ********************************************************************************/


// FIXME drop:


var _utils = __webpack_require__(/*! ./utils */ "./node_modules/@ledgerhq/hw-app-eth/lib/utils.js");

var _errors = __webpack_require__(/*! @ledgerhq/errors */ "./node_modules/@ledgerhq/errors/lib/index.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var remapTransactionRelatedErrors = function remapTransactionRelatedErrors(e) {
  if (e && e.statusCode === 0x6a80) {
    return new _errors.EthAppPleaseEnableContractData("Please enable Contract data on the Ethereum app Settings");
  }
  return e;
};

/**
 * Ethereum API
 *
 * @example
 * import Eth from "@ledgerhq/hw-app-eth";
 * const eth = new Eth(transport)
 */

var Eth = function () {
  function Eth(transport) {
    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "w0w";

    _classCallCheck(this, Eth);

    this.transport = transport;
    transport.decorateAppAPIMethods(this, ["getAddress", "provideERC20TokenInformation", "signTransaction", "signPersonalMessage", "getAppConfiguration"], scrambleKey);
  }

  /**
   * get Ethereum address for a given BIP 32 path.
   * @param path a path in BIP 32 format
   * @option boolDisplay optionally enable or not the display
   * @option boolChaincode optionally enable or not the chaincode request
   * @return an object with a publicKey, address and (optionally) chainCode
   * @example
   * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
   */


  _createClass(Eth, [{
    key: "getAddress",
    value: function getAddress(path, boolDisplay, boolChaincode) {
      var paths = (0, _utils.splitPath)(path);
      var buffer = new Buffer(1 + paths.length * 4);
      buffer[0] = paths.length;
      paths.forEach(function (element, index) {
        buffer.writeUInt32BE(element, 1 + 4 * index);
      });
      return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(function (response) {
        var result = {};
        var publicKeyLength = response[0];
        var addressLength = response[1 + publicKeyLength];
        result.publicKey = response.slice(1, 1 + publicKeyLength).toString("hex");
        result.address = "0x" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString("ascii");
        if (boolChaincode) {
          result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString("hex");
        }
        return result;
      });
    }

    /**
     * This commands provides a trusted description of an ERC 20 token
     * to associate a contract address with a ticker and number of decimals.
     *
     * It shall be run immediately before performing a transaction involving a contract
     * calling this contract address to display the proper token information to the user if necessary.
     *
     * @param {*} info: a blob from "erc20.js" utilities that contains all token information.
     *
     * @example
     * import { byContractAddress } from "@ledgerhq/hw-app-eth/erc20"
     * const zrxInfo = byContractAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")
     * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)
     * const signed = await appEth.signTransaction(path, rawTxHex)
     */

  }, {
    key: "provideERC20TokenInformation",
    value: function provideERC20TokenInformation(_ref) {
      var data = _ref.data;

      return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(function () {
        return true;
      }, function (e) {
        if (e && e.statusCode === 0x6d00) {
          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.
          // we return a flag to know if the call was effective or not
          return false;
        }
        throw e;
      });
    }

    /**
     * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign
     * @example
     eth.signTransaction("44'/60'/0'/0/0", "e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080").then(result => ...)
     */

  }, {
    key: "signTransaction",
    value: function signTransaction(path, rawTxHex) {
      var _this = this;

      var paths = (0, _utils.splitPath)(path);
      var offset = 0;
      var rawTx = new Buffer(rawTxHex, "hex");
      var toSend = [];
      var response = void 0;

      var _loop = function _loop() {
        var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;
        var chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;
        var buffer = new Buffer(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);
        if (offset === 0) {
          buffer[0] = paths.length;
          paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
          });
          rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);
        } else {
          rawTx.copy(buffer, 0, offset, offset + chunkSize);
        }
        toSend.push(buffer);
        offset += chunkSize;
      };

      while (offset !== rawTx.length) {
        _loop();
      }
      return (0, _utils.foreach)(toSend, function (data, i) {
        return _this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {
          response = apduResponse;
        });
      }).then(function () {
        var v = response.slice(0, 1).toString("hex");
        var r = response.slice(1, 1 + 32).toString("hex");
        var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { v: v, r: r, s: s };
      }, function (e) {
        throw remapTransactionRelatedErrors(e);
      });
    }

    /**
     */

  }, {
    key: "getAppConfiguration",
    value: function getAppConfiguration() {
      return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(function (response) {
        var result = {};
        result.arbitraryDataEnabled = response[0] & 0x01;
        result.version = "" + response[1] + "." + response[2] + "." + response[3];
        return result;
      });
    }

    /**
    * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.
    * @example
    eth.signPersonalMessage("44'/60'/0'/0/0", Buffer.from("test").toString("hex")).then(result => {
    var v = result['v'] - 27;
    v = v.toString(16);
    if (v.length < 2) {
      v = "0" + v;
    }
    console.log("Signature 0x" + result['r'] + result['s'] + v);
    })
     */

  }, {
    key: "signPersonalMessage",
    value: function signPersonalMessage(path, messageHex) {
      var _this2 = this;

      var paths = (0, _utils.splitPath)(path);
      var offset = 0;
      var message = new Buffer(messageHex, "hex");
      var toSend = [];
      var response = void 0;

      var _loop2 = function _loop2() {
        var maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;
        var chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;
        var buffer = new Buffer(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);
        if (offset === 0) {
          buffer[0] = paths.length;
          paths.forEach(function (element, index) {
            buffer.writeUInt32BE(element, 1 + 4 * index);
          });
          buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);
          message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);
        } else {
          message.copy(buffer, 0, offset, offset + chunkSize);
        }
        toSend.push(buffer);
        offset += chunkSize;
      };

      while (offset !== message.length) {
        _loop2();
      }
      return (0, _utils.foreach)(toSend, function (data, i) {
        return _this2.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(function (apduResponse) {
          response = apduResponse;
        });
      }).then(function () {
        var v = response[0];
        var r = response.slice(1, 1 + 32).toString("hex");
        var s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");
        return { v: v, r: r, s: s };
      });
    }
  }]);

  return Eth;
}();

exports.default = Eth;
//# sourceMappingURL=Eth.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-app-eth/lib/erc20.js":
/*!********************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-app-eth/lib/erc20.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.list = exports.byContractAddress = undefined;

var _erc = __webpack_require__(/*! ../data/erc20.js */ "./node_modules/@ledgerhq/hw-app-eth/data/erc20.js");

var _erc2 = _interopRequireDefault(_erc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Retrieve the token information by a given contract address if any
 */
var byContractAddress = exports.byContractAddress = function byContractAddress(contract) {
  return get().byContract(asContractAddress(contract));
};

/**
 * list all the ERC20 tokens informations
 */

var list = exports.list = function list() {
  return get().list();
};

var asContractAddress = function asContractAddress(addr) {
  var a = addr.toLowerCase();
  return a.startsWith("0x") ? a : "0x" + a;
};

// this internal get() will lazy load and cache the data from the erc20 data blob
var get = function () {
  var cache = void 0;
  return function () {
    if (cache) return cache;
    var buf = Buffer.from(_erc2.default, "base64");
    var byContract = {};
    var entries = [];
    var i = 0;
    while (i < buf.length) {
      var length = buf.readUInt32BE(i);
      i += 4;
      var item = buf.slice(i, i + length);
      var j = 0;
      var tickerLength = item.readUInt8(j);
      j += 1;
      var _ticker = item.slice(j, j + tickerLength).toString("ascii");
      j += tickerLength;
      var _contractAddress = asContractAddress(item.slice(j, j + 20).toString("hex"));
      j += 20;
      var _decimals = item.readUInt32BE(j);
      j += 4;
      var _chainId = item.readUInt32BE(j);
      j += 4;
      var _signature = item.slice(j);
      var entry = {
        ticker: _ticker,
        contractAddress: _contractAddress,
        decimals: _decimals,
        chainId: _chainId,
        signature: _signature,
        data: item
      };
      entries.push(entry);
      byContract[_contractAddress] = entry;
      i += length;
    }
    var api = {
      list: function list() {
        return entries;
      },
      byContract: function (_byContract) {
        function byContract(_x) {
          return _byContract.apply(this, arguments);
        }

        byContract.toString = function () {
          return _byContract.toString();
        };

        return byContract;
      }(function (contractAddress) {
        return byContract[contractAddress];
      })
    };
    cache = api;
    return api;
  };
}();
//# sourceMappingURL=erc20.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-app-eth/lib/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-app-eth/lib/utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defer = defer;
exports.splitPath = splitPath;
exports.eachSeries = eachSeries;
exports.foreach = foreach;
exports.doIf = doIf;
exports.asyncWhile = asyncWhile;
function defer() {
  var resolve = void 0,
      reject = void 0;
  var promise = new Promise(function (success, failure) {
    resolve = success;
    reject = failure;
  });
  if (!resolve || !reject) throw "defer() error"; // this never happens and is just to make flow happy
  return { promise: promise, resolve: resolve, reject: reject };
}

// TODO use bip32-path library
/********************************************************************************
 *   Ledger Node JS API
 *   (c) 2016-2017 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ********************************************************************************/


function splitPath(path) {
  var result = [];
  var components = path.split("/");
  components.forEach(function (element) {
    var number = parseInt(element, 10);
    if (isNaN(number)) {
      return; // FIXME shouldn't it throws instead?
    }
    if (element.length > 1 && element[element.length - 1] === "'") {
      number += 0x80000000;
    }
    result.push(number);
  });
  return result;
}

// TODO use async await

function eachSeries(arr, fun) {
  return arr.reduce(function (p, e) {
    return p.then(function () {
      return fun(e);
    });
  }, Promise.resolve());
}

function foreach(arr, callback) {
  function iterate(index, array, result) {
    if (index >= array.length) {
      return result;
    } else return callback(array[index], index).then(function (res) {
      result.push(res);
      return iterate(index + 1, array, result);
    });
  }
  return Promise.resolve().then(function () {
    return iterate(0, arr, []);
  });
}

function doIf(condition, callback) {
  return Promise.resolve().then(function () {
    if (condition) {
      return callback();
    }
  });
}

function asyncWhile(predicate, callback) {
  function iterate(result) {
    if (!predicate()) {
      return result;
    } else {
      return callback().then(function (res) {
        result.push(res);
        return iterate(result);
      });
    }
  }
  return Promise.resolve([]).then(iterate);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-u2f/lib/TransportU2F.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-u2f/lib/TransportU2F.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _u2fApi = __webpack_require__(/*! u2f-api */ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/index.js");

var _hwTransport = __webpack_require__(/*! @ledgerhq/hw-transport */ "./node_modules/@ledgerhq/hw-transport/lib/Transport.js");

var _hwTransport2 = _interopRequireDefault(_hwTransport);

var _logs = __webpack_require__(/*! @ledgerhq/logs */ "./node_modules/@ledgerhq/logs/lib/index.js");

var _errors = __webpack_require__(/*! @ledgerhq/errors */ "./node_modules/@ledgerhq/errors/lib/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function wrapU2FTransportError(originalError, message, id) {
  var err = new _errors.TransportError(message, id);
  // $FlowFixMe
  err.originalError = originalError;
  return err;
}

function wrapApdu(apdu, key) {
  var result = Buffer.alloc(apdu.length);
  for (var i = 0; i < apdu.length; i++) {
    result[i] = apdu[i] ^ key[i % key.length];
  }
  return result;
}

// Convert from normal to web-safe, strip trailing "="s
var webSafe64 = function webSafe64(base64) {
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
};

// Convert from web-safe to normal, add trailing "="s
var normal64 = function normal64(base64) {
  return base64.replace(/-/g, "+").replace(/_/g, "/") + "==".substring(0, 3 * base64.length % 4);
};

function attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {
  var keyHandle = wrapApdu(apdu, scrambleKey);
  var challenge = Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex");
  var signRequest = {
    version: "U2F_V2",
    keyHandle: webSafe64(keyHandle.toString("base64")),
    challenge: webSafe64(challenge.toString("base64")),
    appId: location.origin
  };
  (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));
  return (0, _u2fApi.sign)(signRequest, timeoutMillis / 1000).then(function (response) {
    var signatureData = response.signatureData;

    if (typeof signatureData === "string") {
      var data = Buffer.from(normal64(signatureData), "base64");
      var result = void 0;
      if (!unwrap) {
        result = data;
      } else {
        result = data.slice(5);
      }
      (0, _logs.log)("apdu", "<= " + result.toString("hex"));
      return result;
    } else {
      throw response;
    }
  });
}

var transportInstances = [];

function emitDisconnect() {
  transportInstances.forEach(function (t) {
    return t.emit("disconnect");
  });
  transportInstances = [];
}

function isTimeoutU2FError(u2fError) {
  return u2fError.metaData.code === 5;
}

/**
 * U2F web Transport implementation
 * @example
 * import TransportU2F from "@ledgerhq/hw-transport-u2f";
 * ...
 * TransportU2F.create().then(transport => ...)
 */

var TransportU2F = function (_Transport) {
  _inherits(TransportU2F, _Transport);

  _createClass(TransportU2F, null, [{
    key: "open",


    /**
     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)
     */


    /*
     */
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_) {
        var _openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new TransportU2F());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function open(_x) {
        return _ref.apply(this, arguments);
      }

      return open;
    }()

    /*
     */

  }]);

  function TransportU2F() {
    _classCallCheck(this, TransportU2F);

    var _this = _possibleConstructorReturn(this, (TransportU2F.__proto__ || Object.getPrototypeOf(TransportU2F)).call(this));

    _this.unwrap = true;

    transportInstances.push(_this);
    return _this;
  }

  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */


  _createClass(TransportU2F, [{
    key: "exchange",
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(apdu) {
        var isU2FError;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);
                isU2FError = _typeof(_context2.t0.metaData) === "object";

                if (!isU2FError) {
                  _context2.next = 14;
                  break;
                }

                if (isTimeoutU2FError(_context2.t0)) {
                  emitDisconnect();
                }
                // the wrapping make error more usable and "printable" to the end user.
                throw wrapU2FTransportError(_context2.t0, "Failed to sign with Ledger device: U2F " + _context2.t0.metaData.type, "U2F_" + _context2.t0.metaData.code);

              case 14:
                throw _context2.t0;

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 6]]);
      }));

      function exchange(_x3) {
        return _ref2.apply(this, arguments);
      }

      return exchange;
    }()

    /**
     */

  }, {
    key: "setScrambleKey",
    value: function setScrambleKey(scrambleKey) {
      this.scrambleKey = Buffer.from(scrambleKey, "ascii");
    }

    /**
     */

  }, {
    key: "setUnwrap",
    value: function setUnwrap(unwrap) {
      this.unwrap = unwrap;
    }
  }, {
    key: "close",
    value: function close() {
      // u2f have no way to clean things up
      return Promise.resolve();
    }
  }]);

  return TransportU2F;
}(_hwTransport2.default);

TransportU2F.isSupported = _u2fApi.isSupported;

TransportU2F.list = function () {
  return (
    // this transport is not discoverable but we are going to guess if it is here with isSupported()
    (0, _u2fApi.isSupported)().then(function (supported) {
      return supported ? [null] : [];
    })
  );
};

TransportU2F.listen = function (observer) {
  var unsubscribed = false;
  (0, _u2fApi.isSupported)().then(function (supported) {
    if (unsubscribed) return;
    if (supported) {
      observer.next({ type: "add", descriptor: null });
      observer.complete();
    } else {
      observer.error(new _errors.TransportError("U2F browser support is needed for Ledger. " + "Please use Chrome, Opera or Firefox with a U2F extension. " + "Also make sure you're on an HTTPS connection", "U2FNotSupported"));
    }
  });
  return {
    unsubscribe: function unsubscribe() {
      unsubscribed = true;
    }
  };
};

exports.default = TransportU2F;
//# sourceMappingURL=TransportU2F.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__( /*! ./lib/u2f-api */ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/u2f-api.js" );

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/google-u2f-api.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/google-u2f-api.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2014 Google Inc. All rights reserved
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

/**
 * @fileoverview The U2F api.
 */



/** Namespace for the U2F api.
 * @type {Object}
 */
var u2f = u2f || {};

module.exports = u2f; // Adaptation for u2f-api package

/**
 * The U2F extension id
 * @type {string}
 * @const
 */
u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';

/**
 * Message types for messsages to/from the extension
 * @const
 * @enum {string}
 */
u2f.MessageTypes = {
  'U2F_REGISTER_REQUEST': 'u2f_register_request',
  'U2F_SIGN_REQUEST': 'u2f_sign_request',
  'U2F_REGISTER_RESPONSE': 'u2f_register_response',
  'U2F_SIGN_RESPONSE': 'u2f_sign_response'
};

/**
 * Response status codes
 * @const
 * @enum {number}
 */
u2f.ErrorCodes = {
  'OK': 0,
  'OTHER_ERROR': 1,
  'BAD_REQUEST': 2,
  'CONFIGURATION_UNSUPPORTED': 3,
  'DEVICE_INELIGIBLE': 4,
  'TIMEOUT': 5
};

/**
 * A message type for registration requests
 * @typedef {{
 *   type: u2f.MessageTypes,
 *   signRequests: Array.<u2f.SignRequest>,
 *   registerRequests: ?Array.<u2f.RegisterRequest>,
 *   timeoutSeconds: ?number,
 *   requestId: ?number
 * }}
 */
u2f.Request;

/**
 * A message for registration responses
 * @typedef {{
 *   type: u2f.MessageTypes,
 *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),
 *   requestId: ?number
 * }}
 */
u2f.Response;

/**
 * An error object for responses
 * @typedef {{
 *   errorCode: u2f.ErrorCodes,
 *   errorMessage: ?string
 * }}
 */
u2f.Error;

/**
 * Data object for a single sign request.
 * @typedef {{
 *   version: string,
 *   challenge: string,
 *   keyHandle: string,
 *   appId: string
 * }}
 */
u2f.SignRequest;

/**
 * Data object for a sign response.
 * @typedef {{
 *   keyHandle: string,
 *   signatureData: string,
 *   clientData: string
 * }}
 */
u2f.SignResponse;

/**
 * Data object for a registration request.
 * @typedef {{
 *   version: string,
 *   challenge: string,
 *   appId: string
 * }}
 */
u2f.RegisterRequest;

/**
 * Data object for a registration response.
 * @typedef {{
 *   registrationData: string,
 *   clientData: string
 * }}
 */
u2f.RegisterResponse;


// Low level MessagePort API support

/**
 * Call MessagePort disconnect
 */
u2f.disconnect = function() {
  if (u2f.port_ && u2f.port_.port_) {
    u2f.port_.port_.disconnect();
    u2f.port_ = null;
  }
};

/**
 * Sets up a MessagePort to the U2F extension using the
 * available mechanisms.
 * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
 */
u2f.getMessagePort = function(callback) {
  if (typeof chrome != 'undefined' && chrome.runtime) {
    // The actual message here does not matter, but we need to get a reply
    // for the callback to run. Thus, send an empty signature request
    // in order to get a failure response.
    var msg = {
      type: u2f.MessageTypes.U2F_SIGN_REQUEST,
      signRequests: []
    };
    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {
      if (!chrome.runtime.lastError) {
        // We are on a whitelisted origin and can talk directly
        // with the extension.
        u2f.getChromeRuntimePort_(callback);
      } else {
        // chrome.runtime was available, but we couldn't message
        // the extension directly, use iframe
        u2f.getIframePort_(callback);
      }
    });
  } else {
    // chrome.runtime was not available at all, which is normal
    // when this origin doesn't have access to any extensions.
    u2f.getIframePort_(callback);
  }
};

/**
 * Connects directly to the extension via chrome.runtime.connect
 * @param {function(u2f.WrappedChromeRuntimePort_)} callback
 * @private
 */
u2f.getChromeRuntimePort_ = function(callback) {
  var port = chrome.runtime.connect(u2f.EXTENSION_ID,
    {'includeTlsChannelId': true});
  setTimeout(function() {
    callback(null, new u2f.WrappedChromeRuntimePort_(port));
  }, 0);
};

/**
 * A wrapper for chrome.runtime.Port that is compatible with MessagePort.
 * @param {Port} port
 * @constructor
 * @private
 */
u2f.WrappedChromeRuntimePort_ = function(port) {
  this.port_ = port;
};

/**
 * Posts a message on the underlying channel.
 * @param {Object} message
 */
u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
  this.port_.postMessage(message);
};

/**
 * Emulates the HTML 5 addEventListener interface. Works only for the
 * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.
 * @param {string} eventName
 * @param {function({data: Object})} handler
 */
u2f.WrappedChromeRuntimePort_.prototype.addEventListener =
    function(eventName, handler) {
  var name = eventName.toLowerCase();
  if (name == 'message' || name == 'onmessage') {
    this.port_.onMessage.addListener(function(message) {
      // Emulate a minimal MessageEvent object
      handler({'data': message});
    });
  } else {
    console.error('WrappedChromeRuntimePort only supports onMessage');
  }
};

/**
 * Sets up an embedded trampoline iframe, sourced from the extension.
 * @param {function(MessagePort)} callback
 * @private
 */
u2f.getIframePort_ = function(callback) {
  // Create the iframe
  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;
  var iframe = document.createElement('iframe');
  iframe.src = iframeOrigin + '/u2f-comms.html';
  iframe.setAttribute('style', 'display:none');
  document.body.appendChild(iframe);

  var hasCalledBack = false;

  var channel = new MessageChannel();
  var ready = function(message) {
    if (message.data == 'ready') {
      channel.port1.removeEventListener('message', ready);
      if (!hasCalledBack)
      {
        hasCalledBack = true;
        callback(null, channel.port1);
      }
    } else {
      console.error('First event on iframe port was not "ready"');
    }
  };
  channel.port1.addEventListener('message', ready);
  channel.port1.start();

  iframe.addEventListener('load', function() {
    // Deliver the port to the iframe and initialize
    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);
  });

  // Give this 200ms to initialize, after that, we treat this method as failed
  setTimeout(function() {
    if (!hasCalledBack)
    {
      hasCalledBack = true;
      callback(new Error("IFrame extension not supported"));
    }
  }, 200);
};


// High-level JS API

/**
 * Default extension response timeout in seconds.
 * @const
 */
u2f.EXTENSION_TIMEOUT_SEC = 30;

/**
 * A singleton instance for a MessagePort to the extension.
 * @type {MessagePort|u2f.WrappedChromeRuntimePort_}
 * @private
 */
u2f.port_ = null;

/**
 * Callbacks waiting for a port
 * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}
 * @private
 */
u2f.waitingForPort_ = [];

/**
 * A counter for requestIds.
 * @type {number}
 * @private
 */
u2f.reqCounter_ = 0;

/**
 * A map from requestIds to client callbacks
 * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))
 *                       |function((u2f.Error|u2f.SignResponse)))>}
 * @private
 */
u2f.callbackMap_ = {};

/**
 * Creates or retrieves the MessagePort singleton to use.
 * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
 * @private
 */
u2f.getPortSingleton_ = function(callback) {
  if (u2f.port_) {
    callback(null, u2f.port_);
  } else {
    if (u2f.waitingForPort_.length == 0) {
      u2f.getMessagePort(function(err, port) {
        if (!err) {
          u2f.port_ = port;
          u2f.port_.addEventListener('message',
            /** @type {function(Event)} */ (u2f.responseHandler_));
        }

        // Careful, here be async callbacks. Maybe.
        while (u2f.waitingForPort_.length)
          u2f.waitingForPort_.shift()(err, port);
      });
    }
    u2f.waitingForPort_.push(callback);
  }
};

/**
 * Handles response messages from the extension.
 * @param {MessageEvent.<u2f.Response>} message
 * @private
 */
u2f.responseHandler_ = function(message) {
  var response = message.data;
  var reqId = response['requestId'];
  if (!reqId || !u2f.callbackMap_[reqId]) {
    console.error('Unknown or missing requestId in response.');
    return;
  }
  var cb = u2f.callbackMap_[reqId];
  delete u2f.callbackMap_[reqId];
  cb(null, response['responseData']);
};

/**
 * Calls the callback with true or false as first and only argument
 * @param {Function} callback
 */
u2f.isSupported = function(callback) {
  u2f.getPortSingleton_(function(err, port) {
    callback(!err);
  });
}

/**
 * Dispatches an array of sign requests to available U2F tokens.
 * @param {Array.<u2f.SignRequest>} signRequests
 * @param {function((u2f.Error|u2f.SignResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.sign = function(signRequests, callback, opt_timeoutSeconds) {
  u2f.getPortSingleton_(function(err, port) {
    if (err)
      return callback(err);

    var reqId = ++u2f.reqCounter_;
    u2f.callbackMap_[reqId] = callback;
    var req = {
      type: u2f.MessageTypes.U2F_SIGN_REQUEST,
      signRequests: signRequests,
      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
      requestId: reqId
    };
    port.postMessage(req);
  });
};

/**
 * Dispatches register requests to available U2F tokens. An array of sign
 * requests identifies already registered tokens.
 * @param {Array.<u2f.RegisterRequest>} registerRequests
 * @param {Array.<u2f.SignRequest>} signRequests
 * @param {function((u2f.Error|u2f.RegisterResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.register = function(registerRequests, signRequests,
    callback, opt_timeoutSeconds) {
  u2f.getPortSingleton_(function(err, port) {
    if (err)
      return callback(err);

    var reqId = ++u2f.reqCounter_;
    u2f.callbackMap_[reqId] = callback;
    var req = {
      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
      signRequests: signRequests,
      registerRequests: registerRequests,
      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
      requestId: reqId
    };
    port.postMessage(req);
  });
};


/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/u2f-api.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/u2f-api.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

module.exports = API;

var chromeApi = __webpack_require__( /*! ./google-u2f-api */ "./node_modules/@ledgerhq/hw-transport-u2f/node_modules/u2f-api/lib/google-u2f-api.js" );

// Feature detection (yes really)
var isBrowser = ( typeof navigator !== 'undefined' ) && !!navigator.userAgent;
var isSafari = isBrowser && navigator.userAgent.match( /Safari\// )
	&& !navigator.userAgent.match( /Chrome\// );
var isEDGE = isBrowser && navigator.userAgent.match( /Edge\/1[2345]/ );

var _backend = null;
function getBackend( Promise )
{
	if ( !_backend )
		_backend = new Promise( function( resolve, reject )
		{
			function notSupported( )
			{
				// Note; {native: true} means *not* using Google's hack
				resolve( { u2f: null, native: true } );
			}

			if ( !isBrowser )
				return notSupported( );

			if ( isSafari )
				// Safari doesn't support U2F, and the Safari-FIDO-U2F
				// extension lacks full support (Multi-facet apps), so we
				// block it until proper support.
				return notSupported( );

			var hasNativeSupport =
				( typeof window.u2f !== 'undefined' ) &&
				( typeof window.u2f.sign === 'function' );

			if ( hasNativeSupport )
				resolve( { u2f: window.u2f, native: true } );

			if ( isEDGE )
				// We don't want to check for Google's extension hack on EDGE
				// as it'll cause trouble (popups, etc)
				return notSupported( );

			if ( location.protocol === 'http:' )
				// U2F isn't supported over http, only https
				return notSupported( );

			if ( typeof MessageChannel === 'undefined' )
				// Unsupported browser, the chrome hack would throw
				return notSupported( );

			// Test for google extension support
			chromeApi.isSupported( function( ok )
			{
				if ( ok )
					resolve( { u2f: chromeApi, native: false } );
				else
					notSupported( );
			} );
		} );

	return _backend;
}

function API( Promise )
{
	return {
		isSupported   : isSupported.bind( Promise ),
		ensureSupport : ensureSupport.bind( Promise ),
		register      : register.bind( Promise ),
		sign          : sign.bind( Promise ),
		ErrorCodes    : API.ErrorCodes,
		ErrorNames    : API.ErrorNames
	};
}

API.ErrorCodes = {
	CANCELLED: -1,
	OK: 0,
	OTHER_ERROR: 1,
	BAD_REQUEST: 2,
	CONFIGURATION_UNSUPPORTED: 3,
	DEVICE_INELIGIBLE: 4,
	TIMEOUT: 5
};
API.ErrorNames = {
	"-1": "CANCELLED",
	"0": "OK",
	"1": "OTHER_ERROR",
	"2": "BAD_REQUEST",
	"3": "CONFIGURATION_UNSUPPORTED",
	"4": "DEVICE_INELIGIBLE",
	"5": "TIMEOUT"
};

function makeError( msg, err )
{
	var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR
	var type = API.ErrorNames[ '' + code ];
	var error = new Error( msg );
	error.metaData = {
		type: type,
		code: code
	}
	return error;
}

function deferPromise( Promise, promise )
{
	var ret = { };
	ret.promise = new Promise( function( resolve, reject ) {
		ret.resolve = resolve;
		ret.reject = reject;
		promise.then( resolve, reject );
	} );
	/**
	 * Reject request promise and disconnect port if 'disconnect' flag is true
	 * @param {string} msg
	 * @param {boolean} disconnect
	 */
	ret.promise.cancel = function( msg, disconnect )
	{
		getBackend( Promise )
		.then( function( backend )
		{
			if ( disconnect && !backend.native )
				backend.u2f.disconnect( );

			ret.reject( makeError( msg, { errorCode: -1 } ) );
		} );
	};
	return ret;
}

function defer( Promise, fun )
{
	return deferPromise( Promise, new Promise( function( resolve, reject )
	{
		try
		{
			fun && fun( resolve, reject );
		}
		catch ( err )
		{
			reject( err );
		}
	} ) );
}

function isSupported( )
{
	var Promise = this;

	return getBackend( Promise )
	.then( function( backend )
	{
		return !!backend.u2f;
	} );
}

function _ensureSupport( backend )
{
	if ( !backend.u2f )
	{
		if ( location.protocol === 'http:' )
			throw new Error( "U2F isn't supported over http, only https" );
		throw new Error( "U2F not supported" );
	}
}

function ensureSupport( )
{
	var Promise = this;

	return getBackend( Promise )
	.then( _ensureSupport );
}

function register( registerRequests, signRequests /* = null */, timeout )
{
	var Promise = this;

	if ( !Array.isArray( registerRequests ) )
		registerRequests = [ registerRequests ];

	if ( typeof signRequests === 'number' && typeof timeout === 'undefined' )
	{
		timeout = signRequests;
		signRequests = null;
	}

	if ( !signRequests )
		signRequests = [ ];

	return deferPromise( Promise, getBackend( Promise )
	.then( function( backend )
	{
		_ensureSupport( backend );

		var native = backend.native;
		var u2f = backend.u2f;

		return new Promise( function( resolve, reject )
		{
			function cbNative( response )
			{
				if ( response.errorCode )
					reject( makeError( "Registration failed", response ) );
				else
				{
					delete response.errorCode;
					resolve( response );
				}
			}

			function cbChrome( err, response )
			{
				if ( err )
					reject( err );
				else if ( response.errorCode )
					reject( makeError( "Registration failed", response ) );
				else
					resolve( response );
			}

			if ( native )
			{
				var appId = registerRequests[ 0 ].appId;

				u2f.register(
					appId, registerRequests, signRequests, cbNative, timeout );
			}
			else
			{
				u2f.register(
					registerRequests, signRequests, cbChrome, timeout );
			}
		} );
	} ) ).promise;
}

function sign( signRequests, timeout )
{
	var Promise = this;

	if ( !Array.isArray( signRequests ) )
		signRequests = [ signRequests ];

	return deferPromise( Promise, getBackend( Promise )
	.then( function( backend )
	{
		_ensureSupport( backend );

		var native = backend.native;
		var u2f = backend.u2f;

		return new Promise( function( resolve, reject )
		{
			function cbNative( response )
			{
				if ( response.errorCode )
					reject( makeError( "Sign failed", response ) );
				else
				{
					delete response.errorCode;
					resolve( response );
				}
			}

			function cbChrome( err, response )
			{
				if ( err )
					reject( err );
				else if ( response.errorCode )
					reject( makeError( "Sign failed", response ) );
				else
					resolve( response );
			}

			if ( native )
			{
				var appId = signRequests[ 0 ].appId;
				var challenge = signRequests[ 0 ].challenge;

				u2f.sign( appId, challenge, signRequests, cbNative, timeout );
			}
			else
			{
				u2f.sign( signRequests, cbChrome, timeout );
			}
		} );
	} ) ).promise;
}

function makeDefault( func )
{
	API[ func ] = function( )
	{
		if ( !global.Promise )
			// This is very unlikely to ever happen, since browsers
			// supporting U2F will most likely support Promises.
			throw new Error( "The platform doesn't natively support promises" );

		var args = [ ].slice.call( arguments );
		return API( global.Promise )[ func ].apply( null, args );
	};
}

// Provide default functions using the built-in Promise if available.
makeDefault( 'isSupported' );
makeDefault( 'ensureSupport' );
makeDefault( 'register' );
makeDefault( 'sign' );

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webusb/lib/TransportWebUSB.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-webusb/lib/TransportWebUSB.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _hwTransport = __webpack_require__(/*! @ledgerhq/hw-transport */ "./node_modules/@ledgerhq/hw-transport/lib/Transport.js");

var _hwTransport2 = _interopRequireDefault(_hwTransport);

var _hidFraming = __webpack_require__(/*! @ledgerhq/devices/lib/hid-framing */ "./node_modules/@ledgerhq/devices/lib/hid-framing.js");

var _hidFraming2 = _interopRequireDefault(_hidFraming);

var _devices = __webpack_require__(/*! @ledgerhq/devices */ "./node_modules/@ledgerhq/devices/lib/index.js");

var _logs = __webpack_require__(/*! @ledgerhq/logs */ "./node_modules/@ledgerhq/logs/lib/index.js");

var _errors = __webpack_require__(/*! @ledgerhq/errors */ "./node_modules/@ledgerhq/errors/lib/index.js");

var _webusb = __webpack_require__(/*! ./webusb */ "./node_modules/@ledgerhq/hw-transport-webusb/lib/webusb.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var configurationValue = 1;
var endpointNumber = 3;

/**
 * WebUSB Transport implementation
 * @example
 * import TransportWebUSB from "@ledgerhq/hw-transport-webusb";
 * ...
 * TransportWebUSB.create().then(transport => ...)
 */

var TransportWebUSB = function (_Transport) {
  _inherits(TransportWebUSB, _Transport);

  function TransportWebUSB(device, interfaceNumber) {
    _classCallCheck(this, TransportWebUSB);

    var _this = _possibleConstructorReturn(this, (TransportWebUSB.__proto__ || Object.getPrototypeOf(TransportWebUSB)).call(this));

    _initialiseProps.call(_this);

    _this.device = device;
    _this.interfaceNumber = interfaceNumber;
    _this.deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    return _this;
  }

  /**
   * Check if WebUSB transport is supported.
   */


  /**
   * List the WebUSB devices that was previously authorized by the user.
   */


  /**
   * Actively listen to WebUSB devices and emit ONE device
   * that was either accepted before, if not it will trigger the native permission UI.
   *
   * Important: it must be called in the context of a UI click!
   */


  _createClass(TransportWebUSB, [{
    key: "close",


    /**
     * Release the transport device
     */
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.exchangeBusyPromise;

              case 2:
                _context.next = 4;
                return this.device.releaseInterface(this.interfaceNumber);

              case 4:
                _context.next = 6;
                return this.device.reset();

              case 6:
                _context.next = 8;
                return this.device.close();

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _ref.apply(this, arguments);
      }

      return close;
    }()

    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */

  }, {
    key: "setScrambleKey",
    value: function setScrambleKey() {}
  }], [{
    key: "request",


    /**
     * Similar to create() except it will always display the device permission (even if some devices are already accepted).
     */
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var device;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return (0, _webusb.requestLedgerDevice)();

              case 2:
                device = _context2.sent;
                return _context2.abrupt("return", TransportWebUSB.open(device));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function request() {
        return _ref2.apply(this, arguments);
      }

      return request;
    }()

    /**
     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
     */

  }, {
    key: "openConnected",
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var devices;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return (0, _webusb.getLedgerDevices)();

              case 2:
                devices = _context3.sent;

                if (!(devices.length === 0)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", null);

              case 5:
                return _context3.abrupt("return", TransportWebUSB.open(devices[0]));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function openConnected() {
        return _ref3.apply(this, arguments);
      }

      return openConnected;
    }()

    /**
     * Create a Ledger transport with a USBDevice
     */

  }, {
    key: "open",
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(device) {
        var iface, interfaceNumber, transport, onDisconnect;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return device.open();

              case 2:
                if (!(device.configuration === null)) {
                  _context4.next = 5;
                  break;
                }

                _context4.next = 5;
                return device.selectConfiguration(configurationValue);

              case 5:
                _context4.next = 7;
                return device.reset();

              case 7:
                iface = device.configurations[0].interfaces.find(function (_ref5) {
                  var alternates = _ref5.alternates;
                  return alternates.some(function (a) {
                    return a.interfaceClass === 255;
                  });
                });

                if (iface) {
                  _context4.next = 10;
                  break;
                }

                throw new _errors.TransportInterfaceNotAvailable("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");

              case 10:
                interfaceNumber = iface.interfaceNumber;
                _context4.prev = 11;
                _context4.next = 14;
                return device.claimInterface(interfaceNumber);

              case 14:
                _context4.next = 21;
                break;

              case 16:
                _context4.prev = 16;
                _context4.t0 = _context4["catch"](11);
                _context4.next = 20;
                return device.close();

              case 20:
                throw new _errors.TransportInterfaceNotAvailable(_context4.t0.message);

              case 21:
                transport = new TransportWebUSB(device, interfaceNumber);

                onDisconnect = function onDisconnect(e) {
                  if (device === e.device) {
                    // $FlowFixMe
                    navigator.usb.removeEventListener("disconnect", onDisconnect);
                    transport._emitDisconnect(new _errors.DisconnectedDevice());
                  }
                };
                // $FlowFixMe


                navigator.usb.addEventListener("disconnect", onDisconnect);
                return _context4.abrupt("return", transport);

              case 25:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[11, 16]]);
      }));

      function open(_x) {
        return _ref4.apply(this, arguments);
      }

      return open;
    }()
  }]);

  return TransportWebUSB;
}(_hwTransport2.default);

TransportWebUSB.isSupported = _webusb.isSupported;
TransportWebUSB.list = _webusb.getLedgerDevices;

TransportWebUSB.listen = function (observer) {
  var unsubscribed = false;
  (0, _webusb.getFirstLedgerDevice)().then(function (device) {
    if (!unsubscribed) {
      var deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
      observer.next({ type: "add", descriptor: device, deviceModel: deviceModel });
      observer.complete();
    }
  }, function (error) {
    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {
      observer.error(new _errors.TransportWebUSBGestureRequired(error.message));
    } else {
      observer.error(new _errors.TransportOpenUserCancelled(error.message));
    }
  });
  function unsubscribe() {
    unsubscribed = true;
  }
  return { unsubscribe: unsubscribe };
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.channel = Math.floor(Math.random() * 0xffff);
  this.packetSize = 64;
  this._disconnectEmitted = false;

  this._emitDisconnect = function (e) {
    if (_this2._disconnectEmitted) return;
    _this2._disconnectEmitted = true;
    _this2.emit("disconnect", e);
  };

  this.exchange = function (apdu) {
    return _this2.exchangeAtomicImpl(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
      var channel, packetSize, framing, blocks, i, result, acc, r, buffer;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              channel = _this2.channel, packetSize = _this2.packetSize;

              (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));

              framing = (0, _hidFraming2.default)(channel, packetSize);

              // Write...

              blocks = framing.makeBlocks(apdu);
              i = 0;

            case 5:
              if (!(i < blocks.length)) {
                _context5.next = 12;
                break;
              }

              (0, _logs.log)("hid-frame", "=> " + blocks[i].toString("hex"));
              _context5.next = 9;
              return _this2.device.transferOut(endpointNumber, blocks[i]);

            case 9:
              i++;
              _context5.next = 5;
              break;

            case 12:

              // Read...
              result = void 0;
              acc = void 0;

            case 14:
              if (result = framing.getReducedResult(acc)) {
                _context5.next = 23;
                break;
              }

              _context5.next = 17;
              return _this2.device.transferIn(endpointNumber, packetSize);

            case 17:
              r = _context5.sent;
              buffer = Buffer.from(r.data.buffer);

              (0, _logs.log)("hid-frame", "<= " + buffer.toString("hex"));
              acc = framing.reduceResponse(acc, buffer);
              _context5.next = 14;
              break;

            case 23:

              (0, _logs.log)("apdu", "<= " + result.toString("hex"));
              return _context5.abrupt("return", result);

            case 25:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, _this2);
    }))).catch(function (e) {
      if (e && e.message && e.message.includes("disconnected")) {
        _this2._emitDisconnect(e);
        throw new _errors.DisconnectedDeviceDuringOperation(e.message);
      }
      throw e;
    });
  };
};

exports.default = TransportWebUSB;
//# sourceMappingURL=TransportWebUSB.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webusb/lib/webusb.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-webusb/lib/webusb.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSupported = exports.getFirstLedgerDevice = exports.getLedgerDevices = exports.requestLedgerDevice = undefined;

var requestLedgerDevice = exports.requestLedgerDevice = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var device;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return navigator.usb.requestDevice({ filters: ledgerDevices });

          case 2:
            device = _context.sent;
            return _context.abrupt("return", device);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function requestLedgerDevice() {
    return _ref.apply(this, arguments);
  };
}();

var getLedgerDevices = exports.getLedgerDevices = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var devices;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return navigator.usb.getDevices();

          case 2:
            devices = _context2.sent;
            return _context2.abrupt("return", devices.filter(function (d) {
              return d.vendorId === _devices.ledgerUSBVendorId;
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function getLedgerDevices() {
    return _ref2.apply(this, arguments);
  };
}();

var getFirstLedgerDevice = exports.getFirstLedgerDevice = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var existingDevices;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return getLedgerDevices();

          case 2:
            existingDevices = _context3.sent;

            if (!(existingDevices.length > 0)) {
              _context3.next = 5;
              break;
            }

            return _context3.abrupt("return", existingDevices[0]);

          case 5:
            return _context3.abrupt("return", requestLedgerDevice());

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function getFirstLedgerDevice() {
    return _ref3.apply(this, arguments);
  };
}();

var _devices = __webpack_require__(/*! @ledgerhq/devices */ "./node_modules/@ledgerhq/devices/lib/index.js");

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var ledgerDevices = [{ vendorId: _devices.ledgerUSBVendorId }];

var isSupported = exports.isSupported = function isSupported() {
  return Promise.resolve(!!navigator &&
  // $FlowFixMe
  !!navigator.usb && typeof navigator.usb.getDevices === "function");
};
//# sourceMappingURL=webusb.js.map

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport/lib/Transport.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport/lib/Transport.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAltStatusMessage = exports.StatusCodes = exports.TransportStatusError = exports.TransportError = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events2 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var _events3 = _interopRequireDefault(_events2);

var _errors = __webpack_require__(/*! @ledgerhq/errors */ "./node_modules/@ledgerhq/errors/lib/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

exports.TransportError = _errors.TransportError;
exports.TransportStatusError = _errors.TransportStatusError;
exports.StatusCodes = _errors.StatusCodes;
exports.getAltStatusMessage = _errors.getAltStatusMessage;

/**
 */


/**
 */


/**
 * type: add or remove event
 * descriptor: a parameter that can be passed to open(descriptor)
 * deviceModel: device info on the model (is it a nano s, nano x, ...)
 * device: transport specific device info
 */

/**
 */

/**
 * Transport defines the generic interface to share between node/u2f impl
 * A **Descriptor** is a parametric type that is up to be determined for the implementation.
 * it can be for instance an ID, an file path, a URL,...
 */
var Transport = function () {
  function Transport() {
    var _this = this;

    _classCallCheck(this, Transport);

    this.exchangeTimeout = 30000;
    this._events = new _events3.default();

    this.send = function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cla, ins, p1, p2) {
        var data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Buffer.alloc(0);
        var statusList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [_errors.StatusCodes.OK];
        var response, sw;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(data.length >= 256)) {
                  _context.next = 2;
                  break;
                }

                throw new _errors.TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");

              case 2:
                _context.next = 4;
                return _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));

              case 4:
                response = _context.sent;
                sw = response.readUInt16BE(response.length - 2);

                if (statusList.some(function (s) {
                  return s === sw;
                })) {
                  _context.next = 8;
                  break;
                }

                throw new _errors.TransportStatusError(sw);

              case 8:
                return _context.abrupt("return", response);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, _this);
      }));

      return function (_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      };
    }();

    this.exchangeAtomicImpl = function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(f) {
        var resolveBusy, busyPromise, res;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!_this.exchangeBusyPromise) {
                  _context2.next = 2;
                  break;
                }

                throw new _errors.TransportError("Transport race condition", "RaceCondition");

              case 2:
                resolveBusy = void 0;
                busyPromise = new Promise(function (r) {
                  resolveBusy = r;
                });

                _this.exchangeBusyPromise = busyPromise;
                _context2.prev = 5;
                _context2.next = 8;
                return f();

              case 8:
                res = _context2.sent;
                return _context2.abrupt("return", res);

              case 10:
                _context2.prev = 10;

                if (resolveBusy) resolveBusy();
                _this.exchangeBusyPromise = null;
                return _context2.finish(10);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, _this, [[5,, 10, 14]]);
      }));

      return function (_x7) {
        return _ref2.apply(this, arguments);
      };
    }();

    this._appAPIlock = null;
  }

  /**
   * Statically check if a transport is supported on the user's platform/browser.
   */


  /**
   * List once all available descriptors. For a better granularity, checkout `listen()`.
   * @return a promise of descriptors
   * @example
   * TransportFoo.list().then(descriptors => ...)
   */


  /**
   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )
   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `"add"` or `"remove"` and descriptor is a value you can pass to `open(descriptor)`.
   * each listen() call will first emit all potential device already connected and then will emit events can come over times,
   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.
   * @param observer is an object with a next, error and complete function (compatible with observer pattern)
   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.
   * @example
  const sub = TransportFoo.listen({
  next: e => {
    if (e.type==="add") {
      sub.unsubscribe();
      const transport = await TransportFoo.open(e.descriptor);
      ...
    }
  },
  error: error => {},
  complete: () => {}
  })
   */


  /**
   * attempt to create a Transport instance with potentially a descriptor.
   * @param descriptor: the descriptor to open the transport with.
   * @param timeout: an optional timeout
   * @return a Promise of Transport instance
   * @example
  TransportFoo.open(descriptor).then(transport => ...)
   */


  /**
   * low level api to communicate with the device
   * This method is for implementations to implement but should not be directly called.
   * Instead, the recommanded way is to use send() method
   * @param apdu the data to send
   * @return a Promise of response data
   */


  /**
   * set the "scramble key" for the next exchanges with the device.
   * Each App can have a different scramble key and they internally will set it at instanciation.
   * @param key the scramble key
   */


  /**
   * close the exchange with the device.
   * @return a Promise that ends when the transport is closed.
   */


  _createClass(Transport, [{
    key: "on",


    /**
     * Listen to an event on an instance of transport.
     * Transport implementation can have specific events. Here is the common events:
     * * `"disconnect"` : triggered if Transport is disconnected
     */
    value: function on(eventName, cb) {
      this._events.on(eventName, cb);
    }

    /**
     * Stop listening to an event on an instance of transport.
     */

  }, {
    key: "off",
    value: function off(eventName, cb) {
      this._events.removeListener(eventName, cb);
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var _events;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_events = this._events).emit.apply(_events, [event].concat(_toConsumableArray(args)));
    }

    /**
     * Enable or not logs of the binary exchange
     */

  }, {
    key: "setDebugMode",
    value: function setDebugMode() {
      console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    }

    /**
     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
     */

  }, {
    key: "setExchangeTimeout",
    value: function setExchangeTimeout(exchangeTimeout) {
      this.exchangeTimeout = exchangeTimeout;
    }

    /**
     * wrapper on top of exchange to simplify work of the implementation.
     * @param cla
     * @param ins
     * @param p1
     * @param p2
     * @param data
     * @param statusList is a list of accepted status code (shorts). [0x9000] by default
     * @return a Promise of response buffer
     */

  }, {
    key: "decorateAppAPIMethods",
    value: function decorateAppAPIMethods(self, methods, scrambleKey) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = methods[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var methodName = _step.value;

          self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "decorateAppAPIMethod",
    value: function decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {
      var _this2 = this;

      return function () {
        var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          var _appAPIlock;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _appAPIlock = _this2._appAPIlock;

                  if (!_appAPIlock) {
                    _context3.next = 3;
                    break;
                  }

                  return _context3.abrupt("return", Promise.reject(new _errors.TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked")));

                case 3:
                  _context3.prev = 3;

                  _this2._appAPIlock = methodName;
                  _this2.setScrambleKey(scrambleKey);
                  _context3.next = 8;
                  return f.apply(ctx, args);

                case 8:
                  return _context3.abrupt("return", _context3.sent);

                case 9:
                  _context3.prev = 9;

                  _this2._appAPIlock = null;
                  return _context3.finish(9);

                case 12:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, _this2, [[3,, 9, 12]]);
        }));

        return function () {
          return _ref3.apply(this, arguments);
        };
      }();
    }
  }], [{
    key: "create",


    /**
     * create() allows to open the first descriptor available or
     * throw if there is none or if timeout is reached.
     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
     * @example
    TransportFoo.create().then(transport => ...)
     */
    value: function create() {
      var _this3 = this;

      var openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
      var listenTimeout = arguments[1];

      return new Promise(function (resolve, reject) {
        var found = false;
        var sub = _this3.listen({
          next: function next(e) {
            found = true;
            if (sub) sub.unsubscribe();
            if (listenTimeoutId) clearTimeout(listenTimeoutId);
            _this3.open(e.descriptor, openTimeout).then(resolve, reject);
          },
          error: function error(e) {
            if (listenTimeoutId) clearTimeout(listenTimeoutId);
            reject(e);
          },
          complete: function complete() {
            if (listenTimeoutId) clearTimeout(listenTimeoutId);
            if (!found) {
              reject(new _errors.TransportError(_this3.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
            }
          }
        });
        var listenTimeoutId = listenTimeout ? setTimeout(function () {
          sub.unsubscribe();
          reject(new _errors.TransportError(_this3.ErrorMessage_ListenTimeout, "ListenTimeout"));
        }, listenTimeout) : null;
      });
    }

    // $FlowFixMe

  }]);

  return Transport;
}();

Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
exports.default = Transport;
//# sourceMappingURL=Transport.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@ledgerhq/logs/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@ledgerhq/logs/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * A Log object
 */
var id = 0;
var subscribers = [];

/**
 * log something
 * @param type a namespaced identifier of the log (it is not a level like "debug", "error" but more like "apdu-in", "apdu-out", etc...)
 * @param message a clear message of the log associated to the type
 */
var log = exports.log = function log(type, message, data) {
  var obj = { type: type, id: String(++id), date: new Date() };
  if (message) obj.message = message;
  if (data) obj.data = data;
  dispatch(obj);
};

/**
 * listen to logs.
 * @param cb that is called for each future log() with the Log object
 * @return a function that can be called to unsubscribe the listener
 */
var listen = exports.listen = function listen(cb) {
  subscribers.push(cb);
  return function () {
    var i = subscribers.indexOf(cb);
    if (i !== -1) {
      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952
      subscribers[i] = subscribers[subscribers.length - 1];
      subscribers.pop();
    }
  };
};

function dispatch(log) {
  for (var i = 0; i < subscribers.length; i++) {
    try {
      subscribers[i](log);
    } catch (e) {
      console.error(e);
    }
  }
}

// for debug purpose
global.__ledgerLogsListen = listen;
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/dist/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/dist/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var createLogger = _interopDefault(__webpack_require__(/*! logging */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/logging/lib/browser.js"));
var EventEmitter = _interopDefault(__webpack_require__(/*! events */ "./node_modules/events/events.js"));
var browserOrNode = __webpack_require__(/*! browser-or-node */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/browser-or-node/lib/index.js");
var detectBrowser = __webpack_require__(/*! detect-browser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/detect-browser/index.js");
var eccrypto = _interopDefault(__webpack_require__(/*! eccrypto */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/eccrypto/browser.js"));
var ethUtils = _interopDefault(__webpack_require__(/*! ethereumjs-util */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethereumjs-util/dist/index.js"));
var crypto = _interopDefault(__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js"));
var secp256k1 = _interopDefault(__webpack_require__(/*! secp256k1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/elliptic.js"));
var debugLogger = _interopDefault(__webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/browser.js"));
var uuid = _interopDefault(__webpack_require__(/*! uuid/v4 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/v4.js"));
var io = _interopDefault(__webpack_require__(/*! socket.io-client */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/index.js"));
var SimplePeer = _interopDefault(__webpack_require__(/*! simple-peer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/simple-peer/index.js"));

var version = "1.0.14";

var version$1 = version;

var stunServers = [{ urls: 'stun:global.stun.twilio.com:3478?transport=udp' }];

var versions = ['0.0.1'];

var connectionCodeSchemas = {
  '0.0.1': ['version', 'key', 'connId']
};

var connectionCodeSeparator = '_';

var signal = {
  attemptingTurn: 'attemptingTurn',
  turnToken: 'turnToken',
  tryTurn: 'tryTurn',
  connection: 'connection',
  connect: 'connect',
  signature: 'signature',
  offerSignal: 'offerSignal',
  offer: 'offer',
  answerSignal: 'answerSignal',
  answer: 'answer',
  rtcConnected: 'rtcConnected',
  disconnect: 'disconnect',
  handshake: 'handshake',
  confirmation: 'confirmation',
  invalidConnection: 'InvalidConnection',
  confirmationFailedBusy: 'confirmationFailedBusy',
  confirmationFailed: 'confirmationFailed'
};

var rtc = {
  error: 'error',
  connect: 'connect',
  close: 'close',
  data: 'data',
  signal: 'signal'
};

var iceConnectionState = {
  new: 'new',
  connecting: 'connecting',
  connected: 'connected',
  disconnected: 'disconnected',
  failed: 'failed',
  closed: 'closed'
};

var stages = {
  initiator: 'initiator',
  receiver: 'receiver'
};

var lifeCycle = {
  RtcInitiatedEvent: 'RtcInitiatedEvent',
  signatureCheck: 'signatureCheck',
  SocketConnectedEvent: 'SocketConnectedEvent',
  confirmationFailedEvent: 'confirmationFailedEvent',
  confirmationFailedBusyEvent: 'confirmationFailedBusyEvent',
  invalidConnectionEvent: 'invalidConnectionEvent',
  codeDisplay: 'codeDisplay',
  checkNumber: 'checkNumber',
  ConnectionId: 'ConnectionId',
  receiverVersion: 'receiverVersion',
  offerCreated: 'offerCreated',
  sendOffer: 'sendOffer',
  answerReceived: 'answerReceived',
  RtcConnectedEvent: 'RtcConnectedEvent',
  RtcConnectedEmitted: 'RtcConnectedEmitted',
  RtcClosedEvent: 'RtcClosedEvent',
  RtcDisconnectEvent: 'RtcDisconnectEvent',
  RtcDestroyedEvent: 'RtcDestroyedEvent',
  RtcFailedEvent: 'RtcFailedEvent',
  RtcErrorEvent: 'RtcErrorEvent',
  UsingFallback: 'UsingFallback',
  Failed: 'failed',
  attemptedDisconnectedSend: 'attemptedDisconnectedSend'
};

var communicationTypes = {
  address: 'address',
  signMessage: 'signMessage',
  signTx: 'signTx'
};

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/* eslint-disable no-undef */

var logger = createLogger('MewConnectCommon');

var MewConnectCommon = function (_EventEmitter) {
  inherits(MewConnectCommon, _EventEmitter);

  function MewConnectCommon() {
    classCallCheck(this, MewConnectCommon);

    var _this = possibleConstructorReturn(this, (MewConnectCommon.__proto__ || Object.getPrototypeOf(MewConnectCommon)).call(this));

    _this.isBrowser = browserOrNode.isBrowser;

    _this.jsonDetails = {
      stunSrvers: [].concat(toConsumableArray(stunServers)),
      signals: _extends({}, signal),
      stages: _extends({}, stages),
      lifeCycle: _extends({}, lifeCycle),
      rtc: _extends({}, rtc),
      communicationTypes: _extends({}, communicationTypes),
      iceConnectionState: _extends({}, iceConnectionState),
      connectionCodeSeparator: connectionCodeSeparator,
      version: version$1,
      versions: versions,
      connectionCodeSchemas: connectionCodeSchemas
    };
    return _this;
  }

  createClass(MewConnectCommon, [{
    key: 'isJSON',
    value: function isJSON(arg) {
      try {
        JSON.parse(arg);
        return true;
      } catch (e) {
        return false;
      }
    }
  }], [{
    key: 'getBrowserRTC',
    value: function getBrowserRTC() {
      if (typeof window === 'undefined') return null;
      var wrtc = {
        RTCPeerConnection:
        // eslint-disable-next-line no-undef
        window.RTCPeerConnection ||
        // eslint-disable-next-line no-undef
        window.mozRTCPeerConnection ||
        // eslint-disable-next-line no-undef
        window.webkitRTCPeerConnection,
        RTCSessionDescription:
        // eslint-disable-next-line no-undef
        window.RTCSessionDescription ||
        // eslint-disable-next-line no-undef
        window.mozRTCSessionDescription ||
        // eslint-disable-next-line no-undef
        window.webkitRTCSessionDescription,
        RTCIceCandidate:
        // eslint-disable-next-line no-undef
        window.RTCIceCandidate ||
        // eslint-disable-next-line no-undef
        window.mozRTCIceCandidate ||
        // eslint-disable-next-line no-undef
        window.webkitRTCIceCandidate
      };
      if (!wrtc.RTCPeerConnection) return null;
      return wrtc;
    }
  }, {
    key: 'checkWebRTCAvailable',
    value: function checkWebRTCAvailable() {
      var doesNotHaveWebRTC = MewConnectCommon.getBrowserRTC() == null;
      return !doesNotHaveWebRTC;
      // return false
    }
  }, {
    key: 'checkBrowser',
    value: function checkBrowser() {
      var browser = detectBrowser.detect();
      if (browser === null) {
        browser = { version: { split: function split() {
              return [1];
            } } };
      }
      var browserVersion = browser.version.split(0, 1)[0];
      /*
       * Chrome > 23
       * Firefox > 22
       * Opera > 18
       * Safari > 11 (caveats exist)
       * Edge - none (RTCDataChannel not supported)
       * IE - none
       * */
      if (typeof window !== 'undefined') {
        if (browser.name === 'safari') {
          // eslint-disable-next-line global-require
          __webpack_require__(/*! webrtc-adapter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_core.js");
          return MewConnectCommon.buildBrowserResult(true, 'Safari', 'version: ' + browser.version);
        }
        if (browser.name === 'ie') {
          return MewConnectCommon.buildBrowserResult(true, 'Internet Explorer', '', true);
        }
        if (browser.name === 'edge') {
          return MewConnectCommon.buildBrowserResult(true, 'Edge', 'version: ' + browser.version, true);
        }
        var name = '';
        var minVersion = 0;

        if (browser.name === 'opera') {
          name = 'Opera';
          minVersion = 18;
        } else if (browser.name === 'firefox') {
          name = 'Firefox';
          minVersion = 22;
        } else if (browser.name === 'chrome') {
          name = 'Chrome';
          minVersion = 23;
        } else {
          return MewConnectCommon.buildBrowserResult(false, '', '', true);
        }

        try {
          if (minVersion >= +browserVersion) {
            return MewConnectCommon.buildBrowserResult(true, name, 'version: ' + browserVersion);
          }
          return MewConnectCommon.buildBrowserResult(false, '', '');
        } catch (e) {
          logger.error(e);
        }
      }
    }
  }, {
    key: 'buildBrowserResult',
    value: function buildBrowserResult(status, browser, browserVersion, noSupport) {
      return {
        status: status,
        browser: browser,
        browserVersion: browserVersion,
        noSupport: noSupport || false
      };
    }
  }]);
  return MewConnectCommon;
}(EventEmitter);

var logger$1 = createLogger('MewCrypto');

var MewConnectCrypto = function () {
  function MewConnectCrypto() {
    classCallCheck(this, MewConnectCrypto);
  }

  createClass(MewConnectCrypto, [{
    key: 'setPrivate',
    value: function setPrivate(pvtKey) {
      this.prvt = Buffer.from(pvtKey, 'hex');
    }
  }, {
    key: 'generateMessage',
    value: function generateMessage() {
      return crypto.randomBytes(32).toString('hex');
    }

    // Not for the Address, but generate them for the connection check

  }, {
    key: 'prepareKey',
    value: function prepareKey() {
      this.prvt = this.generatePrivate();
      this.pub = this.generatePublic(this.prvt);
      return { pub: this.pub, pvt: this.prvt };
    }
  }, {
    key: 'generatePrivate',
    value: function generatePrivate() {
      var privKey = void 0;
      do {
        privKey = crypto.randomBytes(32);
      } while (!secp256k1.privateKeyVerify(privKey));
      return privKey;
    }
  }, {
    key: 'generatePublic',
    value: function generatePublic(privKey) {
      var pvt = Buffer.from(privKey, 'hex');
      this.prvt = pvt;
      return secp256k1.publicKeyCreate(pvt);
    }
  }, {
    key: 'encrypt',
    value: function encrypt(dataToSend) {
      var publicKeyA = eccrypto.getPublic(this.prvt);
      return new Promise(function (resolve, reject) {
        eccrypto.encrypt(publicKeyA, Buffer.from(dataToSend)).then(function (_initial) {
          resolve(_initial);
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: 'decrypt',
    value: function decrypt(dataToSee) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        eccrypto.decrypt(_this.prvt, {
          ciphertext: Buffer.from(dataToSee.ciphertext),
          ephemPublicKey: Buffer.from(dataToSee.ephemPublicKey),
          iv: Buffer.from(dataToSee.iv),
          mac: Buffer.from(dataToSee.mac)
        }).then(function (_initial) {
          var result = void 0;
          try {
            if (_this.isJSON(_initial)) {
              var humanRadable = JSON.parse(_initial);
              if (Array.isArray(humanRadable)) {
                result = humanRadable[0];
              } else {
                result = humanRadable;
              }
            } else {
              result = _initial.toString();
            }
          } catch (e) {
            logger$1.error(e);
          }
          resolve(JSON.stringify(result));
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: 'signMessage',
    value: function signMessage(msgToSign) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        try {
          var msg = ethUtils.hashPersonalMessage(ethUtils.toBuffer(msgToSign));
          var signed = ethUtils.ecsign(Buffer.from(msg), Buffer.from(_this2.prvt, 'hex'));
          var combined = Buffer.concat([Buffer.from([signed.v]), Buffer.from(signed.r), Buffer.from(signed.s)]);
          var combinedHex = combined.toString('hex');
          resolve(combinedHex);
        } catch (e) {
          reject(e);
        }
      });
    }
  }, {
    key: 'bufferToConnId',
    value: function bufferToConnId(buf) {
      return buf.toString('hex').slice(32);
    }
  }, {
    key: 'isJSON',
    value: function isJSON(arg) {
      try {
        JSON.parse(arg);
        return true;
      } catch (e) {
        return false;
      }
    }
  }], [{
    key: 'create',
    value: function create() {
      return new MewConnectCrypto();
    }
  }]);
  return MewConnectCrypto;
}();

var debug = debugLogger('MEWconnect:initiator');
var debugPeer = debugLogger('MEWconnectVerbose:peer-instances');
var debugStages = debugLogger('MEWconnect:initiator-stages');
var logger$2 = createLogger('MewConnectInitiator');

var MewConnectInitiator = function (_MewConnectCommon) {
  inherits(MewConnectInitiator, _MewConnectCommon);

  function MewConnectInitiator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, MewConnectInitiator);

    var _this = possibleConstructorReturn(this, (MewConnectInitiator.__proto__ || Object.getPrototypeOf(MewConnectInitiator)).call(this));

    _this.supportedBrowser = MewConnectCommon.checkBrowser();

    _this.activePeerId = '';
    _this.allPeerIds = [];
    _this.peersCreated = [];

    _this.destroyOnUnload();
    _this.p = null;
    _this.socketConnected = false;
    _this.connected = false;
    _this.tryingTurn = false;
    _this.turnDisabled = false;
    _this.signalUrl = null;
    _this.iceState = '';
    _this.turnServers = [];

    _this.io = options.io || io;
    _this.Peer = options.wrtc || SimplePeer;
    _this.mewCrypto = options.cryptoImpl || MewConnectCrypto.create();

    _this.signals = _this.jsonDetails.signals;
    _this.rtcEvents = _this.jsonDetails.rtc;
    _this.version = _this.jsonDetails.version;
    _this.versions = _this.jsonDetails.versions;
    _this.lifeCycle = _this.jsonDetails.lifeCycle;
    _this.stunServers = options.stunServers || _this.jsonDetails.stunSrvers;
    _this.iceStates = _this.jsonDetails.iceConnectionState;

    // Socket is abandoned.  disconnect.
    setTimeout(function () {
      if (_this.socket) {
        _this.socketDisconnect();
      }
    }, 120000);
    return _this;
  }

  createClass(MewConnectInitiator, [{
    key: 'isAlive',
    value: function isAlive() {
      if (this.p !== null) {
        return this.p.connected && !this.p.destroyed;
      }
      return false;
    }

    // Factory function to create instance using default supplied libraries

  }, {
    key: 'destroyOnUnload',


    // Check if a WebRTC connection exists before a window/tab is closed or refreshed
    // Destroy the connection if one exists
    value: function destroyOnUnload() {
      var _this2 = this;

      if (browserOrNode.isBrowser) {
        // eslint-disable-next-line no-undef
        window.onunload = window.onbeforeunload = function () {
          var iceStates = [_this2.iceStates.new, _this2.iceStates.connecting, _this2.iceStates.connected];
          if (!_this2.Peer.destroyed || iceStates.includes(_this2.iceState)) {
            _this2.rtcDestroy();
          }
        };
      }
    }
  }, {
    key: 'getSocketConnectionState',


    // Returns a boolean indicating whether the socket connection exists and is active
    value: function getSocketConnectionState() {
      return this.socketConnected;
    }

    // Returns a boolean indicating whether the WebRTC connection exists and is active

  }, {
    key: 'getConnectonState',
    value: function getConnectonState() {
      return this.connected;
    }

    // can be used to listen to specific events, especially those that pass data

  }, {
    key: 'uiCommunicator',
    value: function uiCommunicator(event, data) {
      this.emit(event, data);
      this.emitStatus(event);
    }

    // special status emitter to allow simple listening of various statuses in one listener

  }, {
    key: 'emitStatus',
    value: function emitStatus(event) {
      this.emit('status', event);
    }

    // Emit/Provide the details used in creating the QR Code

  }, {
    key: 'displayCode',
    value: function displayCode(data) {
      debug('handshake', data);
      this.socketKey = data;
      var separator = this.jsonDetails.connectionCodeSeparator;
      var qrCodeString = this.version + separator + data + separator + this.connId;

      this.uiCommunicator(this.lifeCycle.codeDisplay, qrCodeString);
      this.uiCommunicator(this.lifeCycle.checkNumber, data);
      this.uiCommunicator(this.lifeCycle.ConnectionId, this.connId);
    }

    // ===================== [Start] WebSocket Communication Methods and Handlers ========================

    // The initial method called to initiate the exchange that can create a WebRTC connection

  }, {
    key: 'regenerateCode',
    value: function () {
      var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.signalUrl === null)) {
                  _context.next = 2;
                  break;
                }

                throw Error('regenerateCode called before initial code generation');

              case 2:
                this.socketDisconnect();
                this.initiatorStart(this.signalUrl);

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function regenerateCode() {
        return _ref.apply(this, arguments);
      }

      return regenerateCode;
    }()
  }, {
    key: 'useFallback',
    value: function () {
      var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.socketEmit(this.signals.tryTurn, { connId: this.connId });

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function useFallback() {
        return _ref2.apply(this, arguments);
      }

      return useFallback;
    }()

    // Initalize a websocket connection with the signal server

  }, {
    key: 'initiatorStart',
    value: function () {
      var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(url) {
        var toSign, options;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.signalUrl === null) {
                  this.signalUrl = url;
                }
                this.keys = this.mewCrypto.prepareKey();
                toSign = this.mewCrypto.generateMessage();
                _context3.next = 5;
                return this.mewCrypto.signMessage(this.keys.pvt.toString('hex'));

              case 5:
                this.signed = _context3.sent;

                this.connId = this.mewCrypto.bufferToConnId(this.keys.pub);
                this.displayCode(this.keys.pvt.toString('hex'));
                this.uiCommunicator(this.lifeCycle.signatureCheck);
                options = {
                  query: {
                    stage: 'initiator',
                    signed: this.signed,
                    message: toSign,
                    connId: this.connId
                  },
                  transports: ['websocket', 'polling', 'flashsocket'],
                  secure: true
                };

                this.socketManager = this.io(url, options);
                this.socket = this.socketManager.connect();
                this.initiatorConnect(this.socket);

              case 13:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function initiatorStart(_x2) {
        return _ref3.apply(this, arguments);
      }

      return initiatorStart;
    }()

    // ------------- WebSocket Communication Methods and Handlers ------------------------------

    // ----- Wrapper around Socket.IO methods
    // socket.emit wrapper

  }, {
    key: 'socketEmit',
    value: function socketEmit(signal, data) {
      this.socket.binary(false).emit(signal, data);
    }

    // socket.disconnect wrapper

  }, {
    key: 'socketDisconnect',
    value: function socketDisconnect() {
      this.socket.disconnect();
      this.socketConnected = false;
    }

    // socket.on listener registration wrapper

  }, {
    key: 'socketOn',
    value: function socketOn(signal, func) {
      this.socket.on(signal, func);
    }

    // ----- Setup handlers for communication with the signal server

  }, {
    key: 'initiatorConnect',
    value: function initiatorConnect(socket) {
      var _this3 = this;

      debugStages('INITIATOR CONNECT');
      this.uiCommunicator(this.lifeCycle.SocketConnectedEvent);

      this.socket.on(this.signals.connect, function () {
        debugStages('SOCKET CONNECTED');
        _this3.socketConnected = true;
      });

      this.socketOn(this.signals.confirmation, this.sendOffer.bind(this)); // response
      this.socketOn(this.signals.answer, this.recieveAnswer.bind(this));
      this.socketOn(this.signals.confirmationFailedBusy, this.busyFailure.bind(this));
      this.socketOn(this.signals.confirmationFailed, this.confirmationFailure.bind(this));
      this.socketOn(this.signals.invalidConnection, this.invalidFailure.bind(this));
      this.socketOn(this.signals.disconnect, this.socketDisconnectHandler.bind(this));
      this.socketOn(this.signals.attemptingTurn, this.willAttemptTurn.bind(this));
      this.socketOn(this.signals.turnToken, this.beginTurn.bind(this));
      return socket;
    }

    // ----- Socket Event handlers

    // Handle Socket Disconnect Event

  }, {
    key: 'socketDisconnectHandler',
    value: function socketDisconnectHandler(reason) {
      debug(reason);
      this.socketConnected = false;
    }

    // Handle Socket Attempting Turn informative signal
    // Provide Notice that initial WebRTC connection failed and the fallback method will be used

  }, {
    key: 'willAttemptTurn',
    value: function willAttemptTurn() {
      this.tryingTurn = true;
      debugStages('TRY TURN CONNECTION');
      this.uiCommunicator(this.lifeCycle.UsingFallback);
    }

    // Handle Socket event to initiate turn connection
    // Handle Receipt of TURN server details, and begin a WebRTC connection attempt using TURN

  }, {
    key: 'beginTurn',
    value: function beginTurn(data) {
      this.tryingTurn = true;
      this.retryViaTurn(data);
    }

    // ----- Failure Handlers

    // Handle Failure due to an attempt to join a connection with two existing endpoints

  }, {
    key: 'busyFailure',
    value: function busyFailure() {
      this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedBusyEvent);
      debug('confirmation Failed: Busy');
    }

    // Handle Failure due to no opposing peer existing

  }, {
    key: 'invalidFailure',
    value: function invalidFailure() {
      this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.invalidConnectionEvent);
      debug('confirmation Failed: no opposite peer found');
    }

    // Handle Failure due to the handshake/ verify details being invalid for the connection ID

  }, {
    key: 'confirmationFailure',
    value: function confirmationFailure() {
      this.uiCommunicator(this.lifeCycle.Failed, this.lifeCycle.confirmationFailedEvent);
      debug('confirmation Failed: invalid confirmation');
    }

    // =============== [End] WebSocket Communication Methods and Handlers ========================

    // ======================== [Start] WebRTC Communication Methods =============================

    // ----- WebRTC Setup Methods

    // A connection pair exists, create and send WebRTC OFFER

  }, {
    key: 'sendOffer',
    value: function () {
      var _ref4 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(data) {
        var plainTextVersion, options;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.mewCrypto.decrypt(data.version);

              case 2:
                plainTextVersion = _context4.sent;

                this.peerVersion = plainTextVersion;
                this.uiCommunicator(this.lifeCycle.receiverVersion, plainTextVersion);
                debug('sendOffer', data);
                options = {
                  signalListener: this.initiatorSignalListener,
                  webRtcConfig: {
                    servers: this.stunServers
                  }
                };

                this.initiatorStartRTC(this.socket, options);

              case 8:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function sendOffer(_x3) {
        return _ref4.apply(this, arguments);
      }

      return sendOffer;
    }()
  }, {
    key: 'initiatorSignalListener',
    value: function initiatorSignalListener(socket, options) {
      var _this4 = this;

      return function () {
        var _ref5 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(data) {
          var encryptedSend;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.prev = 0;

                  debug('SIGNAL', JSON.stringify(data));
                  _context5.next = 4;
                  return _this4.mewCrypto.encrypt(JSON.stringify(data));

                case 4:
                  encryptedSend = _context5.sent;

                  _this4.uiCommunicator(_this4.lifeCycle.sendOffer);
                  _this4.socketEmit(_this4.signals.offerSignal, {
                    data: encryptedSend,
                    connId: _this4.connId,
                    options: options.servers
                  });
                  _context5.next = 12;
                  break;

                case 9:
                  _context5.prev = 9;
                  _context5.t0 = _context5['catch'](0);

                  logger$2.error(_context5.t0);

                case 12:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, _this4, [[0, 9]]);
        }));

        return function (_x4) {
          return _ref5.apply(this, arguments);
        };
      }();
    }

    // Handle the WebRTC ANSWER from the opposite (mobile) peer

  }, {
    key: 'recieveAnswer',
    value: function () {
      var _ref6 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(data) {
        var plainTextOffer;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this.mewCrypto.decrypt(data.data);

              case 3:
                plainTextOffer = _context6.sent;

                this.rtcRecieveAnswer({ data: plainTextOffer });
                _context6.next = 10;
                break;

              case 7:
                _context6.prev = 7;
                _context6.t0 = _context6['catch'](0);

                logger$2.error(_context6.t0);

              case 10:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 7]]);
      }));

      function recieveAnswer(_x5) {
        return _ref6.apply(this, arguments);
      }

      return recieveAnswer;
    }()
  }, {
    key: 'rtcRecieveAnswer',
    value: function rtcRecieveAnswer(data) {
      this.uiCommunicator(this.lifeCycle.answerReceived);
      this.p.signal(JSON.parse(data.data));
    }
  }, {
    key: 'setActivePeerId',
    value: function setActivePeerId() {
      this.activePeerId = uuid();
      this.allPeerIds.push(this.activePeerId);
    }
  }, {
    key: 'getActivePeerId',
    value: function getActivePeerId() {
      var split = this.activePeerId.split('-');
      return split.join('-');
    }
  }, {
    key: 'initiatorStartRTC',
    value: function initiatorStartRTC(socket, options) {
      this.setActivePeerId();
      var webRtcConfig = options.webRtcConfig || {};
      var signalListener = this.initiatorSignalListener(socket, webRtcConfig.servers);
      var webRtcServers = webRtcConfig.servers || this.stunServers;

      var suppliedOptions = options.webRtcOptions || {};

      var defaultOptions = {
        initiator: true,
        trickle: false,
        iceTransportPolicy: 'relay',
        config: {
          iceServers: webRtcServers
        }
      };

      var simpleOptions = _extends({}, defaultOptions, {
        suppliedOptions: suppliedOptions
      });
      debug('initiatorStartRTC - options: ' + simpleOptions);
      this.uiCommunicator(this.lifeCycle.RtcInitiatedEvent);
      this.p = new this.Peer(simpleOptions);
      var peerID = this.getActivePeerId();
      this.p.peerInstanceId = peerID;
      this.peersCreated.push(this.p);
      this.p.on(this.rtcEvents.error, this.onError.bind(this, peerID));
      this.p.on(this.rtcEvents.connect, this.onConnect.bind(this, peerID));
      this.p.on(this.rtcEvents.close, this.onClose.bind(this, peerID));
      this.p.on(this.rtcEvents.data, this.onData.bind(this, peerID));
      this.p.on(this.rtcEvents.signal, signalListener.bind(this));
      this.p._pc.addEventListener('iceconnectionstatechange', this.stateChangeListener.bind(this, peerID));
    }

    // ----- WebRTC Communication Event Handlers

  }, {
    key: 'stateChangeListener',
    value: function stateChangeListener(peerID, evt) {
      // eslint-disable-next-line no-undef
      if (typeof jest === 'undefined') {
        // included because target is not defined in jest
        debug('iceConnectionState: ' + evt.target.iceConnectionState);
        debugPeer('this.allPeerIds', this.allPeerIds);
        debugPeer('peerID', peerID);
        if (evt.target.iceConnectionState === 'connected' || evt.target.iceConnectionState === 'completed') {
          if (!this.connected) {
            this.connected = true;
            this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);
          }
        }
      }
    }
  }, {
    key: 'onConnect',
    value: function onConnect(peerID) {
      debugStages('RTC CONNECT', 'ok');
      debugPeer('peerID', peerID);
      this.connected = true;
      this.turnDisabled = true;
      this.socketEmit(this.signals.rtcConnected, this.socketKey);
      this.socketDisconnect();
      this.uiCommunicator(this.lifeCycle.RtcConnectedEvent);
    }
  }, {
    key: 'onData',
    value: function () {
      var _ref7 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(peerID, data) {
        var decryptedData, parsed;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                debug('DATA RECEIVED', data.toString());
                debugPeer('peerID', peerID);
                _context7.prev = 2;
                decryptedData = void 0;

                if (!this.isJSON(data)) {
                  _context7.next = 10;
                  break;
                }

                _context7.next = 7;
                return this.mewCrypto.decrypt(JSON.parse(data.toString()));

              case 7:
                decryptedData = _context7.sent;
                _context7.next = 13;
                break;

              case 10:
                _context7.next = 12;
                return this.mewCrypto.decrypt(JSON.parse(data.toString()));

              case 12:
                decryptedData = _context7.sent;

              case 13:
                if (this.isJSON(decryptedData)) {
                  parsed = JSON.parse(decryptedData);

                  debug('DECRYPTED DATA RECEIVED 1', parsed);
                  this.emit(parsed.type, parsed.data);
                } else {
                  debug('DECRYPTED DATA RECEIVED 2', decryptedData);
                  this.emit(decryptedData.type, decryptedData.data);
                }
                _context7.next = 21;
                break;

              case 16:
                _context7.prev = 16;
                _context7.t0 = _context7['catch'](2);

                logger$2.error(_context7.t0);
                debug('onData ERROR: data=', data);
                debug('onData ERROR: data.toString()=', data.toString());

              case 21:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this, [[2, 16]]);
      }));

      function onData(_x6, _x7) {
        return _ref7.apply(this, arguments);
      }

      return onData;
    }()
  }, {
    key: 'onClose',
    value: function onClose(peerID, data) {
      debugStages('WRTC MAYBE CLOSE');
      debugPeer('peerID', peerID);
      if (!this.isAlive()) {
        debugStages('WRTC CLOSE', data);
        if (this.connected) {
          this.uiCommunicator(this.lifeCycle.RtcClosedEvent);
          this.connected = false;
        } else {
          this.connected = false;
        }
      }
    }
  }, {
    key: 'onError',
    value: function onError(peerID, err) {
      debugStages('WRTC ERROR');
      debugPeer('peerID', peerID);
      debug(err.code);
      debug('error', err);
      if (!this.connected && !this.tryingTurn && !this.turnDisabled) {
        this.useFallback();
      } else {
        if (!this.isAlive()) {
          this.uiCommunicator(this.lifeCycle.RtcErrorEvent);
        }
      }
    }

    // ----- WebRTC Communication Methods

  }, {
    key: 'sendRtcMessageClosure',
    value: function sendRtcMessageClosure(type, msg) {
      var _this5 = this;

      return function () {
        debug('[SEND RTC MESSAGE Closure] type:  ' + type + ',  message:  ' + msg);
        _this5.rtcSend(JSON.stringify({ type: type, data: msg }));
      };
    }
  }, {
    key: 'sendRtcMessage',
    value: function sendRtcMessage(type, msg) {
      debug('[SEND RTC MESSAGE] type:  ' + type + ',  message:  ' + msg);
      this.rtcSend(JSON.stringify({ type: type, data: msg }));
    }
  }, {
    key: 'disconnectRTCClosure',
    value: function disconnectRTCClosure() {
      var _this6 = this;

      return function () {
        debugStages('DISCONNECT RTC Closure');
        _this6.connected = false;
        _this6.uiCommunicator(_this6.lifeCycle.RtcDisconnectEvent);
        _this6.rtcDestroy();
        _this6.instance = null;
      };
    }
  }, {
    key: 'disconnectRTC',
    value: function disconnectRTC() {
      debugStages('DISCONNECT RTC');
      this.connected = false;
      this.uiCommunicator(this.lifeCycle.RtcDisconnectEvent);
      this.rtcDestroy();
      this.instance = null;
    }
  }, {
    key: 'rtcSend',
    value: function () {
      var _ref8 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(arg) {
        var encryptedSend;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.isAlive()) {
                  _context8.next = 15;
                  break;
                }

                encryptedSend = void 0;

                if (!(typeof arg === 'string')) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 5;
                return this.mewCrypto.encrypt(arg);

              case 5:
                encryptedSend = _context8.sent;
                _context8.next = 11;
                break;

              case 8:
                _context8.next = 10;
                return this.mewCrypto.encrypt(JSON.stringify(arg));

              case 10:
                encryptedSend = _context8.sent;

              case 11:
                debug('SENDING RTC');
                this.p.send(JSON.stringify(encryptedSend));
                _context8.next = 16;
                break;

              case 15:
                // eslint-disable-next-line
                this.uiCommunicator(this.lifeCycle.attemptedDisconnectedSend);

              case 16:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function rtcSend(_x8) {
        return _ref8.apply(this, arguments);
      }

      return rtcSend;
    }()
  }, {
    key: 'rtcDestroy',
    value: function rtcDestroy() {
      if (this.isAlive()) {
        this.p.destroy();
        this.connected = false;
        this.uiCommunicator(this.lifeCycle.RtcDestroyedEvent);
      }
    }

    // ----- WebRTC Communication TURN Fallback Initiator/Handler
    // Fallback Step if initial webRTC connection attempt fails.
    // Retries setting up the WebRTC connection using TURN

  }, {
    key: 'retryViaTurn',
    value: function retryViaTurn(data) {
      debugStages('Retrying via TURN');
      var options = {
        signalListener: this.initiatorSignalListener,
        webRtcConfig: {
          servers: data.data
        }
      };
      this.initiatorStartRTC(this.socket, options);
    }

    // ======================== [End] WebRTC Communication Methods =============================

  }], [{
    key: 'init',
    value: function init(opts) {
      var options = opts !== null ? opts : {};
      return new MewConnectInitiator(options);
    }
  }, {
    key: 'checkBrowser',
    value: function checkBrowser() {
      return MewConnectCommon.checkBrowser();
    }
  }, {
    key: 'checkWebRTCAvailable',
    value: function checkWebRTCAvailable() {
      return MewConnectCommon.checkWebRTCAvailable();
    }
  }]);
  return MewConnectInitiator;
}(MewConnectCommon);

// INITIATOR CLIENT

var index = {
  Crypto: MewConnectCrypto,
  Initiator: MewConnectInitiator
};

module.exports = index;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/after/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/after/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/arraybuffer.slice/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/arraybuffer.slice/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/backo2/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/backo2/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bip66/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bip66/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

function check (buffer) {
  if (buffer.length < 8) return false
  if (buffer.length > 72) return false
  if (buffer[0] !== 0x30) return false
  if (buffer[1] !== buffer.length - 2) return false
  if (buffer[2] !== 0x02) return false

  var lenR = buffer[3]
  if (lenR === 0) return false
  if (5 + lenR >= buffer.length) return false
  if (buffer[4 + lenR] !== 0x02) return false

  var lenS = buffer[5 + lenR]
  if (lenS === 0) return false
  if ((6 + lenR + lenS) !== buffer.length) return false

  if (buffer[4] & 0x80) return false
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) return false

  if (buffer[lenR + 6] & 0x80) return false
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) return false
  return true
}

function decode (buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short')
  if (buffer.length > 72) throw new Error('DER sequence length is too long')
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence')
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid')
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer')

  var lenR = buffer[3]
  if (lenR === 0) throw new Error('R length is zero')
  if (5 + lenR >= buffer.length) throw new Error('R length is too long')
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)')

  var lenS = buffer[5 + lenR]
  if (lenS === 0) throw new Error('S length is zero')
  if ((6 + lenR + lenS) !== buffer.length) throw new Error('S length is invalid')

  if (buffer[4] & 0x80) throw new Error('R value is negative')
  if (lenR > 1 && (buffer[4] === 0x00) && !(buffer[5] & 0x80)) throw new Error('R value excessively padded')

  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative')
  if (lenS > 1 && (buffer[lenR + 6] === 0x00) && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded')

  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  }
}

/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
function encode (r, s) {
  var lenR = r.length
  var lenS = s.length
  if (lenR === 0) throw new Error('R length is zero')
  if (lenS === 0) throw new Error('S length is zero')
  if (lenR > 33) throw new Error('R length is too long')
  if (lenS > 33) throw new Error('S length is too long')
  if (r[0] & 0x80) throw new Error('R value is negative')
  if (s[0] & 0x80) throw new Error('S value is negative')
  if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) throw new Error('R value excessively padded')
  if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) throw new Error('S value excessively padded')

  var signature = Buffer.allocUnsafe(6 + lenR + lenS)

  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30
  signature[1] = signature.length - 2
  signature[2] = 0x02
  signature[3] = r.length
  r.copy(signature, 4)
  signature[4 + lenR] = 0x02
  signature[5 + lenR] = s.length
  s.copy(signature, 6 + lenR)

  return signature
}

module.exports = {
  check: check,
  decode: decode,
  encode: encode
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/blob/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/blob/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(/*! buffer */ 4).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/brorand/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/brorand/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 5);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/browser-or-node/lib/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/browser-or-node/lib/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* global window */

var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;

exports.isBrowser = isBrowser;
exports.isNode = isNode;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/cipher-base/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/cipher-base/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-bind/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-bind/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/create-hash/browser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/create-hash/browser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var MD5 = __webpack_require__(/*! md5.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/md5.js/index.js")
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ripemd160/index.js")
var sha = __webpack_require__(/*! sha.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/index.js")
var Base = __webpack_require__(/*! cipher-base */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/cipher-base/index.js")

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/browser.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/browser.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = Object({"NODE_ENV":"development","BASE_URL":""}).DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/common.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/common.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/detect-browser/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/detect-browser/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {function detect() {
  if (typeof navigator !== 'undefined') {
    return parseUserAgent(navigator.userAgent);
  }

  return getNodeVersion();
}

function detectOS(userAgentString) {
  var rules = getOperatingSystemRules();
  var detected = rules.filter(function (os) {
    return os.rule && os.rule.test(userAgentString);
  })[0];

  return detected ? detected.name : null;
}

function getNodeVersion() {
  var isNode = typeof process !== 'undefined' && process.version;
  return isNode && {
    name: 'node',
    version: process.version.slice(1),
    os: process.platform
  };
}

function parseUserAgent(userAgentString) {
  var browsers = getBrowserRules();
  if (!userAgentString) {
    return null;
  }

  var detected = browsers.map(function(browser) {
    var match = browser.rule.exec(userAgentString);
    var version = match && match[1].split(/[._]/).slice(0,3);

    if (version && version.length < 3) {
      version = version.concat(version.length == 1 ? [0, 0] : [0]);
    }

    return match && {
      name: browser.name,
      version: version.join('.')
    };
  }).filter(Boolean)[0] || null;

  if (detected) {
    detected.os = detectOS(userAgentString);
  }

  if (/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/i.test(userAgentString)) {
    detected = detected || {};
    detected.bot = true;
  }

  return detected;
}

function getBrowserRules() {
  return buildRules([
    [ 'aol', /AOLShield\/([0-9\._]+)/ ],
    [ 'edge', /Edge\/([0-9\._]+)/ ],
    [ 'yandexbrowser', /YaBrowser\/([0-9\._]+)/ ],
    [ 'vivaldi', /Vivaldi\/([0-9\.]+)/ ],
    [ 'kakaotalk', /KAKAOTALK\s([0-9\.]+)/ ],
    [ 'samsung', /SamsungBrowser\/([0-9\.]+)/ ],
    [ 'chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/ ],
    [ 'phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/ ],
    [ 'crios', /CriOS\/([0-9\.]+)(:?\s|$)/ ],
    [ 'firefox', /Firefox\/([0-9\.]+)(?:\s|$)/ ],
    [ 'fxios', /FxiOS\/([0-9\.]+)/ ],
    [ 'opera', /Opera\/([0-9\.]+)(?:\s|$)/ ],
    [ 'opera', /OPR\/([0-9\.]+)(:?\s|$)$/ ],
    [ 'ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/ ],
    [ 'ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/ ],
    [ 'ie', /MSIE\s(7\.0)/ ],
    [ 'bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/ ],
    [ 'android', /Android\s([0-9\.]+)/ ],
    [ 'ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/ ],
    [ 'safari', /Version\/([0-9\._]+).*Safari/ ],
    [ 'facebook', /FBAV\/([0-9\.]+)/],
    [ 'instagram', /Instagram\s([0-9\.]+)/],
    [ 'ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/]
  ]);
}

function getOperatingSystemRules() {
  return buildRules([
    [ 'iOS', /iP(hone|od|ad)/ ],
    [ 'Android OS', /Android/ ],
    [ 'BlackBerry OS', /BlackBerry|BB10/ ],
    [ 'Windows Mobile', /IEMobile/ ],
    [ 'Amazon OS', /Kindle/ ],
    [ 'Windows 3.11', /Win16/ ],
    [ 'Windows 95', /(Windows 95)|(Win95)|(Windows_95)/ ],
    [ 'Windows 98', /(Windows 98)|(Win98)/ ],
    [ 'Windows 2000', /(Windows NT 5.0)|(Windows 2000)/ ],
    [ 'Windows XP', /(Windows NT 5.1)|(Windows XP)/ ],
    [ 'Windows Server 2003', /(Windows NT 5.2)/ ],
    [ 'Windows Vista', /(Windows NT 6.0)/ ],
    [ 'Windows 7', /(Windows NT 6.1)/ ],
    [ 'Windows 8', /(Windows NT 6.2)/ ],
    [ 'Windows 8.1', /(Windows NT 6.3)/ ],
    [ 'Windows 10', /(Windows NT 10.0)/ ],
    [ 'Windows ME', /Windows ME/ ],
    [ 'Open BSD', /OpenBSD/ ],
    [ 'Sun OS', /SunOS/ ],
    [ 'Linux', /(Linux)|(X11)/ ],
    [ 'Mac OS', /(Mac_PowerPC)|(Macintosh)/ ],
    [ 'QNX', /QNX/ ],
    [ 'BeOS', /BeOS/ ],
    [ 'OS/2', /OS\/2/ ],
    [ 'Search Bot', /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/ ]
  ]);
}

function buildRules(ruleTuples) {
  return ruleTuples.map(function(tuple) {
    return {
      name: tuple[0],
      rule: tuple[1]
    };
  });
}

module.exports = {
  detect: detect,
  detectOS: detectOS,
  getNodeVersion: getNodeVersion,
  parseUserAgent: parseUserAgent
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/eccrypto/browser.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/eccrypto/browser.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, Buffer) {

var EC = __webpack_require__(/*! elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js").ec;

var ec = new EC("secp256k1");
var browserCrypto = global.crypto || global.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;

var nodeCrypto = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");

const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');
const ZERO32 = Buffer.alloc(32, 0);

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

function isScalar (x) {
  return Buffer.isBuffer(x) && x.length === 32;
}

function isValidPrivateKey(privateKey) {
  if (!isScalar(privateKey))
  {
    return false;
  }
  return privateKey.compare(ZERO32) > 0 && // > 0
  privateKey.compare(EC_GROUP_ORDER) < 0; // < G
}

// Compare two buffers in constant time to prevent timing attacks.
function equalConstTime(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  var res = 0;
  for (var i = 0; i < b1.length; i++) {
    res |= b1[i] ^ b2[i];  // jshint ignore:line
  }
  return res === 0;
}

/* This must check if we're in the browser or
not, since the functions are different and does
not convert using browserify */
function randomBytes(size) {
  var arr = new Uint8Array(size);
  if (typeof window === 'undefined') {
    return Buffer.from(nodeCrypto.randomBytes(size));
  } else {
    browserCrypto.getRandomValues(arr);
  }
  return Buffer.from(arr);
}

function sha512(msg) {
  return new Promise(function(resolve) {
    var hash = nodeCrypto.createHash('sha512');
    var result = hash.update(msg).digest();
    resolve(new Uint8Array(result));
  });
}

function getAes(op) {
  return function(iv, key, data) {
    return new Promise(function(resolve) {
      if (subtle) {
        var importAlgorithm = {name: "AES-CBC"};
        var keyp = subtle.importKey("raw", key, importAlgorithm, false, [op]);
        return keyp.then(function(cryptoKey) {
          var encAlgorithm = {name: "AES-CBC", iv: iv};
          return subtle[op](encAlgorithm, cryptoKey, data);
        }).then(function(result) {
          resolve(Buffer.from(new Uint8Array(result)));
        });
      } else {
        if (op === 'encrypt') {
          var cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);
          cipher.update(data);
          resolve(cipher.final());
        }
        else if (op === 'decrypt') {
          var decipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);
          decipher.update(data);
          resolve(decipher.final());
        }
      }
    });
  };
}

var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");

function hmacSha256Sign(key, msg) {
  return new Promise(function(resolve) {
    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));
    hmac.update(msg);
    var result = hmac.digest();
    resolve(result);
  });
}

function hmacSha256Verify(key, msg, sig) {
  return new Promise(function(resolve) {
    var hmac = nodeCrypto.createHmac('sha256', Buffer.from(key));
    hmac.update(msg);
    var expectedSig = hmac.digest();
    resolve(equalConstTime(expectedSig, sig));
  });
}

var getPublic = exports.getPublic = function(privateKey) {
  // This function has sync API so we throw an error immediately.
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  // XXX(Kagami): `elliptic.utils.encode` returns array for every
  // encoding except `hex`.
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("arr"));
};

/**
 * Get compressed version of public key.
 */
var getPublicCompressed = exports.getPublicCompressed = function(privateKey) { // jshint ignore:line
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  // See https://github.com/wanderer/secp256k1-node/issues/46
  let compressed = true;
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, "arr"));
};

// NOTE(Kagami): We don't use promise shim in Browser implementation
// because it's supported natively in new browsers (see
// <http://caniuse.com/#feat=promises>) and we can use only new browsers
// because of the WebCryptoAPI (see
// <http://caniuse.com/#feat=cryptography>).
exports.sign = function(privateKey, msg) {
  return new Promise(function(resolve) {
    assert(privateKey.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKey), "Bad private key");
    assert(msg.length > 0, "Message should not be empty");
    assert(msg.length <= 32, "Message is too long");
    resolve(Buffer.from(ec.sign(msg, privateKey, {canonical: true}).toDER()));
  });
};

exports.verify = function(publicKey, msg, sig) {
  return new Promise(function(resolve, reject) {
    assert(publicKey.length === 65 || publicKey.length === 33, "Bad public key");
    if (publicKey.length === 65)
    {
      assert(publicKey[0] === 4, "Bad public key");
    }
    if (publicKey.length === 33)
    {
      assert(publicKey[0] === 2 || publicKey[0] === 3, "Bad public key");
    }
    assert(msg.length > 0, "Message should not be empty");
    assert(msg.length <= 32, "Message is too long");
    if (ec.verify(msg, sig, publicKey)) {
      resolve(null);
    } else {
      reject(new Error("Bad signature"));
    }
  });
};

var derive = exports.derive = function(privateKeyA, publicKeyB) {
  return new Promise(function(resolve) {
    assert(Buffer.isBuffer(privateKeyA), "Bad private key");
    assert(Buffer.isBuffer(publicKeyB), "Bad public key");
    assert(privateKeyA.length === 32, "Bad private key");
    assert(isValidPrivateKey(privateKeyA), "Bad private key");
    assert(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
    if (publicKeyB.length === 65)
    {
      assert(publicKeyB[0] === 4, "Bad public key");
    }
    if (publicKeyB.length === 33)
    {
      assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
    }
    var keyA = ec.keyFromPrivate(privateKeyA);
    var keyB = ec.keyFromPublic(publicKeyB);
    var Px = keyA.derive(keyB.getPublic());  // BN instance
    resolve(Buffer.from(Px.toArray()));
  });
};

exports.encrypt = function(publicKeyTo, msg, opts) {
  opts = opts || {};
  // Tmp variables to save context from flat promises;
  var iv, ephemPublicKey, ciphertext, macKey;
  return new Promise(function(resolve) {
    var ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
    // There is a very unlikely possibility that it is not a valid key
    while(!isValidPrivateKey(ephemPrivateKey))
    {
      ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
    }
    ephemPublicKey = getPublic(ephemPrivateKey);
    resolve(derive(ephemPrivateKey, publicKeyTo));
  }).then(function(Px) {
    return sha512(Px);
  }).then(function(hash) {
    iv = opts.iv || randomBytes(16);
    var encryptionKey = hash.slice(0, 32);
    macKey = hash.slice(32);
    return aesCbcEncrypt(iv, encryptionKey, msg);
  }).then(function(data) {
    ciphertext = data;
    var dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
    return hmacSha256Sign(macKey, dataToMac);
  }).then(function(mac) {
    return {
      iv: iv,
      ephemPublicKey: ephemPublicKey,
      ciphertext: ciphertext,
      mac: mac,
    };
  });
};

exports.decrypt = function(privateKey, opts) {
  // Tmp variable to save context from flat promises;
  var encryptionKey;
  return derive(privateKey, opts.ephemPublicKey).then(function(Px) {
    return sha512(Px);
  }).then(function(hash) {
    encryptionKey = hash.slice(0, 32);
    var macKey = hash.slice(32);
    var dataToMac = Buffer.concat([
      opts.iv,
      opts.ephemPublicKey,
      opts.ciphertext
    ]);
    return hmacSha256Verify(macKey, dataToMac, opts.mac);
  }).then(function(macGood) {
    assert(macGood, "Bad MAC");
    return aesCbcDecrypt(opts.iv, encryptionKey, opts.ciphertext);
  }).then(function(msg) {
    return Buffer.from(new Uint8Array(msg));
  });
};


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/brorand/index.js");
elliptic.hmacDRBG = __webpack_require__(/*! ./elliptic/hmac-drbg */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/hmac-drbg.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/base.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

  // Useful for many curves
  this.zero = new bn(0).toRed(this.red);
  this.one = new bn(1).toRed(this.red);
  this.two = new bn(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;
  return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();
  if (bytes[0] === 0x04 && bytes.length - 1 === 2 * len) {
    return this.point(bytes.slice(1, 1 + len),
                      bytes.slice(1 + len, 1 + 2 * len));
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new bn(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new bn(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new bn(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y = rhs.redMul(lhs.redInvm()).redSqrt();
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new bn(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = z ? new bn(z, 16) : this.curve.one;
    this.t = t && new bn(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js");
var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.i4 = new bn(4).toRed(this.red).redInvm();
  this.two = new bn(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new bn(x, 16);
    this.z = new bn(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/short.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn(vec.a, 16),
        b: new bn(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn.mont(num);
  var tinv = new bn(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn(1);
  var y1 = new bn(0);
  var x2 = new bn(0);
  var y2 = new bn(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn(0);
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = new bn(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curves.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/curves.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/index.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn(2));
  do {
    var priv = new bn(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new bn(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray();
  for (var i = bkey.length; i < bytes; i++)
    bkey.unshift(0);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray();
  for (var i = nonce.length; i < bytes; i++)
    nonce.unshift(0);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn(1));
  do {
    var k = new bn(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  } while (true);
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new bn(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  var p = this.g.mulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  return p.getX().umod(this.n).cmp(r) === 0;
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new bn(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var eNeg = n.sub(e);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = signature.r.invm(n);
  return r.mul(s).add(this.g.mul(eNeg)).mul(rInv);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime = this.recoverPubKey(e, signature, i);

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/key.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new bn(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new bn(options.r, 16);
  this.s = new bn(options.s, 16);
  if (options.recoveryParam !== null)
    this.recoveryParam = options.recoveryParam;
  else
    this.recoveryParam = null;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new bn(r);
  this.s = new bn(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof bn)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/hmac-drbg.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/hmac-drbg.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/utils.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/lib/elliptic/utils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var bn = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (!enc) {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, computer) {
  var name = computer.name;
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new bn(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/package.json":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/elliptic/package.json ***!
  \**********************************************************************************************/
/*! exports provided: name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies, _resolved, _integrity, _from, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"elliptic\",\"version\":\"6.0.2\",\"description\":\"EC cryptography\",\"main\":\"lib/elliptic.js\",\"files\":[\"lib\"],\"scripts\":{\"test\":\"make lint && istanbul test _mocha --reporter=spec test/*-test.js\",\"coveralls\":\"cat ./coverage/lcov.info | coveralls\"},\"repository\":{\"type\":\"git\",\"url\":\"git@github.com:indutny/elliptic\"},\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"author\":\"Fedor Indutny <fedor@indutny.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"homepage\":\"https://github.com/indutny/elliptic\",\"devDependencies\":{\"browserify\":\"^3.44.2\",\"coveralls\":\"^2.11.3\",\"istanbul\":\"^0.3.17\",\"jscs\":\"^1.11.3\",\"jshint\":\"^2.6.0\",\"mocha\":\"^2.1.0\",\"uglify-js\":\"^2.4.13\"},\"dependencies\":{\"bn.js\":\"^4.0.0\",\"brorand\":\"^1.0.1\",\"hash.js\":\"^1.0.0\",\"inherits\":\"^2.0.1\"},\"_resolved\":\"https://registry.npmjs.org/elliptic/-/elliptic-6.0.2.tgz\",\"_integrity\":\"sha1-IZuWzZKqmIXZHTHB/ULqpetEg6k=\",\"_from\":\"elliptic@6.0.2\"}");

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(/*! ./socket */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/socket.js");

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/socket.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/socket.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:socket');
var index = __webpack_require__(/*! indexof */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/indexof/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");
var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseuri/index.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js");

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(/*! ./transport */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transport.js");
Socket.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/index.js");
Socket.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transport.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transport.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/index.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/index.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/xmlhttprequest.js");
var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-xhr.js");
var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-jsonp.js");
var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/websocket.js");

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module requirements.
 */

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js");

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/xmlhttprequest.js");
var Polling = __webpack_require__(/*! ./polling */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/polling.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transport.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/xmlhttprequest.js");
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/websocket.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/transport.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js")('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
} else {
  try {
    NodeWebSocket = __webpack_require__(/*! ws */ 6);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-cors/index.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/browser.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = Object({"NODE_ENV":"development","BASE_URL":""}).DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/debug.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/debug/src/debug.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/ms/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/node_modules/ms/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/browser.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var keys = __webpack_require__(/*! ./keys */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/keys.js");
var hasBinary = __webpack_require__(/*! has-binary2 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/index.js");
var sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/arraybuffer.slice/index.js");
var after = __webpack_require__(/*! after */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/after/index.js");
var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/utf8.js");

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(/*! blob */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/blob/index.js");

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/keys.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/keys.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/utf8.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-parser/lib/utf8.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethereumjs-util/dist/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethereumjs-util/dist/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var createKeccakHash = __webpack_require__(/*! keccak */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/js.js");
var secp256k1 = __webpack_require__(/*! secp256k1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/elliptic.js");
var assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
var rlp = __webpack_require__(/*! rlp */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rlp/dist/index.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/create-hash/browser.js");
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer;
Object.assign(exports, __webpack_require__(/*! ethjs-util */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethjs-util/lib/index.js"));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  return createKeccakHash('keccak' + bits).update(a).digest();
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethjs-util/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ethjs-util/lib/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var isHexPrefixed = __webpack_require__(/*! is-hex-prefixed */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/is-hex-prefixed/src/index.js");
var stripHexPrefix = __webpack_require__(/*! strip-hex-prefix */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/strip-hex-prefix/src/index.js");

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/get-browser-rtc/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/get-browser-rtc/index.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof window === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||
      window.webkitRTCPeerConnection,
    RTCSessionDescription: window.RTCSessionDescription ||
      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||
      window.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/node_modules/isarray/index.js");

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/node_modules/isarray/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/node_modules/isarray/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-cors/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-cors/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash-base/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash-base/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/hmac.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/hmac.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/ripemd.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/ripemd.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/1.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/1.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/224.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/224.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/256.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/256.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/384.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/384.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/512.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/512.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/common.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/sha/common.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash/utils.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-crypto-utils/lib/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/indexof/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/indexof/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/is-hex-prefixed/src/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/is-hex-prefixed/src/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/isarray/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/isarray/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/js.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/js.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(/*! ./lib/api */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/index.js")(__webpack_require__(/*! ./lib/keccak */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak.js"))


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var createKeccak = __webpack_require__(/*! ./keccak */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/keccak.js")
var createShake = __webpack_require__(/*! ./shake */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/shake.js")

module.exports = function (KeccakState) {
  var Keccak = createKeccak(KeccakState)
  var Shake = createShake(KeccakState)

  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/keccak.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/keccak.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")

module.exports = function (KeccakState) {
  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Keccak, Transform)

  Keccak.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype._flush = function (callback) {
    var error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Keccak.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Keccak.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    var digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  Keccak.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  Keccak.prototype._clone = function () {
    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Keccak
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/shake.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/api/shake.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var Transform = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Transform
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")

module.exports = function (KeccakState) {
  function Shake (rate, capacity, delimitedSuffix, options) {
    Transform.call(this, options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  inherits(Shake, Transform)

  Shake.prototype._transform = function (chunk, encoding, callback) {
    var error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  Shake.prototype._flush = function () {}

  Shake.prototype._read = function (size) {
    this.push(this.squeeze(size))
  }

  Shake.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  Shake.prototype.squeeze = function (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    var data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  Shake.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  Shake.prototype._clone = function () {
    var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }

  return Shake
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak-state-unroll.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak-state-unroll.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (var round = 0; round < 24; ++round) {
    // theta
    var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    var t1slo0 = s[0] ^ lo
    var t1shi0 = s[1] ^ hi
    var t1slo5 = s[10] ^ lo
    var t1shi5 = s[11] ^ hi
    var t1slo10 = s[20] ^ lo
    var t1shi10 = s[21] ^ hi
    var t1slo15 = s[30] ^ lo
    var t1shi15 = s[31] ^ hi
    var t1slo20 = s[40] ^ lo
    var t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    var t1slo1 = s[2] ^ lo
    var t1shi1 = s[3] ^ hi
    var t1slo6 = s[12] ^ lo
    var t1shi6 = s[13] ^ hi
    var t1slo11 = s[22] ^ lo
    var t1shi11 = s[23] ^ hi
    var t1slo16 = s[32] ^ lo
    var t1shi16 = s[33] ^ hi
    var t1slo21 = s[42] ^ lo
    var t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    var t1slo2 = s[4] ^ lo
    var t1shi2 = s[5] ^ hi
    var t1slo7 = s[14] ^ lo
    var t1shi7 = s[15] ^ hi
    var t1slo12 = s[24] ^ lo
    var t1shi12 = s[25] ^ hi
    var t1slo17 = s[34] ^ lo
    var t1shi17 = s[35] ^ hi
    var t1slo22 = s[44] ^ lo
    var t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    var t1slo3 = s[6] ^ lo
    var t1shi3 = s[7] ^ hi
    var t1slo8 = s[16] ^ lo
    var t1shi8 = s[17] ^ hi
    var t1slo13 = s[26] ^ lo
    var t1shi13 = s[27] ^ hi
    var t1slo18 = s[36] ^ lo
    var t1shi18 = s[37] ^ hi
    var t1slo23 = s[46] ^ lo
    var t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    var t1slo4 = s[8] ^ lo
    var t1shi4 = s[9] ^ hi
    var t1slo9 = s[18] ^ lo
    var t1shi9 = s[19] ^ hi
    var t1slo14 = s[28] ^ lo
    var t1shi14 = s[29] ^ hi
    var t1slo19 = s[38] ^ lo
    var t1shi19 = s[39] ^ hi
    var t1slo24 = s[48] ^ lo
    var t1shi24 = s[49] ^ hi

    // rho & pi
    var t2slo0 = t1slo0
    var t2shi0 = t1shi0
    var t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    var t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    var t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    var t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    var t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    var t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    var t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    var t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    var t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    var t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    var t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    var t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    var t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    var t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    var t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    var t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    var t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    var t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    var t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    var t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    var t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    var t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    var t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    var t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    var t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    var t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    var t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    var t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    var t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    var t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    var t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    var t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    var t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    var t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    var t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    var t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    var t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    var t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    var t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    var t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    var t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    var t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    var t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    var t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    var t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    var t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    var t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    var t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var keccakState = __webpack_require__(/*! ./keccak-state-unroll */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/keccak/lib/keccak-state-unroll.js")

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  var output = Buffer.alloc(length)
  for (var i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/logging/lib/browser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/logging/lib/browser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// super basic browser support just to avoid breaking universal builds.
// title and log level are not included in the output at this time.
function createLogger() /* title */{
    function logger() {
        console.log.apply(console, arguments);
    }
    return {
        info: logger,
        warn: logger,
        error: logger,
        debug: logger
    };
}

exports.default = createLogger;

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/md5.js/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/md5.js/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash-base/index.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ms/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ms/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseuri/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseuri/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/randombytes/browser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/randombytes/browser.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_readable.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_readable.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 7);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_transform.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_transform.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_writable.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_writable.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 8);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/readable-browser.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/readable-browser.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ripemd160/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/ripemd160/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var HashBase = __webpack_require__(/*! hash-base */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash-base/index.js")

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rlp/dist/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rlp/dist/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
Object.defineProperty(exports, "__esModule", { value: true });
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
    if (input instanceof Array) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
    }
    else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v.slice(0, 2) === '00') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream) {
    if (stream === void 0) { stream = false; }
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        var llength = firstByte - 0xf6;
        var length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */
function _decode(input) {
    var length, llength, data, innerRemainder, d;
    var decoded = [];
    var firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        llength = firstByte - 0xb6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    var hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (BN.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rtcpeerconnection-shim/rtcpeerconnection.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rtcpeerconnection-shim/rtcpeerconnection.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var SDPUtils = __webpack_require__(/*! sdp */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sdp/sdp.js");

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        // If the offer contained RTX but the answer did not,
        // remove RTX from sendEncodingParameters.
        var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

        var hasRtx = commonCapabilities.codecs.filter(function(c) {
          return c.name.toLowerCase() === 'rtx';
        }).length;
        if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
          delete transceiver.sendEncodingParameters[0].rtx;
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
      }
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      if (transceiver.iceTransport && transceiver.dtlsTransport &&
          !transceiver.rejected) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      }
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/node-libs-browser/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sdp/sdp.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sdp/sdp.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 /* eslint-env node */


// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    address: parts[4], // address is an alias for ip.
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.address || candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: primarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(msidParts) {
    return msidParts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
// sessUser is optional and defaults to 'thisisadapterortc'
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  var user = sessUser || 'thisisadapterortc';
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=' + user + ' ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (true) {
  module.exports = SDPUtils;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/elliptic.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/elliptic.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = __webpack_require__(/*! ./lib */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/index.js")(__webpack_require__(/*! ./lib/elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/elliptic/index.js"))


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/assert.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/assert.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/der.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/der.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var bip66 = __webpack_require__(/*! bip66 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bip66/index.js")

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/elliptic/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/elliptic/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer
var createHash = __webpack_require__(/*! create-hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/create-hash/browser.js")
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js")
var EC = __webpack_require__(/*! elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js").ec

var messages = __webpack_require__(/*! ../messages.json */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/messages.json")

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var assert = __webpack_require__(/*! ./assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/assert.js")
var der = __webpack_require__(/*! ./der */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/der.js")
var messages = __webpack_require__(/*! ./messages.json */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/messages.json")

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/messages.json":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/lib/messages.json ***!
  \****************************************************************************************************/
/*! exports provided: COMPRESSED_TYPE_INVALID, EC_PRIVATE_KEY_TYPE_INVALID, EC_PRIVATE_KEY_LENGTH_INVALID, EC_PRIVATE_KEY_RANGE_INVALID, EC_PRIVATE_KEY_TWEAK_ADD_FAIL, EC_PRIVATE_KEY_TWEAK_MUL_FAIL, EC_PRIVATE_KEY_EXPORT_DER_FAIL, EC_PRIVATE_KEY_IMPORT_DER_FAIL, EC_PUBLIC_KEYS_TYPE_INVALID, EC_PUBLIC_KEYS_LENGTH_INVALID, EC_PUBLIC_KEY_TYPE_INVALID, EC_PUBLIC_KEY_LENGTH_INVALID, EC_PUBLIC_KEY_PARSE_FAIL, EC_PUBLIC_KEY_CREATE_FAIL, EC_PUBLIC_KEY_TWEAK_ADD_FAIL, EC_PUBLIC_KEY_TWEAK_MUL_FAIL, EC_PUBLIC_KEY_COMBINE_FAIL, ECDH_FAIL, ECDSA_SIGNATURE_TYPE_INVALID, ECDSA_SIGNATURE_LENGTH_INVALID, ECDSA_SIGNATURE_PARSE_FAIL, ECDSA_SIGNATURE_PARSE_DER_FAIL, ECDSA_SIGNATURE_SERIALIZE_DER_FAIL, ECDSA_SIGN_FAIL, ECDSA_RECOVER_FAIL, MSG32_TYPE_INVALID, MSG32_LENGTH_INVALID, OPTIONS_TYPE_INVALID, OPTIONS_DATA_TYPE_INVALID, OPTIONS_DATA_LENGTH_INVALID, OPTIONS_NONCEFN_TYPE_INVALID, RECOVERY_ID_TYPE_INVALID, RECOVERY_ID_VALUE_INVALID, TWEAK_TYPE_INVALID, TWEAK_LENGTH_INVALID, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"COMPRESSED_TYPE_INVALID\":\"compressed should be a boolean\",\"EC_PRIVATE_KEY_TYPE_INVALID\":\"private key should be a Buffer\",\"EC_PRIVATE_KEY_LENGTH_INVALID\":\"private key length is invalid\",\"EC_PRIVATE_KEY_RANGE_INVALID\":\"private key range is invalid\",\"EC_PRIVATE_KEY_TWEAK_ADD_FAIL\":\"tweak out of range or resulting private key is invalid\",\"EC_PRIVATE_KEY_TWEAK_MUL_FAIL\":\"tweak out of range\",\"EC_PRIVATE_KEY_EXPORT_DER_FAIL\":\"couldn't export to DER format\",\"EC_PRIVATE_KEY_IMPORT_DER_FAIL\":\"couldn't import from DER format\",\"EC_PUBLIC_KEYS_TYPE_INVALID\":\"public keys should be an Array\",\"EC_PUBLIC_KEYS_LENGTH_INVALID\":\"public keys Array should have at least 1 element\",\"EC_PUBLIC_KEY_TYPE_INVALID\":\"public key should be a Buffer\",\"EC_PUBLIC_KEY_LENGTH_INVALID\":\"public key length is invalid\",\"EC_PUBLIC_KEY_PARSE_FAIL\":\"the public key could not be parsed or is invalid\",\"EC_PUBLIC_KEY_CREATE_FAIL\":\"private was invalid, try again\",\"EC_PUBLIC_KEY_TWEAK_ADD_FAIL\":\"tweak out of range or resulting public key is invalid\",\"EC_PUBLIC_KEY_TWEAK_MUL_FAIL\":\"tweak out of range\",\"EC_PUBLIC_KEY_COMBINE_FAIL\":\"the sum of the public keys is not valid\",\"ECDH_FAIL\":\"scalar was invalid (zero or overflow)\",\"ECDSA_SIGNATURE_TYPE_INVALID\":\"signature should be a Buffer\",\"ECDSA_SIGNATURE_LENGTH_INVALID\":\"signature length is invalid\",\"ECDSA_SIGNATURE_PARSE_FAIL\":\"couldn't parse signature\",\"ECDSA_SIGNATURE_PARSE_DER_FAIL\":\"couldn't parse DER signature\",\"ECDSA_SIGNATURE_SERIALIZE_DER_FAIL\":\"couldn't serialize signature to DER format\",\"ECDSA_SIGN_FAIL\":\"nonce generation function failed or private key is invalid\",\"ECDSA_RECOVER_FAIL\":\"couldn't recover public key from signature\",\"MSG32_TYPE_INVALID\":\"message should be a Buffer\",\"MSG32_LENGTH_INVALID\":\"message length is invalid\",\"OPTIONS_TYPE_INVALID\":\"options should be an Object\",\"OPTIONS_DATA_TYPE_INVALID\":\"options.data should be a Buffer\",\"OPTIONS_DATA_LENGTH_INVALID\":\"options.data length is invalid\",\"OPTIONS_NONCEFN_TYPE_INVALID\":\"options.noncefn should be a Function\",\"RECOVERY_ID_TYPE_INVALID\":\"recovery should be a Number\",\"RECOVERY_ID_VALUE_INVALID\":\"recovery should have value between -1 and 4\",\"TWEAK_TYPE_INVALID\":\"tweak should be a Buffer\",\"TWEAK_LENGTH_INVALID\":\"tweak length is invalid\"}");

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/package.json").version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curves.js");

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/index.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/base.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/edwards.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \***********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/short.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(/*! ../curve */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curve/index.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js");
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curves.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/curves.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/index.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \*********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hmac-drbg/lib/hmac-drbg.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/key.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");

var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/hash.js/lib/hash.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/key.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var elliptic = __webpack_require__(/*! ../../elliptic */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic.js");
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/utils.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/lib/elliptic/utils.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/bn.js/lib/bn.js");
var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-assert/index.js");
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/package.json":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/secp256k1/node_modules/elliptic/package.json ***!
  \*********************************************************************************************************************/
/*! exports provided: name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies, _resolved, _integrity, _from, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"elliptic\",\"version\":\"6.4.1\",\"description\":\"EC cryptography\",\"main\":\"lib/elliptic.js\",\"files\":[\"lib\"],\"scripts\":{\"jscs\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"jshint\":\"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js\",\"lint\":\"npm run jscs && npm run jshint\",\"unit\":\"istanbul test _mocha --reporter=spec test/index.js\",\"test\":\"npm run lint && npm run unit\",\"version\":\"grunt dist && git add dist/\"},\"repository\":{\"type\":\"git\",\"url\":\"git@github.com:indutny/elliptic\"},\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"author\":\"Fedor Indutny <fedor@indutny.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"homepage\":\"https://github.com/indutny/elliptic\",\"devDependencies\":{\"brfs\":\"^1.4.3\",\"coveralls\":\"^2.11.3\",\"grunt\":\"^0.4.5\",\"grunt-browserify\":\"^5.0.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-connect\":\"^1.0.0\",\"grunt-contrib-copy\":\"^1.0.0\",\"grunt-contrib-uglify\":\"^1.0.1\",\"grunt-mocha-istanbul\":\"^3.0.1\",\"grunt-saucelabs\":\"^8.6.2\",\"istanbul\":\"^0.4.2\",\"jscs\":\"^2.9.0\",\"jshint\":\"^2.6.0\",\"mocha\":\"^2.1.0\"},\"dependencies\":{\"bn.js\":\"^4.4.0\",\"brorand\":\"^1.0.1\",\"hash.js\":\"^1.0.0\",\"hmac-drbg\":\"^1.0.0\",\"inherits\":\"^2.0.1\",\"minimalistic-assert\":\"^1.0.0\",\"minimalistic-crypto-utils\":\"^1.0.0\"},\"_resolved\":\"https://registry.npmjs.org/elliptic/-/elliptic-6.4.1.tgz\",\"_integrity\":\"sha512-BsXLz5sqX8OHcsh7CqBMztyXARmGQ3LWPtGjJi6DiJHq5C/qvi9P3OqgswKSDftbu8+IoI/QDTAm2fFnQ9SZSQ==\",\"_from\":\"elliptic@6.4.1\"}");

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha.js")
exports.sha1 = __webpack_require__(/*! ./sha1 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha1.js")
exports.sha224 = __webpack_require__(/*! ./sha224 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha224.js")
exports.sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha256.js")
exports.sha384 = __webpack_require__(/*! ./sha384 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha384.js")
exports.sha512 = __webpack_require__(/*! ./sha512 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha512.js")


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha1.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha1.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha224.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha224.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var Sha256 = __webpack_require__(/*! ./sha256 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha256.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha256.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha256.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha384.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha384.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var SHA512 = __webpack_require__(/*! ./sha512 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha512.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha512.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/sha512.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sha.js/hash.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/safe-buffer/index.js").Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/simple-peer/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/simple-peer/index.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = Peer

var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/debug/src/browser.js")('simple-peer')
var getBrowserRTC = __webpack_require__(/*! get-browser-rtc */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/get-browser-rtc/index.js")
var inherits = __webpack_require__(/*! inherits */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/inherits/inherits_browser.js")
var randombytes = __webpack_require__(/*! randombytes */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/randombytes/browser.js")
var stream = __webpack_require__(/*! readable-stream */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/readable-stream/readable-browser.js")

var MAX_BUFFERED_AMOUNT = 64 * 1024
var ICECOMPLETE_TIMEOUT = 5 * 1000
var CHANNEL_CLOSING_TIMEOUT = 5 * 1000

inherits(Peer, stream.Duplex)

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
function Peer (opts) {
  var self = this
  if (!(self instanceof Peer)) return new Peer(opts)

  self._id = randombytes(4).toString('hex').slice(0, 7)
  self._debug('new peer %o', opts)

  opts = Object.assign({
    allowHalfOpen: false
  }, opts)

  stream.Duplex.call(self, opts)

  self.channelName = opts.initiator
    ? opts.channelName || randombytes(20).toString('hex')
    : null

  // Needed by _transformConstraints, so set this early
  self._isChromium = typeof window !== 'undefined' && !!window.webkitRTCPeerConnection

  self.initiator = opts.initiator || false
  self.channelConfig = opts.channelConfig || Peer.channelConfig
  self.config = Object.assign({}, Peer.config, opts.config)
  self.constraints = self._transformConstraints(opts.constraints || Peer.constraints)
  self.offerConstraints = self._transformConstraints(opts.offerConstraints || {})
  self.answerConstraints = self._transformConstraints(opts.answerConstraints || {})
  self.sdpTransform = opts.sdpTransform || function (sdp) { return sdp }
  self.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
  self.trickle = opts.trickle !== undefined ? opts.trickle : true
  self.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
  self.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

  self.destroyed = false
  self.connected = false

  self.remoteAddress = undefined
  self.remoteFamily = undefined
  self.remotePort = undefined
  self.localAddress = undefined
  self.localPort = undefined

  self._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
    ? opts.wrtc
    : getBrowserRTC()

  if (!self._wrtc) {
    if (typeof window === 'undefined') {
      throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT')
    } else {
      throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT')
    }
  }

  self._pcReady = false
  self._channelReady = false
  self._iceComplete = false // ice candidate trickle done (got null candidate)
  self._iceCompleteTimer = null // send an offer/answer anyway after some timeout
  self._channel = null
  self._pendingCandidates = []

  self._isNegotiating = !self.initiator // is this peer waiting for negotiation to complete?
  self._batchedNegotiation = false // batch synchronous negotiations
  self._queuedNegotiation = false // is there a queued negotiation request?
  self._sendersAwaitingStable = []
  self._senderMap = new Map()
  self._firstStable = true
  self._closingInterval = null

  self._remoteTracks = []
  self._remoteStreams = []

  self._chunk = null
  self._cb = null
  self._interval = null

  self._pc = new (self._wrtc.RTCPeerConnection)(self.config, self.constraints)
  if (self._isChromium || (self._wrtc && self._wrtc.electronDaemon)) { // HACK: Electron and Chromium need a promise shim
    shimPromiseAPI(self._wrtc.RTCPeerConnection, self._pc)
  }

  // We prefer feature detection whenever possible, but sometimes that's not
  // possible for certain implementations.
  self._isReactNativeWebrtc = typeof self._pc._peerConnectionId === 'number'

  self._pc.oniceconnectionstatechange = function () {
    self._onIceStateChange()
  }
  self._pc.onicegatheringstatechange = function () {
    self._onIceStateChange()
  }
  self._pc.onsignalingstatechange = function () {
    self._onSignalingStateChange()
  }
  self._pc.onicecandidate = function (event) {
    self._onIceCandidate(event)
  }

  // Other spec events, unused by this implementation:
  // - onconnectionstatechange
  // - onicecandidateerror
  // - onfingerprintfailure
  // - onnegotiationneeded

  if (self.initiator) {
    self._setupData({
      channel: self._pc.createDataChannel(self.channelName, self.channelConfig)
    })
  } else {
    self._pc.ondatachannel = function (event) {
      self._setupData(event)
    }
  }

  if ('addTrack' in self._pc) {
    if (self.streams) {
      self.streams.forEach(function (stream) {
        self.addStream(stream)
      })
    }
    self._pc.ontrack = function (event) {
      self._onTrack(event)
    }
  }

  if (self.initiator) {
    self._needsNegotiation()
  }

  self._onFinishBound = function () {
    self._onFinish()
  }
  self.once('finish', self._onFinishBound)
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose config, constraints, and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config, opts.constraints, or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: 'stun:stun.l.google.com:19302'
    },
    {
      urls: 'stun:global.stun.twilio.com:3478?transport=udp'
    }
  ]
}
Peer.constraints = {}
Peer.channelConfig = {}

Object.defineProperty(Peer.prototype, 'bufferSize', {
  get: function () {
    var self = this
    return (self._channel && self._channel.bufferedAmount) || 0
  }
})

Peer.prototype.address = function () {
  var self = this
  return { port: self.localPort, family: 'IPv4', address: self.localAddress }
}

Peer.prototype.signal = function (data) {
  var self = this
  if (self.destroyed) throw makeError('cannot signal after peer is destroyed', 'ERR_SIGNALING')
  if (typeof data === 'string') {
    try {
      data = JSON.parse(data)
    } catch (err) {
      data = {}
    }
  }
  self._debug('signal()')

  if (data.renegotiate && self.initiator) {
    self._debug('got request to renegotiate')
    self._needsNegotiation()
  }
  if (data.candidate) {
    if (self._pc.remoteDescription && self._pc.remoteDescription.type) self._addIceCandidate(data.candidate)
    else self._pendingCandidates.push(data.candidate)
  }
  if (data.sdp) {
    self._pc.setRemoteDescription(new (self._wrtc.RTCSessionDescription)(data)).then(function () {
      if (self.destroyed) return

      self._pendingCandidates.forEach(function (candidate) {
        self._addIceCandidate(candidate)
      })
      self._pendingCandidates = []

      if (self._pc.remoteDescription.type === 'offer') self._createAnswer()
    }).catch(function (err) { self.destroy(makeError(err, 'ERR_SET_REMOTE_DESCRIPTION')) })
  }
  if (!data.sdp && !data.candidate && !data.renegotiate) {
    self.destroy(makeError('signal() called with invalid signal data', 'ERR_SIGNALING'))
  }
}

Peer.prototype._addIceCandidate = function (candidate) {
  var self = this
  try {
    self._pc.addIceCandidate(
      new self._wrtc.RTCIceCandidate(candidate),
      noop,
      function (err) { self.destroy(makeError(err, 'ERR_ADD_ICE_CANDIDATE')) }
    )
  } catch (err) {
    self.destroy(makeError('error adding candidate: ' + err.message, 'ERR_ADD_ICE_CANDIDATE'))
  }
}

/**
 * Send text/binary data to the remote peer.
 * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
 */
Peer.prototype.send = function (chunk) {
  var self = this
  self._channel.send(chunk)
}

/**
 * Add a MediaStream to the connection.
 * @param {MediaStream} stream
 */
Peer.prototype.addStream = function (stream) {
  var self = this

  self._debug('addStream()')

  stream.getTracks().forEach(function (track) {
    self.addTrack(track, stream)
  })
}

/**
 * Add a MediaStreamTrack to the connection.
 * @param {MediaStreamTrack} track
 * @param {MediaStream} stream
 */
Peer.prototype.addTrack = function (track, stream) {
  var self = this

  self._debug('addTrack()')

  var sender = self._pc.addTrack(track, stream)
  var submap = self._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
  submap.set(stream, sender)
  self._senderMap.set(track, submap)
  self._needsNegotiation()
}

/**
 * Replace a MediaStreamTrack by another in the connection.
 * @param {MediaStreamTrack} oldTrack
 * @param {MediaStreamTrack} newTrack
 * @param {MediaStream} stream
 */
Peer.prototype.replaceTrack = async function (oldTrack, newTrack, stream) {
  var self = this

  self._debug('replaceTrack()')

  var submap = self._senderMap.get(oldTrack)
  var sender = submap ? submap.get(stream) : null
  if (!sender) {
    self.destroy(new Error('Cannot replace track that was never added.'))
  }
  if (newTrack) self._senderMap.set(newTrack, submap)

  if (sender.replaceTrack != null) {
    await sender.replaceTrack(newTrack)
  } else {
    self.destroy(makeError('replaceTrack is not supported in this browser', 'ERR_UNSUPPORTED_REPLACETRACK'))
  }
}

/**
 * Remove a MediaStreamTrack from the connection.
 * @param {MediaStreamTrack} track
 * @param {MediaStream} stream
 */
Peer.prototype.removeTrack = function (track, stream) {
  var self = this

  self._debug('removeSender()')

  var submap = self._senderMap.get(track)
  var sender = submap ? submap.get(stream) : null
  if (!sender) {
    self.destroy(new Error('Cannot remove track that was never added.'))
  }
  try {
    self._pc.removeTrack(sender)
  } catch (err) {
    if (err.name === 'NS_ERROR_UNEXPECTED') {
      self._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
    } else {
      self.destroy(err)
    }
  }
}

/**
 * Remove a MediaStream from the connection.
 * @param {MediaStream} stream
 */
Peer.prototype.removeStream = function (stream) {
  var self = this

  self._debug('removeSenders()')

  stream.getTracks().forEach(function (track) {
    self.removeTrack(track, stream)
  })
}

Peer.prototype._needsNegotiation = function () {
  var self = this

  self._debug('_needsNegotiation')
  if (self._batchedNegotiation) return // batch synchronous renegotiations
  self._batchedNegotiation = true
  setTimeout(function () {
    self._batchedNegotiation = false
    self._debug('starting batched negotiation')
    self.negotiate()
  }, 0)
}

Peer.prototype.negotiate = function () {
  var self = this

  if (self.initiator) {
    if (self._isNegotiating) {
      self._queuedNegotiation = true
      self._debug('already negotiating, queueing')
    } else {
      self._debug('start negotiation')
      self._createOffer()
    }
  } else {
    if (!self._isNegotiating) {
      self._debug('requesting negotiation from initiator')
      self.emit('signal', { // request initiator to renegotiate
        renegotiate: true
      })
    }
  }
  self._isNegotiating = true
}

// TODO: Delete this method once readable-stream is updated to contain a default
// implementation of destroy() that automatically calls _destroy()
// See: https://github.com/nodejs/readable-stream/issues/283
Peer.prototype.destroy = function (err) {
  var self = this
  self._destroy(err, function () {})
}

Peer.prototype._destroy = function (err, cb) {
  var self = this
  if (self.destroyed) return

  self._debug('destroy (error: %s)', err && (err.message || err))

  self.readable = self.writable = false

  if (!self._readableState.ended) self.push(null)
  if (!self._writableState.finished) self.end()

  self.destroyed = true
  self.connected = false
  self._pcReady = false
  self._channelReady = false
  self._remoteTracks = null
  self._remoteStreams = null
  self._senderMap = null

  clearInterval(self._closingInterval)
  self._closingInterval = null

  clearInterval(self._interval)
  self._interval = null
  self._chunk = null
  self._cb = null

  if (self._onFinishBound) self.removeListener('finish', self._onFinishBound)
  self._onFinishBound = null

  if (self._channel) {
    try {
      self._channel.close()
    } catch (err) {}

    self._channel.onmessage = null
    self._channel.onopen = null
    self._channel.onclose = null
    self._channel.onerror = null
  }
  if (self._pc) {
    try {
      self._pc.close()
    } catch (err) {}

    self._pc.oniceconnectionstatechange = null
    self._pc.onicegatheringstatechange = null
    self._pc.onsignalingstatechange = null
    self._pc.onicecandidate = null
    if ('addTrack' in self._pc) {
      self._pc.ontrack = null
    }
    self._pc.ondatachannel = null
  }
  self._pc = null
  self._channel = null

  if (err) self.emit('error', err)
  self.emit('close')
  cb()
}

Peer.prototype._setupData = function (event) {
  var self = this
  if (!event.channel) {
    // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
    // which is invalid behavior. Handle it gracefully.
    // See: https://github.com/feross/simple-peer/issues/163
    return self.destroy(makeError('Data channel event is missing `channel` property', 'ERR_DATA_CHANNEL'))
  }

  self._channel = event.channel
  self._channel.binaryType = 'arraybuffer'

  if (typeof self._channel.bufferedAmountLowThreshold === 'number') {
    self._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
  }

  self.channelName = self._channel.label

  self._channel.onmessage = function (event) {
    self._onChannelMessage(event)
  }
  self._channel.onbufferedamountlow = function () {
    self._onChannelBufferedAmountLow()
  }
  self._channel.onopen = function () {
    self._onChannelOpen()
  }
  self._channel.onclose = function () {
    self._onChannelClose()
  }
  self._channel.onerror = function (err) {
    self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
  }

  // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  var isClosing = false
  self._closingInterval = setInterval(function () { // No "onclosing" event
    if (self._channel && self._channel.readyState === 'closing') {
      if (isClosing) self._onChannelClose() // closing timed out: equivalent to onclose firing
      isClosing = true
    } else {
      isClosing = false
    }
  }, CHANNEL_CLOSING_TIMEOUT)
}

Peer.prototype._read = function () {}

Peer.prototype._write = function (chunk, encoding, cb) {
  var self = this
  if (self.destroyed) return cb(makeError('cannot write after peer is destroyed', 'ERR_DATA_CHANNEL'))

  if (self.connected) {
    try {
      self.send(chunk)
    } catch (err) {
      return self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
    }
    if (self._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      self._debug('start backpressure: bufferedAmount %d', self._channel.bufferedAmount)
      self._cb = cb
    } else {
      cb(null)
    }
  } else {
    self._debug('write before connect')
    self._chunk = chunk
    self._cb = cb
  }
}

// When stream finishes writing, close socket. Half open connections are not
// supported.
Peer.prototype._onFinish = function () {
  var self = this
  if (self.destroyed) return

  if (self.connected) {
    destroySoon()
  } else {
    self.once('connect', destroySoon)
  }

  // Wait a bit before destroying so the socket flushes.
  // TODO: is there a more reliable way to accomplish this?
  function destroySoon () {
    setTimeout(function () {
      self.destroy()
    }, 1000)
  }
}

Peer.prototype._startIceCompleteTimeout = function () {
  debug('started iceComplete timeout')
  var self = this
  if (self.destroyed) return
  if (self._iceCompleteTimer) return
  self._iceCompleteTimer = setTimeout(function () {
    if (!self._iceComplete) {
      self._iceComplete = true
      self.emit('iceTimeout')
      self.emit('_iceComplete')
    }
  }, this.iceCompleteTimeout)
}

Peer.prototype._createOffer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createOffer(self.offerConstraints).then(function (offer) {
    if (self.destroyed) return
    if (!self.trickle && !self.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
    offer.sdp = self.sdpTransform(offer.sdp)
    self._pc.setLocalDescription(offer).then(onSuccess).catch(onError)

    function onSuccess () {
      self._debug('createOffer success')
      if (self.destroyed) return
      if (self.trickle || self._iceComplete) sendOffer()
      else self.once('_iceComplete', sendOffer) // wait for candidates
    }

    function onError (err) {
      self.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))
    }

    function sendOffer () {
      if (self.destroyed) return
      var signal = self._pc.localDescription || offer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
  }).catch(function (err) { self.destroy(makeError(err, 'ERR_CREATE_OFFER')) })
}

Peer.prototype._createAnswer = function () {
  var self = this
  if (self.destroyed) return

  self._pc.createAnswer(self.answerConstraints).then(function (answer) {
    if (self.destroyed) return
    if (!self.trickle && !self.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
    answer.sdp = self.sdpTransform(answer.sdp)
    self._pc.setLocalDescription(answer).then(onSuccess).catch(onError)

    function onSuccess () {
      if (self.destroyed) return
      if (self.trickle || self._iceComplete) sendAnswer()
      else self.once('_iceComplete', sendAnswer)
    }

    function onError (err) {
      self.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))
    }

    function sendAnswer () {
      if (self.destroyed) return
      var signal = self._pc.localDescription || answer
      self._debug('signal')
      self.emit('signal', {
        type: signal.type,
        sdp: signal.sdp
      })
    }
  }).catch(function (err) { self.destroy(makeError(err, 'ERR_CREATE_ANSWER')) })
}

Peer.prototype._onIceStateChange = function () {
  var self = this
  if (self.destroyed) return
  var iceConnectionState = self._pc.iceConnectionState
  var iceGatheringState = self._pc.iceGatheringState

  self._debug(
    'iceStateChange (connection: %s) (gathering: %s)',
    iceConnectionState,
    iceGatheringState
  )
  self.emit('iceStateChange', iceConnectionState, iceGatheringState)

  if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
    self._pcReady = true
    self._maybeReady()
  }
  if (iceConnectionState === 'failed') {
    self.destroy(makeError('Ice connection failed.', 'ERR_ICE_CONNECTION_FAILURE'))
  }
  if (iceConnectionState === 'closed') {
    self.destroy(new Error('Ice connection closed.'))
  }
}

Peer.prototype.getStats = function (cb) {
  var self = this

  // Promise-based getStats() (standard)
  if (self._pc.getStats.length === 0) {
    self._pc.getStats().then(function (res) {
      var reports = []
      res.forEach(function (report) {
        reports.push(report)
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Two-parameter callback-based getStats() (deprecated, former standard)
  } else if (self._isReactNativeWebrtc) {
    self._pc.getStats(null, function (res) {
      var reports = []
      res.forEach(function (report) {
        reports.push(report)
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Single-parameter callback-based getStats() (non-standard)
  } else if (self._pc.getStats.length > 0) {
    self._pc.getStats(function (res) {
      // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
      if (self.destroyed) return

      var reports = []
      res.result().forEach(function (result) {
        var report = {}
        result.names().forEach(function (name) {
          report[name] = result.stat(name)
        })
        report.id = result.id
        report.type = result.type
        report.timestamp = result.timestamp
        reports.push(report)
      })
      cb(null, reports)
    }, function (err) { cb(err) })

  // Unknown browser, skip getStats() since it's anyone's guess which style of
  // getStats() they implement.
  } else {
    cb(null, [])
  }
}

Peer.prototype._maybeReady = function () {
  var self = this
  self._debug('maybeReady pc %s channel %s', self._pcReady, self._channelReady)
  if (self.connected || self._connecting || !self._pcReady || !self._channelReady) return

  self._connecting = true

  // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
  function findCandidatePair () {
    if (self.destroyed) return

    self.getStats(function (err, items) {
      if (self.destroyed) return

      // Treat getStats error as non-fatal. It's not essential.
      if (err) items = []

      var remoteCandidates = {}
      var localCandidates = {}
      var candidatePairs = {}
      var foundSelectedCandidatePair = false

      items.forEach(function (item) {
        // TODO: Once all browsers support the hyphenated stats report types, remove
        // the non-hypenated ones
        if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
          remoteCandidates[item.id] = item
        }
        if (item.type === 'localcandidate' || item.type === 'local-candidate') {
          localCandidates[item.id] = item
        }
        if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
          candidatePairs[item.id] = item
        }
      })

      items.forEach(function (item) {
        // Spec-compliant
        if (item.type === 'transport' && item.selectedCandidatePairId) {
          setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
        }

        // Old implementations
        if (
          (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
          ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
        ) {
          setSelectedCandidatePair(item)
        }
      })

      function setSelectedCandidatePair (selectedCandidatePair) {
        foundSelectedCandidatePair = true

        var local = localCandidates[selectedCandidatePair.localCandidateId]

        if (local && local.ip) {
          // Spec
          self.localAddress = local.ip
          self.localPort = Number(local.port)
        } else if (local && local.ipAddress) {
          // Firefox
          self.localAddress = local.ipAddress
          self.localPort = Number(local.portNumber)
        } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
          // TODO: remove this once Chrome 58 is released
          local = selectedCandidatePair.googLocalAddress.split(':')
          self.localAddress = local[0]
          self.localPort = Number(local[1])
        }

        var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

        if (remote && remote.ip) {
          // Spec
          self.remoteAddress = remote.ip
          self.remotePort = Number(remote.port)
        } else if (remote && remote.ipAddress) {
          // Firefox
          self.remoteAddress = remote.ipAddress
          self.remotePort = Number(remote.portNumber)
        } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
          // TODO: remove this once Chrome 58 is released
          remote = selectedCandidatePair.googRemoteAddress.split(':')
          self.remoteAddress = remote[0]
          self.remotePort = Number(remote[1])
        }
        self.remoteFamily = 'IPv4'

        self._debug(
          'connect local: %s:%s remote: %s:%s',
          self.localAddress, self.localPort, self.remoteAddress, self.remotePort
        )
      }

      // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
      // But wait until at least 1 candidate pair is available
      if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
        setTimeout(findCandidatePair, 100)
        return
      } else {
        self._connecting = false
        self.connected = true
      }

      if (self._chunk) {
        try {
          self.send(self._chunk)
        } catch (err) {
          return self.destroy(makeError(err, 'ERR_DATA_CHANNEL'))
        }
        self._chunk = null
        self._debug('sent chunk from "write before connect"')

        var cb = self._cb
        self._cb = null
        cb(null)
      }

      // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
      // fallback to using setInterval to implement backpressure.
      if (typeof self._channel.bufferedAmountLowThreshold !== 'number') {
        self._interval = setInterval(function () { self._onInterval() }, 150)
        if (self._interval.unref) self._interval.unref()
      }

      self._debug('connect')
      self.emit('connect')
    })
  }
  findCandidatePair()
}

Peer.prototype._onInterval = function () {
  var self = this
  if (!self._cb || !self._channel || self._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
    return
  }
  self._onChannelBufferedAmountLow()
}

Peer.prototype._onSignalingStateChange = function () {
  var self = this
  if (self.destroyed) return

  if (self._pc.signalingState === 'stable' && !self._firstStable) {
    self._isNegotiating = false

    // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
    self._debug('flushing sender queue', self._sendersAwaitingStable)
    self._sendersAwaitingStable.forEach(function (sender) {
      self._pc.removeTrack(sender)
      self._queuedNegotiation = true
    })
    self._sendersAwaitingStable = []

    if (self._queuedNegotiation) {
      self._debug('flushing negotiation queue')
      self._queuedNegotiation = false
      self._needsNegotiation() // negotiate again
    }

    self._debug('negotiate')
    self.emit('negotiate')
  }
  self._firstStable = false

  self._debug('signalingStateChange %s', self._pc.signalingState)
  self.emit('signalingStateChange', self._pc.signalingState)
}

Peer.prototype._onIceCandidate = function (event) {
  var self = this
  if (self.destroyed) return
  if (event.candidate && self.trickle) {
    self.emit('signal', {
      candidate: {
        candidate: event.candidate.candidate,
        sdpMLineIndex: event.candidate.sdpMLineIndex,
        sdpMid: event.candidate.sdpMid
      }
    })
  } else if (!event.candidate && !self._iceComplete) {
    self._iceComplete = true
    self.emit('_iceComplete')
  }
  // as soon as we've received one valid candidate start timeout
  if (event.candidate) {
    self._startIceCompleteTimeout()
  }
}

Peer.prototype._onChannelMessage = function (event) {
  var self = this
  if (self.destroyed) return
  var data = event.data
  if (data instanceof ArrayBuffer) data = Buffer.from(data)
  self.push(data)
}

Peer.prototype._onChannelBufferedAmountLow = function () {
  var self = this
  if (self.destroyed || !self._cb) return
  self._debug('ending backpressure: bufferedAmount %d', self._channel.bufferedAmount)
  var cb = self._cb
  self._cb = null
  cb(null)
}

Peer.prototype._onChannelOpen = function () {
  var self = this
  if (self.connected || self.destroyed) return
  self._debug('on channel open')
  self._channelReady = true
  self._maybeReady()
}

Peer.prototype._onChannelClose = function () {
  var self = this
  if (self.destroyed) return
  self._debug('on channel close')
  self.destroy()
}

Peer.prototype._onTrack = function (event) {
  var self = this
  if (self.destroyed) return

  event.streams.forEach(function (eventStream) {
    self._debug('on track')
    self.emit('track', event.track, eventStream)

    self._remoteTracks.push({
      track: event.track,
      stream: eventStream
    })

    if (self._remoteStreams.some(function (remoteStream) {
      return remoteStream.id === eventStream.id
    })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

    self._remoteStreams.push(eventStream)
    setTimeout(function () {
      self.emit('stream', eventStream) // ensure all tracks have been added
    }, 0)
  })
}

Peer.prototype.setConstraints = function (constraints) {
  var self = this
  if (self.initiator) {
    self.offerConstraints = self._transformConstraints(constraints)
  } else {
    self.answerConstraints = self._transformConstraints(constraints)
  }
}

Peer.prototype._debug = function () {
  var self = this
  var args = [].slice.call(arguments)
  args[0] = '[' + self._id + '] ' + args[0]
  debug.apply(null, args)
}

// Transform constraints objects into the new format (unless Chromium)
// TODO: This can be removed when Chromium supports the new format
Peer.prototype._transformConstraints = function (constraints) {
  var self = this

  if (Object.keys(constraints).length === 0) {
    return constraints
  }

  if ((constraints.mandatory || constraints.optional) && !self._isChromium) {
    // convert to new format

    // Merge mandatory and optional objects, prioritizing mandatory
    var newConstraints = Object.assign({}, constraints.optional, constraints.mandatory)

    // fix casing
    if (newConstraints.OfferToReceiveVideo !== undefined) {
      newConstraints.offerToReceiveVideo = newConstraints.OfferToReceiveVideo
      delete newConstraints['OfferToReceiveVideo']
    }

    if (newConstraints.OfferToReceiveAudio !== undefined) {
      newConstraints.offerToReceiveAudio = newConstraints.OfferToReceiveAudio
      delete newConstraints['OfferToReceiveAudio']
    }

    return newConstraints
  } else if (!constraints.mandatory && !constraints.optional && self._isChromium) {
    // convert to old format

    // fix casing
    if (constraints.offerToReceiveVideo !== undefined) {
      constraints.OfferToReceiveVideo = constraints.offerToReceiveVideo
      delete constraints['offerToReceiveVideo']
    }

    if (constraints.offerToReceiveAudio !== undefined) {
      constraints.OfferToReceiveAudio = constraints.offerToReceiveAudio
      delete constraints['offerToReceiveAudio']
    }

    return {
      mandatory: constraints // NOTE: All constraints are upgraded to mandatory
    }
  }

  return constraints
}

// HACK: Minimal shim to force Chrome and WRTC to use their more reliable callback API
function shimPromiseAPI (RTCPeerConnection, pc) {
  pc.createOffer = function (constraints) {
    return new Promise((resolve, reject) => {
      RTCPeerConnection.prototype.createOffer.call(this, resolve, reject, constraints)
    })
  }
  pc.createAnswer = function (constraints) {
    return new Promise((resolve, reject) => {
      RTCPeerConnection.prototype.createAnswer.call(this, resolve, reject, constraints)
    })
  }
  pc.setLocalDescription = function (description) {
    return new Promise((resolve, reject) => {
      RTCPeerConnection.prototype.setLocalDescription.call(this, description, resolve, reject)
    })
  }
  pc.setRemoteDescription = function (description) {
    return new Promise((resolve, reject) => {
      RTCPeerConnection.prototype.setRemoteDescription.call(this, description, resolve, reject)
    })
  }
}

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function makeError (message, code) {
  var err = new Error(message)
  err.code = code
  return err
}

function noop () {}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(/*! ./url */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/url.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/index.js");
var Manager = __webpack_require__(/*! ./manager */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/manager.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(/*! ./manager */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/manager.js");
exports.Socket = __webpack_require__(/*! ./socket */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/socket.js");


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/manager.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/manager.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/engine.io-client/lib/index.js");
var Socket = __webpack_require__(/*! ./socket */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/socket.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:manager');
var indexOf = __webpack_require__(/*! indexof */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/indexof/index.js");
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/backo2/index.js");

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/on.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/on.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/socket.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/socket.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");
var toArray = __webpack_require__(/*! to-array */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/to-array/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:socket');
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseqs/index.js");
var hasBin = __webpack_require__(/*! has-binary2 */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/has-binary2/index.js");

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/url.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/lib/url.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/parseuri/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js")('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/browser.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = Object({"NODE_ENV":"development","BASE_URL":""}).DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/debug.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/debug/src/debug.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/ms/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-client/node_modules/ms/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/binary.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/binary.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/is-buffer.js");
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js")('socket.io-parser');
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/component-emitter/index.js");
var binary = __webpack_require__(/*! ./binary */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/binary.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/is-buffer.js");

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/is-buffer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/is-buffer.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {
module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = Object({"NODE_ENV":"development","BASE_URL":""}).DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/isarray/index.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/isarray/index.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/ms/index.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/socket.io-parser/node_modules/ms/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/strip-hex-prefix/src/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/strip-hex-prefix/src/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isHexPrefixed = __webpack_require__(/*! is-hex-prefixed */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/is-hex-prefixed/src/index.js");

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/to-array/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/to-array/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/util-deprecate/browser.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/util-deprecate/browser.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/bytesToUuid.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/bytesToUuid.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/rng-browser.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/rng-browser.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/v4.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/v4.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */



var adapterFactory = __webpack_require__(/*! ./adapter_factory.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_factory.js");
module.exports = adapterFactory({window: global.window});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */



var utils = __webpack_require__(/*! ./utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = __webpack_require__(/*! ./chrome/chrome_shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js") || null;
  var edgeShim = __webpack_require__(/*! ./edge/edge_shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/edge_shim.js") || null;
  var firefoxShim = __webpack_require__(/*! ./firefox/firefox_shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js") || null;
  var safariShim = __webpack_require__(/*! ./safari/safari_shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/safari/safari_shim.js") || null;
  var commonShim = __webpack_require__(/*! ./common_shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/common_shim.js") || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);
      edgeShim.shimGetDisplayMedia(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

var utils = __webpack_require__(/*! ../utils.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
var logging = utils.log;

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

module.exports = {
  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js"),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else {
      // even if RTCRtpTransceiver is in window, it is only used and
      // emitted in unified-plan. Unfortunately this means we need
      // to unconditionally wrap the event.
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          Object.defineProperty(e, 'transceiver',
            {value: {receiver: e.receiver}});
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSenderReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          var pc = this;
          var senders = origGetSenders.apply(pc, []);
          senders.forEach(function(sender) {
            sender._pc = pc;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function() {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function() {
        var sender = this;
        return this._pc.getStats().then(function(result) {
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          return filterStats(result, sender.track, true);
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function() {
          var pc = this;
          var receivers = origGetReceivers.apply(pc, []);
          receivers.forEach(function(receiver) {
            receiver._pc = pc;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function() {
        var receiver = this;
        return this._pc.getStats().then(function(result) {
          return filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function() {
      var pc = this;
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender;
        var receiver;
        var err;
        pc.getSenders().forEach(function(s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        pc.getReceivers().forEach(function(r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(pc, arguments);
    };
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    if (!window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    }
    if (!window.RTCPeerConnection) {
      return;
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  },

  fixNegotiationNeeded: function(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function(e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  },

  shimGetDisplayMedia: function(window, getSourceId) {
    if (!window.navigator || !window.navigator.mediaDevices ||
        'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' +
          'a function');
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function(constraints) {
      return getSourceId(constraints)
        .then(function(sourceId) {
          var widthSpecified = constraints.video && constraints.video.width;
          var heightSpecified = constraints.video && constraints.video.height;
          var frameRateSpecified = constraints.video &&
            constraints.video.frameRate;
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: frameRateSpecified || 3
            }
          };
          if (widthSpecified) {
            constraints.video.mandatory.maxWidth = widthSpecified;
          }
          if (heightSpecified) {
            constraints.video.mandatory.maxHeight = heightSpecified;
          }
          return window.navigator.mediaDevices.getUserMedia(constraints);
        });
    };
    window.navigator.getDisplayMedia = function(constraints) {
      utils.deprecated('navigator.getDisplayMedia',
          'navigator.mediaDevices.getDisplayMedia');
      return window.navigator.mediaDevices.getDisplayMedia(constraints);
    };
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

var utils = __webpack_require__(/*! ../utils.js */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/common_shim.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var SDPUtils = __webpack_require__(/*! sdp */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/sdp/sdp.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function() {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      wrapDcSend(dataChannel, pc);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/edge_shim.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/edge_shim.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
var filterIceServers = __webpack_require__(/*! ./filtericeservers */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/filtericeservers.js");
var shimRTCPeerConnection = __webpack_require__(/*! rtcpeerconnection-shim */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/rtcpeerconnection-shim/rtcpeerconnection.js");

module.exports = {
  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/getusermedia.js"),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = shimRTCPeerConnection(window,
        browserDetails.version);
    window.RTCPeerConnection = function(config) {
      if (config && config.iceServers) {
        config.iceServers = filterIceServers(config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  },
  shimGetDisplayMedia: function(window, preferredMediaSource) {
    if (!('getDisplayMedia' in window.navigator) ||
        !window.navigator.mediaDevices ||
        'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    var origGetDisplayMedia = window.navigator.getDisplayMedia;
    window.navigator.mediaDevices.getDisplayMedia = function(constraints) {
      return origGetDisplayMedia.call(window.navigator, constraints);
    };
    window.navigator.getDisplayMedia = function(constraints) {
      utils.deprecated('navigator.getDisplayMedia',
          'navigator.mediaDevices.getDisplayMedia');
      return origGetDisplayMedia.call(window.navigator, constraints);
    };
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/filtericeservers.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/filtericeservers.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
module.exports = function(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/getusermedia.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/edge/getusermedia.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");

module.exports = {
  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js"),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        },
        enumerable: true,
        configurable: true
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimSenderGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function() {
      return this.track ? this._pc.getStats(this.track) :
          Promise.resolve(new Map());
    };
  },

  shimReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function() {
        var pc = this;
        var receivers = origGetReceivers.apply(pc, []);
        receivers.forEach(function(receiver) {
          receiver._pc = pc;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function() {
      return this._pc.getStats(this.track);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  },

  shimRTCDataChannel: function(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  },

  shimGetDisplayMedia: function(window, preferredMediaSource) {
    if (!window.navigator || !window.navigator.mediaDevices ||
        'getDisplayMedia' in window.navigator.mediaDevices) {
      return;
    }
    window.navigator.mediaDevices.getDisplayMedia = function(constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window.navigator.mediaDevices.getUserMedia(constraints);
    };
    window.navigator.getDisplayMedia = function(constraints) {
      utils.deprecated('navigator.getDisplayMedia',
          'navigator.mediaDevices.getDisplayMedia');
      return window.navigator.mediaDevices.getDisplayMedia(constraints);
    };
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

var utils = __webpack_require__(/*! ../utils */ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js");

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
          }
          this.addEventListener('addstream', this._onaddstream = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/webrtc-adapter/src/js/utils.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};


/***/ }),

/***/ "./node_modules/@myetherwallet/mewconnect-web-client/node_modules/yeast/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@myetherwallet/mewconnect-web-client/node_modules/yeast/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    textOne: {
      type: String,
      default: ''
    },
    textTwo: {
      type: String,
      default: ''
    },
    funcOne: {
      type: Function,
      default: function _default() {}
    },
    funcTwo: {
      type: Function,
      default: function _default() {}
    },
    disabled: {
      type: Boolean,
      default: false
    }
  }
});

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ __webpack_exports__["default"] = ({
  props: {
    func: {
      type: Function,
      default: function _default() {}
    },
    actionName: {
      type: String,
      default: ''
    },
    loading: {
      type: Boolean,
      default: false
    },
    error: {
      type: Object,
      default: function _default() {
        return {
          msg: '',
          errored: false
        };
      }
    }
  },
  data: function data() {
    return {
      show: false,
      password: ''
    };
  },
  watch: {
    password: function password(newVal) {
      this.$emit('passwordChange', newVal);
    }
  },
  methods: {
    close: function close() {
      this.$refs.passwordModal.hide();
    }
  }
});

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");
/* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty */ "./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js");
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm.js");
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! web3-utils */ "./node_modules/web3-utils/src/index.js");
/* harmony import */ var web3_utils__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(web3_utils__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _wallets_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/wallets/bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _wallets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/wallets */ "./src/wallets/index.js");
/* harmony import */ var worker_loader_workers_wallet_worker_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! worker-loader!@/workers/wallet.worker.js */ "./node_modules/worker-loader/dist/cjs.js!./src/workers/wallet.worker.js");
/* harmony import */ var worker_loader_workers_wallet_worker_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(worker_loader_workers_wallet_worker_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var _components_Blockie__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/Blockie */ "./src/components/Blockie/index.js");
/* harmony import */ var _components_PasswordModalComponent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../components/PasswordModalComponent */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/index.js");
/* harmony import */ var _components_AcceptCancelButtons__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../components/AcceptCancelButtons */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/index.js");
/* harmony import */ var _builds_mewcx_cxHelpers_cxEvents__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @/builds/mewcx/cxHelpers/cxEvents */ "./src/builds/mewcx/cxHelpers/cxEvents.js");








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










/* harmony default export */ __webpack_exports__["default"] = ({
  components: {
    blockie: _components_Blockie__WEBPACK_IMPORTED_MODULE_13__["default"],
    'accept-cancel-buttons': _components_AcceptCancelButtons__WEBPACK_IMPORTED_MODULE_15__["default"],
    'password-modal-component': _components_PasswordModalComponent__WEBPACK_IMPORTED_MODULE_14__["default"]
  },
  data: function data() {
    return {
      address: '',
      message: '',
      password: '',
      signingKeystore: {},
      loading: false,
      error: {}
    };
  },
  computed: _objectSpread({}, Object(vuex__WEBPACK_IMPORTED_MODULE_7__["mapState"])(['linkQuery'])),
  mounted: function mounted() {
    var _self = this;

    var _self$linkQuery = _self.linkQuery,
        address = _self$linkQuery.address,
        msgToSign = _self$linkQuery.msgToSign;
    _self.address = address;
    _self.message = web3_utils__WEBPACK_IMPORTED_MODULE_8___default.a.hexToAscii(msgToSign);
    window.chrome.storage.sync.get(address, function (res) {
      _self.signingKeystore = JSON.parse(res[address]).priv;
    });
  },
  methods: {
    updatePassword: function updatePassword(e) {
      this.error = {
        msg: '',
        errored: false
      };
      this.password = e;
    },
    unlockWallet: function unlockWallet() {
      this.loading = true;
      var worker = new worker_loader_workers_wallet_worker_js__WEBPACK_IMPORTED_MODULE_11___default.a();

      var _self = this;

      worker.postMessage({
        type: 'unlockWallet',
        data: [JSON.parse(this.signingKeystore), this.password]
      });

      worker.onmessage = function (e) {
        _self.loading = false;

        _self.signMsg(e.data._privKey);
      };

      worker.onerror = function (e) {
        e.preventDefault();
        _self.loading = false;
        _self.error = {
          msg: 'Unlock failed: Wrong password!',
          errored: true
        };
      };
    },
    signMsg: function () {
      var _signMsg = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(priv) {
        var wallet, _self, signedMsg;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                wallet = new _wallets__WEBPACK_IMPORTED_MODULE_10__["WalletInterface"](Buffer.from(priv), false, _wallets_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_9__["KEYSTORE"]);
                _self = this;
                _context.next = 4;
                return wallet.signMessage(this.message);

              case 4:
                signedMsg = _context.sent;
                window.chrome.tabs.query({
                  url: "*://*.".concat(_helpers__WEBPACK_IMPORTED_MODULE_12__["Misc"].getService(_self.linkQuery.url), "/*")
                }, function (tab) {
                  var obj = {
                    event: _builds_mewcx_cxHelpers_cxEvents__WEBPACK_IMPORTED_MODULE_16__["MEW_SIGNED_MSG"],
                    payload: '0x' + signedMsg.toString('hex')
                  };
                  window.chrome.tabs.sendMessage(tab[0].id, obj);
                  window.close();
                });

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signMsg(_x) {
        return _signMsg.apply(this, arguments);
      }

      return signMsg;
    }(),
    openPasswordModal: function openPasswordModal() {
      this.$refs.passwordModal.$refs.passwordModal.show();
    },
    rejectAction: function rejectAction() {
      var _self = this;

      window.chrome.tabs.query({
        url: "*://*.".concat(_helpers__WEBPACK_IMPORTED_MODULE_12__["Misc"].getService(_self.linkQuery.url), "/*")
      }, function (tab) {
        var obj = {
          event: _builds_mewcx_cxHelpers_cxEvents__WEBPACK_IMPORTED_MODULE_16__["REJECT_MEW_SIGN_MSG"]
        };
        window.chrome.tabs.sendMessage(tab[0].id, obj);
        window.close();
      });
    }
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function(_h, _vm) {
  var _c = _vm._c
  return _c("div", { staticClass: "buttons-container" }, [
    _c(
      "button",
      {
        staticClass: "sign",
        attrs: { disabled: _vm.props.disabled },
        on: {
          click: function($event) {
            $event.preventDefault()
            $event.stopPropagation()
            return _vm.props.funcOne($event)
          }
        }
      },
      [_vm._v("\n    " + _vm._s(_vm.props.textOne) + "\n  ")]
    ),
    _c(
      "button",
      {
        staticClass: "reject",
        on: {
          click: function($event) {
            $event.preventDefault()
            $event.stopPropagation()
            return _vm.props.funcTwo($event)
          }
        }
      },
      [_vm._v("\n    " + _vm._s(_vm.tprops.extTwo) + "\n  ")]
    )
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _c(
        "b-modal",
        {
          ref: "passwordModal",
          attrs: {
            "hide-footer": "",
            "hide-header": "",
            title: "Address",
            "modal-class": "cx-password-modal"
          }
        },
        [
          _c("div", { staticClass: "modal-contents" }, [
            _c("div", { staticClass: "header-container" }, [
              _c("p", [_vm._v("Password")]),
              _c("i", {
                staticClass: "fa fa-times fa-lg",
                on: { click: _vm.close }
              })
            ]),
            _c("form", { staticClass: "password-form" }, [
              _c("div", { staticClass: "input-container" }, [
                (_vm.show ? "text" : "password") === "checkbox"
                  ? _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.password,
                          expression: "password"
                        }
                      ],
                      ref: "mnemonicPasswordInput",
                      attrs: {
                        name: "Password",
                        autocomplete: "off",
                        placeholder: "Enter password",
                        type: "checkbox"
                      },
                      domProps: {
                        checked: Array.isArray(_vm.password)
                          ? _vm._i(_vm.password, null) > -1
                          : _vm.password
                      },
                      on: {
                        change: function($event) {
                          var $$a = _vm.password,
                            $$el = $event.target,
                            $$c = $$el.checked ? true : false
                          if (Array.isArray($$a)) {
                            var $$v = null,
                              $$i = _vm._i($$a, $$v)
                            if ($$el.checked) {
                              $$i < 0 && (_vm.password = $$a.concat([$$v]))
                            } else {
                              $$i > -1 &&
                                (_vm.password = $$a
                                  .slice(0, $$i)
                                  .concat($$a.slice($$i + 1)))
                            }
                          } else {
                            _vm.password = $$c
                          }
                        }
                      }
                    })
                  : (_vm.show ? "text" : "password") === "radio"
                  ? _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.password,
                          expression: "password"
                        }
                      ],
                      ref: "mnemonicPasswordInput",
                      attrs: {
                        name: "Password",
                        autocomplete: "off",
                        placeholder: "Enter password",
                        type: "radio"
                      },
                      domProps: { checked: _vm._q(_vm.password, null) },
                      on: {
                        change: function($event) {
                          _vm.password = null
                        }
                      }
                    })
                  : _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.password,
                          expression: "password"
                        }
                      ],
                      ref: "mnemonicPasswordInput",
                      attrs: {
                        name: "Password",
                        autocomplete: "off",
                        placeholder: "Enter password",
                        type: _vm.show ? "text" : "password"
                      },
                      domProps: { value: _vm.password },
                      on: {
                        input: function($event) {
                          if ($event.target.composing) {
                            return
                          }
                          _vm.password = $event.target.value
                        }
                      }
                    }),
                _c(
                  "p",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.error.msg !== "",
                        expression: "error.msg !== ''"
                      }
                    ],
                    staticClass: "error-msg"
                  },
                  [_vm._v(_vm._s(_vm.error.msg))]
                ),
                _vm.show
                  ? _c("img", {
                      attrs: {
                        src: __webpack_require__(/*! @/assets/images/icons/show-password.svg */ "./src/assets/images/icons/show-password.svg")
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault()
                          _vm.show = !_vm.show
                        }
                      }
                    })
                  : _vm._e(),
                !_vm.show
                  ? _c("img", {
                      attrs: {
                        src: __webpack_require__(/*! @/assets/images/icons/hide-password.svg */ "./src/assets/images/icons/hide-password.svg")
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault()
                          _vm.show = !_vm.show
                        }
                      }
                    })
                  : _vm._e()
              ]),
              _c(
                "button",
                {
                  staticClass: "submit-button large-round-button-green-filled",
                  attrs: {
                    disabled:
                      _vm.password === "" || _vm.loading || _vm.error.errored,
                    type: "submit"
                  },
                  on: {
                    click: function($event) {
                      $event.preventDefault()
                      return _vm.func($event)
                    }
                  }
                },
                [
                  _c(
                    "span",
                    {
                      directives: [
                        {
                          name: "show",
                          rawName: "v-show",
                          value: !_vm.loading,
                          expression: "!loading"
                        }
                      ]
                    },
                    [_vm._v(_vm._s(_vm.actionName))]
                  ),
                  _c("i", {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.loading,
                        expression: "loading"
                      }
                    ],
                    staticClass: "fa fa-spin fa-spinner"
                  })
                ]
              )
            ]),
            _c("p", { staticClass: "terms" }, [
              _vm._v(
                "\n        By entering your password, you accept our\n        "
              ),
              _c(
                "a",
                {
                  attrs: {
                    href: "https://www.myetherwallet.com/terms-and-conditions",
                    target: "_blank"
                  }
                },
                [_vm._v("\n          Terms and conditions\n        ")]
              )
            ])
          ])
        ]
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "sign-message-container" },
    [
      _vm._m(0),
      _c("div", { staticClass: "sign-message-address" }, [
        _c("p", [_vm._v("Signing Address")]),
        _c(
          "div",
          { staticClass: "signing-address" },
          [
            _c("blockie", {
              attrs: { address: _vm.address, width: "30px", height: "30px" }
            }),
            _c("p", [
              _vm._v(
                "\n        " +
                  _vm._s(_vm._f("concatAddr")(_vm.address)) +
                  "\n      "
              )
            ])
          ],
          1
        )
      ]),
      _c("div", { staticClass: "sign-message-content" }, [
        _c("p", [_vm._v("Message")]),
        _c("div", { staticClass: "message-container" }, [
          _vm._v("\n      " + _vm._s(_vm.message) + "\n    ")
        ])
      ]),
      _c("accept-cancel-buttons", {
        attrs: {
          "func-one": _vm.openPasswordModal,
          "func-two": _vm.rejectAction,
          "text-one": "Sign",
          "text-two": "Reject"
        }
      }),
      _c("password-modal-component", {
        ref: "passwordModal",
        attrs: {
          func: _vm.unlockWallet,
          "action-name": "Sign Message",
          loading: _vm.loading,
          error: _vm.error
        },
        on: { passwordChange: _vm.updatePassword }
      })
    ],
    1
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "sign-message-header" }, [
      _c("p", [_vm._v("Confirmation")])
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/core-js/library/fn/get-iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/get-iterator.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
module.exports = __webpack_require__(/*! ../modules/core.get-iterator */ "./node_modules/core-js/library/modules/core.get-iterator.js");


/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/library/fn/reflect/get.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/fn/reflect/get.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.reflect.get */ "./node_modules/core-js/library/modules/es6.reflect.get.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Reflect.get;


/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var get = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.reflect.get.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.reflect.get.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),

/***/ "./node_modules/core-js/modules/_array-copy-within.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/_array-copy-within.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_array-fill.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/_array-fill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_to-index.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/_to-index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-array.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-array.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/modules/_export.js");
  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/core-js/modules/_typed-buffer.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/modules/_property-desc.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/modules/_to-absolute-index.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/modules/_has.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/modules/_classof.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/modules/_is-object.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/modules/_to-object.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/modules/_is-array-iter.js");
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/modules/_object-create.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/modules/_object-gpo.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/modules/core.get-iterator-method.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/modules/_wks.js");
  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/core-js/modules/_array-methods.js");
  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/modules/_array-includes.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/modules/_species-constructor.js");
  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/modules/es6.array.iterator.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/modules/_iterators.js");
  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/modules/_iter-detect.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/core-js/modules/_set-species.js");
  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/core-js/modules/_array-copy-within.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/modules/_object-gopd.js");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/modules/_typed-buffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/_typed-buffer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/modules/_descriptors.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/modules/_library.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/core-js/modules/_typed.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/modules/_redefine-all.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/modules/_fails.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/modules/_an-instance.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/modules/_to-length.js");
var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/core-js/modules/_to-index.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/modules/_object-gopn.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/modules/_object-dp.js").f;
var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/core-js/modules/_array-fill.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/modules/_set-to-string-tag.js");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/modules/_typed.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/_typed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/modules/_hide.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/modules/_uid.js");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "./node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".buttons-container[data-v-5012fca8] {\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-pack: distribute;\n      justify-content: space-around;\n  padding: 20px 0;\n}\n.buttons-container button[data-v-5012fca8] {\n    border: none;\n    border-radius: 5px;\n    color: #fff;\n    min-width: 120px;\n    padding: 10px;\n    text-align: center;\n}\n.buttons-container button.sign[data-v-5012fca8] {\n      background-color: #05c0a5;\n}\n.buttons-container button.sign[data-v-5012fca8]:disabled {\n        background-color: #999;\n}\n.buttons-container button.reject[data-v-5012fca8] {\n      background-color: #ff122f;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".header-container[data-v-19018dc8] {\n  -webkit-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  padding-bottom: 25px;\n}\n.header-container p[data-v-19018dc8] {\n    color: #334758;\n    font-size: 20px;\n    font-weight: bold;\n    margin: 0;\n}\n.header-container i[data-v-19018dc8] {\n    cursor: pointer;\n}\n.password-form[data-v-19018dc8] {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n.password-form .input-container[data-v-19018dc8] {\n    position: relative;\n    margin-bottom: 10px;\n}\n.password-form .input-container img[data-v-19018dc8] {\n      position: absolute;\n      top: 25px;\n      right: 10px;\n}\n.password-form .input-container input[data-v-19018dc8] {\n      background-color: #f9f9f9;\n      border-radius: 5px;\n      border: 0;\n      font-size: 14px;\n      padding: 20px;\n      width: 100%;\n}\n.password-form button[data-v-19018dc8] {\n    background-color: #05c0a5;\n    border-radius: 5px;\n    border: 0;\n    color: #fff;\n    margin: 0 auto;\n    padding: 20px 0;\n    text-align: center;\n    width: 100%;\n}\n.password-form button[data-v-19018dc8]:disabled {\n      background-color: #999;\n      cursor: auto;\n      pointer-events: none;\n}\n.password-form button img[data-v-19018dc8] {\n      margin-left: 5px;\n      width: 20px;\n}\n.terms[data-v-19018dc8] {\n  font-size: 15px;\n  padding-top: 20px;\n  text-align: center;\n}\n.terms a[data-v-19018dc8] {\n    color: #05c0a5;\n}\n.error-msg[data-v-19018dc8] {\n  color: #f00;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".sign-message-container[data-v-252e4c84] {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n  padding: 10px;\n}\n.sign-message-container .sign-message-header p[data-v-252e4c84] {\n    color: #334758;\n    font-size: 20px;\n    font-weight: bold;\n    margin: 0;\n}\n.sign-message-container .sign-message-address[data-v-252e4c84],\n  .sign-message-container .sign-message-content[data-v-252e4c84] {\n    padding-top: 35px;\n}\n.sign-message-container .sign-message-address p[data-v-252e4c84],\n    .sign-message-container .sign-message-content p[data-v-252e4c84] {\n      color: #334758;\n      font-weight: bold;\n      margin: 0;\n      padding: 10px;\n}\n.sign-message-container .sign-message-address .signing-address[data-v-252e4c84] {\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    background-color: #f2fafa;\n    border-radius: 5px;\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -ms-flex-pack: distribute;\n        justify-content: space-around;\n    padding: 15px 10px;\n}\n.sign-message-container .sign-message-address .signing-address p[data-v-252e4c84] {\n      color: #334758;\n      font-weight: normal;\n      padding: 0;\n}\n.sign-message-container .sign-message-content .message-container[data-v-252e4c84] {\n    background-color: #f2fafa;\n    border-radius: 5px;\n    min-height: 140px;\n    overflow-wrap: break-word;\n    padding: 15px 20px;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/semver/semver.js":
/*!***************************************!*\
  !*** ./node_modules/semver/semver.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    Object({"NODE_ENV":"development","BASE_URL":""}) &&
    Object({"NODE_ENV":"development","BASE_URL":""}).NODE_DEBUG &&
    /\bsemver\b/i.test(Object({"NODE_ENV":"development","BASE_URL":""}).NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/blockchain.js":
/*!*****************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/blockchain.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // blockchain events

exports.__esModule = true;
exports.NOTIFICATION = exports.BLOCK = exports.CONNECT = exports.ERROR = void 0;
var ERROR = 'blockchain-error';
exports.ERROR = ERROR;
var CONNECT = 'blockchain-connect';
exports.CONNECT = CONNECT;
var BLOCK = 'blockchain-block';
exports.BLOCK = BLOCK;
var NOTIFICATION = 'blockchain-notification';
exports.NOTIFICATION = NOTIFICATION;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/device.js":
/*!*************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/device.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // device list events

exports.__esModule = true;
exports.UNREADABLE = exports.WAIT_FOR_SELECTION = exports.WORD = exports.PASSPHRASE_ON_DEVICE = exports.PASSPHRASE = exports.PIN = exports.BUTTON = exports.LOADING = exports.USED_ELSEWHERE = exports.RELEASED = exports.ACQUIRED = exports.RELEASE = exports.ACQUIRE = exports.CHANGED = exports.DISCONNECT = exports.CONNECT_UNACQUIRED = exports.CONNECT = void 0;
var CONNECT = 'device-connect';
exports.CONNECT = CONNECT;
var CONNECT_UNACQUIRED = 'device-connect_unacquired';
exports.CONNECT_UNACQUIRED = CONNECT_UNACQUIRED;
var DISCONNECT = 'device-disconnect';
exports.DISCONNECT = DISCONNECT;
var CHANGED = 'device-changed';
exports.CHANGED = CHANGED;
var ACQUIRE = 'device-acquire';
exports.ACQUIRE = ACQUIRE;
var RELEASE = 'device-release';
exports.RELEASE = RELEASE;
var ACQUIRED = 'device-acquired';
exports.ACQUIRED = ACQUIRED;
var RELEASED = 'device-released';
exports.RELEASED = RELEASED;
var USED_ELSEWHERE = 'device-used_elsewhere';
exports.USED_ELSEWHERE = USED_ELSEWHERE;
var LOADING = 'device-loading'; // trezor-link events in protobuf format

exports.LOADING = LOADING;
var BUTTON = 'button';
exports.BUTTON = BUTTON;
var PIN = 'pin';
exports.PIN = PIN;
var PASSPHRASE = 'passphrase';
exports.PASSPHRASE = PASSPHRASE;
var PASSPHRASE_ON_DEVICE = 'passphrase_on_device';
exports.PASSPHRASE_ON_DEVICE = PASSPHRASE_ON_DEVICE;
var WORD = 'word'; // custom

exports.WORD = WORD;
var WAIT_FOR_SELECTION = 'device-wait_for_selection'; // this string has different prefix than other constants and it's used as device path

exports.WAIT_FOR_SELECTION = WAIT_FOR_SELECTION;
var UNREADABLE = 'unreadable-device';
exports.UNREADABLE = UNREADABLE;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/errors.js":
/*!*************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/errors.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.NO_COIN_INFO = exports.BACKEND_NO_URL = exports.WEBUSB_ERROR_MESSAGE = exports.INVALID_PIN_ERROR_MESSAGE = exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = exports.INVALID_STATE = exports.CALL_OVERRIDE = exports.INITIALIZATION_FAILED = exports.DEVICE_USED_ELSEWHERE = exports.PERMISSIONS_NOT_GRANTED = exports.POPUP_CLOSED = exports.INVALID_PARAMETERS = exports.DEVICE_CALL_IN_PROGRESS = exports.DEVICE_NOT_FOUND = exports.WRONG_TRANSPORT_CONFIG = exports.NO_TRANSPORT = exports.MANAGEMENT_NOT_ALLOWED = exports.MANIFEST_NOT_SET = exports.BROWSER_NOT_SUPPORTED = exports.POPUP_TIMEOUT = exports.IFRAME_TIMEOUT = exports.IFRAME_INITIALIZED = exports.IFRAME_BLOCKED = exports.NO_IFRAME = exports.invalidParameter = exports.TrezorError = void 0;

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js"));

var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ "./node_modules/@babel/runtime/helpers/wrapNativeSuper.js"));

var TrezorError =
/*#__PURE__*/
function (_Error) {
  (0, _inheritsLoose2["default"])(TrezorError, _Error);

  function TrezorError(code, message) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.code = code;
    _this.message = message;
    return _this;
  }

  return TrezorError;
}((0, _wrapNativeSuper2["default"])(Error));

exports.TrezorError = TrezorError;

var invalidParameter = function invalidParameter(message) {
  return new TrezorError('Connect_InvalidParameter', message);
}; // level 100 error during initialization


exports.invalidParameter = invalidParameter;
var NO_IFRAME = new TrezorError(100, 'TrezorConnect not yet initialized');
exports.NO_IFRAME = NO_IFRAME;
var IFRAME_BLOCKED = new TrezorError('iframe_blocked', 'TrezorConnect iframe was blocked');
exports.IFRAME_BLOCKED = IFRAME_BLOCKED;
var IFRAME_INITIALIZED = new TrezorError(101, 'TrezorConnect has been already initialized');
exports.IFRAME_INITIALIZED = IFRAME_INITIALIZED;
var IFRAME_TIMEOUT = new TrezorError(102, 'Iframe timeout');
exports.IFRAME_TIMEOUT = IFRAME_TIMEOUT;
var POPUP_TIMEOUT = new TrezorError(103, 'Popup timeout');
exports.POPUP_TIMEOUT = POPUP_TIMEOUT;
var BROWSER_NOT_SUPPORTED = new TrezorError(104, 'Browser not supported');
exports.BROWSER_NOT_SUPPORTED = BROWSER_NOT_SUPPORTED;
var MANIFEST_NOT_SET = new TrezorError(105, 'Manifest not set. Read more at https://github.com/trezor/connect/blob/develop/docs/index.md');
exports.MANIFEST_NOT_SET = MANIFEST_NOT_SET;
var MANAGEMENT_NOT_ALLOWED = new TrezorError(105, 'Management method not allowed for this configuration');
exports.MANAGEMENT_NOT_ALLOWED = MANAGEMENT_NOT_ALLOWED;
var NO_TRANSPORT = new TrezorError(500, 'Transport is missing');
exports.NO_TRANSPORT = NO_TRANSPORT;
var WRONG_TRANSPORT_CONFIG = new TrezorError(5002, 'Wrong config response'); // config_signed

exports.WRONG_TRANSPORT_CONFIG = WRONG_TRANSPORT_CONFIG;
var DEVICE_NOT_FOUND = new TrezorError(501, 'Device not found'); // export const DEVICE_CALL_IN_PROGRESS: TrezorError = new TrezorError(502, "Device call in progress.");

exports.DEVICE_NOT_FOUND = DEVICE_NOT_FOUND;
var DEVICE_CALL_IN_PROGRESS = new TrezorError(503, 'Device call in progress');
exports.DEVICE_CALL_IN_PROGRESS = DEVICE_CALL_IN_PROGRESS;
var INVALID_PARAMETERS = new TrezorError(504, 'Invalid parameters');
exports.INVALID_PARAMETERS = INVALID_PARAMETERS;
var POPUP_CLOSED = new Error('Popup closed');
exports.POPUP_CLOSED = POPUP_CLOSED;
var PERMISSIONS_NOT_GRANTED = new TrezorError(403, 'Permissions not granted');
exports.PERMISSIONS_NOT_GRANTED = PERMISSIONS_NOT_GRANTED;
var DEVICE_USED_ELSEWHERE = new TrezorError(700, 'Device is used in another window');
exports.DEVICE_USED_ELSEWHERE = DEVICE_USED_ELSEWHERE;
var INITIALIZATION_FAILED = new TrezorError('Failure_Initialize', 'Initialization failed');
exports.INITIALIZATION_FAILED = INITIALIZATION_FAILED;
var CALL_OVERRIDE = new TrezorError('Failure_ActionOverride', 'override');
exports.CALL_OVERRIDE = CALL_OVERRIDE;
var INVALID_STATE = new TrezorError('Failure_PassphraseState', 'Passphrase is incorrect'); // a slight hack
// this error string is hard-coded
// in both bridge and extension

exports.INVALID_STATE = INVALID_STATE;
var WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = 'wrong previous session';
exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = WRONG_PREVIOUS_SESSION_ERROR_MESSAGE;
var INVALID_PIN_ERROR_MESSAGE = 'PIN invalid';
exports.INVALID_PIN_ERROR_MESSAGE = INVALID_PIN_ERROR_MESSAGE;
var WEBUSB_ERROR_MESSAGE = 'NetworkError: Unable to claim interface.'; // BlockBook

exports.WEBUSB_ERROR_MESSAGE = WEBUSB_ERROR_MESSAGE;
var BACKEND_NO_URL = new TrezorError('Backend_init', 'Url not found');
exports.BACKEND_NO_URL = BACKEND_NO_URL;
var NO_COIN_INFO = invalidParameter('Coin not found.');
exports.NO_COIN_INFO = NO_COIN_INFO;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/iframe.js":
/*!*************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/iframe.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.RESPONSE = exports.CALL = exports.ERROR = exports.BOOTSTRAP = void 0;
var BOOTSTRAP = 'iframe-bootstrap';
exports.BOOTSTRAP = BOOTSTRAP;
var ERROR = 'iframe-error';
exports.ERROR = ERROR;
var CALL = 'iframe-call';
exports.CALL = CALL;
var RESPONSE = 'iframe-response';
exports.RESPONSE = RESPONSE;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/index.js":
/*!************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.BLOCKCHAIN_EVENT = exports.RESPONSE_EVENT = exports.TRANSPORT_EVENT = exports.DEVICE_EVENT = exports.UI_EVENT = exports.CORE_EVENT = void 0;
var CORE_EVENT = 'CORE_EVENT';
exports.CORE_EVENT = CORE_EVENT;
var UI_EVENT = 'UI_EVENT';
exports.UI_EVENT = UI_EVENT;
var DEVICE_EVENT = 'DEVICE_EVENT';
exports.DEVICE_EVENT = DEVICE_EVENT;
var TRANSPORT_EVENT = 'TRANSPORT_EVENT';
exports.TRANSPORT_EVENT = TRANSPORT_EVENT;
var RESPONSE_EVENT = 'RESPONSE_EVENT';
exports.RESPONSE_EVENT = RESPONSE_EVENT;
var BLOCKCHAIN_EVENT = 'BLOCKCHAIN_EVENT';
exports.BLOCKCHAIN_EVENT = BLOCKCHAIN_EVENT;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/popup.js":
/*!************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/popup.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.CLOSE_WINDOW = exports.CANCEL_POPUP_REQUEST = exports.CLOSED = exports.CLOSE = exports.HANDSHAKE = exports.OPEN_TIMEOUT = exports.OPENED = exports.LOG = exports.EXTENSION_USB_PERMISSIONS = exports.EXTENSION_REQUEST = exports.BOOTSTRAP = exports.INIT = void 0;
var INIT = 'popup-init';
exports.INIT = INIT;
var BOOTSTRAP = 'popup-bootstrap';
exports.BOOTSTRAP = BOOTSTRAP;
var EXTENSION_REQUEST = 'popup-extension_request';
exports.EXTENSION_REQUEST = EXTENSION_REQUEST;
var EXTENSION_USB_PERMISSIONS = 'open-usb-permissions';
exports.EXTENSION_USB_PERMISSIONS = EXTENSION_USB_PERMISSIONS;
var LOG = 'popup-log';
exports.LOG = LOG;
var OPENED = 'popup-opened';
exports.OPENED = OPENED;
var OPEN_TIMEOUT = 'popup-open_timeout';
exports.OPEN_TIMEOUT = OPEN_TIMEOUT;
var HANDSHAKE = 'popup-handshake';
exports.HANDSHAKE = HANDSHAKE;
var CLOSE = 'popup-close';
exports.CLOSE = CLOSE;
var CLOSED = 'popup-closed';
exports.CLOSED = CLOSED;
var CANCEL_POPUP_REQUEST = 'ui-cancel-popup-request';
exports.CANCEL_POPUP_REQUEST = CANCEL_POPUP_REQUEST;
var CLOSE_WINDOW = 'window.close';
exports.CLOSE_WINDOW = CLOSE_WINDOW;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/transport.js":
/*!****************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/transport.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.START_PENDING = exports.RECONNECT = exports.REQUEST = exports.STREAM = exports.UPDATE = exports.ERROR = exports.START = void 0;
var START = 'transport-start';
exports.START = START;
var ERROR = 'transport-error';
exports.ERROR = ERROR;
var UPDATE = 'transport-update';
exports.UPDATE = UPDATE;
var STREAM = 'transport-stream';
exports.STREAM = STREAM;
var REQUEST = 'transport-request_device';
exports.REQUEST = REQUEST;
var RECONNECT = 'transport-reconnect';
exports.RECONNECT = RECONNECT;
var START_PENDING = 'transport-start_pending';
exports.START_PENDING = START_PENDING;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/constants/ui.js":
/*!*********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/constants/ui.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ADDRESS_VALIDATION = exports.BUNDLE_PROGRESS = exports.LOGIN_CHALLENGE_RESPONSE = exports.LOGIN_CHALLENGE_REQUEST = exports.CUSTOM_MESSAGE_RESPONSE = exports.CUSTOM_MESSAGE_REQUEST = exports.CHANGE_SETTINGS = exports.RECEIVE_WORD = exports.RECEIVE_FEE = exports.RECEIVE_ACCOUNT = exports.CHANGE_ACCOUNT = exports.RECEIVE_DEVICE = exports.RECEIVE_PASSPHRASE = exports.RECEIVE_PIN = exports.RECEIVE_CONFIRMATION = exports.RECEIVE_PERMISSION = exports.REQUEST_WORD = exports.REQUEST_BUTTON = exports.INSUFFICIENT_FUNDS = exports.UPDATE_CUSTOM_FEE = exports.SELECT_FEE = exports.SELECT_ACCOUNT = exports.SELECT_DEVICE = exports.SET_OPERATION = exports.LOADING = exports.CONNECT = exports.INVALID_PASSPHRASE_ACTION = exports.INVALID_PASSPHRASE = exports.REQUEST_PASSPHRASE_ON_DEVICE = exports.REQUEST_PASSPHRASE = exports.INVALID_PIN = exports.REQUEST_PIN = exports.REQUEST_CONFIRMATION = exports.REQUEST_PERMISSION = exports.CLOSE_UI_WINDOW = exports.REQUEST_UI_WINDOW = exports.RECEIVE_BROWSER = exports.BROWSER_OUTDATED = exports.BROWSER_NOT_SUPPORTED = exports.DEVICE_NEEDS_BACKUP = exports.FIRMWARE_NOT_INSTALLED = exports.FIRMWARE_NOT_COMPATIBLE = exports.FIRMWARE_NOT_SUPPORTED = exports.FIRMWARE_OUTDATED = exports.FIRMWARE_OLD = exports.SEEDLESS = exports.INITIALIZE = exports.REQUIRE_MODE = exports.NOT_IN_BOOTLOADER = exports.BOOTLOADER = exports.TRANSPORT = exports.IFRAME_HANDSHAKE = void 0;
var IFRAME_HANDSHAKE = 'iframe-handshake';
exports.IFRAME_HANDSHAKE = IFRAME_HANDSHAKE;
var TRANSPORT = 'ui-no_transport';
exports.TRANSPORT = TRANSPORT;
var BOOTLOADER = 'ui-device_bootloader_mode';
exports.BOOTLOADER = BOOTLOADER;
var NOT_IN_BOOTLOADER = 'ui-device_not_in_bootloader_mode';
exports.NOT_IN_BOOTLOADER = NOT_IN_BOOTLOADER;
var REQUIRE_MODE = 'ui-device_require_mode';
exports.REQUIRE_MODE = REQUIRE_MODE;
var INITIALIZE = 'ui-device_not_initialized';
exports.INITIALIZE = INITIALIZE;
var SEEDLESS = 'ui-device_seedless';
exports.SEEDLESS = SEEDLESS;
var FIRMWARE_OLD = 'ui-device_firmware_old';
exports.FIRMWARE_OLD = FIRMWARE_OLD;
var FIRMWARE_OUTDATED = 'ui-device_firmware_outdated';
exports.FIRMWARE_OUTDATED = FIRMWARE_OUTDATED;
var FIRMWARE_NOT_SUPPORTED = 'ui-device_firmware_unsupported';
exports.FIRMWARE_NOT_SUPPORTED = FIRMWARE_NOT_SUPPORTED;
var FIRMWARE_NOT_COMPATIBLE = 'ui-device_firmware_not_compatible';
exports.FIRMWARE_NOT_COMPATIBLE = FIRMWARE_NOT_COMPATIBLE;
var FIRMWARE_NOT_INSTALLED = 'ui-device_firmware_not_installed';
exports.FIRMWARE_NOT_INSTALLED = FIRMWARE_NOT_INSTALLED;
var DEVICE_NEEDS_BACKUP = 'ui-device_needs_backup';
exports.DEVICE_NEEDS_BACKUP = DEVICE_NEEDS_BACKUP;
var BROWSER_NOT_SUPPORTED = 'ui-browser_not_supported';
exports.BROWSER_NOT_SUPPORTED = BROWSER_NOT_SUPPORTED;
var BROWSER_OUTDATED = 'ui-browser_outdated';
exports.BROWSER_OUTDATED = BROWSER_OUTDATED;
var RECEIVE_BROWSER = 'ui-receive_browser';
exports.RECEIVE_BROWSER = RECEIVE_BROWSER;
var REQUEST_UI_WINDOW = 'ui-request_window';
exports.REQUEST_UI_WINDOW = REQUEST_UI_WINDOW;
var CLOSE_UI_WINDOW = 'ui-close_window';
exports.CLOSE_UI_WINDOW = CLOSE_UI_WINDOW;
var REQUEST_PERMISSION = 'ui-request_permission';
exports.REQUEST_PERMISSION = REQUEST_PERMISSION;
var REQUEST_CONFIRMATION = 'ui-request_confirmation';
exports.REQUEST_CONFIRMATION = REQUEST_CONFIRMATION;
var REQUEST_PIN = 'ui-request_pin';
exports.REQUEST_PIN = REQUEST_PIN;
var INVALID_PIN = 'ui-invalid_pin';
exports.INVALID_PIN = INVALID_PIN;
var REQUEST_PASSPHRASE = 'ui-request_passphrase';
exports.REQUEST_PASSPHRASE = REQUEST_PASSPHRASE;
var REQUEST_PASSPHRASE_ON_DEVICE = 'ui-request_passphrase_on_device';
exports.REQUEST_PASSPHRASE_ON_DEVICE = REQUEST_PASSPHRASE_ON_DEVICE;
var INVALID_PASSPHRASE = 'ui-invalid_passphrase';
exports.INVALID_PASSPHRASE = INVALID_PASSPHRASE;
var INVALID_PASSPHRASE_ACTION = 'ui-invalid_passphrase_action';
exports.INVALID_PASSPHRASE_ACTION = INVALID_PASSPHRASE_ACTION;
var CONNECT = 'ui-connect';
exports.CONNECT = CONNECT;
var LOADING = 'ui-loading';
exports.LOADING = LOADING;
var SET_OPERATION = 'ui-set_operation';
exports.SET_OPERATION = SET_OPERATION;
var SELECT_DEVICE = 'ui-select_device';
exports.SELECT_DEVICE = SELECT_DEVICE;
var SELECT_ACCOUNT = 'ui-select_account';
exports.SELECT_ACCOUNT = SELECT_ACCOUNT;
var SELECT_FEE = 'ui-select_fee';
exports.SELECT_FEE = SELECT_FEE;
var UPDATE_CUSTOM_FEE = 'ui-update_custom_fee';
exports.UPDATE_CUSTOM_FEE = UPDATE_CUSTOM_FEE;
var INSUFFICIENT_FUNDS = 'ui-insufficient_funds';
exports.INSUFFICIENT_FUNDS = INSUFFICIENT_FUNDS;
var REQUEST_BUTTON = 'ui-button';
exports.REQUEST_BUTTON = REQUEST_BUTTON;
var REQUEST_WORD = 'ui-request_word';
exports.REQUEST_WORD = REQUEST_WORD;
var RECEIVE_PERMISSION = 'ui-receive_permission';
exports.RECEIVE_PERMISSION = RECEIVE_PERMISSION;
var RECEIVE_CONFIRMATION = 'ui-receive_confirmation';
exports.RECEIVE_CONFIRMATION = RECEIVE_CONFIRMATION;
var RECEIVE_PIN = 'ui-receive_pin';
exports.RECEIVE_PIN = RECEIVE_PIN;
var RECEIVE_PASSPHRASE = 'ui-receive_passphrase';
exports.RECEIVE_PASSPHRASE = RECEIVE_PASSPHRASE;
var RECEIVE_DEVICE = 'ui-receive_device';
exports.RECEIVE_DEVICE = RECEIVE_DEVICE;
var CHANGE_ACCOUNT = 'ui-change_account';
exports.CHANGE_ACCOUNT = CHANGE_ACCOUNT;
var RECEIVE_ACCOUNT = 'ui-receive_account';
exports.RECEIVE_ACCOUNT = RECEIVE_ACCOUNT;
var RECEIVE_FEE = 'ui-receive_fee';
exports.RECEIVE_FEE = RECEIVE_FEE;
var RECEIVE_WORD = 'ui-receive_word';
exports.RECEIVE_WORD = RECEIVE_WORD;
var CHANGE_SETTINGS = 'ui-change_settings';
exports.CHANGE_SETTINGS = CHANGE_SETTINGS;
var CUSTOM_MESSAGE_REQUEST = 'ui-custom_request';
exports.CUSTOM_MESSAGE_REQUEST = CUSTOM_MESSAGE_REQUEST;
var CUSTOM_MESSAGE_RESPONSE = 'ui-custom_response';
exports.CUSTOM_MESSAGE_RESPONSE = CUSTOM_MESSAGE_RESPONSE;
var LOGIN_CHALLENGE_REQUEST = 'ui-login_challenge_request';
exports.LOGIN_CHALLENGE_REQUEST = LOGIN_CHALLENGE_REQUEST;
var LOGIN_CHALLENGE_RESPONSE = 'ui-login_challenge_response';
exports.LOGIN_CHALLENGE_RESPONSE = LOGIN_CHALLENGE_RESPONSE;
var BUNDLE_PROGRESS = 'ui-bundle_progress';
exports.BUNDLE_PROGRESS = BUNDLE_PROGRESS;
var ADDRESS_VALIDATION = 'ui-address_validation';
exports.ADDRESS_VALIDATION = ADDRESS_VALIDATION;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/data/ConnectSettings.js":
/*!*****************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/data/ConnectSettings.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.parse = exports.DEFAULT_PRIORITY = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/*
 * Initial settings for connect.
 * It could be changed by passing values into TrezorConnect.init(...) method
 */
var VERSION = '7.0.5';
var versionN = VERSION.split('.').map(function (s) {
  return parseInt(s);
});
var DIRECTORY = "" + versionN[0] + (versionN[1] > 0 ? "." + versionN[1] : '') + "/";
var DEFAULT_DOMAIN = "https://connect.trezor.io/" + DIRECTORY;
var DEFAULT_PRIORITY = 2;
exports.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
var initialSettings = {
  configSrc: 'data/config.json',
  // constant
  version: VERSION,
  // constant
  debug: false,
  origin: null,
  priority: DEFAULT_PRIORITY,
  trustedHost: false,
  connectSrc: DEFAULT_DOMAIN,
  iframeSrc: DEFAULT_DOMAIN + "iframe.html",
  popup: true,
  popupSrc: DEFAULT_DOMAIN + "popup.html",
  webusbSrc: DEFAULT_DOMAIN + "webusb.html",
  transportReconnect: false,
  webusb: true,
  pendingTransportEvent: true,
  supportedBrowser: typeof navigator !== 'undefined' ? !/Trident|MSIE/.test(navigator.userAgent) : true,
  extension: null,
  manifest: null
};
var currentSettings = initialSettings;

var parseManifest = function parseManifest(manifest) {
  if (typeof manifest.email !== 'string') {
    return null;
  }

  if (typeof manifest.appUrl !== 'string') {
    return null;
  }

  return {
    email: manifest.email,
    appUrl: manifest.appUrl
  };
};

var parse = function parse(input) {
  if (!input) return currentSettings;

  var settings = _objectSpread({}, currentSettings);

  if (input.hasOwnProperty('debug')) {
    if (Array.isArray(input)) {// enable log with prefix
    }

    if (typeof input.debug === 'boolean') {
      settings.debug = input.debug;
    } else if (typeof input.debug === 'string') {
      settings.debug = input.debug === 'true';
    }
  }

  if (typeof input.connectSrc === 'string') {
    // TODO: escape string, validate url
    settings.connectSrc = input.connectSrc;
  } else if (typeof window !== 'undefined' && typeof window.__TREZOR_CONNECT_SRC === 'string') {
    settings.connectSrc = window.__TREZOR_CONNECT_SRC;
  }

  settings.iframeSrc = settings.connectSrc + "iframe.html";
  settings.popupSrc = settings.connectSrc + "popup.html";
  settings.webusbSrc = settings.connectSrc + "webusb.html";

  if (typeof input.transportReconnect === 'boolean') {
    settings.transportReconnect = input.transportReconnect;
  }

  if (typeof input.webusb === 'boolean') {
    settings.webusb = input.webusb;
  }

  if (typeof input.popup === 'boolean') {
    settings.popup = input.popup;
  }

  if (typeof input.pendingTransportEvent === 'boolean') {
    settings.pendingTransportEvent = input.pendingTransportEvent;
  } // local files


  if (typeof window !== 'undefined' && window.location.protocol === 'file:') {
    settings.origin = "file://" + window.location.pathname;
    settings.webusb = false;
  }

  if (typeof input.extension === 'string') {
    settings.extension = input.extension;
  }

  if (typeof input.manifest === 'object') {
    settings.manifest = parseManifest(input.manifest);
  }

  currentSettings = settings;
  return currentSettings;
};

exports.parse = parse;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/iframe/builder.js":
/*!***********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/iframe/builder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _deferred = __webpack_require__(/*! ../utils/deferred */ "./node_modules/trezor-connect/lib/utils/deferred.js");

var _ui = __webpack_require__(/*! ../constants/ui */ "./node_modules/trezor-connect/lib/constants/ui.js");

var _errors = __webpack_require__(/*! ../constants/errors */ "./node_modules/trezor-connect/lib/constants/errors.js");

var _inlineStyles = _interopRequireDefault(__webpack_require__(/*! ./inline-styles */ "./node_modules/trezor-connect/lib/iframe/inline-styles.js"));

var instance;
exports.instance = instance;
var origin;
exports.origin = origin;
var initPromise = (0, _deferred.create)();
exports.initPromise = initPromise;
var timeout = 0;
exports.timeout = timeout;
var error;
exports.error = error;
var _messageID = 0; // every postMessage to iframe has its own promise to resolve

var messagePromises = {};
exports.messagePromises = messagePromises;

var init =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(settings) {
    var existedFrame, manifestString, manifest, src, iframeSrcHost, onLoad;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            existedFrame = document.getElementById('trezorconnect');

            if (existedFrame) {
              exports.instance = instance = existedFrame;
            } else {
              exports.instance = instance = document.createElement('iframe');
              instance.frameBorder = '0';
              instance.width = '0px';
              instance.height = '0px';
              instance.style.position = 'absolute';
              instance.style.display = 'none';
              instance.style.border = '0px';
              instance.style.width = '0px';
              instance.style.height = '0px';
              instance.id = 'trezorconnect';
            }

            manifestString = settings.manifest ? JSON.stringify(settings.manifest) : 'undefined'; // note: btoa(undefined) === btoa('undefined') === "dW5kZWZpbmVk"

            manifest = "&version=" + settings.version + "&manifest=" + encodeURIComponent(btoa(JSON.stringify(manifestString)));
            src = settings.iframeSrc + "?" + Date.now() + manifest;
            instance.setAttribute('src', src);

            if (settings.webusb) {
              instance.setAttribute('allow', 'usb');
            } // eslint-disable-next-line no-irregular-whitespace, no-useless-escape


            iframeSrcHost = instance.src.match(/^.+\:\/\/[^\/]+/);

            if (iframeSrcHost && iframeSrcHost.length > 0) {
              exports.origin = origin = iframeSrcHost[0];
            }

            exports.timeout = timeout = window.setTimeout(function () {
              initPromise.reject(_errors.IFRAME_TIMEOUT);
            }, 10000);

            onLoad = function onLoad() {
              if (!instance) {
                initPromise.reject(_errors.IFRAME_BLOCKED);
                return;
              }

              try {
                // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                var iframeOrigin = instance.contentWindow.location.origin;

                if (!iframeOrigin || iframeOrigin === 'null') {
                  // eslint-disable-next-line no-use-before-define
                  handleIframeBlocked();
                  return;
                }
              } catch (e) {// empty
              }

              var extension; // $FlowIssue chrome is not declared outside

              if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                chrome.runtime.onConnect.addListener(function () {});
                extension = chrome.runtime.id;
              }

              instance.contentWindow.postMessage({
                type: _ui.IFRAME_HANDSHAKE,
                payload: {
                  settings: settings,
                  extension: extension
                }
              }, origin);
              instance.onload = undefined;
            }; // IE hack


            if (instance.attachEvent) {
              instance.attachEvent('onload', onLoad);
            } else {
              instance.onload = onLoad;
            } // inject iframe into host document body


            if (document.body) {
              document.body.appendChild(instance); // eslint-disable-next-line no-use-before-define

              injectStyleSheet();
            }

            _context.prev = 13;
            _context.next = 16;
            return initPromise.promise;

          case 16:
            _context.next = 21;
            break;

          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](13);
            throw _context.t0.message || _context.t0;

          case 21:
            _context.prev = 21;
            window.clearTimeout(timeout);
            exports.timeout = timeout = 0;
            return _context.finish(21);

          case 25:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[13, 18, 21, 25]]);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.init = init;

var injectStyleSheet = function injectStyleSheet() {
  if (!instance) {
    throw _errors.IFRAME_BLOCKED;
  }

  var doc = instance.ownerDocument;
  var head = doc.head || doc.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.setAttribute('type', 'text/css');
  style.setAttribute('id', 'TrezorConnectStylesheet'); // $FlowIssue

  if (style.styleSheet) {
    // IE
    // $FlowIssue
    style.styleSheet.cssText = _inlineStyles["default"];
  } else {
    style.appendChild(document.createTextNode(_inlineStyles["default"]));
  }

  head.append(style);
};

var handleIframeBlocked = function handleIframeBlocked() {
  window.clearTimeout(timeout);
  exports.error = error = _errors.IFRAME_BLOCKED.message; // eslint-disable-next-line no-use-before-define

  dispose();
  initPromise.reject(_errors.IFRAME_BLOCKED);
}; // post messages to iframe


var postMessage = function postMessage(message, usePromise) {
  if (usePromise === void 0) {
    usePromise = true;
  }

  if (!instance) {
    throw _errors.IFRAME_BLOCKED;
  }

  if (usePromise) {
    _messageID++;
    message.id = _messageID;
    messagePromises[_messageID] = (0, _deferred.create)();
    instance.contentWindow.postMessage(message, origin);
    return messagePromises[_messageID].promise;
  }

  instance.contentWindow.postMessage(message, origin);
  return null;
};

exports.postMessage = postMessage;

var dispose = function dispose() {
  if (instance && instance.parentNode) {
    try {
      instance.parentNode.removeChild(instance);
    } catch (error) {// do nothing
    }
  }

  exports.instance = instance = null;
  exports.timeout = timeout = 0;
};

exports.dispose = dispose;

var clearTimeout = function clearTimeout() {
  window.clearTimeout(timeout);
};

exports.clearTimeout = clearTimeout;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/iframe/inline-styles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/iframe/inline-styles.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;
var css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
var _default = css;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/trezor-connect/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
var _exportNames = {
  UI_EVENT: true,
  DEVICE_EVENT: true,
  RESPONSE_EVENT: true,
  TRANSPORT_EVENT: true,
  BLOCKCHAIN_EVENT: true,
  TRANSPORT: true,
  UI: true,
  DEVICE: true,
  BLOCKCHAIN: true
};
exports.BLOCKCHAIN = exports.DEVICE = exports.UI = exports.TRANSPORT = exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _events = _interopRequireDefault(__webpack_require__(/*! events */ "./node_modules/events/events.js"));

var _constants = __webpack_require__(/*! ./constants */ "./node_modules/trezor-connect/lib/constants/index.js");

exports.UI_EVENT = _constants.UI_EVENT;
exports.DEVICE_EVENT = _constants.DEVICE_EVENT;
exports.RESPONSE_EVENT = _constants.RESPONSE_EVENT;
exports.TRANSPORT_EVENT = _constants.TRANSPORT_EVENT;
exports.BLOCKCHAIN_EVENT = _constants.BLOCKCHAIN_EVENT;

var TRANSPORT = _interopRequireWildcard(__webpack_require__(/*! ./constants/transport */ "./node_modules/trezor-connect/lib/constants/transport.js"));

exports.TRANSPORT = TRANSPORT;

var POPUP = _interopRequireWildcard(__webpack_require__(/*! ./constants/popup */ "./node_modules/trezor-connect/lib/constants/popup.js"));

var IFRAME = _interopRequireWildcard(__webpack_require__(/*! ./constants/iframe */ "./node_modules/trezor-connect/lib/constants/iframe.js"));

var UI = _interopRequireWildcard(__webpack_require__(/*! ./constants/ui */ "./node_modules/trezor-connect/lib/constants/ui.js"));

exports.UI = UI;

var DEVICE = _interopRequireWildcard(__webpack_require__(/*! ./constants/device */ "./node_modules/trezor-connect/lib/constants/device.js"));

exports.DEVICE = DEVICE;

var BLOCKCHAIN = _interopRequireWildcard(__webpack_require__(/*! ./constants/blockchain */ "./node_modules/trezor-connect/lib/constants/blockchain.js"));

exports.BLOCKCHAIN = BLOCKCHAIN;

var ERROR = _interopRequireWildcard(__webpack_require__(/*! ./constants/errors */ "./node_modules/trezor-connect/lib/constants/errors.js"));

var _PopupManager = _interopRequireDefault(__webpack_require__(/*! ./popup/PopupManager */ "./node_modules/trezor-connect/lib/popup/PopupManager.js"));

var iframe = _interopRequireWildcard(__webpack_require__(/*! ./iframe/builder */ "./node_modules/trezor-connect/lib/iframe/builder.js"));

var _button = _interopRequireDefault(__webpack_require__(/*! ./webusb/button */ "./node_modules/trezor-connect/lib/webusb/button.js"));

var _debug = _interopRequireWildcard(__webpack_require__(/*! ./utils/debug */ "./node_modules/trezor-connect/lib/utils/debug.js"));

var _message = __webpack_require__(/*! ./message */ "./node_modules/trezor-connect/lib/message/index.js");

var _ConnectSettings = __webpack_require__(/*! ./data/ConnectSettings */ "./node_modules/trezor-connect/lib/data/ConnectSettings.js");

var $T = _interopRequireWildcard(__webpack_require__(/*! ./types */ "./node_modules/trezor-connect/lib/types/index.js"));

var _blockchainEvent = __webpack_require__(/*! ./types/blockchainEvent */ "./node_modules/trezor-connect/lib/types/blockchainEvent.js");

Object.keys(_blockchainEvent).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _blockchainEvent[key];
});

var _account = __webpack_require__(/*! ./types/account */ "./node_modules/trezor-connect/lib/types/account.js");

Object.keys(_account).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _account[key];
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var eventEmitter = new _events["default"]();

var _log = (0, _debug.init)('[trezor-connect.js]');

var _settings;

var _popupManager;

var initPopupManager = function initPopupManager() {
  var pm = new _PopupManager["default"](_settings);
  pm.on(POPUP.CLOSED, function () {
    iframe.postMessage({
      type: POPUP.CLOSED
    }, false);
  });
  return pm;
}; // handle message received from iframe


var handleMessage = function handleMessage(messageEvent) {
  // ignore messages from domain other then iframe origin
  if (messageEvent.origin !== iframe.origin) return;
  var message = (0, _message.parseMessage)(messageEvent.data); // TODO: destructuring with type
  // https://github.com/Microsoft/TypeScript/issues/240
  // const { id, event, type, data, error }: CoreMessage = message;

  var id = message.id || 0;
  var event = message.event;
  var type = message.type;
  var payload = message.payload;

  _log.log('handleMessage', message);

  switch (event) {
    case _constants.RESPONSE_EVENT:
      if (iframe.messagePromises[id]) {
        // clear unnecessary fields from message object
        delete message.type;
        delete message.event; // delete message.id;
        // message.__id = id;
        // resolve message promise (send result of call method)

        iframe.messagePromises[id].resolve(message);
        delete iframe.messagePromises[id];
      } else {
        _log.warn("Unknown message id " + id);
      }

      break;

    case _constants.DEVICE_EVENT:
      // pass DEVICE event up to html
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload); // DEVICE_EVENT also emit single events (connect/disconnect...)

      break;

    case _constants.TRANSPORT_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.BLOCKCHAIN_EVENT:
      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);
      break;

    case _constants.UI_EVENT:
      if (type === IFRAME.BOOTSTRAP) {
        iframe.clearTimeout();
        break;
      } else if (type === POPUP.BOOTSTRAP) {
        // Popup did open but is still loading JS
        _popupManager.cancelOpenTimeout();

        break;
      } // pass UI event up


      eventEmitter.emit(event, message);
      eventEmitter.emit(type, payload);

      if (type === UI.IFRAME_HANDSHAKE) {
        if (payload.error) {
          iframe.initPromise.reject(new Error(payload.error));
        } else {
          _popupManager.setBroadcast(payload.broadcast);

          iframe.initPromise.resolve();
        }
      } else if (type === POPUP.CANCEL_POPUP_REQUEST) {
        _popupManager.cancel();
      } else if (type === UI.CLOSE_UI_WINDOW) {
        _popupManager.close();
      }

      break;

    default:
      _log.log('Undefined message', event, messageEvent);

  }
};

var init =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(settings) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (settings === void 0) {
              settings = {};
            }

            if (!iframe.instance) {
              _context.next = 3;
              break;
            }

            throw ERROR.IFRAME_INITIALIZED;

          case 3:
            if (!_settings) {
              _settings = (0, _ConnectSettings.parse)(settings);
            }

            if (_settings.manifest) {
              _context.next = 6;
              break;
            }

            throw ERROR.MANIFEST_NOT_SET;

          case 6:
            if (_settings.supportedBrowser) {
              _context.next = 8;
              break;
            }

            throw ERROR.BROWSER_NOT_SUPPORTED;

          case 8:
            if (!_popupManager) {
              _popupManager = initPopupManager();
            }

            _log.enabled = _settings.debug;
            window.addEventListener('message', handleMessage);
            window.addEventListener('beforeunload', function () {
              if (_popupManager) {
                _popupManager.onBeforeUnload();
              }

              iframe.dispose();
            });
            _context.next = 14;
            return iframe.init(_settings);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init(_x) {
    return _ref.apply(this, arguments);
  };
}();

var call =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(params) {
    var response;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(!iframe.instance && !iframe.timeout)) {
              _context2.next = 19;
              break;
            }

            // init popup with lazy loading before iframe initialization
            _settings = (0, _ConnectSettings.parse)(_settings);

            if (_settings.manifest) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: ERROR.MANIFEST_NOT_SET.message
              }
            });

          case 4:
            if (_settings.supportedBrowser) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: ERROR.BROWSER_NOT_SUPPORTED.message
              }
            });

          case 6:
            _popupManager = initPopupManager();

            _popupManager.request(true); // auto init with default settings


            _context2.prev = 8;
            _context2.next = 11;
            return init(_settings);

          case 11:
            _context2.next = 13;
            return _popupManager.resolveLazyLoad();

          case 13:
            _context2.next = 19;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](8);

            _popupManager.close();

            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: _context2.t0
              }
            });

          case 19:
            if (!iframe.timeout) {
              _context2.next = 23;
              break;
            }

            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: ERROR.NO_IFRAME.message
              }
            });

          case 23:
            if (!iframe.error) {
              _context2.next = 25;
              break;
            }

            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: iframe.error
              }
            });

          case 25:
            // request popup window it might be used in the future
            // if (eventEmitter.listeners(UI_EVENT).length < 1) { _popupManager.request(params); }
            if (_settings.popup) {
              _popupManager.request();
            } // post message to iframe


            _context2.prev = 26;
            _context2.next = 29;
            return iframe.postMessage({
              type: IFRAME.CALL,
              payload: params
            });

          case 29:
            response = _context2.sent;

            if (!response) {
              _context2.next = 35;
              break;
            }

            // TODO: unlock popupManager request only if there wasn't error "in progress"
            if (response.payload.error !== ERROR.DEVICE_CALL_IN_PROGRESS.message) {
              _popupManager.unlock();
            }

            return _context2.abrupt("return", response);

          case 35:
            _popupManager.unlock(); // TODO


            return _context2.abrupt("return", {
              success: false,
              payload: {
                error: 'No response from iframe'
              }
            });

          case 37:
            _context2.next = 43;
            break;

          case 39:
            _context2.prev = 39;
            _context2.t1 = _context2["catch"](26);

            _log.error('__call error', _context2.t1);

            return _context2.abrupt("return", _context2.t1);

          case 43:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 15], [26, 39]]);
  }));

  return function call(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

var customMessageResponse = function customMessageResponse(payload) {
  iframe.postMessage({
    event: _constants.UI_EVENT,
    type: UI.CUSTOM_MESSAGE_RESPONSE,
    payload: payload
  });
};

var TrezorConnect = function TrezorConnect() {};

(0, _defineProperty2["default"])(TrezorConnect, "manifest", function (data) {
  _settings = (0, _ConnectSettings.parse)({
    manifest: data
  });
});
(0, _defineProperty2["default"])(TrezorConnect, "getSettings",
/*#__PURE__*/
(0, _asyncToGenerator2["default"])(
/*#__PURE__*/
_regenerator["default"].mark(function _callee3() {
  return _regenerator["default"].wrap(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (iframe.instance) {
            _context3.next = 2;
            break;
          }

          return _context3.abrupt("return", {
            success: false,
            payload: {
              error: 'Iframe not initialized yet, you need to call TrezorConnect.init or any other method first.'
            }
          });

        case 2:
          _context3.next = 4;
          return call({
            method: 'getSettings'
          });

        case 4:
          return _context3.abrupt("return", _context3.sent);

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  }, _callee3);
})));
(0, _defineProperty2["default"])(TrezorConnect, "init",
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee4(settings) {
    return _regenerator["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return init(settings);

          case 2:
            return _context4.abrupt("return", _context4.sent);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x3) {
    return _ref4.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "on", function (type, fn) {
  eventEmitter.on(type, fn);
});
(0, _defineProperty2["default"])(TrezorConnect, "off", function (type, fn) {
  eventEmitter.removeListener(type, fn);
});
(0, _defineProperty2["default"])(TrezorConnect, "uiResponse", function (response) {
  iframe.postMessage(_objectSpread({
    event: _constants.UI_EVENT
  }, response));
});
(0, _defineProperty2["default"])(TrezorConnect, "changeSettings", function (settings) {
  var parsedSettings = (0, _ConnectSettings.parse)(settings);
  _log.enabled = parsedSettings.debug;
  iframe.postMessage({
    type: UI.CHANGE_SETTINGS,
    payload: parsedSettings
  }, false);
});
(0, _defineProperty2["default"])(TrezorConnect, "blockchainDisconnect",
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee5(params) {
    return _regenerator["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return call(_objectSpread({
              method: 'blockchainDisconnect'
            }, params));

          case 2:
            return _context5.abrupt("return", _context5.sent);

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function (_x4) {
    return _ref5.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "blockchainEstimateFee",
/*#__PURE__*/
function () {
  var _ref6 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee6(params) {
    return _regenerator["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return call(_objectSpread({
              method: 'blockchainEstimateFee'
            }, params));

          case 2:
            return _context6.abrupt("return", _context6.sent);

          case 3:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function (_x5) {
    return _ref6.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "blockchainSubscribe",
/*#__PURE__*/
function () {
  var _ref7 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee7(params) {
    return _regenerator["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return call(_objectSpread({
              method: 'blockchainSubscribe'
            }, params));

          case 2:
            return _context7.abrupt("return", _context7.sent);

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function (_x6) {
    return _ref7.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "blockchainUnsubscribe",
/*#__PURE__*/
function () {
  var _ref8 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee8(params) {
    return _regenerator["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return call(_objectSpread({
              method: 'blockchainUnsubscribe'
            }, params));

          case 2:
            return _context8.abrupt("return", _context8.sent);

          case 3:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x7) {
    return _ref8.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "customMessage",
/*#__PURE__*/
function () {
  var _ref9 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee10(params) {
    var callback, customMessageListener, response;
    return _regenerator["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (!(typeof params.callback !== 'function')) {
              _context10.next = 2;
              break;
            }

            return _context10.abrupt("return", {
              success: false,
              payload: {
                error: 'Parameter "callback" is not a function'
              }
            });

          case 2:
            // TODO: set message listener only if iframe is loaded correctly
            callback = params.callback;
            delete params.callback;

            customMessageListener =
            /*#__PURE__*/
            function () {
              var _ref10 = (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              _regenerator["default"].mark(function _callee9(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee9$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === UI.CUSTOM_MESSAGE_REQUEST)) {
                          _context9.next = 6;
                          break;
                        }

                        _context9.next = 4;
                        return callback(data.payload);

                      case 4:
                        payload = _context9.sent;

                        if (payload) {
                          customMessageResponse(payload);
                        } else {
                          customMessageResponse({
                            message: 'release'
                          });
                        }

                      case 6:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee9);
              }));

              return function customMessageListener(_x9) {
                return _ref10.apply(this, arguments);
              };
            }();

            window.addEventListener('message', customMessageListener, false);
            _context10.next = 8;
            return call(_objectSpread({
              method: 'customMessage'
            }, params));

          case 8:
            response = _context10.sent;
            window.removeEventListener('message', customMessageListener);
            return _context10.abrupt("return", response);

          case 11:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function (_x8) {
    return _ref9.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "requestLogin",
/*#__PURE__*/
function () {
  var _ref11 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee12(params) {
    var callback, loginChallengeListener, response;
    return _regenerator["default"].wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            if (!(typeof params.callback === 'function')) {
              _context12.next = 12;
              break;
            }

            callback = params.callback;
            delete params.callback; // delete callback value. this field cannot be sent using postMessage function
            // TODO: set message listener only if iframe is loaded correctly

            loginChallengeListener =
            /*#__PURE__*/
            function () {
              var _ref12 = (0, _asyncToGenerator2["default"])(
              /*#__PURE__*/
              _regenerator["default"].mark(function _callee11(event) {
                var data, payload;
                return _regenerator["default"].wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        data = event.data;

                        if (!(data && data.type === UI.LOGIN_CHALLENGE_REQUEST)) {
                          _context11.next = 13;
                          break;
                        }

                        _context11.prev = 2;
                        _context11.next = 5;
                        return callback();

                      case 5:
                        payload = _context11.sent;
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: payload
                        });
                        _context11.next = 13;
                        break;

                      case 9:
                        _context11.prev = 9;
                        _context11.t0 = _context11["catch"](2);
                        console.warn('TrezorConnect.requestLogin: callback error', _context11.t0);
                        iframe.postMessage({
                          event: _constants.UI_EVENT,
                          type: UI.LOGIN_CHALLENGE_RESPONSE,
                          payload: _context11.t0.message
                        });

                      case 13:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11, null, [[2, 9]]);
              }));

              return function loginChallengeListener(_x11) {
                return _ref12.apply(this, arguments);
              };
            }();

            window.addEventListener('message', loginChallengeListener, false);
            _context12.next = 7;
            return call(_objectSpread({
              method: 'requestLogin'
            }, params, {
              asyncChallenge: true
            }));

          case 7:
            response = _context12.sent;
            window.removeEventListener('message', loginChallengeListener);
            return _context12.abrupt("return", response);

          case 12:
            _context12.next = 14;
            return call(_objectSpread({
              method: 'requestLogin'
            }, params));

          case 14:
            return _context12.abrupt("return", _context12.sent);

          case 15:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));

  return function (_x10) {
    return _ref11.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "resetDevice",
/*#__PURE__*/
function () {
  var _ref13 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee13(params) {
    return _regenerator["default"].wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return call(_objectSpread({
              method: 'resetDevice'
            }, params));

          case 2:
            return _context13.abrupt("return", _context13.sent);

          case 3:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));

  return function (_x12) {
    return _ref13.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "cardanoGetAddress",
/*#__PURE__*/
function () {
  var _ref14 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee14(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context14.next = 3;
            return call(_objectSpread({
              method: 'cardanoGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context14.abrupt("return", _context14.sent);

          case 4:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));

  return function (_x13) {
    return _ref14.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "cardanoGetPublicKey",
/*#__PURE__*/
function () {
  var _ref15 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee15(params) {
    return _regenerator["default"].wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return call(_objectSpread({
              method: 'cardanoGetPublicKey'
            }, params));

          case 2:
            return _context15.abrupt("return", _context15.sent);

          case 3:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  return function (_x14) {
    return _ref15.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "cardanoSignTransaction",
/*#__PURE__*/
function () {
  var _ref16 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee16(params) {
    return _regenerator["default"].wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return call(_objectSpread({
              method: 'cardanoSignTransaction'
            }, params));

          case 2:
            return _context16.abrupt("return", _context16.sent);

          case 3:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));

  return function (_x15) {
    return _ref16.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "cipherKeyValue",
/*#__PURE__*/
function () {
  var _ref17 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee17(params) {
    return _regenerator["default"].wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:
            _context17.next = 2;
            return call(_objectSpread({
              method: 'cipherKeyValue'
            }, params));

          case 2:
            return _context17.abrupt("return", _context17.sent);

          case 3:
          case "end":
            return _context17.stop();
        }
      }
    }, _callee17);
  }));

  return function (_x16) {
    return _ref17.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "composeTransaction",
/*#__PURE__*/
function () {
  var _ref18 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee18(params) {
    return _regenerator["default"].wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return call(_objectSpread({
              method: 'composeTransaction'
            }, params));

          case 2:
            return _context18.abrupt("return", _context18.sent);

          case 3:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee18);
  }));

  return function (_x17) {
    return _ref18.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "debugLinkDecision",
/*#__PURE__*/
function () {
  var _ref19 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee19(params) {
    return _regenerator["default"].wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return call(_objectSpread({
              method: 'debugLinkDecision'
            }, params));

          case 2:
            return _context19.abrupt("return", _context19.sent);

          case 3:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19);
  }));

  return function (_x18) {
    return _ref19.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "debugLinkGetState",
/*#__PURE__*/
function () {
  var _ref20 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee20(params) {
    return _regenerator["default"].wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return call(_objectSpread({
              method: 'debugLinkGetState'
            }, params));

          case 2:
            return _context20.abrupt("return", _context20.sent);

          case 3:
          case "end":
            return _context20.stop();
        }
      }
    }, _callee20);
  }));

  return function (_x19) {
    return _ref20.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumGetAccountInfo",
/*#__PURE__*/
function () {
  var _ref21 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee21(params) {
    return _regenerator["default"].wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return call(_objectSpread({
              method: 'ethereumGetAccountInfo'
            }, params));

          case 2:
            return _context21.abrupt("return", _context21.sent);

          case 3:
          case "end":
            return _context21.stop();
        }
      }
    }, _callee21);
  }));

  return function (_x20) {
    return _ref21.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumGetAddress",
/*#__PURE__*/
function () {
  var _ref22 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee22(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee22$(_context22) {
      while (1) {
        switch (_context22.prev = _context22.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context22.next = 3;
            return call(_objectSpread({
              method: 'ethereumGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context22.abrupt("return", _context22.sent);

          case 4:
          case "end":
            return _context22.stop();
        }
      }
    }, _callee22);
  }));

  return function (_x21) {
    return _ref22.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumGetPublicKey",
/*#__PURE__*/
function () {
  var _ref23 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee23(params) {
    return _regenerator["default"].wrap(function _callee23$(_context23) {
      while (1) {
        switch (_context23.prev = _context23.next) {
          case 0:
            _context23.next = 2;
            return call(_objectSpread({
              method: 'ethereumGetPublicKey'
            }, params));

          case 2:
            return _context23.abrupt("return", _context23.sent);

          case 3:
          case "end":
            return _context23.stop();
        }
      }
    }, _callee23);
  }));

  return function (_x22) {
    return _ref23.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumSignMessage",
/*#__PURE__*/
function () {
  var _ref24 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee24(params) {
    return _regenerator["default"].wrap(function _callee24$(_context24) {
      while (1) {
        switch (_context24.prev = _context24.next) {
          case 0:
            _context24.next = 2;
            return call(_objectSpread({
              method: 'ethereumSignMessage'
            }, params));

          case 2:
            return _context24.abrupt("return", _context24.sent);

          case 3:
          case "end":
            return _context24.stop();
        }
      }
    }, _callee24);
  }));

  return function (_x23) {
    return _ref24.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumSignTransaction",
/*#__PURE__*/
function () {
  var _ref25 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee25(params) {
    return _regenerator["default"].wrap(function _callee25$(_context25) {
      while (1) {
        switch (_context25.prev = _context25.next) {
          case 0:
            _context25.next = 2;
            return call(_objectSpread({
              method: 'ethereumSignTransaction'
            }, params));

          case 2:
            return _context25.abrupt("return", _context25.sent);

          case 3:
          case "end":
            return _context25.stop();
        }
      }
    }, _callee25);
  }));

  return function (_x24) {
    return _ref25.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "ethereumVerifyMessage",
/*#__PURE__*/
function () {
  var _ref26 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee26(params) {
    return _regenerator["default"].wrap(function _callee26$(_context26) {
      while (1) {
        switch (_context26.prev = _context26.next) {
          case 0:
            _context26.next = 2;
            return call(_objectSpread({
              method: 'ethereumVerifyMessage'
            }, params));

          case 2:
            return _context26.abrupt("return", _context26.sent);

          case 3:
          case "end":
            return _context26.stop();
        }
      }
    }, _callee26);
  }));

  return function (_x25) {
    return _ref26.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "getAccountInfo",
/*#__PURE__*/
function () {
  var _ref27 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee27(params) {
    return _regenerator["default"].wrap(function _callee27$(_context27) {
      while (1) {
        switch (_context27.prev = _context27.next) {
          case 0:
            _context27.next = 2;
            return call(_objectSpread({
              method: 'getAccountInfo'
            }, params));

          case 2:
            return _context27.abrupt("return", _context27.sent);

          case 3:
          case "end":
            return _context27.stop();
        }
      }
    }, _callee27);
  }));

  return function (_x26) {
    return _ref27.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "getAddress",
/*#__PURE__*/
function () {
  var _ref28 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee28(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee28$(_context28) {
      while (1) {
        switch (_context28.prev = _context28.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context28.next = 3;
            return call(_objectSpread({
              method: 'getAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context28.abrupt("return", _context28.sent);

          case 4:
          case "end":
            return _context28.stop();
        }
      }
    }, _callee28);
  }));

  return function (_x27) {
    return _ref28.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "getDeviceState",
/*#__PURE__*/
function () {
  var _ref29 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee29(params) {
    return _regenerator["default"].wrap(function _callee29$(_context29) {
      while (1) {
        switch (_context29.prev = _context29.next) {
          case 0:
            _context29.next = 2;
            return call(_objectSpread({
              method: 'getDeviceState'
            }, params));

          case 2:
            return _context29.abrupt("return", _context29.sent);

          case 3:
          case "end":
            return _context29.stop();
        }
      }
    }, _callee29);
  }));

  return function (_x28) {
    return _ref29.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "getFeatures",
/*#__PURE__*/
function () {
  var _ref30 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee30(params) {
    return _regenerator["default"].wrap(function _callee30$(_context30) {
      while (1) {
        switch (_context30.prev = _context30.next) {
          case 0:
            _context30.next = 2;
            return call(_objectSpread({
              method: 'getFeatures'
            }, params));

          case 2:
            return _context30.abrupt("return", _context30.sent);

          case 3:
          case "end":
            return _context30.stop();
        }
      }
    }, _callee30);
  }));

  return function (_x29) {
    return _ref30.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "getPublicKey",
/*#__PURE__*/
function () {
  var _ref31 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee31(params) {
    return _regenerator["default"].wrap(function _callee31$(_context31) {
      while (1) {
        switch (_context31.prev = _context31.next) {
          case 0:
            _context31.next = 2;
            return call(_objectSpread({
              method: 'getPublicKey'
            }, params));

          case 2:
            return _context31.abrupt("return", _context31.sent);

          case 3:
          case "end":
            return _context31.stop();
        }
      }
    }, _callee31);
  }));

  return function (_x30) {
    return _ref31.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "liskGetAddress",
/*#__PURE__*/
function () {
  var _ref32 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee32(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee32$(_context32) {
      while (1) {
        switch (_context32.prev = _context32.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context32.next = 3;
            return call(_objectSpread({
              method: 'liskGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context32.abrupt("return", _context32.sent);

          case 4:
          case "end":
            return _context32.stop();
        }
      }
    }, _callee32);
  }));

  return function (_x31) {
    return _ref32.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "liskGetPublicKey",
/*#__PURE__*/
function () {
  var _ref33 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee33(params) {
    return _regenerator["default"].wrap(function _callee33$(_context33) {
      while (1) {
        switch (_context33.prev = _context33.next) {
          case 0:
            _context33.next = 2;
            return call(_objectSpread({
              method: 'liskGetPublicKey'
            }, params));

          case 2:
            return _context33.abrupt("return", _context33.sent);

          case 3:
          case "end":
            return _context33.stop();
        }
      }
    }, _callee33);
  }));

  return function (_x32) {
    return _ref33.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "liskSignMessage",
/*#__PURE__*/
function () {
  var _ref34 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee34(params) {
    return _regenerator["default"].wrap(function _callee34$(_context34) {
      while (1) {
        switch (_context34.prev = _context34.next) {
          case 0:
            _context34.next = 2;
            return call(_objectSpread({
              method: 'liskSignMessage'
            }, params));

          case 2:
            return _context34.abrupt("return", _context34.sent);

          case 3:
          case "end":
            return _context34.stop();
        }
      }
    }, _callee34);
  }));

  return function (_x33) {
    return _ref34.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "liskSignTransaction",
/*#__PURE__*/
function () {
  var _ref35 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee35(params) {
    return _regenerator["default"].wrap(function _callee35$(_context35) {
      while (1) {
        switch (_context35.prev = _context35.next) {
          case 0:
            _context35.next = 2;
            return call(_objectSpread({
              method: 'liskSignTransaction'
            }, params));

          case 2:
            return _context35.abrupt("return", _context35.sent);

          case 3:
          case "end":
            return _context35.stop();
        }
      }
    }, _callee35);
  }));

  return function (_x34) {
    return _ref35.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "liskVerifyMessage",
/*#__PURE__*/
function () {
  var _ref36 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee36(params) {
    return _regenerator["default"].wrap(function _callee36$(_context36) {
      while (1) {
        switch (_context36.prev = _context36.next) {
          case 0:
            _context36.next = 2;
            return call(_objectSpread({
              method: 'liskVerifyMessage'
            }, params));

          case 2:
            return _context36.abrupt("return", _context36.sent);

          case 3:
          case "end":
            return _context36.stop();
        }
      }
    }, _callee36);
  }));

  return function (_x35) {
    return _ref36.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "nemGetAddress",
/*#__PURE__*/
function () {
  var _ref37 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee37(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee37$(_context37) {
      while (1) {
        switch (_context37.prev = _context37.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context37.next = 3;
            return call(_objectSpread({
              method: 'nemGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context37.abrupt("return", _context37.sent);

          case 4:
          case "end":
            return _context37.stop();
        }
      }
    }, _callee37);
  }));

  return function (_x36) {
    return _ref37.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "nemSignTransaction",
/*#__PURE__*/
function () {
  var _ref38 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee38(params) {
    return _regenerator["default"].wrap(function _callee38$(_context38) {
      while (1) {
        switch (_context38.prev = _context38.next) {
          case 0:
            _context38.next = 2;
            return call(_objectSpread({
              method: 'nemSignTransaction'
            }, params));

          case 2:
            return _context38.abrupt("return", _context38.sent);

          case 3:
          case "end":
            return _context38.stop();
        }
      }
    }, _callee38);
  }));

  return function (_x37) {
    return _ref38.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "pushTransaction",
/*#__PURE__*/
function () {
  var _ref39 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee39(params) {
    return _regenerator["default"].wrap(function _callee39$(_context39) {
      while (1) {
        switch (_context39.prev = _context39.next) {
          case 0:
            _context39.next = 2;
            return call(_objectSpread({
              method: 'pushTransaction'
            }, params));

          case 2:
            return _context39.abrupt("return", _context39.sent);

          case 3:
          case "end":
            return _context39.stop();
        }
      }
    }, _callee39);
  }));

  return function (_x38) {
    return _ref39.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "rippleGetAccountInfo",
/*#__PURE__*/
function () {
  var _ref40 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee40(params) {
    return _regenerator["default"].wrap(function _callee40$(_context40) {
      while (1) {
        switch (_context40.prev = _context40.next) {
          case 0:
            _context40.next = 2;
            return call(_objectSpread({
              method: 'rippleGetAccountInfo'
            }, params));

          case 2:
            return _context40.abrupt("return", _context40.sent);

          case 3:
          case "end":
            return _context40.stop();
        }
      }
    }, _callee40);
  }));

  return function (_x39) {
    return _ref40.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "rippleGetAddress",
/*#__PURE__*/
function () {
  var _ref41 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee41(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee41$(_context41) {
      while (1) {
        switch (_context41.prev = _context41.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context41.next = 3;
            return call(_objectSpread({
              method: 'rippleGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context41.abrupt("return", _context41.sent);

          case 4:
          case "end":
            return _context41.stop();
        }
      }
    }, _callee41);
  }));

  return function (_x40) {
    return _ref41.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "rippleSignTransaction",
/*#__PURE__*/
function () {
  var _ref42 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee42(params) {
    return _regenerator["default"].wrap(function _callee42$(_context42) {
      while (1) {
        switch (_context42.prev = _context42.next) {
          case 0:
            _context42.next = 2;
            return call(_objectSpread({
              method: 'rippleSignTransaction'
            }, params));

          case 2:
            return _context42.abrupt("return", _context42.sent);

          case 3:
          case "end":
            return _context42.stop();
        }
      }
    }, _callee42);
  }));

  return function (_x41) {
    return _ref42.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "signMessage",
/*#__PURE__*/
function () {
  var _ref43 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee43(params) {
    return _regenerator["default"].wrap(function _callee43$(_context43) {
      while (1) {
        switch (_context43.prev = _context43.next) {
          case 0:
            _context43.next = 2;
            return call(_objectSpread({
              method: 'signMessage'
            }, params));

          case 2:
            return _context43.abrupt("return", _context43.sent);

          case 3:
          case "end":
            return _context43.stop();
        }
      }
    }, _callee43);
  }));

  return function (_x42) {
    return _ref43.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "signTransaction",
/*#__PURE__*/
function () {
  var _ref44 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee44(params) {
    return _regenerator["default"].wrap(function _callee44$(_context44) {
      while (1) {
        switch (_context44.prev = _context44.next) {
          case 0:
            _context44.next = 2;
            return call(_objectSpread({
              method: 'signTransaction'
            }, params));

          case 2:
            return _context44.abrupt("return", _context44.sent);

          case 3:
          case "end":
            return _context44.stop();
        }
      }
    }, _callee44);
  }));

  return function (_x43) {
    return _ref44.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "stellarGetAddress",
/*#__PURE__*/
function () {
  var _ref45 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee45(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee45$(_context45) {
      while (1) {
        switch (_context45.prev = _context45.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context45.next = 3;
            return call(_objectSpread({
              method: 'stellarGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context45.abrupt("return", _context45.sent);

          case 4:
          case "end":
            return _context45.stop();
        }
      }
    }, _callee45);
  }));

  return function (_x44) {
    return _ref45.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "stellarSignTransaction",
/*#__PURE__*/
function () {
  var _ref46 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee46(params) {
    return _regenerator["default"].wrap(function _callee46$(_context46) {
      while (1) {
        switch (_context46.prev = _context46.next) {
          case 0:
            _context46.next = 2;
            return call(_objectSpread({
              method: 'stellarSignTransaction'
            }, params));

          case 2:
            return _context46.abrupt("return", _context46.sent);

          case 3:
          case "end":
            return _context46.stop();
        }
      }
    }, _callee46);
  }));

  return function (_x45) {
    return _ref46.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "tezosGetAddress",
/*#__PURE__*/
function () {
  var _ref47 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee47(params) {
    var useEventListener;
    return _regenerator["default"].wrap(function _callee47$(_context47) {
      while (1) {
        switch (_context47.prev = _context47.next) {
          case 0:
            useEventListener = eventEmitter.listenerCount(UI.ADDRESS_VALIDATION) > 0;
            _context47.next = 3;
            return call(_objectSpread({
              method: 'tezosGetAddress'
            }, params, {
              useEventListener: useEventListener
            }));

          case 3:
            return _context47.abrupt("return", _context47.sent);

          case 4:
          case "end":
            return _context47.stop();
        }
      }
    }, _callee47);
  }));

  return function (_x46) {
    return _ref47.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "tezosGetPublicKey",
/*#__PURE__*/
function () {
  var _ref48 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee48(params) {
    return _regenerator["default"].wrap(function _callee48$(_context48) {
      while (1) {
        switch (_context48.prev = _context48.next) {
          case 0:
            _context48.next = 2;
            return call(_objectSpread({
              method: 'tezosGetPublicKey'
            }, params));

          case 2:
            return _context48.abrupt("return", _context48.sent);

          case 3:
          case "end":
            return _context48.stop();
        }
      }
    }, _callee48);
  }));

  return function (_x47) {
    return _ref48.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "tezosSignTransaction",
/*#__PURE__*/
function () {
  var _ref49 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee49(params) {
    return _regenerator["default"].wrap(function _callee49$(_context49) {
      while (1) {
        switch (_context49.prev = _context49.next) {
          case 0:
            _context49.next = 2;
            return call(_objectSpread({
              method: 'tezosSignTransaction'
            }, params));

          case 2:
            return _context49.abrupt("return", _context49.sent);

          case 3:
          case "end":
            return _context49.stop();
        }
      }
    }, _callee49);
  }));

  return function (_x48) {
    return _ref49.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "eosGetPublicKey",
/*#__PURE__*/
function () {
  var _ref50 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee50(params) {
    return _regenerator["default"].wrap(function _callee50$(_context50) {
      while (1) {
        switch (_context50.prev = _context50.next) {
          case 0:
            _context50.next = 2;
            return call(_objectSpread({
              method: 'eosGetPublicKey'
            }, params));

          case 2:
            return _context50.abrupt("return", _context50.sent);

          case 3:
          case "end":
            return _context50.stop();
        }
      }
    }, _callee50);
  }));

  return function (_x49) {
    return _ref50.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "eosSignTransaction",
/*#__PURE__*/
function () {
  var _ref51 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee51(params) {
    return _regenerator["default"].wrap(function _callee51$(_context51) {
      while (1) {
        switch (_context51.prev = _context51.next) {
          case 0:
            _context51.next = 2;
            return call(_objectSpread({
              method: 'eosSignTransaction'
            }, params));

          case 2:
            return _context51.abrupt("return", _context51.sent);

          case 3:
          case "end":
            return _context51.stop();
        }
      }
    }, _callee51);
  }));

  return function (_x50) {
    return _ref51.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "verifyMessage",
/*#__PURE__*/
function () {
  var _ref52 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee52(params) {
    return _regenerator["default"].wrap(function _callee52$(_context52) {
      while (1) {
        switch (_context52.prev = _context52.next) {
          case 0:
            _context52.next = 2;
            return call(_objectSpread({
              method: 'verifyMessage'
            }, params));

          case 2:
            return _context52.abrupt("return", _context52.sent);

          case 3:
          case "end":
            return _context52.stop();
        }
      }
    }, _callee52);
  }));

  return function (_x51) {
    return _ref52.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "wipeDevice",
/*#__PURE__*/
function () {
  var _ref53 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee53(params) {
    return _regenerator["default"].wrap(function _callee53$(_context53) {
      while (1) {
        switch (_context53.prev = _context53.next) {
          case 0:
            _context53.next = 2;
            return call(_objectSpread({
              method: 'wipeDevice'
            }, params));

          case 2:
            return _context53.abrupt("return", _context53.sent);

          case 3:
          case "end":
            return _context53.stop();
        }
      }
    }, _callee53);
  }));

  return function (_x52) {
    return _ref53.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "applyFlags",
/*#__PURE__*/
function () {
  var _ref54 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee54(params) {
    return _regenerator["default"].wrap(function _callee54$(_context54) {
      while (1) {
        switch (_context54.prev = _context54.next) {
          case 0:
            _context54.next = 2;
            return call(_objectSpread({
              method: 'applyFlags'
            }, params));

          case 2:
            return _context54.abrupt("return", _context54.sent);

          case 3:
          case "end":
            return _context54.stop();
        }
      }
    }, _callee54);
  }));

  return function (_x53) {
    return _ref54.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "applySettings",
/*#__PURE__*/
function () {
  var _ref55 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee55(params) {
    return _regenerator["default"].wrap(function _callee55$(_context55) {
      while (1) {
        switch (_context55.prev = _context55.next) {
          case 0:
            _context55.next = 2;
            return call(_objectSpread({
              method: 'applySettings'
            }, params));

          case 2:
            return _context55.abrupt("return", _context55.sent);

          case 3:
          case "end":
            return _context55.stop();
        }
      }
    }, _callee55);
  }));

  return function (_x54) {
    return _ref55.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "backupDevice",
/*#__PURE__*/
(0, _asyncToGenerator2["default"])(
/*#__PURE__*/
_regenerator["default"].mark(function _callee56() {
  return _regenerator["default"].wrap(function _callee56$(_context56) {
    while (1) {
      switch (_context56.prev = _context56.next) {
        case 0:
          _context56.next = 2;
          return call({
            method: 'backupDevice'
          });

        case 2:
          return _context56.abrupt("return", _context56.sent);

        case 3:
        case "end":
          return _context56.stop();
      }
    }
  }, _callee56);
})));
(0, _defineProperty2["default"])(TrezorConnect, "changePin",
/*#__PURE__*/
function () {
  var _ref57 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee57(params) {
    return _regenerator["default"].wrap(function _callee57$(_context57) {
      while (1) {
        switch (_context57.prev = _context57.next) {
          case 0:
            _context57.next = 2;
            return call(_objectSpread({
              method: 'changePin'
            }, params));

          case 2:
            return _context57.abrupt("return", _context57.sent);

          case 3:
          case "end":
            return _context57.stop();
        }
      }
    }, _callee57);
  }));

  return function (_x55) {
    return _ref57.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "firmwareErase",
/*#__PURE__*/
function () {
  var _ref58 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee58(params) {
    return _regenerator["default"].wrap(function _callee58$(_context58) {
      while (1) {
        switch (_context58.prev = _context58.next) {
          case 0:
            _context58.next = 2;
            return call(_objectSpread({
              method: 'firmwareErase'
            }, params));

          case 2:
            return _context58.abrupt("return", _context58.sent);

          case 3:
          case "end":
            return _context58.stop();
        }
      }
    }, _callee58);
  }));

  return function (_x56) {
    return _ref58.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "firmwareUpload",
/*#__PURE__*/
function () {
  var _ref59 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee59(params) {
    return _regenerator["default"].wrap(function _callee59$(_context59) {
      while (1) {
        switch (_context59.prev = _context59.next) {
          case 0:
            _context59.next = 2;
            return call(_objectSpread({
              method: 'firmwareUpload'
            }, params));

          case 2:
            return _context59.abrupt("return", _context59.sent);

          case 3:
          case "end":
            return _context59.stop();
        }
      }
    }, _callee59);
  }));

  return function (_x57) {
    return _ref59.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "firmwareUpdate",
/*#__PURE__*/
function () {
  var _ref60 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee60(params) {
    return _regenerator["default"].wrap(function _callee60$(_context60) {
      while (1) {
        switch (_context60.prev = _context60.next) {
          case 0:
            _context60.next = 2;
            return call(_objectSpread({
              method: 'firmwareUpdate'
            }, params));

          case 2:
            return _context60.abrupt("return", _context60.sent);

          case 3:
          case "end":
            return _context60.stop();
        }
      }
    }, _callee60);
  }));

  return function (_x58) {
    return _ref60.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "recoveryDevice",
/*#__PURE__*/
function () {
  var _ref61 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee61(params) {
    return _regenerator["default"].wrap(function _callee61$(_context61) {
      while (1) {
        switch (_context61.prev = _context61.next) {
          case 0:
            _context61.next = 2;
            return call(_objectSpread({
              method: 'recoveryDevice'
            }, params));

          case 2:
            return _context61.abrupt("return", _context61.sent);

          case 3:
          case "end":
            return _context61.stop();
        }
      }
    }, _callee61);
  }));

  return function (_x59) {
    return _ref61.apply(this, arguments);
  };
}());
(0, _defineProperty2["default"])(TrezorConnect, "dispose", function () {
  iframe.dispose();

  if (_popupManager) {
    _popupManager.close();
  }
});
(0, _defineProperty2["default"])(TrezorConnect, "cancel", function () {
  if (_popupManager) {
    _popupManager.emit(POPUP.CLOSED);
  }
});
(0, _defineProperty2["default"])(TrezorConnect, "renderWebUSBButton", function (className) {
  (0, _button["default"])(className, _settings.webusbSrc, iframe.origin);
});
var _default = TrezorConnect;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/message/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/message/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.parseMessage = void 0;

// parse MessageEvent .data into CoreMessage
var parseMessage = function parseMessage(messageData) {
  var message = {
    event: messageData.event,
    type: messageData.type,
    payload: messageData.payload
  };

  if (typeof messageData.id === 'number') {
    message.id = messageData.id;
  }

  if (typeof messageData.success === 'boolean') {
    message.success = messageData.success;
  }

  return message;
};

exports.parseMessage = parseMessage;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/popup/PopupManager.js":
/*!***************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/popup/PopupManager.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js"));

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js"));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js"));

var _events = _interopRequireDefault(__webpack_require__(/*! events */ "./node_modules/events/events.js"));

var POPUP = _interopRequireWildcard(__webpack_require__(/*! ../constants/popup */ "./node_modules/trezor-connect/lib/constants/popup.js"));

var ERROR = _interopRequireWildcard(__webpack_require__(/*! ../constants/errors */ "./node_modules/trezor-connect/lib/constants/errors.js"));

var _showPopupRequest = __webpack_require__(/*! ./showPopupRequest */ "./node_modules/trezor-connect/lib/popup/showPopupRequest.js");

var _networkUtils = __webpack_require__(/*! ../utils/networkUtils */ "./node_modules/trezor-connect/lib/utils/networkUtils.js");

var _deferred = __webpack_require__(/*! ../utils/deferred */ "./node_modules/trezor-connect/lib/utils/deferred.js");

// const POPUP_REQUEST_TIMEOUT: number = 602;
var POPUP_REQUEST_TIMEOUT = 850;
var POPUP_CLOSE_INTERVAL = 500;
var POPUP_OPEN_TIMEOUT = 2000;

var PopupManager =
/*#__PURE__*/
function (_EventEmitter) {
  (0, _inheritsLoose2["default"])(PopupManager, _EventEmitter);

  // Window
  function PopupManager(settings) {
    var _this;

    _this = _EventEmitter.call(this) || this;
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestTimeout", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closeInterval", 0);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extension", false);
    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extensionTabId", 0);
    _this.settings = settings;
    _this.src = settings.popupSrc;
    _this.origin = (0, _networkUtils.getOrigin)(settings.popupSrc);
    _this.handleLazyLoading = _this.handleLazyLoading.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

    _this.extension = typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined';

    if (_this.extension) {
      _this.handleExtensionConnect = _this.handleExtensionConnect.bind((0, _assertThisInitialized2["default"])(_this));
      _this.handleExtensionMessage = _this.handleExtensionMessage.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

      chrome.runtime.onConnect.addListener(_this.handleExtensionConnect);
    }

    return _this;
  }

  var _proto = PopupManager.prototype;

  _proto.request = function request(lazyLoad) {
    var _this2 = this;

    if (lazyLoad === void 0) {
      lazyLoad = false;
    }

    // popup request
    // TODO: ie - open imediately and hide it but post handshake after timeout
    // bring popup window to front
    if (this.locked) {
      if (this._window) {
        if (this.extension) {
          // $FlowIssue chrome not declared outside
          chrome.tabs.update(this._window.id, {
            active: true
          });
        } else {
          this._window.focus();
        }
      }

      return;
    }

    this.lazyLoad = lazyLoad ? (0, _deferred.create)(POPUP.INIT) : null;

    if (this.lazyLoad) {
      if (!this.extension) {
        window.addEventListener('message', this.handleLazyLoading, false);
      }
    }

    var openFn = this.open.bind(this);
    this.locked = true;

    if (!this.settings.supportedBrowser) {
      openFn();
    } else {
      this.requestTimeout = window.setTimeout(function () {
        _this2.requestTimeout = 0;
        openFn();
      }, lazyLoad || this.extension ? 1 : POPUP_REQUEST_TIMEOUT);
    }
  };

  _proto.cancel = function cancel() {
    this.close();
  };

  _proto.unlock = function unlock() {
    this.locked = false;
  };

  _proto.open = function open() {
    var _this3 = this;

    if (!this.settings.supportedBrowser) {
      this.openWrapper(this.src + '#unsupported');
      return;
    }

    this.openWrapper(this.lazyLoad ? this.src + '#loading' : this.src);
    this.closeInterval = window.setInterval(function () {
      if (_this3._window) {
        if (_this3.extension) {
          // $FlowIssue chrome not declared outside
          chrome.tabs.get(_this3._window.id, function (tab) {
            if (!tab) {
              _this3.close();

              _this3.emit(POPUP.CLOSED);
            }
          });
        } else if (_this3._window.closed) {
          _this3.close();

          _this3.emit(POPUP.CLOSED);
        }
      }
    }, POPUP_CLOSE_INTERVAL);
    this.openTimeout = window.setTimeout(function () {
      if (!(_this3._window && !_this3._window.closed)) {
        _this3.close();

        (0, _showPopupRequest.showPopupRequest)(_this3.open.bind(_this3), function () {
          _this3.emit(POPUP.CLOSED);
        });
      }
    }, POPUP_OPEN_TIMEOUT);
  };

  _proto.openWrapper = function openWrapper(url) {
    var _this4 = this;

    if (this.extension) {
      // $FlowIssue chrome not declared outside
      chrome.windows.getCurrent(null, function (currentWindow) {
        // Request coming from extension popup,
        // create new window above instead of opening new tab
        if (currentWindow.type !== 'normal') {
          // $FlowIssue chrome not declared outside
          chrome.windows.create({
            url: url
          }, function (newWindow) {
            // $FlowIssue chrome not declared outside
            chrome.tabs.query({
              windowId: newWindow.id,
              active: true
            }, function (tabs) {
              _this4._window = tabs[0];
            });
          });
        } else {
          // $FlowIssue chrome not declared outside
          chrome.tabs.query({
            currentWindow: true,
            active: true
          }, function (tabs) {
            _this4.extensionTabId = tabs[0].id; // $FlowIssue chrome not declared outside

            chrome.tabs.create({
              url: url,
              index: tabs[0].index + 1
            }, function (tab) {
              _this4._window = tab;
            });
          });
        }
      });
    } else {
      this._window = window.open('', '_blank');

      if (this._window) {
        this._window.location.href = url; // otherwise android/chrome loose window.opener reference
      }
    }
  };

  _proto.handleExtensionConnect = function handleExtensionConnect(port) {
    if (port.name === 'trezor-connect') {
      if (!this._window || this._window && this._window.id !== port.sender.tab.id) {
        port.disconnect();
        return;
      }

      this.extensionPort = port; // $FlowIssue need to update ChromePort definition

      this.extensionPort.onMessage.addListener(this.handleExtensionMessage);
    } else if (port.name === 'trezor-usb-permissions') {
      port.postMessage({
        broadcast: this.broadcast
      });
    }
  };

  _proto.handleExtensionMessage = function handleExtensionMessage(message) {
    if (!this.extensionPort) return;

    if (message === POPUP.EXTENSION_REQUEST) {
      this.extensionPort.postMessage({
        type: POPUP.EXTENSION_REQUEST,
        broadcast: this.broadcast
      });
    } else if (message === POPUP.INIT && this.lazyLoad) {
      this.lazyLoad.resolve(true);
    } else if (message === POPUP.EXTENSION_USB_PERMISSIONS) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.query({
        currentWindow: true,
        active: true
      }, function (tabs) {
        // $FlowIssue chrome not declared outside
        chrome.tabs.create({
          url: 'trezor-usb-permissions.html',
          index: tabs[0].index + 1
        }, function (tab) {// do nothing
        });
      });
    } else if (message === POPUP.CLOSE_WINDOW) {
      this.emit(POPUP.CLOSED);
      this.close();
    }
  };

  _proto.setBroadcast = function setBroadcast(broadcast) {
    this.broadcast = broadcast;
  };

  _proto.handleLazyLoading = function handleLazyLoading(event) {
    if (this.lazyLoad && event.data && event.data === POPUP.INIT) {
      this.lazyLoad.resolve(true);
      window.removeEventListener('message', this.handleLazyLoading, false);
    }
  };

  _proto.resolveLazyLoad =
  /*#__PURE__*/
  function () {
    var _resolveLazyLoad = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee() {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this.lazyLoad) {
                _context.next = 5;
                break;
              }

              _context.next = 3;
              return this.lazyLoad.promise;

            case 3:
              _context.next = 6;
              break;

            case 5:
              throw ERROR.POPUP_CLOSED.message;

            case 6:
              if (this.extension) {
                if (this.extensionPort) {
                  this.extensionPort.postMessage({
                    type: POPUP.INIT
                  });
                }
              } else if (this._window) {
                this._window.postMessage({
                  type: POPUP.INIT
                }, this.origin);
              }

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function resolveLazyLoad() {
      return _resolveLazyLoad.apply(this, arguments);
    }

    return resolveLazyLoad;
  }();

  _proto.close = function close() {
    this.locked = false;

    if (this.requestTimeout) {
      window.clearTimeout(this.requestTimeout);
      this.requestTimeout = 0;
    }

    if (this.openTimeout) {
      window.clearTimeout(this.openTimeout);
      this.openTimeout = 0;
    }

    if (this.closeInterval) {
      window.clearInterval(this.closeInterval);
      this.closeInterval = 0;
    }

    if (this.extensionPort) {
      this.extensionPort.disconnect();
      this.extensionPort = null;
    }

    if (this.extensionTabId) {
      // $FlowIssue chrome not declared outside
      chrome.tabs.update(this.extensionTabId, {
        active: true
      });
      this.extensionTabId = 0;
    }

    if (this.lazyLoad) {
      this.lazyLoad = null;
    }

    if (this._window) {
      if (this.extension) {
        // $FlowIssue chrome not declared outside
        chrome.tabs.remove(this._window.id);
      } else {
        this._window.close();
      }

      this._window = null;
    }
  };

  _proto.postMessage = function postMessage(message) {
    var _this5 = this;

    // post message before popup request finalized
    if (this.requestTimeout) {
      return;
    } // device needs interaction but there is no popup/ui
    // maybe popup request wasn't handled
    // ignore "ui_request_window" type


    if (!this._window && message.type !== 'ui_request_window' && this.openTimeout) {
      this.close();
      (0, _showPopupRequest.showPopupRequest)(this.open.bind(this), function () {
        _this5.emit(POPUP.CLOSED);
      });
      return;
    } // post message to popup window


    if (this._window) {
      this._window.postMessage(message, this.origin);
    }
  };

  _proto.onBeforeUnload = function onBeforeUnload() {
    this.close();
  };

  _proto.cancelOpenTimeout = function cancelOpenTimeout() {
    window.clearTimeout(this.openTimeout);
  };

  return PopupManager;
}(_events["default"]);

exports["default"] = PopupManager;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/popup/showPopupRequest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/popup/showPopupRequest.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.showPopupRequest = void 0;
var layerID = 'TrezorConnectInteractionLayer';
var layerInnerHtml = "\n    <div class=\"trezorconnect-container\" id=\"" + layerID + "\">\n        <div class=\"trezorconnect-window\">\n            <div class=\"trezorconnect-head\">\n                <svg class=\"trezorconnect-logo\" x=\"0px\" y=\"0px\" viewBox=\"0 0 163.7 41.9\" width=\"78px\" height=\"20px\" preserveAspectRatio=\"xMinYMin meet\">\n                    <polygon points=\"101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1\"/>\n                    <path d=\"M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z\"/>\n                    <path d=\"M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z\"/>\n                    <polygon points=\"82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 \"/>\n                    <path d=\"M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z\"/>\n                    <path d=\"M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z\"/>\n                    <polygon points=\"40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 \"/>\n                </svg>\n                <div class=\"trezorconnect-close\">\n                    <svg x=\"0px\" y=\"0px\" viewBox=\"24 24 60 60\" width=\"24px\" height=\"24px\" preserveAspectRatio=\"xMinYMin meet\">\n                        <polygon class=\"st0\" points=\"40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 \"/>\n                    </svg>\n                </div>\n            </div>\n            <div class=\"trezorconnect-body\">\n                <h3>Popup was blocked</h3>\n                <p>Please click to \u201CContinue\u201D to open popup manually</p>\n                <button class=\"trezorconnect-open\">Continue</button>\n            </div>\n        </div>\n    </div>\n";

var showPopupRequest = function showPopupRequest(open, cancel) {
  if (document.getElementById(layerID)) {
    return;
  }

  var div = document.createElement('div');
  div.id = layerID;
  div.className = 'trezorconnect-container';
  div.innerHTML = layerInnerHtml;

  if (document.body) {
    document.body.appendChild(div);
  }

  var button = div.getElementsByClassName('trezorconnect-open')[0];

  button.onclick = function () {
    open();

    if (document.body) {
      document.body.removeChild(div);
    }
  };

  var close = div.getElementsByClassName('trezorconnect-close')[0];

  close.onclick = function () {
    cancel();

    if (document.body) {
      document.body.removeChild(div);
    }
  };
};

exports.showPopupRequest = showPopupRequest;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/account.js":
/*!**********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/account.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/blockchainEvent.js":
/*!******************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/blockchainEvent.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var BLOCKCHAIN = _interopRequireWildcard(__webpack_require__(/*! ../constants/blockchain */ "./node_modules/trezor-connect/lib/constants/blockchain.js"));

/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/cardano.js":
/*!**********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/cardano.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/coinInfo.js":
/*!***********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/coinInfo.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/eos.js":
/*!******************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/eos.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/ethereum.js":
/*!***********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/ethereum.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/index.js":
/*!********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;

var _constants = __webpack_require__(/*! ../constants */ "./node_modules/trezor-connect/lib/constants/index.js");

var TRANSPORT = _interopRequireWildcard(__webpack_require__(/*! ../constants/transport */ "./node_modules/trezor-connect/lib/constants/transport.js"));

var POPUP = _interopRequireWildcard(__webpack_require__(/*! ../constants/popup */ "./node_modules/trezor-connect/lib/constants/popup.js"));

var UI = _interopRequireWildcard(__webpack_require__(/*! ../constants/ui */ "./node_modules/trezor-connect/lib/constants/ui.js"));

var DEVICE = _interopRequireWildcard(__webpack_require__(/*! ../constants/device */ "./node_modules/trezor-connect/lib/constants/device.js"));

var P = _interopRequireWildcard(__webpack_require__(/*! ./params */ "./node_modules/trezor-connect/lib/types/params.js"));

var R = _interopRequireWildcard(__webpack_require__(/*! ./response */ "./node_modules/trezor-connect/lib/types/response.js"));

Object.keys(R).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  exports[key] = R[key];
});

var CARDANO = _interopRequireWildcard(__webpack_require__(/*! ./cardano */ "./node_modules/trezor-connect/lib/types/cardano.js"));

var RIPPLE = _interopRequireWildcard(__webpack_require__(/*! ./ripple */ "./node_modules/trezor-connect/lib/types/ripple.js"));

var ETHEREUM = _interopRequireWildcard(__webpack_require__(/*! ./ethereum */ "./node_modules/trezor-connect/lib/types/ethereum.js"));

var NEM = _interopRequireWildcard(__webpack_require__(/*! ./nem */ "./node_modules/trezor-connect/lib/types/nem.js"));

var STELLAR = _interopRequireWildcard(__webpack_require__(/*! ./stellar */ "./node_modules/trezor-connect/lib/types/stellar.js"));

var LISK = _interopRequireWildcard(__webpack_require__(/*! ./lisk */ "./node_modules/trezor-connect/lib/types/lisk.js"));

var TEZOS = _interopRequireWildcard(__webpack_require__(/*! ./tezos */ "./node_modules/trezor-connect/lib/types/tezos.js"));

var EOS = _interopRequireWildcard(__webpack_require__(/*! ./eos */ "./node_modules/trezor-connect/lib/types/eos.js"));

var _coinInfo = __webpack_require__(/*! ./coinInfo */ "./node_modules/trezor-connect/lib/types/coinInfo.js");

Object.keys(_coinInfo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  exports[key] = _coinInfo[key];
});

/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/lisk.js":
/*!*******************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/lisk.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/nem.js":
/*!******************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/nem.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/params.js":
/*!*********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/params.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/response.js":
/*!***********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/response.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/ripple.js":
/*!*********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/ripple.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/stellar.js":
/*!**********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/stellar.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/types/tezos.js":
/*!********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/types/tezos.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/trezor-connect/lib/utils/debug.js":
/*!********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/utils/debug.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) { // https://stackoverflow.com/questions/7505623/colors-in-javascript-console
// https://github.com/pimterry/loglevel/blob/master/lib/loglevel.js
// http://www.color-hex.com/color-palette/5016

exports.__esModule = true;
exports.popupConsole = exports.enableByPrefix = exports.getLog = exports.enable = exports.init = exports["default"] = void 0;

var _this = void 0;

var colors = {
  // green
  'DescriptorStream': 'color: #77ab59',
  'DeviceList': 'color: #36802d',
  'Device': 'color: #bada55',
  'Core': 'color: #c9df8a',
  'IFrame': 'color: #FFFFFF; background: #f4a742;',
  'Popup': 'color: #f48a00'
};

var Log =
/*#__PURE__*/
function () {
  function Log(prefix, enabled) {
    if (enabled === void 0) {
      enabled = false;
    }

    this.prefix = prefix;
    this.enabled = enabled;
    this.messages = [];
    this.css = colors[prefix] || 'color: #000000; background: #FFFFFF;';
  }

  var _proto = Log.prototype;

  _proto.addMessage = function addMessage(level, prefix) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.messages.push({
      level: level,
      prefix: prefix,
      message: args,
      timestamp: new Date().getTime()
    });
  };

  _proto.log = function log() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    this.addMessage.apply(this, ['log', this.prefix].concat(args));

    if (this.enabled) {
      var _console;

      (_console = console).log.apply(_console, [this.prefix].concat(args));
    }
  };

  _proto.error = function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    this.addMessage.apply(this, ['error', this.prefix].concat(args));

    if (this.enabled) {
      var _console2;

      (_console2 = console).error.apply(_console2, [this.prefix].concat(args));
    }
  };

  _proto.warn = function warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    this.addMessage.apply(this, ['warn', this.prefix].concat(args));

    if (this.enabled) {
      var _console3;

      (_console3 = console).warn.apply(_console3, [this.prefix].concat(args));
    }
  };

  _proto.debug = function debug() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    this.addMessage.apply(this, ['debug', this.prefix].concat(args));

    if (this.enabled) {
      var _console4;

      (_console4 = console).log.apply(_console4, ['%c' + this.prefix, this.css].concat(args));
    }
  };

  return Log;
}();

exports["default"] = Log;
var _logs = {};

var init = function init(prefix, enabled) {
  var enab = typeof enabled === 'boolean' ? enabled : false;
  var instance = new Log(prefix, enab);
  _logs[prefix] = instance;
  return instance;
};

exports.init = init;

var enable = function enable(enabled) {
  for (var _i = 0, _Object$keys = Object.keys(_logs); _i < _Object$keys.length; _i++) {
    var l = _Object$keys[_i];
    _logs[l].enabled = enabled;
  }
};

exports.enable = enable;

var getLog = function getLog(args) {
  // if
  var logs = [];

  for (var _i2 = 0, _Object$keys2 = Object.keys(_logs); _i2 < _Object$keys2.length; _i2++) {
    var l = _Object$keys2[_i2];
    logs = logs.concat(_logs[l].messages);
  }

  logs.sort(function (a, b) {
    return a.timestamp - b.timestamp;
  });
  return logs;
};

exports.getLog = getLog;

var enableByPrefix = function enableByPrefix(prefix, enabled) {
  if (_logs[prefix]) {
    _logs[prefix].enabled = enabled;
  }
}; // TODO: enable/disable log at runtime


exports.enableByPrefix = enableByPrefix;

var popupConsole = function popupConsole(tag, postMessage) {
  var c = global.console;
  var orig = {
    error: c.error,
    // warn: c.warn,
    info: c.info,
    debug: c.debug,
    log: c.log
  };
  var log = [];

  var inject = function inject(method, level) {
    return function () {
      // args.unshift('[popup.js]');
      var time = new Date().toUTCString();

      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      log.push([level, time].concat(args));
      postMessage.apply(_this, [{
        type: tag,
        level: level,
        time: time,
        args: JSON.stringify(args)
      }]);
      return method.apply(c, args);
    };
  };

  for (var level in orig) {
    c[level] = inject(orig[level], level);
  }
};

exports.popupConsole = popupConsole;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/trezor-connect/lib/utils/deferred.js":
/*!***********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/utils/deferred.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.create = create;
exports.createAsync = createAsync;
exports.resolveTimeoutPromise = resolveTimeoutPromise;
exports.rejectTimeoutPromise = rejectTimeoutPromise;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

function create(arg, device) {
  var localResolve = function localResolve(t) {};

  var localReject = function localReject(e) {};

  var id;
  var promise = new Promise(
  /*#__PURE__*/
  function () {
    var _ref = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee(resolve, reject) {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localResolve = resolve;
              localReject = reject;

              if (!(typeof arg === 'function')) {
                _context.next = 11;
                break;
              }

              _context.prev = 3;
              _context.next = 6;
              return arg();

            case 6:
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](3);
              reject(_context.t0);

            case 11:
              if (typeof arg === 'string') id = arg;

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 8]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    id: id,
    device: device,
    resolve: localResolve,
    reject: localReject,
    promise: promise
  };
}

function createAsync(innerFn) {
  var localResolve = function localResolve(t) {};

  var localReject = function localReject(e) {};

  var promise = new Promise(function (resolve, reject) {
    localResolve = resolve;
    localReject = reject;
  });

  var inner =
  /*#__PURE__*/
  function () {
    var _ref2 = (0, _asyncToGenerator2["default"])(
    /*#__PURE__*/
    _regenerator["default"].mark(function _callee2() {
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return innerFn();

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function inner() {
      return _ref2.apply(this, arguments);
    };
  }();

  return {
    resolve: localResolve,
    reject: localReject,
    promise: promise,
    run: function run() {
      inner();
      return promise;
    }
  };
}

function resolveTimeoutPromise(delay, result) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve(result);
    }, delay);
  });
}

function rejectTimeoutPromise(delay, error) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      reject(error);
    }, delay);
  });
}

/***/ }),

/***/ "./node_modules/trezor-connect/lib/utils/networkUtils.js":
/*!***************************************************************!*\
  !*** ./node_modules/trezor-connect/lib/utils/networkUtils.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.getOrigin = exports.httpRequest = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"));

__webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/fetch.js");

var httpRequest =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(url, type) {
    var response, txt;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (type === void 0) {
              type = 'text';
            }

            _context.next = 3;
            return fetch(url, {
              credentials: 'same-origin'
            });

          case 3:
            response = _context.sent;

            if (!response.ok) {
              _context.next = 23;
              break;
            }

            if (!(type === 'json')) {
              _context.next = 12;
              break;
            }

            _context.next = 8;
            return response.text();

          case 8:
            txt = _context.sent;
            return _context.abrupt("return", JSON.parse(txt));

          case 12:
            if (!(type === 'binary')) {
              _context.next = 18;
              break;
            }

            _context.next = 15;
            return response.arrayBuffer();

          case 15:
            return _context.abrupt("return", _context.sent);

          case 18:
            _context.next = 20;
            return response.text();

          case 20:
            return _context.abrupt("return", _context.sent);

          case 21:
            _context.next = 24;
            break;

          case 23:
            throw new Error("httpRequest error: " + url + " " + response.statusText);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function httpRequest(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.httpRequest = httpRequest;

var getOrigin = function getOrigin(url) {
  // eslint-disable-next-line no-irregular-whitespace, no-useless-escape
  var parts = url.match(/^.+\:\/\/[^\/]+/);
  return Array.isArray(parts) && parts.length > 0 ? parts[0] : 'unknown';
};

exports.getOrigin = getOrigin;

/***/ }),

/***/ "./node_modules/trezor-connect/lib/webusb/button.js":
/*!**********************************************************!*\
  !*** ./node_modules/trezor-connect/lib/webusb/button.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var render = function render(className, url, origin) {
  var query = className || '.trezor-webusb-button';
  var buttons = document.querySelectorAll(query);
  var src = url + "?" + Date.now();
  buttons.forEach(function (b) {
    if (b.getElementsByTagName('iframe').length < 1) {
      var bounds = b.getBoundingClientRect();
      var btnIframe = document.createElement('iframe');
      btnIframe.frameBorder = '0';
      btnIframe.width = Math.round(bounds.width) + 'px';
      btnIframe.height = Math.round(bounds.height) + 'px';
      btnIframe.style.position = 'absolute';
      btnIframe.style.top = '0px';
      btnIframe.style.left = '0px';
      btnIframe.style.zIndex = '1'; // btnIframe.style.opacity = '0'; // this makes click impossible on cross-origin

      btnIframe.setAttribute('allow', 'usb');
      btnIframe.setAttribute('scrolling', 'no');

      btnIframe.onload = function () {
        btnIframe.contentWindow.postMessage({// style: JSON.stringify( window.getComputedStyle(b) ),
          // outer: b.outerHTML,
          // inner: b.innerHTML
        }, origin);
      };

      btnIframe.src = src; // inject iframe into button

      b.append(btnIframe);
    }
  });
};

var _default = render;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/u2f-api/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/u2f-api/dist/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var u2fApi = __webpack_require__(/*! ./lib/u2f-api */ "./node_modules/u2f-api/dist/lib/u2f-api.js");
__export(__webpack_require__(/*! ./lib/u2f-api */ "./node_modules/u2f-api/dist/lib/u2f-api.js"));
exports.default = u2fApi;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/u2f-api/dist/lib/generated-google-u2f-api.js":
/*!*******************************************************************!*\
  !*** ./node_modules/u2f-api/dist/lib/generated-google-u2f-api.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//Copyright 2014-2015 Google Inc. All rights reserved.

//Use of this source code is governed by a BSD-style
//license that can be found in the LICENSE file or at
//https://developers.google.com/open-source/licenses/bsd

/**
 * @fileoverview The U2F api.
 */
// 'use strict';


/**
 * Namespace for the U2F api.
 * @type {Object}
 */
var u2f = u2f || {};

module.exports.chromeApi = u2f; // Adaptation for u2f-api package

/**
 * FIDO U2F Javascript API Version
 * @number
 */
var js_api_version;

/**
 * The U2F extension id
 * @const {string}
 */
// The Chrome packaged app extension ID.
// Uncomment this if you want to deploy a server instance that uses
// the package Chrome app and does not require installing the U2F Chrome extension.
 u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';
// The U2F Chrome extension ID.
// Uncomment this if you want to deploy a server instance that uses
// the U2F Chrome extension to authenticate.
// u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';


/**
 * Message types for messsages to/from the extension
 * @const
 * @enum {string}
 */
u2f.MessageTypes = {
    'U2F_REGISTER_REQUEST': 'u2f_register_request',
    'U2F_REGISTER_RESPONSE': 'u2f_register_response',
    'U2F_SIGN_REQUEST': 'u2f_sign_request',
    'U2F_SIGN_RESPONSE': 'u2f_sign_response',
    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',
    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'
};


/**
 * Response status codes
 * @const
 * @enum {number}
 */
u2f.ErrorCodes = {
    'OK': 0,
    'OTHER_ERROR': 1,
    'BAD_REQUEST': 2,
    'CONFIGURATION_UNSUPPORTED': 3,
    'DEVICE_INELIGIBLE': 4,
    'TIMEOUT': 5
};


/**
 * A message for registration requests
 * @typedef {{
 *   type: u2f.MessageTypes,
 *   appId: ?string,
 *   timeoutSeconds: ?number,
 *   requestId: ?number
 * }}
 */
u2f.U2fRequest;


/**
 * A message for registration responses
 * @typedef {{
 *   type: u2f.MessageTypes,
 *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),
 *   requestId: ?number
 * }}
 */
u2f.U2fResponse;


/**
 * An error object for responses
 * @typedef {{
 *   errorCode: u2f.ErrorCodes,
 *   errorMessage: ?string
 * }}
 */
u2f.Error;

/**
 * Data object for a single sign request.
 * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC, USB_INTERNAL}}
 */
u2f.Transport;


/**
 * Data object for a single sign request.
 * @typedef {Array<u2f.Transport>}
 */
u2f.Transports;

/**
 * Data object for a single sign request.
 * @typedef {{
 *   version: string,
 *   challenge: string,
 *   keyHandle: string,
 *   appId: string
 * }}
 */
u2f.SignRequest;


/**
 * Data object for a sign response.
 * @typedef {{
 *   keyHandle: string,
 *   signatureData: string,
 *   clientData: string
 * }}
 */
u2f.SignResponse;


/**
 * Data object for a registration request.
 * @typedef {{
 *   version: string,
 *   challenge: string
 * }}
 */
u2f.RegisterRequest;


/**
 * Data object for a registration response.
 * @typedef {{
 *   version: string,
 *   keyHandle: string,
 *   transports: Transports,
 *   appId: string
 * }}
 */
u2f.RegisterResponse;


/**
 * Data object for a registered key.
 * @typedef {{
 *   version: string,
 *   keyHandle: string,
 *   transports: ?Transports,
 *   appId: ?string
 * }}
 */
u2f.RegisteredKey;


/**
 * Data object for a get API register response.
 * @typedef {{
 *   js_api_version: number
 * }}
 */
u2f.GetJsApiVersionResponse;


//Low level MessagePort API support

/**
 * Sets up a MessagePort to the U2F extension using the
 * available mechanisms.
 * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
 */
u2f.getMessagePort = function(callback) {
  if (typeof chrome != 'undefined' && chrome.runtime) {
    // The actual message here does not matter, but we need to get a reply
    // for the callback to run. Thus, send an empty signature request
    // in order to get a failure response.
    var msg = {
        type: u2f.MessageTypes.U2F_SIGN_REQUEST,
        signRequests: []
    };
    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {
      if (!chrome.runtime.lastError) {
        // We are on a whitelisted origin and can talk directly
        // with the extension.
        u2f.getChromeRuntimePort_(callback);
      } else {
        // chrome.runtime was available, but we couldn't message
        // the extension directly, use iframe
        u2f.getIframePort_(callback);
      }
    });
  } else if (u2f.isAndroidChrome_()) {
    u2f.getAuthenticatorPort_(callback);
  } else if (u2f.isIosChrome_()) {
    u2f.getIosPort_(callback);
  } else {
    // chrome.runtime was not available at all, which is normal
    // when this origin doesn't have access to any extensions.
    u2f.getIframePort_(callback);
  }
};

/**
 * Detect chrome running on android based on the browser's useragent.
 * @private
 */
u2f.isAndroidChrome_ = function() {
  var userAgent = navigator.userAgent;
  return userAgent.indexOf('Chrome') != -1 &&
  userAgent.indexOf('Android') != -1;
};

/**
 * Detect chrome running on iOS based on the browser's platform.
 * @private
 */
u2f.isIosChrome_ = function() {
  return ["iPhone", "iPad", "iPod"].indexOf(navigator.platform) > -1;
};

/**
 * Connects directly to the extension via chrome.runtime.connect.
 * @param {function(u2f.WrappedChromeRuntimePort_)} callback
 * @private
 */
u2f.getChromeRuntimePort_ = function(callback) {
  var port = chrome.runtime.connect(u2f.EXTENSION_ID,
      {'includeTlsChannelId': true});
  setTimeout(function() {
    callback(new u2f.WrappedChromeRuntimePort_(port));
  }, 0);
};

/**
 * Return a 'port' abstraction to the Authenticator app.
 * @param {function(u2f.WrappedAuthenticatorPort_)} callback
 * @private
 */
u2f.getAuthenticatorPort_ = function(callback) {
  setTimeout(function() {
    callback(new u2f.WrappedAuthenticatorPort_());
  }, 0);
};

/**
 * Return a 'port' abstraction to the iOS client app.
 * @param {function(u2f.WrappedIosPort_)} callback
 * @private
 */
u2f.getIosPort_ = function(callback) {
  setTimeout(function() {
    callback(new u2f.WrappedIosPort_());
  }, 0);
};

/**
 * A wrapper for chrome.runtime.Port that is compatible with MessagePort.
 * @param {Port} port
 * @constructor
 * @private
 */
u2f.WrappedChromeRuntimePort_ = function(port) {
  this.port_ = port;
};

/**
 * Format and return a sign request compliant with the JS API version supported by the extension.
 * @param {Array<u2f.SignRequest>} signRequests
 * @param {number} timeoutSeconds
 * @param {number} reqId
 * @return {Object}
 */
u2f.formatSignRequest_ =
  function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {
  if (js_api_version === undefined || js_api_version < 1.1) {
    // Adapt request to the 1.0 JS API
    var signRequests = [];
    for (var i = 0; i < registeredKeys.length; i++) {
      signRequests[i] = {
          version: registeredKeys[i].version,
          challenge: challenge,
          keyHandle: registeredKeys[i].keyHandle,
          appId: appId
      };
    }
    return {
      type: u2f.MessageTypes.U2F_SIGN_REQUEST,
      signRequests: signRequests,
      timeoutSeconds: timeoutSeconds,
      requestId: reqId
    };
  }
  // JS 1.1 API
  return {
    type: u2f.MessageTypes.U2F_SIGN_REQUEST,
    appId: appId,
    challenge: challenge,
    registeredKeys: registeredKeys,
    timeoutSeconds: timeoutSeconds,
    requestId: reqId
  };
};

/**
 * Format and return a register request compliant with the JS API version supported by the extension..
 * @param {Array<u2f.SignRequest>} signRequests
 * @param {Array<u2f.RegisterRequest>} signRequests
 * @param {number} timeoutSeconds
 * @param {number} reqId
 * @return {Object}
 */
u2f.formatRegisterRequest_ =
  function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {
  if (js_api_version === undefined || js_api_version < 1.1) {
    // Adapt request to the 1.0 JS API
    for (var i = 0; i < registerRequests.length; i++) {
      registerRequests[i].appId = appId;
    }
    var signRequests = [];
    for (var i = 0; i < registeredKeys.length; i++) {
      signRequests[i] = {
          version: registeredKeys[i].version,
          challenge: registerRequests[0],
          keyHandle: registeredKeys[i].keyHandle,
          appId: appId
      };
    }
    return {
      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
      signRequests: signRequests,
      registerRequests: registerRequests,
      timeoutSeconds: timeoutSeconds,
      requestId: reqId
    };
  }
  // JS 1.1 API
  return {
    type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
    appId: appId,
    registerRequests: registerRequests,
    registeredKeys: registeredKeys,
    timeoutSeconds: timeoutSeconds,
    requestId: reqId
  };
};


/**
 * Posts a message on the underlying channel.
 * @param {Object} message
 */
u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
  this.port_.postMessage(message);
};


/**
 * Emulates the HTML 5 addEventListener interface. Works only for the
 * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.
 * @param {string} eventName
 * @param {function({data: Object})} handler
 */
u2f.WrappedChromeRuntimePort_.prototype.addEventListener =
    function(eventName, handler) {
  var name = eventName.toLowerCase();
  if (name == 'message' || name == 'onmessage') {
    this.port_.onMessage.addListener(function(message) {
      // Emulate a minimal MessageEvent object
      handler({'data': message});
    });
  } else {
    console.error('WrappedChromeRuntimePort only supports onMessage');
  }
};

/**
 * Wrap the Authenticator app with a MessagePort interface.
 * @constructor
 * @private
 */
u2f.WrappedAuthenticatorPort_ = function() {
  this.requestId_ = -1;
  this.requestObject_ = null;
}

/**
 * Launch the Authenticator intent.
 * @param {Object} message
 */
u2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {
  var intentUrl =
    u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +
    ';S.request=' + encodeURIComponent(JSON.stringify(message)) +
    ';end';
  document.location = intentUrl;
};

/**
 * Tells what type of port this is.
 * @return {String} port type
 */
u2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {
  return "WrappedAuthenticatorPort_";
};


/**
 * Emulates the HTML 5 addEventListener interface.
 * @param {string} eventName
 * @param {function({data: Object})} handler
 */
u2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {
  var name = eventName.toLowerCase();
  if (name == 'message') {
    var self = this;
    /* Register a callback to that executes when
     * chrome injects the response. */
    window.addEventListener(
        'message', self.onRequestUpdate_.bind(self, handler), false);
  } else {
    console.error('WrappedAuthenticatorPort only supports message');
  }
};

/**
 * Callback invoked  when a response is received from the Authenticator.
 * @param function({data: Object}) callback
 * @param {Object} message message Object
 */
u2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =
    function(callback, message) {
  var messageObject = JSON.parse(message.data);
  var intentUrl = messageObject['intentURL'];

  var errorCode = messageObject['errorCode'];
  var responseObject = null;
  if (messageObject.hasOwnProperty('data')) {
    responseObject = /** @type {Object} */ (
        JSON.parse(messageObject['data']));
  }

  callback({'data': responseObject});
};

/**
 * Base URL for intents to Authenticator.
 * @const
 * @private
 */
u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =
  'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';

/**
 * Wrap the iOS client app with a MessagePort interface.
 * @constructor
 * @private
 */
u2f.WrappedIosPort_ = function() {};

/**
 * Launch the iOS client app request
 * @param {Object} message
 */
u2f.WrappedIosPort_.prototype.postMessage = function(message) {
  var str = JSON.stringify(message);
  var url = "u2f://auth?" + encodeURI(str);
  location.replace(url);
};

/**
 * Tells what type of port this is.
 * @return {String} port type
 */
u2f.WrappedIosPort_.prototype.getPortType = function() {
  return "WrappedIosPort_";
};

/**
 * Emulates the HTML 5 addEventListener interface.
 * @param {string} eventName
 * @param {function({data: Object})} handler
 */
u2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {
  var name = eventName.toLowerCase();
  if (name !== 'message') {
    console.error('WrappedIosPort only supports message');
  }
};

/**
 * Sets up an embedded trampoline iframe, sourced from the extension.
 * @param {function(MessagePort)} callback
 * @private
 */
u2f.getIframePort_ = function(callback) {
  // Create the iframe
  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;
  var iframe = document.createElement('iframe');
  iframe.src = iframeOrigin + '/u2f-comms.html';
  iframe.setAttribute('style', 'display:none');
  document.body.appendChild(iframe);

  var channel = new MessageChannel();
  var ready = function(message) {
    if (message.data == 'ready') {
      channel.port1.removeEventListener('message', ready);
      callback(channel.port1);
    } else {
      console.error('First event on iframe port was not "ready"');
    }
  };
  channel.port1.addEventListener('message', ready);
  channel.port1.start();

  iframe.addEventListener('load', function() {
    // Deliver the port to the iframe and initialize
    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);
  });
};


//High-level JS API

/**
 * Default extension response timeout in seconds.
 * @const
 */
u2f.EXTENSION_TIMEOUT_SEC = 30;

/**
 * A singleton instance for a MessagePort to the extension.
 * @type {MessagePort|u2f.WrappedChromeRuntimePort_}
 * @private
 */
u2f.port_ = null;

/**
 * Callbacks waiting for a port
 * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}
 * @private
 */
u2f.waitingForPort_ = [];

/**
 * A counter for requestIds.
 * @type {number}
 * @private
 */
u2f.reqCounter_ = 0;

/**
 * A map from requestIds to client callbacks
 * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))
 *                       |function((u2f.Error|u2f.SignResponse)))>}
 * @private
 */
u2f.callbackMap_ = {};

/**
 * Creates or retrieves the MessagePort singleton to use.
 * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
 * @private
 */
u2f.getPortSingleton_ = function(callback) {
  if (u2f.port_) {
    callback(u2f.port_);
  } else {
    if (u2f.waitingForPort_.length == 0) {
      u2f.getMessagePort(function(port) {
        u2f.port_ = port;
        u2f.port_.addEventListener('message',
            /** @type {function(Event)} */ (u2f.responseHandler_));

        // Careful, here be async callbacks. Maybe.
        while (u2f.waitingForPort_.length)
          u2f.waitingForPort_.shift()(u2f.port_);
      });
    }
    u2f.waitingForPort_.push(callback);
  }
};

/**
 * Handles response messages from the extension.
 * @param {MessageEvent.<u2f.Response>} message
 * @private
 */
u2f.responseHandler_ = function(message) {
  var response = message.data;
  var reqId = response['requestId'];
  if (!reqId || !u2f.callbackMap_[reqId]) {
    console.error('Unknown or missing requestId in response.');
    return;
  }
  var cb = u2f.callbackMap_[reqId];
  delete u2f.callbackMap_[reqId];
  cb(response['responseData']);
};

/**
 * Calls the callback with true or false as first and only argument
 * @param {Function} callback
 */
u2f.isSupported = function(callback) {
  var hasCalledBack = false;
  function reply(value) {
    if (hasCalledBack)
      return;
    hasCalledBack = true;
    callback(value);
  }
  u2f.getApiVersion(
    function (response) {
      js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];
      reply(true);
    }
  );
  // No response from extension within 1500ms -> no support
  setTimeout(reply.bind(null, false), 1500);
};

/**
 * Dispatches an array of sign requests to available U2F tokens.
 * If the JS API version supported by the extension is unknown, it first sends a
 * message to the extension to find out the supported API version and then it sends
 * the sign request.
 * @param {string=} appId
 * @param {string=} challenge
 * @param {Array<u2f.RegisteredKey>} registeredKeys
 * @param {function((u2f.Error|u2f.SignResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
  if (js_api_version === undefined) {
    // Send a message to get the extension to JS API version, then send the actual sign request.
    u2f.getApiVersion(
        function (response) {
          js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];
          console.log("Extension JS API Version: ", js_api_version);
          u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
        });
  } else {
    // We know the JS API version. Send the actual sign request in the supported API version.
    u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);
  }
};

/**
 * Dispatches an array of sign requests to available U2F tokens.
 * @param {string=} appId
 * @param {string=} challenge
 * @param {Array<u2f.RegisteredKey>} registeredKeys
 * @param {function((u2f.Error|u2f.SignResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {
  u2f.getPortSingleton_(function(port) {
    var reqId = ++u2f.reqCounter_;
    u2f.callbackMap_[reqId] = callback;
    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?
        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);
    var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);
    port.postMessage(req);
  });
};

/**
 * Dispatches register requests to available U2F tokens. An array of sign
 * requests identifies already registered tokens.
 * If the JS API version supported by the extension is unknown, it first sends a
 * message to the extension to find out the supported API version and then it sends
 * the register request.
 * @param {string=} appId
 * @param {Array<u2f.RegisterRequest>} registerRequests
 * @param {Array<u2f.RegisteredKey>} registeredKeys
 * @param {function((u2f.Error|u2f.RegisterResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
  if (js_api_version === undefined) {
    // Send a message to get the extension to JS API version, then send the actual register request.
    u2f.getApiVersion(
        function (response) {
          js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];
          console.log("Extension JS API Version: ", js_api_version);
          u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,
              callback, opt_timeoutSeconds);
        });
  } else {
    // We know the JS API version. Send the actual register request in the supported API version.
    u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,
        callback, opt_timeoutSeconds);
  }
};

/**
 * Dispatches register requests to available U2F tokens. An array of sign
 * requests identifies already registered tokens.
 * @param {string=} appId
 * @param {Array<u2f.RegisterRequest>} registerRequests
 * @param {Array<u2f.RegisteredKey>} registeredKeys
 * @param {function((u2f.Error|u2f.RegisterResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {
  u2f.getPortSingleton_(function(port) {
    var reqId = ++u2f.reqCounter_;
    u2f.callbackMap_[reqId] = callback;
    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?
        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);
    var req = u2f.formatRegisterRequest_(
        appId, registeredKeys, registerRequests, timeoutSeconds, reqId);
    port.postMessage(req);
  });
};


/**
 * Dispatches a message to the extension to find out the supported
 * JS API version.
 * If the user is on a mobile phone and is thus using Google Authenticator instead
 * of the Chrome extension, don't send the request and simply return 0.
 * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback
 * @param {number=} opt_timeoutSeconds
 */
u2f.getApiVersion = function(callback, opt_timeoutSeconds) {
 u2f.getPortSingleton_(function(port) {
   // If we are using Android Google Authenticator or iOS client app,
   // do not fire an intent to ask which JS API version to use.
   if (port.getPortType) {
     var apiVersion;
     switch (port.getPortType()) {
       case 'WrappedIosPort_':
       case 'WrappedAuthenticatorPort_':
         apiVersion = 1.1;
         break;

       default:
         apiVersion = 0;
         break;
     }
     callback({ 'js_api_version': apiVersion });
     return;
   }
    var reqId = ++u2f.reqCounter_;
    u2f.callbackMap_[reqId] = callback;
    var req = {
      type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,
      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
      requestId: reqId
    };
    port.postMessage(req);
  });
};


/***/ }),

/***/ "./node_modules/u2f-api/dist/lib/u2f-api.js":
/*!**************************************************!*\
  !*** ./node_modules/u2f-api/dist/lib/u2f-api.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
var generated_google_u2f_api_1 = __webpack_require__(/*! ./generated-google-u2f-api */ "./node_modules/u2f-api/dist/lib/generated-google-u2f-api.js");
// Feature detection (yes really)
// For IE and Edge detection, see https://stackoverflow.com/questions/31757852#31757969
// and https://stackoverflow.com/questions/56360225#56361977
var isBrowser = (typeof navigator !== 'undefined') && !!navigator.userAgent;
var isSafari = isBrowser && navigator.userAgent.match(/Safari\//)
    && !navigator.userAgent.match(/Chrome\//);
var isEDGE = isBrowser && /(Edge\/)|(edg\/)/i.test(navigator.userAgent);
var isIE = isBrowser && /(MSIE 9|MSIE 10|rv:11.0)/i.test(navigator.userAgent);
var _backend = null;
function getBackend() {
    if (_backend)
        return _backend;
    var supportChecker = new Promise(function (resolve, reject) {
        function notSupported() {
            resolve({ u2f: null });
        }
        if (!isBrowser)
            return notSupported();
        if (isSafari)
            // Safari doesn't support U2F, and the Safari-FIDO-U2F
            // extension lacks full support (Multi-facet apps), so we
            // block it until proper support.
            return notSupported();
        var hasNativeSupport = (typeof window.u2f !== 'undefined') &&
            (typeof window.u2f.sign === 'function');
        if (hasNativeSupport)
            return resolve({ u2f: window.u2f });
        if (isEDGE || isIE)
            // We don't want to check for Google's extension hack on EDGE & IE
            // as it'll cause trouble (popups, etc)
            return notSupported();
        if (location.protocol === 'http:')
            // U2F isn't supported over http, only https
            return notSupported();
        if (typeof MessageChannel === 'undefined')
            // Unsupported browser, the chrome hack would throw
            return notSupported();
        // Test for google extension support
        generated_google_u2f_api_1.chromeApi.isSupported(function (ok) {
            if (ok)
                resolve({ u2f: generated_google_u2f_api_1.chromeApi });
            else
                notSupported();
        });
    })
        .then(function (response) {
        _backend = response.u2f ? supportChecker : null;
        return response;
    });
    return supportChecker;
}
exports.ErrorCodes = {
    OK: 0,
    OTHER_ERROR: 1,
    BAD_REQUEST: 2,
    CONFIGURATION_UNSUPPORTED: 3,
    DEVICE_INELIGIBLE: 4,
    TIMEOUT: 5
};
exports.ErrorNames = {
    "0": "OK",
    "1": "OTHER_ERROR",
    "2": "BAD_REQUEST",
    "3": "CONFIGURATION_UNSUPPORTED",
    "4": "DEVICE_INELIGIBLE",
    "5": "TIMEOUT"
};
function makeError(msg, err) {
    var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR
    var type = exports.ErrorNames[('' + code)];
    var error = new Error(msg);
    error.metaData = { type: type, code: code };
    return error;
}
function isSupported() {
    return getBackend()
        .then(function (backend) { return !!backend.u2f; });
}
exports.isSupported = isSupported;
function _ensureSupport(backend) {
    if (!backend.u2f) {
        if (location.protocol === 'http:')
            throw new Error("U2F isn't supported over http, only https");
        throw new Error("U2F not supported");
    }
}
function ensureSupport() {
    return getBackend()
        .then(_ensureSupport);
}
exports.ensureSupport = ensureSupport;
function arrayify(value) {
    if (value != null && Array.isArray(value))
        return value;
    return value == null
        ? []
        : Array.isArray(value)
            ? value.slice() : [value];
}
function register(registerRequests, signRequests, timeout) {
    var _registerRequests = arrayify(registerRequests);
    if (typeof signRequests === 'number' && typeof timeout === 'undefined') {
        timeout = signRequests;
        signRequests = [];
    }
    var _signRequests = arrayify(signRequests);
    return getBackend()
        .then(function (backend) {
        _ensureSupport(backend);
        var u2f = backend.u2f;
        return new Promise(function (resolve, reject) {
            function callback(response) {
                if (response.errorCode)
                    reject(makeError("Registration failed", response));
                else {
                    delete response.errorCode;
                    resolve(response);
                }
            }
            var appId = _registerRequests[0].appId;
            u2f.register(appId, _registerRequests, _signRequests, callback, timeout);
        });
    });
}
exports.register = register;
function sign(signRequests, timeout) {
    var _signRequests = arrayify(signRequests);
    return getBackend()
        .then(function (backend) {
        _ensureSupport(backend);
        var u2f = backend.u2f;
        return new Promise(function (resolve, reject) {
            var _a;
            function callback(response) {
                if (response.errorCode)
                    reject(makeError("Sign failed", response));
                else {
                    delete response.errorCode;
                    resolve(response);
                }
            }
            var appId = _signRequests[0].appId;
            var challenge = _signRequests[0].challenge;
            var registeredKeys = (_a = []).concat.apply(_a, _signRequests
                .map(function (_a) {
                var version = _a.version, keyHandle = _a.keyHandle, appId = _a.appId;
                return arrayify(keyHandle)
                    .map(function (keyHandle) {
                    return ({ version: version, keyHandle: keyHandle, appId: appId });
                });
            }));
            u2f.sign(appId, challenge, registeredKeys, callback, timeout);
        });
    });
}
exports.sign = sign;
//# sourceMappingURL=u2f-api.js.map

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--8-oneOf-1-0!./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("860e7842", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(true) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&", function() {
     var newContent = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&");
     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--8-oneOf-1-0!./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("36b6f059", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(true) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&", function() {
     var newContent = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&");
     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader??ref--8-oneOf-1-0!./node_modules/css-loader??ref--8-oneOf-1-1!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src??ref--8-oneOf-1-2!./node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! ../../../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("7e93f330", content, false, {"sourceMap":false,"shadowMode":false});
// Hot Module Replacement
if(true) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&", function() {
     var newContent = __webpack_require__(/*! !../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& */ "./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&");
     if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':')
    var key = parts.shift().trim()
    if (key) {
      var value = parts.join(':').trim()
      headers.append(key, value)
    }
  })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : 'OK'
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = self.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      resolve(new Response(body, options))
    }

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'))
    }

    xhr.onabort = function() {
      reject(new DOMException('Aborted', 'AbortError'))
    }

    xhr.open(request.method, request.url, true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob'
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value)
    })

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!self.fetch) {
  self.fetch = fetch
  self.Headers = Headers
  self.Request = Request
  self.Response = Response
}


/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js!./src/workers/wallet.worker.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js!./src/workers/wallet.worker.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "0e98863a26b11b92bb38.worker.js");
};

/***/ }),

/***/ "./src/assets/images/icons/hide-password.svg":
/*!***************************************************!*\
  !*** ./src/assets/images/icons/hide-password.svg ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/hide-password.svg";

/***/ }),

/***/ "./src/assets/images/icons/show-password.svg":
/*!***************************************************!*\
  !*** ./src/assets/images/icons/show-password.svg ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/show-password.svg";

/***/ }),

/***/ "./src/builds/mewcx/cxHelpers/cxEvents.js":
/*!************************************************!*\
  !*** ./src/builds/mewcx/cxHelpers/cxEvents.js ***!
  \************************************************/
/*! exports provided: WEB3_DETECTED, INJECT_WEB3, SELECTED_MEW_CX_ACC, MEW_TX_HASH, MEW_SIGNED_MSG, REJECT_MEW_CX_ACC, REJECT_MEW_TX_SIGN, REJECT_MEW_SIGN_MSG, WEB3_GET_ACC, WEB3_SEND_TX, WEB3_SEND_SIGN_MSG, WEB3_RECEIVE_ACC, WEB3_RECEIVE_TX_HASH, WEB3_RECEIVE_SIGNED_MSG, WEB3_REJECT, WEB3_NETWORK_CHANGE, WEB3_CHAIN_CHANGE, CX_FETCH_MEW_ACCS, CX_WEB3_DETECTED, CX_CONFIRM_SEND_TX, CX_SIGN_MSG, CX_INJECT_WEB3, CX_SEND_SIGNED_TX, WEB3_RPC_REQUEST, NETWORK_SWITCH_AND_CHAIN_ID, WEB3_INJECT_SUCCESS, CX_SUBSCRIBE, WEB3_SUBSCRIBE_LISTENER, WEB3_SUBSCRIPTION_LISTENER, WEB3_SUBSCRIBE, WEB3_SUBSCRIBE_RES, WEB3_SUBSCRIBTION_RES, WEB3_SUBSCRIPTION_ERR, WEB3_UNSUBSCRIBE, CX_UNSUBSCRIBE, WEB3_UNSUBSCRIBE_RES, WEB3_QUERY_GASPRICE, WEB3_RECEIVE_GASPRICE, CX_GET_GASPRICE, WEB3_GET_TX_COUNT, CX_GET_TX_COUNT, WEB3_RECEIVE_TX_COUNT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_DETECTED", function() { return WEB3_DETECTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INJECT_WEB3", function() { return INJECT_WEB3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SELECTED_MEW_CX_ACC", function() { return SELECTED_MEW_CX_ACC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEW_TX_HASH", function() { return MEW_TX_HASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MEW_SIGNED_MSG", function() { return MEW_SIGNED_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REJECT_MEW_CX_ACC", function() { return REJECT_MEW_CX_ACC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REJECT_MEW_TX_SIGN", function() { return REJECT_MEW_TX_SIGN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REJECT_MEW_SIGN_MSG", function() { return REJECT_MEW_SIGN_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_GET_ACC", function() { return WEB3_GET_ACC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SEND_TX", function() { return WEB3_SEND_TX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SEND_SIGN_MSG", function() { return WEB3_SEND_SIGN_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RECEIVE_ACC", function() { return WEB3_RECEIVE_ACC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RECEIVE_TX_HASH", function() { return WEB3_RECEIVE_TX_HASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RECEIVE_SIGNED_MSG", function() { return WEB3_RECEIVE_SIGNED_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_REJECT", function() { return WEB3_REJECT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_NETWORK_CHANGE", function() { return WEB3_NETWORK_CHANGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_CHAIN_CHANGE", function() { return WEB3_CHAIN_CHANGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_FETCH_MEW_ACCS", function() { return CX_FETCH_MEW_ACCS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_WEB3_DETECTED", function() { return CX_WEB3_DETECTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_CONFIRM_SEND_TX", function() { return CX_CONFIRM_SEND_TX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_SIGN_MSG", function() { return CX_SIGN_MSG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_INJECT_WEB3", function() { return CX_INJECT_WEB3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_SEND_SIGNED_TX", function() { return CX_SEND_SIGNED_TX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RPC_REQUEST", function() { return WEB3_RPC_REQUEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NETWORK_SWITCH_AND_CHAIN_ID", function() { return NETWORK_SWITCH_AND_CHAIN_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_INJECT_SUCCESS", function() { return WEB3_INJECT_SUCCESS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_SUBSCRIBE", function() { return CX_SUBSCRIBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIBE_LISTENER", function() { return WEB3_SUBSCRIBE_LISTENER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIPTION_LISTENER", function() { return WEB3_SUBSCRIPTION_LISTENER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIBE", function() { return WEB3_SUBSCRIBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIBE_RES", function() { return WEB3_SUBSCRIBE_RES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIBTION_RES", function() { return WEB3_SUBSCRIBTION_RES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_SUBSCRIPTION_ERR", function() { return WEB3_SUBSCRIPTION_ERR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_UNSUBSCRIBE", function() { return WEB3_UNSUBSCRIBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_UNSUBSCRIBE", function() { return CX_UNSUBSCRIBE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_UNSUBSCRIBE_RES", function() { return WEB3_UNSUBSCRIBE_RES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_QUERY_GASPRICE", function() { return WEB3_QUERY_GASPRICE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RECEIVE_GASPRICE", function() { return WEB3_RECEIVE_GASPRICE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_GET_GASPRICE", function() { return CX_GET_GASPRICE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_GET_TX_COUNT", function() { return WEB3_GET_TX_COUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CX_GET_TX_COUNT", function() { return CX_GET_TX_COUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEB3_RECEIVE_TX_COUNT", function() { return WEB3_RECEIVE_TX_COUNT; });
var WEB3_DETECTED = 'web3{{id}}web3Detected';
var INJECT_WEB3 = 'injectWeb3';
var SELECTED_MEW_CX_ACC = 'selectedMewCXAccount';
var MEW_TX_HASH = 'mewTxHash';
var MEW_SIGNED_MSG = 'mewSignedMsg';
var REJECT_MEW_CX_ACC = 'rejectMewCXAccount';
var REJECT_MEW_TX_SIGN = 'rejectMewTxSign';
var REJECT_MEW_SIGN_MSG = 'rejectMewSignMsg';
var WEB3_GET_ACC = 'web3{{id}}getAccount';
var WEB3_SEND_TX = 'web3{{id}}sendTx';
var WEB3_SEND_SIGN_MSG = 'web3{{id}}sendSignMsg';
var WEB3_RECEIVE_ACC = 'web3{{id}}receiveAccount';
var WEB3_RECEIVE_TX_HASH = 'web3{{id}}recieveTxHash';
var WEB3_RECEIVE_SIGNED_MSG = 'web3{{id}}recieveSignedMsg';
var WEB3_REJECT = 'web3{{id}}reject';
var WEB3_NETWORK_CHANGE = 'web3{{id}}providerNetworkChange';
var WEB3_CHAIN_CHANGE = 'web3{{id}}providerChainChange';
var CX_FETCH_MEW_ACCS = 'mewCxFetchAccounts';
var CX_WEB3_DETECTED = 'web3Detected';
var CX_CONFIRM_SEND_TX = 'confirmAndSendTx';
var CX_SIGN_MSG = 'signMsg';
var CX_INJECT_WEB3 = 'injectWeb3';
var CX_SEND_SIGNED_TX = 'sendSignedTx';
var WEB3_RPC_REQUEST = 'web3RPCRequest';
var NETWORK_SWITCH_AND_CHAIN_ID = 'networkAndChainIdChanged';
var WEB3_INJECT_SUCCESS = 'web3{{id}}ScriptInjectedSuccessfuly';
var CX_SUBSCRIBE = 'cxSubscription';
var WEB3_SUBSCRIBE_LISTENER = 'web3{{id}}SubscribeListener';
var WEB3_SUBSCRIPTION_LISTENER = 'web3{{id}}SubscriptionListener';
var WEB3_SUBSCRIBE = 'web3{{id}}Subscribe';
var WEB3_SUBSCRIBE_RES = 'web3SubscribeRes';
var WEB3_SUBSCRIBTION_RES = 'web3SubscribtionRes';
var WEB3_SUBSCRIPTION_ERR = 'web3SubscriptionErr';
var WEB3_UNSUBSCRIBE = 'web3{{id}}Unsubscribe';
var CX_UNSUBSCRIBE = 'cxUnsubcribe';
var WEB3_UNSUBSCRIBE_RES = 'web3{{id}}UnsubscribeRes';
var WEB3_QUERY_GASPRICE = 'web3{{id}}QueryGasPrice';
var WEB3_RECEIVE_GASPRICE = 'web3{{id}}ReceiveGasPrice';
var CX_GET_GASPRICE = 'cxGetGasPrice';
var WEB3_GET_TX_COUNT = 'web3{{id}}GetTxCount';
var CX_GET_TX_COUNT = 'cxGetTxCount';
var WEB3_RECEIVE_TX_COUNT = 'web3{{id}}ReceiveTxCount';


/***/ }),

/***/ "./src/helpers/commonGenerator.js":
/*!****************************************!*\
  !*** ./src/helpers/commonGenerator.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var ethereumjs_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethereumjs-common */ "./node_modules/ethereumjs-common/dist/index.js");
/* harmony import */ var ethereumjs_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_common__WEBPACK_IMPORTED_MODULE_0__);


var commonGenerator = function commonGenerator(network) {
  var customCommon = ethereumjs_common__WEBPACK_IMPORTED_MODULE_0___default.a.forCustomChain('mainnet', {
    name: network.type.name_long,
    chainId: network.type.chainID
  });
  return new ethereumjs_common__WEBPACK_IMPORTED_MODULE_0___default.a(customCommon._chainParams, 'petersburg', ['petersburg']);
};

/* harmony default export */ __webpack_exports__["default"] = (commonGenerator);

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue":
/*!***********************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&");
/* harmony import */ var _AcceptCancelButtons_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AcceptCancelButtons.vue?vue&type=script&lang=js& */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _AcceptCancelButtons_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  true,
  null,
  "5012fca8",
  null
  
)

/* hot reload */
if (true) {
  var api = __webpack_require__(/*! ./node_modules/vue-hot-reload-api/dist/index.js */ "./node_modules/vue-hot-reload-api/dist/index.js")
  api.install(__webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js"))
  if (api.compatible) {
    module.hot.accept()
    if (!api.isRecorded('5012fca8')) {
      api.createRecord('5012fca8', component.options)
    } else {
      api.rerender('5012fca8', component.options)
    }
    module.hot.accept(/*! ./AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&");
(function () {
      api.rerender('5012fca8', {
        render: _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["render"],
        staticRenderFns: _AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]
      })
    })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))
  }
}
component.options.__file = "src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js&":
/*!************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../../node_modules/babel-loader/lib!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&":
/*!*********************************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& ***!
  \*********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/vue-style-loader??ref--8-oneOf-1-0!../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=style&index=0&id=5012fca8&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_style_index_0_id_5012fca8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&":
/*!**********************************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& ***!
  \**********************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!cache-loader?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!../../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue?vue&type=template&id=5012fca8&scoped=true&functional=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AcceptCancelButtons_vue_vue_type_template_id_5012fca8_scoped_true_functional_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/index.js":
/*!********************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/index.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AcceptCancelButtons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AcceptCancelButtons */ "./src/layouts/ExtensionWeb3Popup/components/AcceptCancelButtons/AcceptCancelButtons.vue");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _AcceptCancelButtons__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue":
/*!*****************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&");
/* harmony import */ var _PasswordModalComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PasswordModalComponent.vue?vue&type=script&lang=js& */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _PasswordModalComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "19018dc8",
  null
  
)

/* hot reload */
if (true) {
  var api = __webpack_require__(/*! ./node_modules/vue-hot-reload-api/dist/index.js */ "./node_modules/vue-hot-reload-api/dist/index.js")
  api.install(__webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js"))
  if (api.compatible) {
    module.hot.accept()
    if (!api.isRecorded('19018dc8')) {
      api.createRecord('19018dc8', component.options)
    } else {
      api.reload('19018dc8', component.options)
    }
    module.hot.accept(/*! ./PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&");
(function () {
      api.rerender('19018dc8', {
        render: _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
        staticRenderFns: _PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]
      })
    })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))
  }
}
component.options.__file = "src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../../node_modules/babel-loader/lib!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&":
/*!***************************************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& ***!
  \***************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/vue-style-loader??ref--8-oneOf-1-0!../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=style&index=0&id=19018dc8&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_style_index_0_id_19018dc8_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&":
/*!************************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& ***!
  \************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!cache-loader?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!../../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue?vue&type=template&id=19018dc8&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_PasswordModalComponent_vue_vue_type_template_id_19018dc8_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/index.js":
/*!***********************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/index.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PasswordModalComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PasswordModalComponent */ "./src/layouts/ExtensionWeb3Popup/components/PasswordModalComponent/PasswordModalComponent.vue");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _PasswordModalComponent__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue":
/*!*****************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&");
/* harmony import */ var _SignMsgContainer_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SignMsgContainer.vue?vue&type=script&lang=js& */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport *//* harmony import */ var _SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");






/* normalize component */

var component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _SignMsgContainer_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
  _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"],
  false,
  null,
  "252e4c84",
  null
  
)

/* hot reload */
if (true) {
  var api = __webpack_require__(/*! ./node_modules/vue-hot-reload-api/dist/index.js */ "./node_modules/vue-hot-reload-api/dist/index.js")
  api.install(__webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js"))
  if (api.compatible) {
    module.hot.accept()
    if (!api.isRecorded('252e4c84')) {
      api.createRecord('252e4c84', component.options)
    } else {
      api.reload('252e4c84', component.options)
    }
    module.hot.accept(/*! ./SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&", function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&");
(function () {
      api.rerender('252e4c84', {
        render: _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"],
        staticRenderFns: _SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]
      })
    })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))
  }
}
component.options.__file = "src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../../node_modules/babel-loader/lib!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=script&lang=js& */ "./node_modules/cache-loader/dist/cjs.js?!./node_modules/babel-loader/lib/index.js!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=script&lang=js&");
/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__["default"] = (_node_modules_cache_loader_dist_cjs_js_ref_12_0_node_modules_babel_loader_lib_index_js_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&":
/*!***************************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& ***!
  \***************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../node_modules/vue-style-loader??ref--8-oneOf-1-0!../../../../../node_modules/css-loader??ref--8-oneOf-1-1!../../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../../node_modules/postcss-loader/src??ref--8-oneOf-1-2!../../../../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true& */ "./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/index.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/sass-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=style&index=0&id=252e4c84&lang=scss&scoped=true&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_vue_style_loader_index_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_style_index_0_id_252e4c84_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); 

/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&":
/*!************************************************************************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& ***!
  \************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!cache-loader?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3c565626-vue-loader-template"}!../../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../../node_modules/vue-loader/lib??vue-loader-options!./SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true& */ "./node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"3c565626-vue-loader-template\"}!./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue?vue&type=template&id=252e4c84&scoped=true&");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _cache_loader_cacheDirectory_node_modules_cache_vue_loader_cacheIdentifier_3c565626_vue_loader_template_node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_SignMsgContainer_vue_vue_type_template_id_252e4c84_scoped_true___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });



/***/ }),

/***/ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/index.js":
/*!*****************************************************************************!*\
  !*** ./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/index.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _SignMsgContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignMsgContainer */ "./src/layouts/ExtensionWeb3Popup/containers/SignMsgContainer/SignMsgContainer.vue");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _SignMsgContainer__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./src/wallets/HDWalletInterface.js":
/*!******************************************!*\
  !*** ./src/wallets/HDWalletInterface.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/get */ "./node_modules/@babel/runtime-corejs2/helpers/esm/get.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/inherits */ "./node_modules/@babel/runtime-corejs2/helpers/esm/inherits.js");
/* harmony import */ var _WalletInterface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WalletInterface */ "./src/wallets/WalletInterface.js");








var HDWalletInterface =
/*#__PURE__*/
function (_WalletInterface) {
  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(HDWalletInterface, _WalletInterface);

  function HDWalletInterface(path, pubkey, isHardware, identifier, errorHandler, txSigner, msgSigner, displayAddress) {
    var _this;

    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, HDWalletInterface);

    _this = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(HDWalletInterface).call(this, pubkey, true, identifier));
    _this.path = path;
    _this.txSigner = txSigner;
    _this.msgSigner = msgSigner;
    _this.isHardware = isHardware;
    _this.errorHandler = errorHandler;
    _this.displayAddress = displayAddress;
    return _this;
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(HDWalletInterface, [{
    key: "signTransaction",
    value: function signTransaction(txParams) {
      return Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(HDWalletInterface.prototype), "signTransaction", this).call(this, txParams, this.txSigner);
    }
  }, {
    key: "signMessage",
    value: function signMessage(msg) {
      return Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(HDWalletInterface.prototype), "signMessage", this).call(this, msg, this.msgSigner);
    }
  }]);

  return HDWalletInterface;
}(_WalletInterface__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (HDWalletInterface);

/***/ }),

/***/ "./src/wallets/WalletInterface.js":
/*!****************************************!*\
  !*** ./src/wallets/WalletInterface.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/wallets/utils.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _helpers_addressUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/helpers/addressUtils */ "./src/helpers/addressUtils.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/store */ "./src/store/index.js");









var WalletInterface =
/*#__PURE__*/
function () {
  function WalletInterface(key) {
    var isPub = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var identifier = arguments.length > 2 ? arguments[2] : undefined;
    var nick = arguments.length > 3 ? arguments[3] : undefined;
    var keystore = arguments.length > 4 ? arguments[4] : undefined;

    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, WalletInterface);

    this.nickname = nick !== null && nick !== '' ? nick : '';
    this.keystore = keystore !== null && keystore !== '' ? keystore : '';
    this.identifier = identifier;

    if (!isPub) {
      var _privKey = Buffer.isBuffer(key) ? key : Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_2__["sanitizeHex"])(key));

      if (!Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["isValidPrivate"])(_privKey)) throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
      this.privateKey = _privKey;
      this.publicKey = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["privateToPublic"])(_privKey);
      this.isPubOnly = false;
    } else {
      var _pubKey = Buffer.isBuffer(key) ? key : Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getBufferFromHex"])(key);

      if (_pubKey.length !== 20 && !Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["isValidPublic"])(_pubKey, true)) throw new Error('Invalid public key');
      if (_pubKey.length === 20) this.isAddress = true;
      this.publicKey = _pubKey;
      this.isPubOnly = true;
    }
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(WalletInterface, [{
    key: "getPrivateKey",
    value: function getPrivateKey() {
      if (this.isPubOnly) throw new Error('public key only wallet');
      return this.privateKey;
    }
  }, {
    key: "getPrivateKeyString",
    value: function getPrivateKeyString() {
      if (this.isPubOnly) throw new Error('public key only wallet');
      return Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["bufferToHex"])(this.getPrivateKey());
    }
  }, {
    key: "getNickname",
    value: function getNickname() {
      if (this.nickname === '') return '';
      return this.nickname;
    }
  }, {
    key: "getKeystore",
    value: function getKeystore() {
      if (this.keystore === '') return '';
      return this.keystore;
    }
  }, {
    key: "getPublicKey",
    value: function getPublicKey() {
      if (this.isAddress) throw new Error('Address only wallet');
      return this.publicKey;
    }
  }, {
    key: "getPublicKeyString",
    value: function getPublicKeyString() {
      return Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["bufferToHex"])(this.getPublicKey());
    }
  }, {
    key: "getAddress",
    value: function getAddress() {
      if (this.isAddress) return this.publicKey;
      return Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["publicToAddress"])(this.publicKey, true);
    }
  }, {
    key: "getAddressString",
    value: function getAddressString() {
      return Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["bufferToHex"])(this.getAddress());
    }
  }, {
    key: "getChecksumAddressString",
    value: function getChecksumAddressString() {
      return Object(_helpers_addressUtils__WEBPACK_IMPORTED_MODULE_6__["toChecksumAddress"])(this.getAddressString());
    }
  }, {
    key: "signTransaction",
    value: function signTransaction(txParams, signer) {
      var _this = this;

      if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');
      return new Promise(function (resolve, reject) {
        if (!_this.isPubOnly) {
          var tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__["Transaction"](txParams, {
            common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(_store__WEBPACK_IMPORTED_MODULE_7__["default"].state.network)
          });
          var networkId = tx.getChainId();
          tx.sign(_this.privateKey);
          var signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["calculateChainIdFromV"])(tx.v);
          if (signedChainId !== networkId) throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');
          resolve(Object(_utils__WEBPACK_IMPORTED_MODULE_2__["getSignTransactionObject"])(tx));
        } else {
          signer(txParams).then(resolve).catch(reject);
        }
      });
    }
  }, {
    key: "signMessage",
    value: function signMessage(msg, signer) {
      var _this2 = this;

      if (this.isPubOnly && typeof signer !== 'function') throw new Error('public key only wallets needs a signer');
      return new Promise(function (resolve, reject) {
        if (!_this2.isPubOnly) {
          var msgHash = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["hashPersonalMessage"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(msg));
          var signed = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["ecsign"])(msgHash, _this2.privateKey);
          resolve(Buffer.concat([Buffer.from(signed.r), Buffer.from(signed.s), Buffer.from([signed.v])]));
        } else {
          signer(msg).then(resolve).catch(reject);
        }
      });
    }
  }]);

  return WalletInterface;
}();

/* harmony default export */ __webpack_exports__["default"] = (WalletInterface);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/bip44/bitboxPaths.js":
/*!******************************************!*\
  !*** ./src/wallets/bip44/bitboxPaths.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["ethereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["singularDTV"], _paths__WEBPACK_IMPORTED_MODULE_0__["expanse"], _paths__WEBPACK_IMPORTED_MODULE_0__["ubiq"], _paths__WEBPACK_IMPORTED_MODULE_0__["ellaism"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherGem"], _paths__WEBPACK_IMPORTED_MODULE_0__["callisto"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumSocial"], _paths__WEBPACK_IMPORTED_MODULE_0__["musicoin"], _paths__WEBPACK_IMPORTED_MODULE_0__["goChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["eosClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["akroma"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherSocialNetwork"], _paths__WEBPACK_IMPORTED_MODULE_0__["pirl"], _paths__WEBPACK_IMPORTED_MODULE_0__["ether1"], _paths__WEBPACK_IMPORTED_MODULE_0__["atheios"], _paths__WEBPACK_IMPORTED_MODULE_0__["tomoChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["mixBlockchain"], _paths__WEBPACK_IMPORTED_MODULE_0__["iolite"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/bip44/index.js":
/*!************************************!*\
  !*** ./src/wallets/bip44/index.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty */ "./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js");
/* harmony import */ var _walletTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _ledgerPaths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ledgerPaths */ "./src/wallets/bip44/ledgerPaths.js");
/* harmony import */ var _trezorPaths__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./trezorPaths */ "./src/wallets/bip44/trezorPaths.js");
/* harmony import */ var _bitboxPaths__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bitboxPaths */ "./src/wallets/bip44/bitboxPaths.js");
/* harmony import */ var _secalotPaths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./secalotPaths */ "./src/wallets/bip44/secalotPaths.js");
/* harmony import */ var _keepkeyPaths__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keepkeyPaths */ "./src/wallets/bip44/keepkeyPaths.js");
/* harmony import */ var _mnemonicPaths__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mnemonicPaths */ "./src/wallets/bip44/mnemonicPaths.js");


var _LEDGER$TREZOR$BITBOX;








/* harmony default export */ __webpack_exports__["default"] = (_LEDGER$TREZOR$BITBOX = {}, Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["LEDGER"], _ledgerPaths__WEBPACK_IMPORTED_MODULE_2__["default"]), Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["TREZOR"], _trezorPaths__WEBPACK_IMPORTED_MODULE_3__["default"]), Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["BITBOX"], _bitboxPaths__WEBPACK_IMPORTED_MODULE_4__["default"]), Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["SECALOT"], _secalotPaths__WEBPACK_IMPORTED_MODULE_5__["default"]), Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["KEEPKEY"], _keepkeyPaths__WEBPACK_IMPORTED_MODULE_6__["default"]), Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_LEDGER$TREZOR$BITBOX, _walletTypes__WEBPACK_IMPORTED_MODULE_1__["MNEMONIC"], _mnemonicPaths__WEBPACK_IMPORTED_MODULE_7__["default"]), _LEDGER$TREZOR$BITBOX);

/***/ }),

/***/ "./src/wallets/bip44/keepkeyPaths.js":
/*!*******************************************!*\
  !*** ./src/wallets/bip44/keepkeyPaths.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["keepkeyEthereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["keepkeyEthereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["singularDTV"], _paths__WEBPACK_IMPORTED_MODULE_0__["expanse"], _paths__WEBPACK_IMPORTED_MODULE_0__["ubiq"], _paths__WEBPACK_IMPORTED_MODULE_0__["ellaism"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherGem"], _paths__WEBPACK_IMPORTED_MODULE_0__["callisto"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumSocial"], _paths__WEBPACK_IMPORTED_MODULE_0__["musicoin"], _paths__WEBPACK_IMPORTED_MODULE_0__["goChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["eosClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["akroma"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherSocialNetwork"], _paths__WEBPACK_IMPORTED_MODULE_0__["pirl"], _paths__WEBPACK_IMPORTED_MODULE_0__["ether1"], _paths__WEBPACK_IMPORTED_MODULE_0__["atheios"], _paths__WEBPACK_IMPORTED_MODULE_0__["tomoChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["mixBlockchain"], _paths__WEBPACK_IMPORTED_MODULE_0__["iolite"], _paths__WEBPACK_IMPORTED_MODULE_0__["thundercore"], _paths__WEBPACK_IMPORTED_MODULE_0__["solidum"], _paths__WEBPACK_IMPORTED_MODULE_0__["dexon"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/bip44/ledgerPaths.js":
/*!******************************************!*\
  !*** ./src/wallets/bip44/ledgerPaths.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["ledgerEthereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ledgerLiveEthereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ledgerEthereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ledgerLiveEthereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskMainnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskTestnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["thundercore"], _paths__WEBPACK_IMPORTED_MODULE_0__["solidum"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/bip44/mnemonicPaths.js":
/*!********************************************!*\
  !*** ./src/wallets/bip44/mnemonicPaths.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["ethereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["singularDTV"], _paths__WEBPACK_IMPORTED_MODULE_0__["expanse"], _paths__WEBPACK_IMPORTED_MODULE_0__["ubiq"], _paths__WEBPACK_IMPORTED_MODULE_0__["ellaism"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherGem"], _paths__WEBPACK_IMPORTED_MODULE_0__["callisto"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumSocial"], _paths__WEBPACK_IMPORTED_MODULE_0__["musicoin"], _paths__WEBPACK_IMPORTED_MODULE_0__["goChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["eosClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["akroma"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherSocialNetwork"], _paths__WEBPACK_IMPORTED_MODULE_0__["pirl"], _paths__WEBPACK_IMPORTED_MODULE_0__["ether1"], _paths__WEBPACK_IMPORTED_MODULE_0__["atheios"], _paths__WEBPACK_IMPORTED_MODULE_0__["tomoChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["mixBlockchain"], _paths__WEBPACK_IMPORTED_MODULE_0__["iolite"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskMainnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskTestnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["thundercore"], _paths__WEBPACK_IMPORTED_MODULE_0__["solidum"], _paths__WEBPACK_IMPORTED_MODULE_0__["metadium"], _paths__WEBPACK_IMPORTED_MODULE_0__["dexon"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/bip44/paths.js":
/*!************************************!*\
  !*** ./src/wallets/bip44/paths.js ***!
  \************************************/
/*! exports provided: ethereum, ethereumClassic, ledgerEthereum, ledgerLiveEthereum, ledgerEthereumClassic, ledgerLiveEthereumClassic, ropsten, singularDTV, expanse, ubiq, ellaism, etherGem, callisto, ethereumSocial, musicoin, goChain, eosClassic, akroma, etherSocialNetwork, pirl, ether1, atheios, tomoChain, mixBlockchain, iolite, rskMainnet, rskTestnet, keepkeyEthereum, keepkeyEthereumClassic, thundercore, solidum, metadium, poaNetwork, reoscChain, dexon, lightstreamsNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ethereum", function() { return ethereum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ethereumClassic", function() { return ethereumClassic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ledgerEthereum", function() { return ledgerEthereum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ledgerLiveEthereum", function() { return ledgerLiveEthereum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ledgerEthereumClassic", function() { return ledgerEthereumClassic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ledgerLiveEthereumClassic", function() { return ledgerLiveEthereumClassic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ropsten", function() { return ropsten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "singularDTV", function() { return singularDTV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expanse", function() { return expanse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ubiq", function() { return ubiq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellaism", function() { return ellaism; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "etherGem", function() { return etherGem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callisto", function() { return callisto; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ethereumSocial", function() { return ethereumSocial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "musicoin", function() { return musicoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "goChain", function() { return goChain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eosClassic", function() { return eosClassic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "akroma", function() { return akroma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "etherSocialNetwork", function() { return etherSocialNetwork; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pirl", function() { return pirl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ether1", function() { return ether1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atheios", function() { return atheios; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tomoChain", function() { return tomoChain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixBlockchain", function() { return mixBlockchain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "iolite", function() { return iolite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rskMainnet", function() { return rskMainnet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rskTestnet", function() { return rskTestnet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keepkeyEthereum", function() { return keepkeyEthereum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keepkeyEthereumClassic", function() { return keepkeyEthereumClassic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "thundercore", function() { return thundercore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solidum", function() { return solidum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "metadium", function() { return metadium; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "poaNetwork", function() { return poaNetwork; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reoscChain", function() { return reoscChain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dexon", function() { return dexon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lightstreamsNetwork", function() { return lightstreamsNetwork; });
var ethereum = {
  path: "m/44'/60'/0'/0",
  label: 'Ethereum'
};
var poaNetwork = {
  path: "m/44'/60'/0'/0",
  label: 'POA network'
};
var ethereumClassic = {
  path: "m/44'/61'/0'/0",
  label: 'Ethereum Classic'
};
var ropsten = {
  path: "m/44'/1'/0'/0",
  label: 'Ethereum Testnet (Ropsten)'
};
var singularDTV = {
  path: "m/0'/0'/0'",
  label: 'SingularDTV'
};
var expanse = {
  path: "m/44'/40'/0'/0",
  label: 'Expanse'
};
var ubiq = {
  path: "m/44'/108'/0'/0",
  label: 'Ubiq'
};
var ellaism = {
  path: "m/44'/163'/0'/0",
  label: 'Ellaism'
};
var etherGem = {
  path: "m/44'/1987'/0'/0",
  label: 'EtherGem'
};
var callisto = {
  path: "m/44'/820'/0'/0",
  label: 'Callisto'
};
var ethereumSocial = {
  path: "m/44'/1128'/0'/0",
  label: 'Ethereum Social'
};
var musicoin = {
  path: "m/44'/184'/0'/0",
  label: 'Musicoin'
};
var goChain = {
  path: "m/44'/6060'/0'/0",
  label: 'GoChain'
};
var eosClassic = {
  path: "m/44'/2018'/0'/0",
  label: 'EOS Classic'
};
var akroma = {
  path: "m/44'/200625'/0'/0",
  label: 'Akroma'
};
var etherSocialNetwork = {
  path: "m/44'/31102'/0'/0",
  label: 'EtherSocial Network'
};
var pirl = {
  path: "m/44'/164'/0'/0",
  label: 'PIRL'
};
var ether1 = {
  path: "m/44'/1313114'/0'/0",
  label: 'Ether-1'
};
var atheios = {
  path: "m/44'/1620'/0'/0",
  label: 'Atheios'
};
var tomoChain = {
  path: "m/44'/889'/0'/0",
  label: 'TomoChain'
};
var mixBlockchain = {
  path: "m/44'/76'/0'/0",
  label: 'Mix Blockchain'
};
var iolite = {
  path: "m/44'/1171337'/0'/0",
  label: 'Iolite'
};
var ledgerEthereum = {
  path: "m/44'/60'/0'",
  label: 'Ethereum'
};
var ledgerLiveEthereum = {
  path: "m/44'/60'",
  label: 'Ethereum - Ledger Live'
};
var ledgerEthereumClassic = {
  path: "m/44'/60'/160720'/0'",
  label: 'Ethereum Classic'
};
var ledgerLiveEthereumClassic = {
  path: "m/44'/61'",
  label: 'Ethereum Classic - Ledger Live'
};
var rskMainnet = {
  path: "m/44'/137'/0'/0",
  label: 'RSK Mainnet'
};
var rskTestnet = {
  path: "m/44'/37310'/0'/0",
  label: 'RSK Testnet'
};
var keepkeyEthereum = {
  path: "m/44'/60'",
  label: 'Ethereum'
};
var keepkeyEthereumClassic = {
  path: "m/44'/61'",
  label: 'Ethereum Classic'
};
var thundercore = {
  path: "m/44'/1001'/0'/0",
  label: 'ThunderCore'
};
var solidum = {
  path: "m/44'/997'/0'/0",
  label: 'Solidum'
};
var metadium = {
  path: "m/44'/916'/0'/0",
  label: 'Metadium'
};
var reoscChain = {
  path: "m/44'/2894'/0'/0",
  label: 'REOSC'
};
var dexon = {
  path: "m/44'/237'/0'/0",
  label: 'DEXON Network'
};
var lightstreamsNetwork = {
  path: "m/44'/60'/0'",
  label: 'Lightstreams Network'
};


/***/ }),

/***/ "./src/wallets/bip44/secalotPaths.js":
/*!*******************************************!*\
  !*** ./src/wallets/bip44/secalotPaths.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["ethereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["singularDTV"], _paths__WEBPACK_IMPORTED_MODULE_0__["expanse"], _paths__WEBPACK_IMPORTED_MODULE_0__["ubiq"], _paths__WEBPACK_IMPORTED_MODULE_0__["ellaism"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherGem"], _paths__WEBPACK_IMPORTED_MODULE_0__["callisto"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumSocial"], _paths__WEBPACK_IMPORTED_MODULE_0__["musicoin"], _paths__WEBPACK_IMPORTED_MODULE_0__["goChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["eosClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["akroma"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherSocialNetwork"], _paths__WEBPACK_IMPORTED_MODULE_0__["pirl"], _paths__WEBPACK_IMPORTED_MODULE_0__["ether1"], _paths__WEBPACK_IMPORTED_MODULE_0__["atheios"], _paths__WEBPACK_IMPORTED_MODULE_0__["tomoChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["mixBlockchain"], _paths__WEBPACK_IMPORTED_MODULE_0__["iolite"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/bip44/trezorPaths.js":
/*!******************************************!*\
  !*** ./src/wallets/bip44/trezorPaths.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _paths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paths */ "./src/wallets/bip44/paths.js");

/* harmony default export */ __webpack_exports__["default"] = ([_paths__WEBPACK_IMPORTED_MODULE_0__["ethereum"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["ropsten"], _paths__WEBPACK_IMPORTED_MODULE_0__["singularDTV"], _paths__WEBPACK_IMPORTED_MODULE_0__["expanse"], _paths__WEBPACK_IMPORTED_MODULE_0__["ubiq"], _paths__WEBPACK_IMPORTED_MODULE_0__["ellaism"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherGem"], _paths__WEBPACK_IMPORTED_MODULE_0__["callisto"], _paths__WEBPACK_IMPORTED_MODULE_0__["ethereumSocial"], _paths__WEBPACK_IMPORTED_MODULE_0__["musicoin"], _paths__WEBPACK_IMPORTED_MODULE_0__["goChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["eosClassic"], _paths__WEBPACK_IMPORTED_MODULE_0__["akroma"], _paths__WEBPACK_IMPORTED_MODULE_0__["etherSocialNetwork"], _paths__WEBPACK_IMPORTED_MODULE_0__["pirl"], _paths__WEBPACK_IMPORTED_MODULE_0__["ether1"], _paths__WEBPACK_IMPORTED_MODULE_0__["atheios"], _paths__WEBPACK_IMPORTED_MODULE_0__["tomoChain"], _paths__WEBPACK_IMPORTED_MODULE_0__["mixBlockchain"], _paths__WEBPACK_IMPORTED_MODULE_0__["iolite"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskMainnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["rskTestnet"], _paths__WEBPACK_IMPORTED_MODULE_0__["lightstreamsNetwork"]]);

/***/ }),

/***/ "./src/wallets/hardware/bitbox/digitalBitboxEth.js":
/*!*********************************************************!*\
  !*** ./src/wallets/hardware/bitbox/digitalBitboxEth.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty */ "./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! semver */ "./node_modules/semver/semver.js");
/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_6__);
/**
 *  (c) 2017 Douglas Bakkum, Shift Devices AG
 *  MIT license
 **/
// Hijacks the U2F auth command to pass HWW API commands
// TODO - Integrate the smart verification mobile app (send result['echo'] from sign response).
//        Requires pairing, for example copy-pasting the pairing code from the desktop app (needs implementation).









var BitBoxSupportedVersion = '7.0.1';
var hijackState = {
  // Order must match that in the firmware code
  responseReady: 0,
  processingCommand: 1,
  incompleteCommand: 2,
  idle: 3
};

var DigitalBitboxEth =
/*#__PURE__*/
function () {
  function DigitalBitboxEth(comm, secret) {
    var _this = this;

    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, DigitalBitboxEth);

    this.comm = comm;
    this.secret = '';
    this.timeout = null;
    this.secret = secret || this.secret;
    this.key = crypto__WEBPACK_IMPORTED_MODULE_4__["createHash"]('sha256').update(new Buffer(this.secret, 'utf8')).digest();
    this.key = crypto__WEBPACK_IMPORTED_MODULE_4__["createHash"]('sha256').update(this.key).digest();
    clearTimeout(this.timeout);
    this.timeout = setTimeout(function () {
      _this.secret = '';
    }, 60000);
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(DigitalBitboxEth, [{
    key: "send",
    value: function send(cmd, encrypt, callback) {
      var _this2 = this;

      var message = '';
      if (encrypt) message = DigitalBitboxEth.aes_cbc_b64_encrypt(cmd, this.key);else message = cmd || ' '; // Need at least 1 byte length for U2F

      this.comm.exchange(message, function (response, err) {
        try {
          if (typeof err !== 'undefined' || typeof response === 'undefined') {
            // Entered on U2F timeouts
            // Poll for the response
            _this2.send('', false, callback);

            return;
          }

          if (response.length == 1) {
            if (response[0] == hijackState.processingCommand) {
              // BitBox is processing the previous command
              // Poll for the response
              _this2.send('', false, callback);
            }

            return;
          }

          response = JSON.parse(response.toString('utf8'));

          if ('error' in response) {
            callback(undefined, DigitalBitboxEth.parseError(response.error));
            return;
          }

          if ('ping' in response) {
            if (!('device' in response)) {
              callback(undefined, 'errorUpgradeFirmware');
              return;
            }

            if (semver__WEBPACK_IMPORTED_MODULE_6__["lt"](response.device.version, BitBoxSupportedVersion)) {
              callback(undefined, 'errorUpgradeFirmware');
              return;
            }

            if (semver__WEBPACK_IMPORTED_MODULE_6__["gt"](response.device.version, BitBoxSupportedVersion)) {
              callback(undefined, 'errorUnsupportedFirmware');
              return;
            }

            callback(response);
          }

          if ('ciphertext' in response) {
            response = JSON.parse(DigitalBitboxEth.aes_cbc_b64_decrypt(response.ciphertext, _this2.key));

            if ('error' in response) {
              callback(undefined, DigitalBitboxEth.parseError(response.error));
              return;
            }

            callback(response);
          }
        } catch (err) {
          // unexpected error
          callback(undefined, 'errorUnexpected');
        }
      });
    }
  }, {
    key: "getStarted",
    value: function getStarted(path, callback) {
      var _this3 = this;

      // First check firmware version compatibility
      // Get extended public key if firmware is compatible
      // Else return an error
      var localCallback = function localCallback(response, error) {
        if (typeof error != 'undefined') {
          callback(undefined, error);
          return;
        }

        _this3.getAddress(path, callback);
      };

      this.send('{"ping":""}', false, localCallback);
    }
  }, {
    key: "getAddress",
    value: function getAddress(path, callback) {
      // Get extended public key
      var cmd = '{"xpub":"' + path + '"}';

      var localCallback = function localCallback(response, error) {
        if (typeof error != 'undefined') {
          callback(undefined, error);
          return;
        }

        var hdkey = hdkey__WEBPACK_IMPORTED_MODULE_5__["fromExtendedKey"](response.xpub);
        var result = {
          publicKey: hdkey.publicKey.toString('hex'),
          chainCode: hdkey.chainCode.toString('hex')
        };
        callback(result);
        return;
      };

      this.send(cmd, true, localCallback);
    }
  }, {
    key: "signTransaction",
    value: function signTransaction(path, eTx) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var chainId = eTx.getChainId();
        var hashToSign = eTx.hash(false).toString('hex');
        DigitalBitboxEth.signGeneric(_this4, path, chainId, hashToSign, function (result, error) {
          if (error) return reject(error);
          resolve(result);
        });
      });
    }
  }, {
    key: "signMessage",
    value: function signMessage(path, messageHex) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var hashToSign = messageHex.toString('hex');
        DigitalBitboxEth.signGeneric(_this5, path, 0, hashToSign, function (result, error) {
          if (error) return reject(error);
          resolve(result);
        });
      });
    }
  }]);

  return DigitalBitboxEth;
}();

Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__["default"])(DigitalBitboxEth, "aes_cbc_b64_decrypt", function (ciphertext, key) {
  try {
    var h = crypto__WEBPACK_IMPORTED_MODULE_4__["createHash"]('sha512').update(key).digest();
    var encryptionKey = h.slice(0, 32);
    var authenticationKey = h.slice(32, 64);
    var ub64 = new Buffer(ciphertext, 'base64').toString('binary');
    var cipher = new Buffer(ub64.slice(0, ub64.length - 32), 'binary');
    var hmac = new Buffer(ub64.slice(ub64.length - 32), 'binary');
    var expectedHmac = crypto__WEBPACK_IMPORTED_MODULE_4__["createHmac"]('sha256', authenticationKey).update(cipher).digest();

    if (!hmac.equals(expectedHmac)) {
      throw 'hmac check failed';
    }

    var iv = new Buffer(cipher.slice(0, 16), 'binary');
    var enc = new Buffer(cipher.slice(16), 'binary');
    var decipher = crypto__WEBPACK_IMPORTED_MODULE_4__["createDecipheriv"]('aes-256-cbc', encryptionKey, iv);
    var dec = decipher.update(enc) + decipher.final();
    return dec.toString('utf8');
  } catch (err) {
    return ciphertext;
  }
});

Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__["default"])(DigitalBitboxEth, "aes_cbc_b64_encrypt", function (plaintext, key) {
  try {
    var h = crypto__WEBPACK_IMPORTED_MODULE_4__["createHash"]('sha512').update(key).digest();
    var encryptionKey = h.slice(0, 32);
    var authenticationKey = h.slice(32, 64);
    var iv = crypto__WEBPACK_IMPORTED_MODULE_4__["randomBytes"](16);
    var cipher = crypto__WEBPACK_IMPORTED_MODULE_4__["createCipheriv"]('aes-256-cbc', encryptionKey, iv);
    var ciphertext = Buffer.concat([iv, cipher.update(plaintext), cipher.final()]);
    var hmac = crypto__WEBPACK_IMPORTED_MODULE_4__["createHmac"]('sha256', authenticationKey).update(ciphertext).digest();
    return Buffer.concat([ciphertext, hmac]).toString('base64');
  } catch (err) {
    return '';
  }
});

Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__["default"])(DigitalBitboxEth, "parseError", function (errObject) {
  var errMsg = {
    err101: 'errorNotInitialized',
    // No password set
    err250: 'errorNotInitialized',
    // Wallet not seeded
    err251: 'errorNotInitialized',
    // Wallet not seeded
    err109: 'errorInvalidPassword' + errObject.message,
    // Wrong password (typically); append error message in order to parse login tries left
    err600: 'errorUserAbort',
    // User aborted action
    err601: 'errorUserTimeout' // Touch button not pressed

  };
  var code = 'err' + ('code' in errObject ? errObject.code.toString() : '');
  var err = {
    message: errMsg[code] || 'errorUnexpected'
  };
  return err;
});

Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_3__["default"])(DigitalBitboxEth, "signGeneric", function (self, path, chainId, hashToSign, callback) {
  var cmd = '{"sign":{"data":[{"hash":"' + hashToSign + '","keypath":"' + path + '"}]}}';

  var localCallback = function localCallback(response, error) {
    if (typeof error != 'undefined') {
      callback(undefined, error);
      return;
    }

    if ('echo' in response) {
      self.send('{"sign":""}', true, localCallback);
      return;
    }

    if ('sign' in response) {
      var vOffset = chainId ? chainId * 2 + 8 : 0;
      var v = new Buffer([parseInt(response.sign[0].recid, 16) + 27 + vOffset]);
      var result = {
        v: v.toString('hex'),
        r: response.sign[0].sig.slice(0, 64),
        s: response.sign[0].sig.slice(64, 128)
      };
      callback(result);
      return;
    }
  };

  self.send(cmd, true, localCallback);
});

/* harmony default export */ __webpack_exports__["default"] = (DigitalBitboxEth);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/bitbox/digitalBitboxUsb.js":
/*!*********************************************************!*\
  !*** ./src/wallets/hardware/bitbox/digitalBitboxUsb.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var u2f_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! u2f-api */ "./node_modules/u2f-api/dist/index.js");
/* harmony import */ var u2f_api__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(u2f_api__WEBPACK_IMPORTED_MODULE_2__);
// eslint-disable

/**
 *  (c) 2017 Douglas Bakkum, Shift Devices AG
 *  MIT license
 **/






var DigitalBitboxUsb = function DigitalBitboxUsb() {}; // Convert from normal to web-safe, strip trailing "="s


DigitalBitboxUsb.webSafe64 = function (base64) {
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}; // Convert from web-safe to normal, add trailing "="s


DigitalBitboxUsb.normal64 = function (base64) {
  return (// eslint-disable-next-line
    base64.replace(/\-/g, '+').replace(/_/g, '/') + '=='.substring(0, 3 * base64.length % 4)
  );
};

DigitalBitboxUsb.prototype.u2fCallback = function (response, callback) {
  if ('signatureData' in response) {
    var data = new Buffer(DigitalBitboxUsb.normal64(response.signatureData), 'base64');
    callback(data.slice(5));
  } else {
    callback(undefined, response);
  }
};

DigitalBitboxUsb.prototype.exchange = function (msg, callback) {
  msg = Buffer.from(msg, 'ascii');
  var kh_max_len = 128 - 2; // Subtract 2 bytes for `index` and `total` header
  // Challenge is needed for U2F but unused in the hijack procedure

  var challenge = new Buffer('dbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdbdb', 'hex');
  var total = Math.ceil(msg.length / kh_max_len);
  var self = this;

  var localCallback = function localCallback(result) {
    self.u2fCallback(result, callback);
  };

  for (var index = 0; index < total; index++) {
    var kh = Buffer.concat([Buffer.from([total]), Buffer.from([index]), msg.slice(index * kh_max_len, (index + 1) * kh_max_len)]);
    var key = {
      appId: location.origin,
      challenge: DigitalBitboxUsb.webSafe64(challenge.toString('base64')),
      version: 'U2F_V2',
      keyHandle: DigitalBitboxUsb.webSafe64(kh.toString('base64'))
    }; // Set timeout to 35 seconds for Windows 10 to wait for user confirmation
    // Keep 3 seconds for other plaforms so that polling is fast enough

    var timeout = void 0;
    navigator.platform.indexOf('Win') >= 0 && (navigator.userAgent.indexOf('Windows NT 10.0') != -1 || navigator.userAgent.indexOf('Windows 10.0') != -1) ? timeout = 35 : timeout = 3;
    u2f_api__WEBPACK_IMPORTED_MODULE_2___default.a.sign(key, timeout).then(localCallback).catch(function (err) {
      callback(undefined, err);
    });
  }
};

/* harmony default export */ __webpack_exports__["default"] = (DigitalBitboxUsb);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/bitbox/errorHandler.js":
/*!*****************************************************!*\
  !*** ./src/wallets/hardware/bitbox/errorHandler.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");








var ERRORS = {
  errorUnexpected: 'bitboxError.unexpected',
  errorInvalidPassword: 'bitboxError.invalidPassword',
  errorUserAbort: 'bitboxError.userAbort',
  errorUserTimeout: 'bitboxError.userTimeout',
  errorNotInitialized: 'bitboxError.notInitialized',
  errorUpgradeFirmware: 'bitboxError.upgradeFirmware',
  errorUnsupportedFirmware: 'bitboxError.unsupportedFirmware'
};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var loginsRemaining = err.message ? err.message.replace(/\D/g, '') : err.replace(/\D/g, '');
  var attempts = loginsRemaining.length > 0 ? loginsRemaining : '';
  var errorValues = Object.keys(ERRORS);
  var warningValues = Object.keys(WARNING);
  var foundError = errorValues.find(function (item) {
    return err.message ? err.message.includes(item) : err.includes(item);
  });
  var foundWarning = warningValues.find(function (item) {
    return err.message ? err.message.includes(item) : err.includes(item);
  });

  if (foundError) {
    _helpers__WEBPACK_IMPORTED_MODULE_6__["Toast"].responseHandler("".concat(vue__WEBPACK_IMPORTED_MODULE_7__["default"].$i18n.t(ERRORS[foundError])).concat(attempts), _helpers__WEBPACK_IMPORTED_MODULE_6__["Toast"].ERROR);
  } else if (foundWarning) {
    _helpers__WEBPACK_IMPORTED_MODULE_6__["Toast"].responseHandler("".concat(vue__WEBPACK_IMPORTED_MODULE_7__["default"].$i18n.t(WARNING[foundWarning])).concat(attempts), _helpers__WEBPACK_IMPORTED_MODULE_6__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_6__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hardware/bitbox/index.js":
/*!**********************************************!*\
  !*** ./src/wallets/hardware/bitbox/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _digitalBitboxUsb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./digitalBitboxUsb */ "./src/wallets/hardware/bitbox/digitalBitboxUsb.js");
/* harmony import */ var _digitalBitboxEth__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./digitalBitboxEth */ "./src/wallets/hardware/bitbox/digitalBitboxEth.js");
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hardware/bitbox/errorHandler.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");

















var NEED_PASSWORD = true;

var BitBoxWallet =
/*#__PURE__*/
function () {
  function BitBoxWallet(password) {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, BitBoxWallet);

    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_8__["BITBOX"];
    this.isHardware = true;
    this.needPassword = NEED_PASSWORD;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_9__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_8__["BITBOX"]];
    this.password = password;
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(BitBoxWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        var transport, rootPub;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                transport = new _digitalBitboxUsb__WEBPACK_IMPORTED_MODULE_6__["default"]();
                this.bitbox = new _digitalBitboxEth__WEBPACK_IMPORTED_MODULE_7__["default"](transport, this.password);
                _context.next = 5;
                return getRootPubKey(this.bitbox, this.basePath);

              case 5:
                rootPub = _context.sent;
                this.hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_13__();
                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function getAccount(idx) {
      var _this = this;

      var derivedKey = this.hdKey.derive('m/' + idx);

      var txSigner =
      /*#__PURE__*/
      function () {
        var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(tx) {
          var networkId, result, signedChainId;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__["Transaction"](tx, {
                    common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_16__["default"])(_store__WEBPACK_IMPORTED_MODULE_14__["default"].state.network)
                  });
                  networkId = tx.getChainId();
                  _context2.next = 4;
                  return _this.bitbox.signTransaction(_this.basePath + '/' + idx, tx);

                case 4:
                  result = _context2.sent;
                  tx.v = Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.v));
                  tx.r = Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.r));
                  tx.s = Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.s));
                  signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_15__["calculateChainIdFromV"])(tx.v);
                  if (signedChainId !== networkId) _helpers__WEBPACK_IMPORTED_MODULE_11__["Toast"].responseHandler(new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId'), false);
                  return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getSignTransactionObject"])(tx));

                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function txSigner(_x2) {
          return _ref.apply(this, arguments);
        };
      }();

      var msgSigner =
      /*#__PURE__*/
      function () {
        var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(msg) {
          var msgHash, result;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  msgHash = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__["hashPersonalMessage"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_5__["toBuffer"])(msg));
                  _context3.next = 3;
                  return _this.bitbox.signMessage(_this.basePath + '/' + idx, msgHash);

                case 3:
                  result = _context3.sent;
                  return _context3.abrupt("return", Buffer.concat([Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.r)), Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.s)), Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result.v))]));

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function msgSigner(_x3) {
          return _ref2.apply(this, arguments);
        };
      }();

      return new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_10__["default"](this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_12__["default"], txSigner, msgSigner, null);
    }
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return BitBoxWallet;
}();

var getRootPubKey = function getRootPubKey(_bitbox, _path) {
  return new Promise(function (resolve, reject) {
    _bitbox.getStarted(_path, function (result, error) {
      if (error) return reject(error);
      resolve({
        publicKey: result.publicKey,
        chainCode: result.chainCode
      });
    });
  });
};

var createWallet =
/*#__PURE__*/
function () {
  var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(basePath, password) {
    var _bitboxWallet;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _bitboxWallet = new BitBoxWallet(password);
            _context4.next = 3;
            return _bitboxWallet.init(basePath);

          case 3:
            return _context4.abrupt("return", _bitboxWallet);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function createWallet(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_12__["default"];
/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/index.js":
/*!***************************************!*\
  !*** ./src/wallets/hardware/index.js ***!
  \***************************************/
/*! exports provided: BitBoxWallet, LedgerWallet, TrezorWallet, SecalotWallet, KeepkeyWallet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bitbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bitbox */ "./src/wallets/hardware/bitbox/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BitBoxWallet", function() { return _bitbox__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _ledger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ledger */ "./src/wallets/hardware/ledger/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LedgerWallet", function() { return _ledger__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _trezor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trezor */ "./src/wallets/hardware/trezor/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TrezorWallet", function() { return _trezor__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _secalot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secalot */ "./src/wallets/hardware/secalot/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SecalotWallet", function() { return _secalot__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _keepkey__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keepkey */ "./src/wallets/hardware/keepkey/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeepkeyWallet", function() { return _keepkey__WEBPACK_IMPORTED_MODULE_4__["default"]; });








/***/ }),

/***/ "./src/wallets/hardware/keepkey/errorHandler.js":
/*!******************************************************!*\
  !*** ./src/wallets/hardware/keepkey/errorHandler.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");







var ERRORS = {
  'No device selected.': 'keepkeyError.noDeviceSelected',
  'Invalid PIN': 'keepkeyError.invalidPin',
  'Unable to claim interface.': 'keepKey.cantClaim',
  'WebUSB is not available in this browser. We recommend trying Chrome.': 'keepKey.browserNotSupported'
};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.keys(ERRORS);
  var warningValues = Object.keys(WARNING);
  var foundError = errorValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });
  var foundWarning = warningValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });

  if (foundError) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(ERRORS[foundError]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].ERROR);
  } else if (foundWarning) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(WARNING[foundWarning]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hardware/keepkey/index.js":
/*!***********************************************!*\
  !*** ./src/wallets/hardware/keepkey/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js");
/* harmony import */ var core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");
/* harmony import */ var core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @keepkey/keepkey.js */ "./node_modules/@keepkey/keepkey.js/dist/keepkey.browser.js");
/* harmony import */ var _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils */ "./src/wallets/hardware/keepkey/utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hardware/keepkey/errorHandler.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");




















var MessageType = _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["Messages"].MessageType;
var MESSAGETYPE_PINMATRIXREQUEST = MessageType.MESSAGETYPE_PINMATRIXREQUEST,
    MESSAGETYPE_PASSPHRASEREQUEST = MessageType.MESSAGETYPE_PASSPHRASEREQUEST;
var NEED_PASSWORD = false;

var KeepkeyWallet =
/*#__PURE__*/
function () {
  function KeepkeyWallet(eventHub) {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_6__["default"])(this, KeepkeyWallet);

    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_9__["KEEPKEY"];
    this.isHardware = true;
    this.needPassword = NEED_PASSWORD;
    this.eventHub = eventHub;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_10__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_9__["KEEPKEY"]];
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_7__["default"])(KeepkeyWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        var _this = this;

        var usbDevice, device, rootPub;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                this.isHardened = this.basePath.split('/').length - 1 === 2;
                _context.next = 4;
                return _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["WebUSBDevice"].requestPair();

              case 4:
                usbDevice = _context.sent;
                device = new _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["WebUSBDevice"]({
                  usbDevice: usbDevice
                });
                this.keepkey = _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["KeepKey"].withWebUSB(device);
                this.keepkey.device.events.on(String(MESSAGETYPE_PINMATRIXREQUEST), function () {
                  _this.eventHub.$emit('showHardwarePinMatrix', {
                    name: _this.identifier
                  }, function (pin) {
                    _this.keepkey.acknowledgeWithPin(pin).catch(_errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"]);
                  });
                });
                this.keepkey.device.events.on(String(MESSAGETYPE_PASSPHRASEREQUEST), function () {
                  _this.eventHub.$emit('showHardwarePassword', {
                    name: _this.identifier
                  }, function (passPhrase) {
                    _this.keepkey.acknowledgeWithPassphrase(passPhrase).catch(_errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"]);
                  });
                });
                _context.next = 11;
                return this.keepkey.initialize();

              case 11:
                if (this.isHardened) {
                  _context.next = 20;
                  break;
                }

                _context.next = 14;
                return getRootPubKey(this.keepkey, this.basePath);

              case 14:
                rootPub = _context.sent;
                this.hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_14___default.a();
                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');
                _context.next = 22;
                break;

              case 20:
                _context.next = 22;
                return getRootPubKey(this.keepkey, this.basePath + '/0 ');

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function () {
      var _getAccount = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(idx) {
        var _this2 = this;

        var derivedKey, accountPath, rootPub, hdKey, txSigner, msgSigner, displayAddress;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.isHardened) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 3;
                return getRootPubKey(this.keepkey, this.basePath + '/' + idx + "'");

              case 3:
                rootPub = _context5.sent;
                hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_14___default.a();
                hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');
                derivedKey = hdKey.derive('m/0/0');
                accountPath = this.basePath + '/' + idx + "'" + '/0/0';
                _context5.next = 13;
                break;

              case 11:
                derivedKey = this.hdKey.derive('m/' + idx);
                accountPath = this.basePath + '/' + idx;

              case 13:
                txSigner =
                /*#__PURE__*/
                function () {
                  var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(tx) {
                    var hexTx, networkId, result, signedChainId;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_16__["Transaction"](tx, {
                              common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_19__["default"])(_store__WEBPACK_IMPORTED_MODULE_18__["default"].state.network)
                            });
                            hexTx = Object(_utils__WEBPACK_IMPORTED_MODULE_12__["getUint8Tx"])(tx);
                            networkId = tx.getChainId();
                            hexTx.addressNList = Object(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["bip32ToAddressNList"])(accountPath);
                            _context2.next = 6;
                            return _this2.keepkey.ethereumSignTx(hexTx, null, null, hexTx.data, networkId);

                          case 6:
                            result = _context2.sent;
                            tx.v = Object(_utils__WEBPACK_IMPORTED_MODULE_13__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_13__["sanitizeHex"])(result.v));
                            tx.r = Object(_utils__WEBPACK_IMPORTED_MODULE_13__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_13__["sanitizeHex"])(result.r));
                            tx.s = Object(_utils__WEBPACK_IMPORTED_MODULE_13__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_13__["sanitizeHex"])(result.s));
                            signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_13__["calculateChainIdFromV"])(tx.v);

                            if (!(signedChainId !== networkId)) {
                              _context2.next = 13;
                              break;
                            }

                            throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');

                          case 13:
                            return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_13__["getSignTransactionObject"])(tx));

                          case 14:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function txSigner(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                msgSigner =
                /*#__PURE__*/
                function () {
                  var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee3(msg) {
                    var signMessage, _ref3, _ref4, response;

                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            signMessage = new _keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["Messages"].EthereumSignMessage();
                            signMessage.setAddressNList(Object(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["bip32ToAddressNList"])(accountPath));
                            signMessage.setMessage(new Uint8Array(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_15__["toBuffer"])(msg)));
                            _context3.next = 5;
                            return _this2.keepkey.device.exchange(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["Messages"].MessageType.MESSAGETYPE_ETHEREUMSIGNMESSAGE, signMessage);

                          case 5:
                            _ref3 = _context3.sent;
                            _ref4 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref3, 2);
                            response = _ref4[1];
                            return _context3.abrupt("return", Buffer.from(response.toObject().signature, 'base64'));

                          case 9:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function msgSigner(_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }();

                displayAddress =
                /*#__PURE__*/
                function () {
                  var _ref5 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4() {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this2.keepkey.ethereumGetAddress({
                              addressNList: Object(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["bip32ToAddressNList"])(accountPath),
                              showDisplay: true
                            });

                          case 2:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function displayAddress() {
                    return _ref5.apply(this, arguments);
                  };
                }();

                return _context5.abrupt("return", new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_11__["default"](accountPath, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"], txSigner, msgSigner, displayAddress));

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccount(_x2) {
        return _getAccount.apply(this, arguments);
      }

      return getAccount;
    }()
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return KeepkeyWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref6 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(basePath, eventHub) {
    var _keepkeyWallet;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _keepkeyWallet = new KeepkeyWallet(eventHub);
            _context6.next = 3;
            return _keepkeyWallet.init(basePath);

          case 3:
            return _context6.abrupt("return", _keepkeyWallet);

          case 4:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function createWallet(_x5, _x6) {
    return _ref6.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"];

var getRootPubKey =
/*#__PURE__*/
function () {
  var _ref7 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee7(_keepkey, _path) {
    var pubObj, hdkey;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return _keepkey.getPublicKey({
              addressNList: Object(_keepkey_keepkey_js__WEBPACK_IMPORTED_MODULE_8__["bip32ToAddressNList"])(_path),
              showDisplay: false
            });

          case 2:
            pubObj = _context7.sent;
            hdkey = hdkey__WEBPACK_IMPORTED_MODULE_14___default.a.fromExtendedKey(pubObj[1]);
            return _context7.abrupt("return", {
              publicKey: hdkey.publicKey.toString('hex'),
              chainCode: hdkey.chainCode.toString('hex')
            });

          case 5:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function getRootPubKey(_x7, _x8) {
    return _ref7.apply(this, arguments);
  };
}();

/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/keepkey/utils.js":
/*!***********************************************!*\
  !*** ./src/wallets/hardware/keepkey/utils.js ***!
  \***********************************************/
/*! exports provided: getUint8Tx */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUint8Tx", function() { return getUint8Tx; });
/* harmony import */ var core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.typed.uint8-array */ "./node_modules/core-js/modules/es6.typed.uint8-array.js");
/* harmony import */ var core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_typed_uint8_array__WEBPACK_IMPORTED_MODULE_0__);


var getUint8Tx = function getUint8Tx(tx) {
  return {
    to: new Uint8Array(tx.to),
    value: new Uint8Array(tx.value),
    data: new Uint8Array(tx.data),
    chainId: tx.getChainId(),
    nonce: new Uint8Array(tx.nonce),
    gasLimit: new Uint8Array(tx.gasLimit),
    gasPrice: new Uint8Array(tx.gasPrice)
  };
};



/***/ }),

/***/ "./src/wallets/hardware/ledger/errorHandler.js":
/*!*****************************************************!*\
  !*** ./src/wallets/hardware/ledger/errorHandler.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");







var ERRORS = {
  'Failed to sign with Ledger device: U2F TIMEOUT': 'ledgerError.failedToSign',
  'Failed to sign with Ledger device: U2F DEVICE_INELIGIBLE': 'ledgerError.failedSignIneligible',
  'No Ledger device found (timeout)': 'ledgerError.noDevice',
  'Ledger Device is busy': 'ledgerError.deviceBusy1',
  'Ledger device: UNKNOWN_ERROR (0x6804)': 'ledgerError.unknown0x6804',
  'Ledger device: Invalid data received (0x6a80)': 'ledgerError.invalidData0x6a80',
  'Ledger device: CLA_NOT_SUPPORTED (0x6e00)': 'ledgerError.claNotSupport0x6e00',
  'Ledger Device is busy (lock getAddress)': 'ledgerError.deviceBusy2',
  'Ledger device: INS_NOT_SUPPORTED (0x6d00)': 'ledgerError.wrongWallet',
  'Ledger Device is busy (lock provideERC20TokenInformation)': 'ledgerError.deviceBusy1',
  'Ledger Device is busy (lock signTransaction)': 'ledgerError.deviceBusy1',
  'Ledger Device is busy (lock signPersonalMessage)': 'ledgerError.deviceBusy1',
  'TransportError: Failed to sign with Ledger device: U2F OTHER_ERROR': 'ledgerError.failedToSignOther',
  'TransportStatusError: Ledger device: UNKNOWN_ERROR (0x6801)': 'ledgerError.unknown0x6801',
  'TransportStatusError: Ledger device: UNKNOWN_ERROR (0x6804)': 'ledgerError.unknown0x6804',
  'Invalid networkId signature returned.': 'ledgerError.invalidNetworkID',
  'EthAppPleaseEnableContractData: Please enable Contract data on the Ethereum app Settings': 'ledgerError.enableContractData',
  'TransportInterfaceNotAvailable: The interface number provided is not supported by the device in its current configuration.': 'ledgerError.transportInterface',
  'No device selected.': 'ledgerError.noDeviceSelected',
  'Incompatible EIP155-based V 10 and chain id 1. See the second parameter of the Transaction constructor to set the chain id.': 'ledgerError.appAndNetworkMismatch',
  'DisconnectedDeviceDuringOperation: The device was disconnected': 'ledgerError.deviceDisconnected',
  'AbortError: The transfer was cancelled': 'ledgerError.deniedByUser'
};
var WARNING = {
  'Ledger device: Condition of use not satisfied (denied by the user?) (0x6985)': 'ledgerError.deniedByUser0x6985',
  "U2F browser support is needed for Ledger. Please use Chrome, Opera or Firefox with a U2F extension. Also make sure you're on an HTTPS connection": 'ledgerError.unsupportedBrowserU2f'
};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var expected = err.message ? err.message.substr(err.message.indexOf('Expected'), err.message.length) : err.substr(err.indexOf('Expected'), err.message);
  var errorValues = Object.keys(ERRORS);
  var warningValues = Object.keys(WARNING);
  var foundError = errorValues.find(function (item) {
    if (err && err.message.includes(item)) return item;
    return item.includes(err.message) || item.includes(err);
  });
  var foundWarning = warningValues.find(function (item) {
    if (err && err.message.includes(item)) return item;
    return item.includes(err.message) || item.includes(err);
  });

  if (foundError) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler("".concat(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(ERRORS[foundError])).concat(expected), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].ERROR);
  } else if (foundWarning) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler("".concat(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(WARNING[foundWarning])).concat(expected), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hardware/ledger/index.js":
/*!**********************************************!*\
  !*** ./src/wallets/hardware/ledger/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.function.name */ "./node_modules/core-js/modules/es6.function.name.js");
/* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _ledgerhq_hw_app_eth__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ledgerhq/hw-app-eth */ "./node_modules/@ledgerhq/hw-app-eth/lib/Eth.js");
/* harmony import */ var _ledgerhq_hw_app_eth__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_ledgerhq_hw_app_eth__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _ledgerhq_hw_app_eth_erc20__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ledgerhq/hw-app-eth/erc20 */ "./node_modules/@ledgerhq/hw-app-eth/erc20.js");
/* harmony import */ var _ledgerhq_hw_app_eth_erc20__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ledgerhq_hw_app_eth_erc20__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _ledgerhq_hw_transport_u2f__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ledgerhq/hw-transport-u2f */ "./node_modules/@ledgerhq/hw-transport-u2f/lib/TransportU2F.js");
/* harmony import */ var _ledgerhq_hw_transport_u2f__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_ledgerhq_hw_transport_u2f__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _ledgerhq_hw_transport_webusb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ledgerhq/hw-transport-webusb */ "./node_modules/@ledgerhq/hw-transport-webusb/lib/TransportWebUSB.js");
/* harmony import */ var _ledgerhq_hw_transport_webusb__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_ledgerhq_hw_transport_webusb__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! platform */ "./node_modules/platform/platform.js");
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(platform__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hardware/ledger/errorHandler.js");






















var NEED_PASSWORD = false;
var OPEN_TIMEOUT = 10000;
var LISTENER_TIMEOUT = 30000;

var ledgerWallet =
/*#__PURE__*/
function () {
  function ledgerWallet() {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_5__["default"])(this, ledgerWallet);

    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_12__["LEDGER"];
    this.isHardware = true;
    this.needPassword = NEED_PASSWORD;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_13__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_12__["LEDGER"]];
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__["default"])(ledgerWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        var rootPub;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                this.isHardened = this.basePath.split('/').length - 1 === 2;
                _context.next = 4;
                return getLedgerTransport();

              case 4:
                this.transport = _context.sent;
                this.ledger = new _ledgerhq_hw_app_eth__WEBPACK_IMPORTED_MODULE_7___default.a(this.transport);
                _context.next = 8;
                return getLedgerAppConfig(this.ledger);

              case 8:
                this.appConfig = _context.sent;

                if (this.isHardened) {
                  _context.next = 16;
                  break;
                }

                _context.next = 12;
                return getRootPubKey(this.ledger, this.basePath);

              case 12:
                rootPub = _context.sent;
                this.hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_15__();
                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function () {
      var _getAccount = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(idx) {
        var _this = this;

        var derivedKey, accountPath, rootPub, hdKey, txSigner, msgSigner, displayAddress;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.isHardened) {
                  _context5.next = 11;
                  break;
                }

                _context5.next = 3;
                return getRootPubKey(this.ledger, this.basePath + '/' + idx + "'");

              case 3:
                rootPub = _context5.sent;
                hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_15__();
                hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');
                derivedKey = hdKey.derive('m/0/0');
                accountPath = this.basePath + '/' + idx + "'" + '/0/0';
                _context5.next = 13;
                break;

              case 11:
                derivedKey = this.hdKey.derive('m/' + idx);
                accountPath = this.basePath + '/' + idx;

              case 13:
                txSigner =
                /*#__PURE__*/
                function () {
                  var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(tx) {
                    var networkId, tokenInfo, result, v, rv, cv, signedChainId;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_9__["Transaction"](tx, {
                              common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_18__["default"])(_store__WEBPACK_IMPORTED_MODULE_17__["default"].state.network)
                            });
                            networkId = tx.getChainId();
                            tx.raw[6] = networkId;
                            tx.raw[7] = Buffer.from([]);
                            tx.raw[8] = Buffer.from([]);
                            tokenInfo = Object(_ledgerhq_hw_app_eth_erc20__WEBPACK_IMPORTED_MODULE_8__["byContractAddress"])('0x' + tx.to.toString('hex'));

                            if (!tokenInfo) {
                              _context2.next = 9;
                              break;
                            }

                            _context2.next = 9;
                            return _this.ledger.provideERC20TokenInformation(tokenInfo);

                          case 9:
                            _context2.next = 11;
                            return _this.ledger.signTransaction(accountPath, tx.serialize().toString('hex'));

                          case 11:
                            result = _context2.sent;
                            // EIP155 support. check/recalc signature v value.
                            v = result.v;
                            rv = parseInt(v, 16);
                            cv = networkId * 2 + 35;

                            if (rv !== cv && (rv & cv) !== rv) {
                              cv += 1; // add signature v bit.
                            }

                            v = cv.toString(16);
                            tx.v = Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(v);
                            tx.r = Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(result.r);
                            tx.s = Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(result.s);
                            signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_19__["calculateChainIdFromV"])(tx.v);

                            if (!(signedChainId !== networkId)) {
                              _context2.next = 23;
                              break;
                            }

                            throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');

                          case 23:
                            return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getSignTransactionObject"])(tx));

                          case 24:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function txSigner(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }();

                msgSigner =
                /*#__PURE__*/
                function () {
                  var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee3(msg) {
                    var result, v, vHex;
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this.ledger.signPersonalMessage(accountPath, Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_20__["toBuffer"])(msg).toString('hex'));

                          case 2:
                            result = _context3.sent;
                            v = parseInt(result.v, 10) - 27;
                            vHex = Object(_utils__WEBPACK_IMPORTED_MODULE_19__["sanitizeHex"])(v.toString(16));
                            return _context3.abrupt("return", Buffer.concat([Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(result.r), Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(result.s), Object(_utils__WEBPACK_IMPORTED_MODULE_19__["getBufferFromHex"])(vHex)]));

                          case 6:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function msgSigner(_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }();

                displayAddress =
                /*#__PURE__*/
                function () {
                  var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4() {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return _this.ledger.getAddress(accountPath, true, false);

                          case 2:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function displayAddress() {
                    return _ref3.apply(this, arguments);
                  };
                }();

                return _context5.abrupt("return", new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_14__["default"](accountPath, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_21__["default"], txSigner, msgSigner, displayAddress));

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccount(_x2) {
        return _getAccount.apply(this, arguments);
      }

      return getAccount;
    }()
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return ledgerWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref4 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(basePath) {
    var _ledgerWallet;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _ledgerWallet = new ledgerWallet();
            _context6.next = 3;
            return _ledgerWallet.init(basePath);

          case 3:
            return _context6.abrupt("return", _ledgerWallet);

          case 4:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function createWallet(_x5) {
    return _ref4.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_21__["default"];

var isWebUsbSupported =
/*#__PURE__*/
function () {
  var _ref5 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee7() {
    var isSupported;
    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return _ledgerhq_hw_transport_webusb__WEBPACK_IMPORTED_MODULE_11___default.a.isSupported();

          case 2:
            isSupported = _context7.sent;
            return _context7.abrupt("return", isSupported && platform__WEBPACK_IMPORTED_MODULE_16___default.a.os.family !== 'Windows' && platform__WEBPACK_IMPORTED_MODULE_16___default.a.name !== 'Opera' // take it out later once the windows issue is fixed
            );

          case 4:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function isWebUsbSupported() {
    return _ref5.apply(this, arguments);
  };
}();

var getLedgerTransport =
/*#__PURE__*/
function () {
  var _ref6 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee8() {
    var transport, support;
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return isWebUsbSupported();

          case 2:
            support = _context8.sent;

            if (!support) {
              _context8.next = 9;
              break;
            }

            _context8.next = 6;
            return _ledgerhq_hw_transport_webusb__WEBPACK_IMPORTED_MODULE_11___default.a.create();

          case 6:
            transport = _context8.sent;
            _context8.next = 12;
            break;

          case 9:
            _context8.next = 11;
            return _ledgerhq_hw_transport_u2f__WEBPACK_IMPORTED_MODULE_10___default.a.create(OPEN_TIMEOUT, LISTENER_TIMEOUT);

          case 11:
            transport = _context8.sent;

          case 12:
            return _context8.abrupt("return", transport);

          case 13:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function getLedgerTransport() {
    return _ref6.apply(this, arguments);
  };
}();

var getLedgerAppConfig =
/*#__PURE__*/
function () {
  var _ref7 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee9(_ledger) {
    var appConfig;
    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return _ledger.getAppConfiguration();

          case 2:
            appConfig = _context9.sent;
            return _context9.abrupt("return", appConfig);

          case 4:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));

  return function getLedgerAppConfig(_x6) {
    return _ref7.apply(this, arguments);
  };
}();

var getRootPubKey =
/*#__PURE__*/
function () {
  var _ref8 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee10(_ledger, _path) {
    var pubObj;
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return _ledger.getAddress(_path, false, true);

          case 2:
            pubObj = _context10.sent;
            return _context10.abrupt("return", {
              publicKey: pubObj.publicKey,
              chainCode: pubObj.chainCode
            });

          case 4:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function getRootPubKey(_x7, _x8) {
    return _ref8.apply(this, arguments);
  };
}();

/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/secalot/errorHandler.js":
/*!******************************************************!*\
  !*** ./src/wallets/hardware/secalot/errorHandler.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");







var ERRORS = {
  'Sign failed': 'secalotError.signFailed',
  "Cannot read property 'requestId' of null": 'secalotError.notConnected',
  'Please update your Secalot firmware to version 4 or greater.': 'secalotError.updateFirmwareToV4',
  'Ethereum wallet on your Secalot is not initialized.': 'secalotError.walletNotInitialized',
  'Invalid PIN-code. Be careful, after entering a wrong PIN-code three times in a row, your Secalot Ethereum wallet would be permanently wiped.': 'secalotError.lastPinTry',
  'PIN-code not verified.': 'secalotError.invalidPinCode',
  'Invalid PIN-code length.': 'secalotError.invalidPinCodeLength',
  'Operation timed out.': 'secalotError.timeout'
};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.keys(ERRORS);
  var warningValues = Object.keys(WARNING);
  var foundError = errorValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });
  var foundWarning = warningValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });

  if (foundError) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(ERRORS[foundError]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].ERROR);
  } else if (foundWarning) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(WARNING[foundWarning]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hardware/secalot/index.js":
/*!***********************************************!*\
  !*** ./src/wallets/hardware/secalot/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _secalotEth__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./secalotEth */ "./src/wallets/hardware/secalot/secalotEth.js");
/* harmony import */ var _secalotUsb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./secalotUsb */ "./src/wallets/hardware/secalot/secalotUsb.js");
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hardware/secalot/errorHandler.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");















var NEED_PASSWORD = true;

var SecalotWallet =
/*#__PURE__*/
function () {
  function SecalotWallet(password) {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, SecalotWallet);

    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__["SECALOT"];
    this.isHardware = true;
    this.needPassword = NEED_PASSWORD;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_8__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__["SECALOT"]];
    this.password = password;
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(SecalotWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        var transport, rootPub;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                transport = new _secalotUsb__WEBPACK_IMPORTED_MODULE_6__["default"]();
                this.secalot = new _secalotEth__WEBPACK_IMPORTED_MODULE_5__["default"](transport, this.password);
                _context.next = 5;
                return getRootPubKey(this.secalot, this.basePath);

              case 5:
                rootPub = _context.sent;
                this.hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_10__();
                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function getAccount(idx) {
      var _this = this;

      var derivedKey = this.hdKey.derive('m/' + idx);

      var txSigner =
      /*#__PURE__*/
      function () {
        var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(tx) {
          var networkId, result, signedChainId;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_4__["Transaction"](tx, {
                    common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_14__["default"])(_store__WEBPACK_IMPORTED_MODULE_13__["default"].state.network)
                  });
                  networkId = tx.getChainId();
                  _context2.next = 4;
                  return _this.secalot.signTransactionAsync(_this.basePath + '/' + idx, tx);

                case 4:
                  result = _context2.sent;
                  tx.v = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_11__["sanitizeHex"])(result.v));
                  tx.r = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_11__["sanitizeHex"])(result.r));
                  tx.s = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_11__["sanitizeHex"])(result.s));
                  signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["calculateChainIdFromV"])(tx.v);

                  if (!(signedChainId !== networkId)) {
                    _context2.next = 11;
                    break;
                  }

                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');

                case 11:
                  return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getSignTransactionObject"])(tx));

                case 12:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function txSigner(_x2) {
          return _ref.apply(this, arguments);
        };
      }();

      var msgSigner =
      /*#__PURE__*/
      function () {
        var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(msg) {
          var result;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this.secalot.signMessageAsync(_this.basePath + '/' + idx, msg);

                case 2:
                  result = _context3.sent;
                  return _context3.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(result));

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function msgSigner(_x3) {
          return _ref2.apply(this, arguments);
        };
      }();

      return new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_9__["default"](this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_12__["default"], txSigner, msgSigner, null);
    }
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return SecalotWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(basePath, password) {
    var _secalotWallet;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _secalotWallet = new SecalotWallet(password);
            _context4.next = 3;
            return _secalotWallet.init(basePath);

          case 3:
            return _context4.abrupt("return", _secalotWallet);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function createWallet(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_12__["default"];

var getRootPubKey = function getRootPubKey(_secalot, _path) {
  return new Promise(function (resolve, reject) {
    _secalot.getAddress(_path, function (result, error) {
      if (error) return reject(error);
      resolve({
        publicKey: result.publicKey,
        chainCode: result.chainCode
      });
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/secalot/secalotEth.js":
/*!****************************************************!*\
  !*** ./src/wallets/hardware/secalot/secalotEth.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.regexp.split */ "./node_modules/core-js/modules/es6.regexp.split.js");
/* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__);







var SecalotEth = function SecalotEth(comm, pinCode) {
  this.comm = comm;
  if (typeof pinCode !== 'undefined') this.pinCode = pinCode;
};

SecalotEth.splitPath = function (path) {
  var result = [];
  var components = path.split('/');
  components.forEach(function (element) {
    var number = parseInt(element, 10);

    if (isNaN(number)) {
      return;
    }

    if (element.length > 1 && element[element.length - 1] === "'") {
      number += 0x80000000;
    }

    result.push(number);
  });
  return result;
};

SecalotEth.getErrorMessage = function (sw, operation) {
  var errorMessage;

  if (sw === 0x6d00) {
    errorMessage = 'Ethereum wallet on your Secalot is not initialized.';
  } else if (sw === 0x6982) {
    if (operation === 'getPublicKey') {
      errorMessage = 'Invalid PIN-code. Be careful, after entering a wrong PIN-code three times in a row, your Secalot Ethereum wallet would be permanently wiped.';
    } else {
      errorMessage = 'PIN-code not verified.';
    }
  } else if (sw === 0x6700) {
    errorMessage = 'Invalid PIN-code length.';
  } else if (sw === 0x6985) {
    errorMessage = 'Operation timed out.';
  } else {
    errorMessage = 'An error has occurred. SW = ' + sw.toString(16) + '.';
  }

  return errorMessage;
};

SecalotEth.prototype.getAddress = function (path, callback) {
  var splitPath = SecalotEth.splitPath(path);
  var apdus = [];
  var buffer;
  var self = this;

  var localCallback = function localCallback(response, error) {
    if (typeof error !== 'undefined') {
      callback(undefined, error);
    } else {
      var result = {};
      response = Buffer.from(response, 'hex');
      var sw = response.readUInt16BE(response.length - 2);

      if (sw !== 0x9000) {
        callback(undefined, SecalotEth.getErrorMessage(sw, 'getPublicKey'));
        return;
      }

      if (apdus.length === 0) {
        result['publicKey'] = response.slice(0, 65).toString('hex');
        result['chainCode'] = response.slice(65, 97).toString('hex');
        callback(result);
      } else {
        self.comm.exchange(apdus.shift(), localCallback);
      }
    }
  };

  buffer = Buffer.alloc(4);
  buffer[0] = 0x80;
  buffer[1] = 0xc4;
  buffer[2] = 0x00;
  buffer[3] = 0x00;
  apdus.push(buffer.toString('hex'));

  if (typeof this.pinCode !== 'undefined') {
    var pin = Buffer.from(this.pinCode, 'utf8');
    buffer = Buffer.alloc(5 + pin.length);
    buffer[0] = 0x80;
    buffer[1] = 0x22;
    buffer[2] = 0x00;
    buffer[3] = 0x00;
    buffer[4] = pin.length;
    pin.copy(buffer, 5, 0, pin.length);
    apdus.push(buffer.toString('hex'));
  }

  buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);
  buffer[0] = 0x80;
  buffer[1] = 0x40;
  buffer[2] = 0x00;
  buffer[3] = 0x00;
  buffer[4] = 1 + splitPath.length * 4;
  buffer[5] = splitPath.length;
  splitPath.forEach(function (element, idx) {
    buffer.writeUInt32BE(element, 6 + 4 * idx);
  });
  apdus.push(buffer.toString('hex'));
  self.comm.exchange(apdus.shift(), localCallback);
};

SecalotEth.prototype.signTransactionAsync = function (path, eTx) {
  var _this = this;

  return new Promise(function (resolve, reject) {
    _this.signTransaction(path, eTx, function (result, error) {
      if (error) return reject(error);
      resolve(result);
    });
  });
};

SecalotEth.prototype.signTransaction = function (path, eTx, callback) {
  var chainID = eTx.getChainId();
  var splitPath = SecalotEth.splitPath(path);
  var offset = 0;
  var rawData = '';
  var apdus = [];
  var self = this;

  var localCallback = function localCallback(response, error) {
    if (typeof error !== 'undefined') {
      callback(undefined, error);
    } else {
      response = Buffer.from(response, 'hex');
      var sw = response.readUInt16BE(response.length - 2);

      if (sw !== 0x9000) {
        callback(undefined, SecalotEth.getErrorMessage(sw, 'signTransaction'));
        return;
      }

      if (apdus.length === 0) {
        var result = {};
        var v = response[0] + 27;

        if (chainID > 0) {
          v += chainID * 2 + 8;
        }

        result['v'] = Buffer.from([v]).toString('hex');
        result['r'] = response.slice(1, 1 + 32).toString('hex');
        result['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');
        callback(result);
      } else {
        self.comm.exchange(apdus.shift(), localCallback);
      }
    }
  };

  var items = eTx.raw.slice(0, 6).concat([Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(chainID), Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["stripZeros"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(0)), Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["stripZeros"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(0))]);
  var dataToHash = ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["rlp"].encode(items);
  rawData = Buffer.from(dataToHash, 'hex');

  while (offset !== rawData.length) {
    var maxChunkSize = 64;
    var chunkSize = offset + maxChunkSize > rawData.length ? rawData.length - offset : maxChunkSize;

    var _buffer = Buffer.alloc(5 + chunkSize);

    _buffer[0] = 0x80;
    _buffer[1] = 0xf2;
    _buffer[2] = offset === 0 ? 0x00 : 0x01;
    _buffer[3] = 0x00;
    _buffer[4] = chunkSize;
    rawData.copy(_buffer, 5, offset, offset + chunkSize);
    apdus.push(_buffer.toString('hex'));
    offset += chunkSize;
  }

  var buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);
  buffer[0] = 0x80;
  buffer[1] = 0xf2;
  buffer[2] = 0x02;
  buffer[3] = 0x00;
  buffer[4] = 1 + splitPath.length * 4;
  buffer[5] = splitPath.length;
  splitPath.forEach(function (element, index) {
    buffer.writeUInt32BE(element, 6 + 4 * index);
  });
  apdus.push(buffer.toString('hex'));
  self.comm.exchange(apdus.shift(), localCallback);
};

SecalotEth.prototype.signMessageAsync = function (path, message) {
  var _this2 = this;

  return new Promise(function (resolve, reject) {
    _this2.signMessage(path, message, function (result, error) {
      if (error) return reject(error);
      resolve(result);
    });
  });
};

SecalotEth.prototype.signMessage = function (path, message, callback) {
  var splitPath = SecalotEth.splitPath(path);
  var offset = 0;
  var rawData = '';
  var apdus = [];
  var self = this;

  var localCallback = function localCallback(response, error) {
    if (typeof error !== 'undefined') {
      callback(undefined, error);
    } else {
      response = Buffer.from(response, 'hex');
      var sw = response.readUInt16BE(response.length - 2);

      if (sw !== 0x9000) {
        callback(undefined, SecalotEth.getErrorMessage(sw, 'signMessage'));
        return;
      }

      if (apdus.length === 0) {
        var obj = {};
        var v = response[0] + 27;
        obj['v'] = Buffer.from([v]).toString('hex');
        obj['r'] = response.slice(1, 1 + 32).toString('hex');
        obj['s'] = response.slice(1 + 32, 1 + 32 + 32).toString('hex');
        var result = obj['r'] + obj['s'] + obj['v'];
        callback('0x' + result.toString('hex'));
      } else {
        self.comm.exchange(apdus.shift(), localCallback);
      }
    }
  };

  message = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(message);
  var prefix = '\x19Ethereum Signed Message:\n' + message.length.toString();
  rawData = Buffer.concat([Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_3__["toBuffer"])(prefix), message]);

  while (offset !== rawData.length) {
    var maxChunkSize = 64;
    var chunkSize = offset + maxChunkSize > rawData.length ? rawData.length - offset : maxChunkSize;

    var _buffer2 = Buffer.alloc(5 + chunkSize);

    _buffer2[0] = 0x80;
    _buffer2[1] = 0xf2;
    _buffer2[2] = offset === 0 ? 0x00 : 0x01;
    _buffer2[3] = offset === 0 ? 0x01 : 0x00;
    _buffer2[4] = chunkSize;
    rawData.copy(_buffer2, 5, offset, offset + chunkSize);
    apdus.push(_buffer2.toString('hex'));
    offset += chunkSize;
  }

  var buffer = Buffer.alloc(5 + 1 + splitPath.length * 4);
  buffer[0] = 0x80;
  buffer[1] = 0xf2;
  buffer[2] = 0x02;
  buffer[3] = 0x00;
  buffer[4] = 1 + splitPath.length * 4;
  buffer[5] = splitPath.length;
  splitPath.forEach(function (element, idx) {
    buffer.writeUInt32BE(element, 6 + 4 * idx);
  });
  apdus.push(buffer.toString('hex'));
  self.comm.exchange(apdus.shift(), localCallback);
};

/* harmony default export */ __webpack_exports__["default"] = (SecalotEth);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/secalot/secalotUsb.js":
/*!****************************************************!*\
  !*** ./src/wallets/hardware/secalot/secalotUsb.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var u2f_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! u2f-api */ "./node_modules/u2f-api/dist/index.js");
/* harmony import */ var u2f_api__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(u2f_api__WEBPACK_IMPORTED_MODULE_2__);






var SecalotUsb = function SecalotUsb() {
  this.timeoutSeconds = 120;
};

SecalotUsb.webSafe64 = function (base64) {
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
};

SecalotUsb.normal64 = function (base64) {
  return (// eslint-disable-next-line
    base64.replace(/\-/g, '+').replace(/_/g, '/') + '=='.substring(0, 3 * base64.length % 4)
  );
};

SecalotUsb.prototype.u2fCallback = function (response, callback) {
  if (typeof response['signatureData'] !== 'undefined') {
    var data = Buffer.from(SecalotUsb.normal64(response['signatureData']), 'base64');

    if (data.length < 5 + 2) {
      callback(undefined, 'Please update your Secalot firmware to version 4 or greater.');
      return;
    }

    if (data[0] !== 0x01 || data[1] !== 0x00 || data[2] !== 0x00 || data[3] !== 0x00 || data[4] !== 0x00) {
      callback(undefined, 'Please update your Secalot firmware to version 4 or greater.');
      return;
    }

    data = data.slice(5, data.length);
    callback(data.toString('hex'));
  } else {
    callback(undefined, response);
  }
};

SecalotUsb.prototype.exchange = function (apduHex, callback) {
  var apdu = Buffer.from('1122334455667788' + apduHex, 'hex');
  var challenge = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
  var key = {};
  key['appId'] = location.origin;
  key['challenge'] = SecalotUsb.webSafe64(challenge.toString('base64'));
  key['version'] = 'U2F_V2';
  key['keyHandle'] = SecalotUsb.webSafe64(apdu.toString('base64'));
  var self = this;

  var localCallback = function localCallback(result) {
    self.u2fCallback(result, callback);
  };

  u2f_api__WEBPACK_IMPORTED_MODULE_2___default.a.sign([key], this.timeoutSeconds).then(localCallback).catch(function (err) {
    callback(undefined, err);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (SecalotUsb);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hardware/trezor/errorHandler.js":
/*!*****************************************************!*\
  !*** ./src/wallets/hardware/trezor/errorHandler.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es6.object.keys */ "./node_modules/core-js/modules/es6.object.keys.js");
/* harmony import */ var core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_object_keys__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");







var ERRORS = {
  'Popup closed': 'trezorError.popupClosed',
  'Device disconnected': 'trezorError.deviceDisconnect',
  'device disconnected during action': 'trezorError.deviceDisconnectAction',
  'Action cancelled by user': 'trezorError.userCancelledAction',
  'Permissions not granted': 'trezorError.noPermission',
  'Device call in progress': 'trezorError.callInProgress',
  'Transport is missing': 'trezorError.transportMissing',
  'EthAppPleaseEnableContractData: Please enable Contract data on the Ethereum app Settings': 'trezorError.turnOnContractData',
  Cancelled: 'trezorError.cancelled',
  'Iframe timeout': 'trezor.iframeTimeout',
  'Browser not supported': 'trezor.unsupportedBrowser',
  'popup failed to open': 'trezor.popupFailedToOpen'
};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.keys(ERRORS);
  var warningValues = Object.keys(WARNING);
  var foundError = errorValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });
  var foundWarning = warningValues.find(function (item) {
    return item.includes(err.message) || item.includes(err);
  });

  if (foundError) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(ERRORS[foundError]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].ERROR);
  } else if (foundWarning) {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(vue__WEBPACK_IMPORTED_MODULE_6__["default"].$i18n.t(WARNING[foundWarning]), _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_5__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hardware/trezor/index.js":
/*!**********************************************!*\
  !*** ./src/wallets/hardware/trezor/index.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var trezor_connect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! trezor-connect */ "./node_modules/trezor-connect/lib/index.js");
/* harmony import */ var trezor_connect__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(trezor_connect__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hardware/trezor/errorHandler.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");
















var NEED_PASSWORD = false;

var TrezorWallet =
/*#__PURE__*/
function () {
  function TrezorWallet() {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, TrezorWallet);

    trezor_connect__WEBPACK_IMPORTED_MODULE_5___default.a.manifest({
      email: 'dev@myetherwallet.com',
      appUrl: 'https://www.myetherwallet.com'
    });
    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_6__["TREZOR"];
    this.isHardware = true;
    this.needPassword = NEED_PASSWORD;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_7__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_6__["TREZOR"]];
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(TrezorWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        var rootPub;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                _context.next = 3;
                return getRootPubKey(this.basePath);

              case 3:
                rootPub = _context.sent;
                this.hdKey = new hdkey__WEBPACK_IMPORTED_MODULE_9__();
                this.hdKey.publicKey = Buffer.from(rootPub.publicKey, 'hex');
                this.hdKey.chainCode = Buffer.from(rootPub.chainCode, 'hex');

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function getAccount(idx) {
      var _this = this;

      var derivedKey = this.hdKey.derive('m/' + idx);

      var txSigner =
      /*#__PURE__*/
      function () {
        var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(tx) {
          var networkId, options, result, signedChainId;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_10__["Transaction"](tx, {
                    common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_15__["default"])(_store__WEBPACK_IMPORTED_MODULE_14__["default"].state.network)
                  });
                  networkId = tx.getChainId();
                  options = {
                    path: _this.basePath + '/' + idx,
                    transaction: Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getHexTxObject"])(tx)
                  };
                  _context2.next = 5;
                  return trezor_connect__WEBPACK_IMPORTED_MODULE_5___default.a.ethereumSignTransaction(options);

                case 5:
                  result = _context2.sent;

                  if (result.success) {
                    _context2.next = 8;
                    break;
                  }

                  throw new Error(result.payload.error);

                case 8:
                  tx.v = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(result.payload.v);
                  tx.r = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(result.payload.r);
                  tx.s = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(result.payload.s);
                  signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_11__["calculateChainIdFromV"])(tx.v);

                  if (!(signedChainId !== networkId)) {
                    _context2.next = 14;
                    break;
                  }

                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');

                case 14:
                  return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getSignTransactionObject"])(tx));

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function txSigner(_x2) {
          return _ref.apply(this, arguments);
        };
      }();

      var msgSigner =
      /*#__PURE__*/
      function () {
        var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(msg) {
          var result;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return trezor_connect__WEBPACK_IMPORTED_MODULE_5___default.a.ethereumSignMessage({
                    path: _this.basePath + '/' + idx,
                    message: Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_12__["toBuffer"])(msg).toString('hex'),
                    hex: true
                  });

                case 2:
                  result = _context3.sent;

                  if (result.success) {
                    _context3.next = 5;
                    break;
                  }

                  throw new Error(result.payload.error);

                case 5:
                  return _context3.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_11__["getBufferFromHex"])(result.payload.signature));

                case 6:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function msgSigner(_x3) {
          return _ref2.apply(this, arguments);
        };
      }();

      var displayAddress =
      /*#__PURE__*/
      function () {
        var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee4() {
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return trezor_connect__WEBPACK_IMPORTED_MODULE_5___default.a.ethereumGetAddress({
                    path: _this.basePath + '/' + idx,
                    showOnTrezor: true
                  });

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function displayAddress() {
          return _ref3.apply(this, arguments);
        };
      }();

      return new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_8__["default"](this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_13__["default"], txSigner, msgSigner, displayAddress);
    }
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return TrezorWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref4 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee5(basePath) {
    var _trezorWallet;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _trezorWallet = new TrezorWallet();
            _context5.next = 3;
            return _trezorWallet.init(basePath);

          case 3:
            return _context5.abrupt("return", _trezorWallet);

          case 4:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function createWallet(_x4) {
    return _ref4.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_13__["default"];

var getRootPubKey =
/*#__PURE__*/
function () {
  var _ref5 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee6(_path) {
    var result;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return trezor_connect__WEBPACK_IMPORTED_MODULE_5___default.a.ethereumGetPublicKey({
              path: _path
            });

          case 2:
            result = _context6.sent;

            if (result.payload) {
              _context6.next = 5;
              break;
            }

            throw new Error('popup failed to open');

          case 5:
            if (result.success) {
              _context6.next = 7;
              break;
            }

            throw new Error(result.payload.error);

          case 7:
            return _context6.abrupt("return", {
              publicKey: result.payload.publicKey,
              chainCode: result.payload.chainCode
            });

          case 8:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function getRootPubKey(_x5) {
    return _ref5.apply(this, arguments);
  };
}();

/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/hybrid/MEWconnect/errorHandler.js":
/*!*******************************************************!*\
  !*** ./src/wallets/hybrid/MEWconnect/errorHandler.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");





var ERRORS = {};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.values(ERRORS);
  var warningValues = Object.values(WARNING);

  if (errorValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].ERROR);
  } else if (warningValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/hybrid/MEWconnect/index.js":
/*!************************************************!*\
  !*** ./src/wallets/hybrid/MEWconnect/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.array.find */ "./node_modules/core-js/modules/es6.array.find.js");
/* harmony import */ var core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_array_find__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/get */ "./node_modules/@babel/runtime-corejs2/helpers/esm/get.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/inherits */ "./node_modules/@babel/runtime-corejs2/helpers/esm/inherits.js");
/* harmony import */ var _myetherwallet_mewconnect_web_client__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @myetherwallet/mewconnect-web-client */ "./node_modules/@myetherwallet/mewconnect-web-client/dist/index.js");
/* harmony import */ var _myetherwallet_mewconnect_web_client__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_myetherwallet_mewconnect_web_client__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _wallets_WalletInterface__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/wallets/WalletInterface */ "./src/wallets/WalletInterface.js");
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/hybrid/MEWconnect/errorHandler.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");



















var SIGNALER_URL = 'https://connect.mewapi.io';
var IS_HARDWARE = true; // TODO: add listener and ui notification on RtcConnectedEvent and RtcClosedEvent

var MEWconnectWalletInterface =
/*#__PURE__*/
function (_WalletInterface) {
  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_9__["default"])(MEWconnectWalletInterface, _WalletInterface);

  function MEWconnectWalletInterface(pubkey, isHardware, identifier, txSigner, msgSigner, mewConnect) {
    var _this;

    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, MEWconnectWalletInterface);

    _this = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_6__["default"])(this, Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__["default"])(MEWconnectWalletInterface).call(this, pubkey, true, identifier));
    _this.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"];
    _this.txSigner = txSigner;
    _this.msgSigner = msgSigner;
    _this.isHardware = isHardware;
    _this.mewConnect = mewConnect;
    return _this;
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(MEWconnectWalletInterface, [{
    key: "getConnection",
    value: function getConnection() {
      return this.mewConnect;
    }
  }, {
    key: "signTransaction",
    value: function signTransaction(txParams) {
      return Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_8__["default"])(Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__["default"])(MEWconnectWalletInterface.prototype), "signTransaction", this).call(this, txParams, this.txSigner);
    }
  }, {
    key: "signMessage",
    value: function signMessage(msg) {
      return Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_get__WEBPACK_IMPORTED_MODULE_8__["default"])(Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_7__["default"])(MEWconnectWalletInterface.prototype), "signMessage", this).call(this, msg, this.msgSigner);
    }
  }]);

  return MEWconnectWalletInterface;
}(_wallets_WalletInterface__WEBPACK_IMPORTED_MODULE_13__["default"]);

var MEWconnectWallet =
/*#__PURE__*/
function () {
  function MEWconnectWallet() {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_4__["default"])(this, MEWconnectWallet);

    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_14__["MEW_CONNECT"];
    this.isHardware = IS_HARDWARE;
    this.mewConnect = new _myetherwallet_mewconnect_web_client__WEBPACK_IMPORTED_MODULE_10___default.a.Initiator();
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_5__["default"])(MEWconnectWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(qrcode) {
        var _this2 = this;

        var txSigner, msgSigner, mewConnect, address;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.mewConnect.on('codeDisplay', qrcode);

                txSigner =
                /*#__PURE__*/
                function () {
                  var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee(tx) {
                    var tokenInfo, networkId;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (tx.data.slice(0, 10) === '0xa9059cbb') {
                              tokenInfo = _store__WEBPACK_IMPORTED_MODULE_11__["default"].state.network.type.tokens.find(function (entry) {
                                return entry.address.toLowerCase() === tx.to.toLowerCase();
                              });

                              if (tokenInfo) {
                                tx.currency = {
                                  symbol: tokenInfo.symbol,
                                  decimals: tokenInfo.decimals,
                                  address: tokenInfo.address
                                };
                              }
                            }

                            networkId = tx.chainId;
                            return _context.abrupt("return", new Promise(function (resolve) {
                              _this2.mewConnect.sendRtcMessage('signTx', JSON.stringify(tx));

                              _this2.mewConnect.once('signTx', function (result) {
                                tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_12__["Transaction"](Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(result), {
                                  common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_18__["default"])(_store__WEBPACK_IMPORTED_MODULE_11__["default"].state.network)
                                });
                                var signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_15__["calculateChainIdFromV"])(tx.v);
                                if (signedChainId !== networkId) throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');
                                resolve(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getSignTransactionObject"])(tx));
                              });
                            }));

                          case 3:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function txSigner(_x2) {
                    return _ref.apply(this, arguments);
                  };
                }();

                msgSigner =
                /*#__PURE__*/
                function () {
                  var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(msg) {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            return _context2.abrupt("return", new Promise(function (resolve) {
                              var msgHash = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_16__["hashPersonalMessage"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_16__["toBuffer"])(msg));

                              _this2.mewConnect.sendRtcMessage('signMessage', {
                                hash: msgHash.toString('hex'),
                                text: msg
                              });

                              _this2.mewConnect.once('signMessage', function (data) {
                                resolve(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["getBufferFromHex"])(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(data.sig)));
                              });
                            }));

                          case 1:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function msgSigner(_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }();

                mewConnect = function mewConnect() {
                  return _this2.mewConnect;
                };

                _context3.next = 6;
                return signalerConnect(SIGNALER_URL, this.mewConnect);

              case 6:
                address = _context3.sent;
                return _context3.abrupt("return", new MEWconnectWalletInterface(Object(_utils__WEBPACK_IMPORTED_MODULE_15__["sanitizeHex"])(address), this.isHardware, this.identifier, txSigner, msgSigner, mewConnect // <- using this.mewConnect here was causing a circular reference and data clone error
                ));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }]);

  return MEWconnectWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(qrcode) {
    var _MEWconnectWallet, _tWallet;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _MEWconnectWallet = new MEWconnectWallet();
            _context4.next = 3;
            return _MEWconnectWallet.init(qrcode);

          case 3:
            _tWallet = _context4.sent;
            return _context4.abrupt("return", _tWallet);

          case 5:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function createWallet(_x4) {
    return _ref3.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_17__["default"];

var signalerConnect = function signalerConnect(url, mewConnect) {
  return new Promise(function (resolve) {
    mewConnect.initiatorStart(url);
    mewConnect.on('RtcConnectedEvent', function () {
      mewConnect.sendRtcMessage('address', '');
      mewConnect.once('address', function (data) {
        resolve(data.address);
      });
    });
  });
};

/* harmony default export */ __webpack_exports__["default"] = (createWallet);

/***/ }),

/***/ "./src/wallets/hybrid/index.js":
/*!*************************************!*\
  !*** ./src/wallets/hybrid/index.js ***!
  \*************************************/
/*! exports provided: MewConnectWallet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MEWconnect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MEWconnect */ "./src/wallets/hybrid/MEWconnect/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MewConnectWallet", function() { return _MEWconnect__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./src/wallets/index.js":
/*!******************************!*\
  !*** ./src/wallets/index.js ***!
  \******************************/
/*! exports provided: LedgerWallet, TrezorWallet, BitBoxWallet, SecalotWallet, KeepkeyWallet, MewConnectWallet, WalletInterface, MnemonicWallet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hardware__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hardware */ "./src/wallets/hardware/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LedgerWallet", function() { return _hardware__WEBPACK_IMPORTED_MODULE_0__["LedgerWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TrezorWallet", function() { return _hardware__WEBPACK_IMPORTED_MODULE_0__["TrezorWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BitBoxWallet", function() { return _hardware__WEBPACK_IMPORTED_MODULE_0__["BitBoxWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SecalotWallet", function() { return _hardware__WEBPACK_IMPORTED_MODULE_0__["SecalotWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeepkeyWallet", function() { return _hardware__WEBPACK_IMPORTED_MODULE_0__["KeepkeyWallet"]; });

/* harmony import */ var _WalletInterface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WalletInterface */ "./src/wallets/WalletInterface.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WalletInterface", function() { return _WalletInterface__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _software__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./software */ "./src/wallets/software/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MnemonicWallet", function() { return _software__WEBPACK_IMPORTED_MODULE_2__["MnemonicWallet"]; });

/* harmony import */ var _hybrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hybrid */ "./src/wallets/hybrid/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MewConnectWallet", function() { return _hybrid__WEBPACK_IMPORTED_MODULE_3__["MewConnectWallet"]; });







/***/ }),

/***/ "./src/wallets/software/index.js":
/*!***************************************!*\
  !*** ./src/wallets/software/index.js ***!
  \***************************************/
/*! exports provided: MnemonicWallet, Web3Wallet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _web3wallet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web3wallet */ "./src/wallets/software/web3wallet/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Web3Wallet", function() { return _web3wallet__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _mnemonic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mnemonic */ "./src/wallets/software/mnemonic/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MnemonicWallet", function() { return _mnemonic__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./src/wallets/software/mnemonic/errorHandler.js":
/*!*******************************************************!*\
  !*** ./src/wallets/software/mnemonic/errorHandler.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");





var ERRORS = {};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.values(ERRORS);
  var warningValues = Object.values(WARNING);

  if (errorValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].ERROR);
  } else if (warningValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/software/mnemonic/index.js":
/*!************************************************!*\
  !*** ./src/wallets/software/mnemonic/index.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");
/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hdkey */ "./node_modules/hdkey/lib/hdkey.js");
/* harmony import */ var hdkey__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(hdkey__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethereumjs-tx */ "./node_modules/ethereumjs-tx/dist/index.js");
/* harmony import */ var ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _bip44__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../bip44 */ "./src/wallets/bip44/index.js");
/* harmony import */ var _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/wallets/HDWalletInterface */ "./src/wallets/HDWalletInterface.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/software/mnemonic/errorHandler.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/store */ "./src/store/index.js");
/* harmony import */ var _helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/helpers/commonGenerator */ "./src/helpers/commonGenerator.js");















var bip39 = __webpack_require__(/*! bip39 */ "./node_modules/bip39/src/index.js");

var NEED_PASSWORD = true;
var IS_HARDWARE = false;

var MnemonicWallet =
/*#__PURE__*/
function () {
  function MnemonicWallet(mnemonic, password) {
    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, MnemonicWallet);

    if (!bip39.validateMnemonic(mnemonic)) throw new Error('Invalid Mnemonic');
    this.identifier = _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__["MNEMONIC"];
    this.isHardware = IS_HARDWARE;
    this.needPassword = NEED_PASSWORD;
    this.mnemonic = mnemonic;
    this.password = password;
    this.supportedPaths = _bip44__WEBPACK_IMPORTED_MODULE_8__["default"][_bip44_walletTypes__WEBPACK_IMPORTED_MODULE_7__["MNEMONIC"]];
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(MnemonicWallet, [{
    key: "init",
    value: function () {
      var _init = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(basePath) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.basePath = basePath ? basePath : this.supportedPaths[0].path;
                this.hdKey = hdkey__WEBPACK_IMPORTED_MODULE_4__["fromMasterSeed"](bip39.mnemonicToSeedSync(this.mnemonic, this.password));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "getAccount",
    value: function getAccount(idx) {
      var derivedKey = this.hdKey.derive(this.basePath + '/' + idx);

      var txSigner =
      /*#__PURE__*/
      function () {
        var _ref = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(tx) {
          var networkId, signedChainId;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  tx = new ethereumjs_tx__WEBPACK_IMPORTED_MODULE_5__["Transaction"](tx, {
                    common: Object(_helpers_commonGenerator__WEBPACK_IMPORTED_MODULE_13__["default"])(_store__WEBPACK_IMPORTED_MODULE_12__["default"].state.network)
                  });
                  networkId = tx.getChainId();
                  tx.sign(derivedKey.privateKey);
                  signedChainId = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["calculateChainIdFromV"])(tx.v);

                  if (!(signedChainId !== networkId)) {
                    _context2.next = 6;
                    break;
                  }

                  throw new Error('Invalid networkId signature returned. Expected: ' + networkId + ', Got: ' + signedChainId, 'InvalidNetworkId');

                case 6:
                  return _context2.abrupt("return", Object(_utils__WEBPACK_IMPORTED_MODULE_10__["getSignTransactionObject"])(tx));

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function txSigner(_x2) {
          return _ref.apply(this, arguments);
        };
      }();

      var msgSigner =
      /*#__PURE__*/
      function () {
        var _ref2 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(msg) {
          var msgHash, signed;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  msgHash = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_6__["hashPersonalMessage"])(Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_6__["toBuffer"])(msg));
                  signed = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_6__["ecsign"])(msgHash, derivedKey.privateKey);
                  return _context3.abrupt("return", Buffer.concat([Buffer.from(signed.r), Buffer.from(signed.s), Buffer.from([signed.v])]));

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function msgSigner(_x3) {
          return _ref2.apply(this, arguments);
        };
      }();

      return new _wallets_HDWalletInterface__WEBPACK_IMPORTED_MODULE_9__["default"](this.basePath + '/' + idx, derivedKey.publicKey, this.isHardware, this.identifier, _errorHandler__WEBPACK_IMPORTED_MODULE_11__["default"], txSigner, msgSigner, null);
    }
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.basePath;
    }
  }, {
    key: "getSupportedPaths",
    value: function getSupportedPaths() {
      return this.supportedPaths;
    }
  }]);

  return MnemonicWallet;
}();

var createWallet =
/*#__PURE__*/
function () {
  var _ref3 = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(mnemonic, password, basePath) {
    var _mnemonicWallet;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _mnemonicWallet = new MnemonicWallet(mnemonic, password);
            _context4.next = 3;
            return _mnemonicWallet.init(basePath);

          case 3:
            return _context4.abrupt("return", _mnemonicWallet);

          case 4:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function createWallet(_x4, _x5, _x6) {
    return _ref3.apply(this, arguments);
  };
}();

createWallet.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_11__["default"];
/* harmony default export */ __webpack_exports__["default"] = (createWallet);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./src/wallets/software/web3wallet/errorHandler.js":
/*!*********************************************************!*\
  !*** ./src/wallets/software/web3wallet/errorHandler.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es7.array.includes */ "./node_modules/core-js/modules/es7.array.includes.js");
/* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.string.includes */ "./node_modules/core-js/modules/es6.string.includes.js");
/* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/web.dom.iterable */ "./node_modules/core-js/modules/web.dom.iterable.js");
/* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es7.object.values */ "./node_modules/core-js/modules/es7.object.values.js");
/* harmony import */ var core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es7_object_values__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/helpers */ "./src/helpers/index.js");





var ERRORS = {
  REJECT_TX: 'Returned error: Error: MetaMask Tx Signature: User denied transaction signature.',
  MEW_REJECT_TX: 'User rejected action!'
};
var WARNING = {};
/* harmony default export */ __webpack_exports__["default"] = (function (err) {
  var errorValues = Object.values(ERRORS);
  var warningValues = Object.values(WARNING);

  if (errorValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].ERROR);
  } else if (warningValues.includes(err.message)) {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].WARN);
  } else {
    _helpers__WEBPACK_IMPORTED_MODULE_4__["Toast"].responseHandler(err, false);
  }
});

/***/ }),

/***/ "./src/wallets/software/web3wallet/index.js":
/*!**************************************************!*\
  !*** ./src/wallets/software/web3wallet/index.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck */ "./node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn */ "./node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf */ "./node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/createClass */ "./node_modules/@babel/runtime-corejs2/helpers/esm/createClass.js");
/* harmony import */ var _Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime-corejs2/helpers/esm/inherits */ "./node_modules/@babel/runtime-corejs2/helpers/esm/inherits.js");
/* harmony import */ var _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../bip44/walletTypes */ "./src/wallets/bip44/walletTypes.js");
/* harmony import */ var _wallets_WalletInterface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/wallets/WalletInterface */ "./src/wallets/WalletInterface.js");
/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! web3 */ "./node_modules/web3/src/index.js");
/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(web3__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils */ "./src/wallets/utils.js");
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./errorHandler */ "./src/wallets/software/web3wallet/errorHandler.js");











var Web3Wallet =
/*#__PURE__*/
function (_WalletInterface) {
  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Web3Wallet, _WalletInterface);

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Web3Wallet, null, [{
    key: "errorHandler",
    get: function get() {
      return _errorHandler__WEBPACK_IMPORTED_MODULE_9__["default"];
    }
  }]);

  function Web3Wallet(address) {
    var _this;

    Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Web3Wallet);

    _this = Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__["default"])(Web3Wallet).call(this, address, true, _bip44_walletTypes__WEBPACK_IMPORTED_MODULE_5__["WEB3_WALLET"]));
    _this.errorHandler = _errorHandler__WEBPACK_IMPORTED_MODULE_9__["default"];

    if (window.ethereum) {
      _this.web3 = new web3__WEBPACK_IMPORTED_MODULE_7___default.a(window.ethereum);
    } else {
      _this.web3 = new web3__WEBPACK_IMPORTED_MODULE_7___default.a(window.web3.currentProvider);
    }

    if (!_this.web3) throw new Error('No Web3 instance found');
    return _this;
  }

  Object(_Users_yelpadillo_workspace_work_myetherwallet_node_modules_babel_runtime_corejs2_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Web3Wallet, [{
    key: "signTransaction",
    value: function signTransaction(tx) {
      tx.from = this.getAddressString();
      return this.web3.eth.sendTransaction(tx);
    }
  }, {
    key: "signMessage",
    value: function signMessage(msg) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.web3.eth.personal.sign(msg, _this2.getAddressString()).then(function (hex) {
          resolve(Object(_utils__WEBPACK_IMPORTED_MODULE_8__["getBufferFromHex"])(hex));
        }).catch(_errorHandler__WEBPACK_IMPORTED_MODULE_9__["default"]);
      });
    }
  }]);

  return Web3Wallet;
}(_wallets_WalletInterface__WEBPACK_IMPORTED_MODULE_6__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Web3Wallet);

/***/ }),

/***/ "./src/wallets/utils.js":
/*!******************************!*\
  !*** ./src/wallets/utils.js ***!
  \******************************/
/*! exports provided: getBufferFromHex, bufferToHex, getSignTransactionObject, sanitizeHex, padLeftEven, getHexTxObject, calculateChainIdFromV */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBufferFromHex", function() { return getBufferFromHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToHex", function() { return bufferToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSignTransactionObject", function() { return getSignTransactionObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sanitizeHex", function() { return sanitizeHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padLeftEven", function() { return padLeftEven; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHexTxObject", function() { return getHexTxObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateChainIdFromV", function() { return calculateChainIdFromV; });
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es6.regexp.to-string */ "./node_modules/core-js/modules/es6.regexp.to-string.js");
/* harmony import */ var core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es6.regexp.replace */ "./node_modules/core-js/modules/es6.regexp.replace.js");
/* harmony import */ var core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es6_regexp_replace__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethereumjs-util */ "./node_modules/ethereumjs-util/dist/index.js");
/* harmony import */ var ethereumjs_util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ethereumjs_util__WEBPACK_IMPORTED_MODULE_2__);




var getBufferFromHex = function getBufferFromHex(hex) {
  hex = sanitizeHex(hex);

  var _hex = hex.toLowerCase().replace('0x', '');

  return new Buffer(_hex, 'hex');
};

var padLeftEven = function padLeftEven(hex) {
  hex = hex.length % 2 != 0 ? '0' + hex : hex;
  return hex;
};

var sanitizeHex = function sanitizeHex(hex) {
  hex = hex.substring(0, 2) == '0x' ? hex.substring(2) : hex;
  if (hex == '') return '';
  return '0x' + padLeftEven(hex);
};

var bufferToHex = function bufferToHex(buffer) {
  return '0x' + buffer.toString('hex');
};

var getHexTxObject = function getHexTxObject(tx) {
  return {
    to: sanitizeHex(tx.to.toString('hex')),
    value: sanitizeHex(tx.value.toString('hex')),
    data: sanitizeHex(tx.data.toString('hex')),
    chainId: tx.getChainId(),
    nonce: sanitizeHex(tx.nonce.toString('hex')),
    gasLimit: sanitizeHex(tx.gasLimit.toString('hex')),
    gasPrice: sanitizeHex(tx.gasPrice.toString('hex'))
  };
};

var getSignTransactionObject = function getSignTransactionObject(tx) {
  return {
    rawTransaction: bufferToHex(tx.serialize()),
    tx: {
      nonce: bufferToHex(tx.nonce),
      gasPrice: bufferToHex(tx.gasPrice),
      gas: tx.gasLimit ? bufferToHex(tx.gasLimit) : bufferToHex(tx.gas),
      to: bufferToHex(tx.to),
      value: bufferToHex(tx.value),
      input: bufferToHex(tx.data),
      v: bufferToHex(tx.v),
      r: bufferToHex(tx.r),
      s: bufferToHex(tx.s),
      hash: bufferToHex(tx.hash())
    }
  };
};

var calculateChainIdFromV = function calculateChainIdFromV(v) {
  var sigV = Object(ethereumjs_util__WEBPACK_IMPORTED_MODULE_2__["bufferToInt"])(v);
  var chainId = Math.floor((sigV - 35) / 2);
  if (chainId < 0) chainId = 0;
  return chainId;
};


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/node-libs-browser/node_modules/buffer/index.js */ "./node_modules/node-libs-browser/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ 4:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 8:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=12.js.map